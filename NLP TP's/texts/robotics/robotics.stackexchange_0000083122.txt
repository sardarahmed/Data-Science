Q:

error while loading shared libraries

I want to use shared objects as libraries. The .so files of them are at my disposal.
I created a catkin_package. That package contains a source, include and lib folder (where I put the .so files)
My CMakeLists.txt of the package is the following:
cmake_minimum_required(VERSION 2.8.3)
project(yocto3d)

find_package(catkin REQUIRED COMPONENTS)

catkin_package()

include_directories(include ${catkin_INCLUDE_DIRS})

add_executable(yocto3d src/main.cpp)
target_link_libraries(yocto3d ${catkin_LIBRARIES} ${PROJECT_SOURCE_DIR}/lib/libyapi.so.1.0.1 ${PROJECT_SOURCE_DIR}/lib/libyocto.so.1.0.1)

Everything compiles without warnings and errors, but when I run
rosrun yocto3d yocto3d

I get the following error (can't find the libraries)
 /home/dh/catkin_ws/devel/lib/yocto3d/yocto3d: error while loading shared libraries: libyocto.so.1.0.1: cannot open shared object file: No such file or directory

What am I missing?

Originally posted by Chrizzl on ROS Answers with karma: 48 on 2017-10-03
Post score: 0

A:

I copied the two libraries (.so files) to /usr/lib. When running the program the files in this folder will be used, when compiling with catkin_make the files in catkin_ws/src/yocto3d/lib will be used.
In conclusion: the paths to the libraries are different when compiling and when running the program.

Originally posted by Chrizzl with karma: 48 on 2017-10-04
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by gvdhoorn on 2017-10-04:
As far as I can tell, #q203315 does not suggest adding lib to your include_directories(..) statement at all. Libraries are not headers, so I also don't really understand how adding that directory to your include path would help here.
Comment by Chrizzl on 2017-10-04:
It probably has to do with the fact that my .so libraries are located inside /lib of my project folder? Maybe rosrun wouldn't look inside that folder at runtime? I don't know exactly why it works either.
Comment by gvdhoorn on 2017-10-04:
include_directories(..) changes the include path, for headers. That is a compile time construct, not something that is used at runtime when loading libraries.
And rosrun is not involved here: your OS (or more precisely: the ELF loader) is complaining it can't find the libs, not ROS.
Comment by Chrizzl on 2017-10-04:
I found out I did one more thing to fix this problem, will edit my answer.
Comment by gvdhoorn on 2017-10-04:
Btw: very nice that you're reporting back about this. If my comments come across as dismissive, don't interprete them that way. I'm just really surprised that adding lib to your include path changes anything here.
Comment by Chrizzl on 2017-10-04:
I think you will understand it now, when you look at my updated answer. I copied the libraries to the runtime location.
Comment by gvdhoorn on 2017-10-04:\

I also copied the two libraries (.so files) to /usr/lib

ok. That is what made things work. The change to your include path is unnecessary.
/usr/lib is by default searched by your system's binary loader for libraries, so that makes sense.
Comment by gvdhoorn on 2017-10-04:
Try to remove the change you made to the include_directories(..) statement. It should still work.
Comment by Chrizzl on 2017-10-04:
Oops, you are right about that! Always a fun thing when you edit things at multiple locations and it suddenly works. Will edit the answer once again.
Comment by gvdhoorn on 2017-10-04:
I'm not sure your conclusion is necessarily correct. You'd have to lookup how CMake treats libraries that are not on the standard linking path, but that is probably the reason why it can't find your library if they're not in /usr/lib.
Btw: suggestion: place the lib in /usr/local/lib.
Comment by Chrizzl on 2017-10-04:
Btw: suggestion: place the lib in /usr/local/lib.
Tried that. It didn't work (tried plain copy and a copy in folder named yocto3d). Anyway, I'm happy it's working now!


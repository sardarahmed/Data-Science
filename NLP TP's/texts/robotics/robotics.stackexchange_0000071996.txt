Q:

example RQT plugin in C++ that uses signals/slots

I cannot for the life of me figure out how to use signals and slots to pass information to the GUI widget in an RQT plugin that is written in C++.  The ROS Tutorial for creating a C++ RQT plugin doesn't even have any data widgets in the GUI, let alone any code to show how to use signals/slots to pipe data to a data widget:  http://wiki.ros.org/rqt/Tutorials/Writing%20a%20C%2B%2B%20Plugin
After several hours of trial and error, I was able to figure out a solution for using signals/slots in a Python RQT plugin, but I can't seem to make the stretch to C++.
Here is the python example I created starting from the ROS Tutorial for creating a python RQT plugin (https://github.com/lucasw/rqt_mypkg) and then adding some of this code from ROS Answers where a user asked how to use signals/slots in python: http://answers.ros.org/question/224152/pyqt-signals-for-ros-callbacks-in-rqt-plugin/
my_module.py:
import os
import rospy

from qt_gui.plugin import Plugin
from python_qt_binding import loadUi
from python_qt_binding.QtGui import QWidget
from std_msgs.msg import Int32
from PyQt4.QtCore import SIGNAL

class MyPlugin(Plugin):

    def __init__(self, context):
        super(MyPlugin, self).__init__(context)
        # Give QObjects reasonable names
        self.setObjectName('MyPlugin')

        # Process standalone plugin command-line arguments
        from argparse import ArgumentParser
        parser = ArgumentParser()
        # Add argument(s) to the parser.
        parser.add_argument("-q", "--quiet", action="store_true",
                      dest="quiet",
                      help="Put plugin in silent mode")
        args, unknowns = parser.parse_known_args(context.argv())
        if not args.quiet:
            print 'arguments: ', args
            print 'unknowns: ', unknowns

        # Create QWidget
        self._widget = QWidget()
        # Get path to UI file which is a sibling of this file
        # in this example the .ui and .py file are in the same folder
        ui_file = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'MyPlugin.ui')
        # Extend the widget with all attributes and children from UI file
        loadUi(ui_file, self._widget)
        # Give QObjects reasonable names
        self._widget.setObjectName('MyPluginUi')
        # Show _widget.windowTitle on left-top of each plugin (when 
        # it's set in _widget). This is useful when you open multiple 
        # plugins at once. Also if you open multiple instances of your 
        # plugin at once, these lines add number to make it easy to 
        # tell from pane to pane.
        if context.serial_number() > 1:
            self._widget.setWindowTitle(self._widget.windowTitle() + (' (%d)' % context.serial_number()))
        # Add widget to the user interface
        context.add_widget(self._widget)

        # kurt added these lines
        self.sub = rospy.Subscriber('my_data', Int32, self.ros_msg_callback, queue_size=1)
        self.connect(self, SIGNAL("changeUI(PyQt_PyObject)"), self.monitoring_slot)

    # kurt added this callback
    def ros_msg_callback(self, data):
        self.emit(SIGNAL("changeUI(PyQt_PyObject)"), data)
        pass

    # kurt added this slot routine
    def monitoring_slot(self, data):
        self._widget.data_myData.setText(str(data))
        self._widget.data_myData.setStyleSheet("color: black; background-color: red;")
        pass

    def shutdown_plugin(self):
        # TODO unregister all publishers here
        pass

    def save_settings(self, plugin_settings, instance_settings):
        # TODO save intrinsic configuration, usually using:
        # instance_settings.set_value(k, v)
        pass

    def restore_settings(self, plugin_settings, instance_settings):
        # TODO restore intrinsic configuration, usually using:
        # v = instance_settings.value(k)
        pass

    #def trigger_configuration(self):
        # Comment in to signal that the plugin has a way to configure
        # This will enable a setting button (gear icon) in each dock widget title bar
        # Usually used to open a modal configuration dialog

MyPlugin.ui:
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>400</width>
    <height>300</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Form</string>
  </property>

  <!-- kurt added this widget -->
  <widget class="QLabel" name="label_myLabel">
   <property name="text">
    <string>Label:</string>
   </property>
   <property name="geometry">
    <rect>
     <x>10</x>
     <y>10</y>
     <width>50</width>
     <height>30</height>
    </rect>
   </property>
  </widget>

  <!-- kurt added this widget -->
  <widget class="QLabel" name="data_myData">
   <property name="text">
    <string>TBD</string>
   </property>
   <property name="geometry">
    <rect>
     <x>70</x>
     <y>10</y>
     <width>50</width>
     <height>30</height>
    </rect>
   </property>
   <property name="styleSheet">
    <string notr="true">color: rgb(0, 255, 0); background-color: rgb(0, 0, 0);</string>
   </property>
  </widget>

 </widget>
 <resources/>
 <connections/>
</ui>

Originally posted by Kurt Leucht on ROS Answers with karma: 486 on 2016-02-12
Post score: 1

A:

I finally figured it out.  Thanks for all the helpful comments below.
I was trying to define both the signal and slot in my own class, per the various QT examples I had found, but I really wanted to signal the existing slot in the existing QLabel class.  For this scenario the solution is way simpler than the QT examples I was using which do not signal an existing slot in an existing class.  This is confusing to new ROS users who need to signal existing QT widgets in their RQT plugins.  This is exactly why I was (and still am) pushing for this signal/slot example code to be added to the ROS C++ RQT Plugin tutorial.
Here is a simple diagram for newbies:
image description http://www.leucht.com/photos-new/var/resizes/misc/Images-for-forum-posting-%28public%29/signalsAndSlotsDiagram.png
Here is the GUI definition file my_plugin.ui:
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MyPluginWidget</class>

 <widget class="QWidget" name="MyPluginWidget">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>400</width>
    <height>300</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Form</string>
  </property>

  <!-- kurt added this widget -->
  <widget class="QLabel" name="label_myLabel">
   <property name="text">
    <string>Label:</string>
   </property>
   <property name="geometry">
    <rect>
     <x>10</x>
     <y>10</y>
     <width>50</width>
     <height>30</height>
    </rect>
   </property>
  </widget>

  <!-- kurt added this widget -->
  <widget class="QLabel" name="data_myData">
   <property name="text">
    <string>TBD</string>
   </property>
   <property name="geometry">
    <rect>
     <x>70</x>
     <y>10</y>
     <width>50</width>
     <height>30</height>
    </rect>
   </property>
   <property name="styleSheet">
    <string notr="true">color: green; background-color: black;</string>
   </property>
  </widget>

 </widget>

 <resources/>
 <connections/>
</ui>

Here is the header file my_plugin.h:
#ifndef rqt_example_cpp_my_plugin_H
#define rqt_example_cpp_my_plugin_H

#include <rqt_gui_cpp/plugin.h>
#include <rqt_example_cpp/ui_my_plugin.h>
#include <QWidget>

// kurt added these 3 includes
#include <ros/ros.h>
#include <std_msgs/Int32.h>
#include <QString>

namespace rqt_example_cpp {

class MyPlugin
  : public rqt_gui_cpp::Plugin
{
  Q_OBJECT
public:
  MyPlugin();
  virtual void initPlugin(qt_gui_cpp::PluginContext& context);

private:
  Ui::MyPluginWidget ui_;
  QWidget* widget_;

  // kurt added these lines to get data from a ROS Topic
  ros::NodeHandle ros_node_handle;
  ros::Subscriber my_subscriber;
  void ros_data_callback(const std_msgs::Int32 message);

// kurt added these signal definitions to pass data to QLabel on GUI
Q_SIGNALS:
  void setText(const QString str);
  void setStyleSheet(const QString str);

};

}  // namespace rqt_example_cpp
#endif  // rqt_example_cpp_my_plugin_H

And here is the source file my_plugin.cpp:
#include "rqt_example_cpp/my_plugin.h"
#include <pluginlib/class_list_macros.h>
#include <QStringList>

namespace rqt_example_cpp {

MyPlugin::MyPlugin()
  : rqt_gui_cpp::Plugin()
  , widget_(0)
{
  setObjectName("MyPlugin");
}

void MyPlugin::initPlugin(qt_gui_cpp::PluginContext& context)
{
  QStringList argv = context.argv();
  widget_ = new QWidget();
  ui_.setupUi(widget_);
  context.addWidget(widget_);

  // kurt added this ROS Topic subscriber
  my_subscriber = ros_node_handle.subscribe("my_data", 1, &MyPlugin::ros_data_callback, this);
   // kurt added these lines to connect the emitted signals below to the GUI's QLabel's public slots
  QObject::connect( this, SIGNAL(setText(const QString)),
            ui_.data_myData, SLOT(setText(const QString))   );
  QObject::connect( this, SIGNAL(setStyleSheet(const QString)),
            ui_.data_myData, SLOT(setStyleSheet(const QString)) );
}

// kurt added this ROS topic callback to get data from ROS and send signals to QLabel on GUI
void MyPlugin::ros_data_callback(const std_msgs::Int32 message) {
    QString str(QString::number(message.data));
    // this line actually calls the setText() routine on the GUI's QLabel 
    // via the connection of signal and slot
    emit setText(str);
    // another signal is used to set the color of the widget
    if (message.data > 9) {
        emit setStyleSheet("color: black; background-color: red;");
    }
    else {
        emit setStyleSheet("color: green; background-color: black;");
    }
}

} // namespace
PLUGINLIB_DECLARE_CLASS(rqt_example_cpp, MyPlugin, rqt_example_cpp::MyPlugin, rqt_gui_cpp::Plugin)

OLD, ORIGINAL ANSWER IS BELOW:
This is not the answer because it does not work, but I think it is probably close to the right answer.  Hopefully someone can comment on what exactly is wrong with this code.
This is an attempt at an RQT plugin in C++ that passes ROS topic data to a GUI widget.  I started with the RQT Example CPP files (https://github.com/lucasw/rqt_mypkg) that the ROS Tutorial points to (http://wiki.ros.org/rqt/Tutorials/Writing%20a%20C%2B%2B%20Plugin).  Then I tried to add signal/slot code based on the QT Signal/Slot documentation (http://doc.qt.io/qt-4.8/signalsandslots.html).
It compiles and it runs.  But it gives the following warning when it runs and the connection is obviously not made:
Object::connect: No such signal rqt_example_cpp::MyPlugin::setDataValue(int)
Object::connect: (sender name:   'MyPlugin')
Object::connect: (receiver name: 'data_myData')

my_plugin.h
#ifndef rqt_example_cpp_my_plugin_H
#define rqt_example_cpp_my_plugin_H

#include <rqt_gui_cpp/plugin.h>
#include <rqt_example_cpp/ui_my_plugin.h>
#include <QWidget>

// kurt added these includes
#include <ros/ros.h>
#include <std_msgs/Int32.h>
#include <QString>

namespace rqt_example_cpp {

class MyPlugin
  : public rqt_gui_cpp::Plugin
{
  Q_OBJECT
public:
  MyPlugin();
  virtual void initPlugin(qt_gui_cpp::PluginContext& context);
  virtual void shutdownPlugin();
  virtual void saveSettings(qt_gui_cpp::Settings& plugin_settings, qt_gui_cpp::Settings& instance_settings) const;
  virtual void restoreSettings(const qt_gui_cpp::Settings& plugin_settings, const qt_gui_cpp::Settings& instance_settings);

  // Comment in to signal that the plugin has a way to configure it
  // bool hasConfiguration() const;
  // void triggerConfiguration();
private:
  Ui::MyPluginWidget ui_;
  QWidget* widget_;

  // kurt added all these
  ros::NodeHandle ros_node_handle;
  ros::Subscriber my_subscriber;
  void ros_data_callback(const std_msgs::Int32 message);

// kurt added this section
public slots:
  void setDataValue(int value);

// kurt added this section
signals:
  void setText(QString str);

};

}  // namespace rqt_example_cpp
#endif  // rqt_example_cpp_my_plugin_H

my_plugin.cpp
#include "rqt_example_cpp/my_plugin.h"
#include <pluginlib/class_list_macros.h>
#include <QStringList>

namespace rqt_example_cpp {

MyPlugin::MyPlugin()
  : rqt_gui_cpp::Plugin()
  , widget_(0)
{
  // Constructor is called first before initPlugin function, needless to say.

  // give QObjects reasonable names
  setObjectName("MyPlugin");
}

void MyPlugin::initPlugin(qt_gui_cpp::PluginContext& context)
{
  // access standalone command line arguments
  QStringList argv = context.argv();
  // create QWidget
  widget_ = new QWidget();
  // extend the widget with all attributes and children from UI file
  ui_.setupUi(widget_);
  // add widget to the user interface
  context.addWidget(widget_);

  // kurt added this subscriber
  my_subscriber = ros_node_handle.subscribe("my_data", 1, &MyPlugin::ros_data_callback, this);

   // kurt added this signal/slot connector
  QObject::connect( this, SIGNAL(setDataValue(int)),
            ui_.data_myData, SLOT(setText(const QString))   );

}

void MyPlugin::shutdownPlugin()
{
  // TODO unregister all publishers here
}

void MyPlugin::saveSettings(qt_gui_cpp::Settings& plugin_settings, qt_gui_cpp::Settings& instance_settings) const
{
  // TODO save intrinsic configuration, usually using:
  // instance_settings.setValue(k, v)
}

void MyPlugin::restoreSettings(const qt_gui_cpp::Settings& plugin_settings, const qt_gui_cpp::Settings& instance_settings)
{
  // TODO restore intrinsic configuration, usually using:
  // v = instance_settings.value(k)
}

// kurt added this ROS topic callback
void MyPlugin::ros_data_callback(const std_msgs::Int32 message) {
    printf("ROS callback saw data change.\n");
    MyPlugin::setDataValue(message.data);
}

// kurt added this slot routine
void MyPlugin::setDataValue(int value) {
    printf("QT slot routine saw data change.\n");
    QString str(QString::number(value));
    emit setText(str);
}

/*bool hasConfiguration() const
{
  return true;
}

void triggerConfiguration()
{
  // Usually used to open a dialog to offer the user a set of configuration
}*/

} // namespace
PLUGINLIB_DECLARE_CLASS(rqt_example_cpp, MyPlugin, rqt_example_cpp::MyPlugin, rqt_gui_cpp::Plugin)

my_plugin.ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MyPluginWidget</class>

 <widget class="QWidget" name="MyPluginWidget">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>400</width>
    <height>300</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Form</string>
  </property>

  <!-- kurt added this widget -->
  <widget class="QLabel" name="label_myLabel">
   <property name="text">
    <string>Label:</string>
   </property>
   <property name="geometry">
    <rect>
     <x>10</x>
     <y>10</y>
     <width>50</width>
     <height>30</height>
    </rect>
   </property>
  </widget>

  <!-- kurt added this widget -->
  <widget class="QLabel" name="data_myData">
   <property name="text">
    <string>TBD</string>
   </property>
   <property name="geometry">
    <rect>
     <x>70</x>
     <y>10</y>
     <width>50</width>
     <height>30</height>
    </rect>
   </property>
   <property name="styleSheet">
    <string notr="true">color: rgb(0, 255, 0); background-color: rgb(0, 0, 0);</string>
   </property>
  </widget>

 </widget>

 <resources/>
 <connections/>
</ui>

Originally posted by Kurt Leucht with karma: 486 on 2016-02-12
This answer was ACCEPTED on the original site
Post score: 4

Original comments
Comment by rastaxe on 2016-02-13:
This is more a question related to Qt than ROS, I think. However, in the connect you are swapping signal and slot. If you declare setText as slot you have to put SLOT(setText()) in the connect. In the .h use Q_SIGNALS instead of signals and public Q_SLOTS instead of public slots.
Comment by kramer on 2016-02-13:
You cannot connect signals and slots with different signatures.
Comment by Kurt Leucht on 2016-02-14:
"you cannot connect signals and slots with different signatures"  Thanks.  This is exactly why a simple working example would be helpful to have on the ROS RQT plugin tutorial site for new users to have as a starting point for their own RQT plugins.
Comment by Dirk Thomas on 2016-02-14:
Maybe you want to start with the Qt tutorials then since what you describe has nothing to do with rqt but how Qt signals and slots work. And I am sure there are really good tutorials out there for that topic.
Comment by Kurt Leucht on 2016-02-14:
"Maybe you want to start with the Qt tutorials". I did.  As I said in my wrong answer above, I used the following documentation (http://doc.qt.io/qt-4.8/signalsandslots.html) to try to integrate signals/slots into the simple example C++ RQT plugin.  But it did not work.  Maybe I'm just dumb.
Comment by Dirk Thomas on 2016-02-15:
As the other comments already point out you are swapping signals and slots (you declared setDataValue to be a slot but use it with SIGNAL(setDataValue(int)) and (b) try to connect two different signature (int with String).
Comment by Dirk Thomas on 2016-02-15:
Try something exactly as it is described in the Qt tutorial you referenced yourself: public slots: void setValue(int value); and signals: void valueChanged(int newValue);. And once that works try iterating from there toward what you would like to have.
Comment by Kurt Leucht on 2016-02-16:
Thanks for all the helpful comments!  Turns out I was defining both the signal and slot in my code when I really only wanted to signal the existing slot in the QLabel class.  The solution in this case was way simpler than all those QT signal/slot tutorials I was looking at.
Comment by elpidiovaldez on 2016-11-17:
I see this topic is old now, but I would like to warn others of a Qt feature that cost me a wasted evening.  Qt does not understand namespaces, even though the C++ compiler does. See this link for more info: http://www.qtcentre.org/threads/22595-connecting-signals-and-slots-from-different-namespaces
Comment by danividanivi on 2018-01-17:
I had exactly the same problem, just in my case it is a service instead of a publisher subscriber. This definitely should be in the tutorials, many thanks to you.
Comment by Tejas Kumar shastha on 2018-04-16:
This was very helpful to me and should certainly go into the tutorial! Thanks!
Comment by Kurt Leucht on 2020-04-03:
"This definitely should be in the tutorials, many thanks to you."  Thanks!  I agree!  Would have saved me a ton of time and frustration.
Comment by Kurt Leucht on 2020-04-03:
"This was very helpful to me and should certainly go into the tutorial!"  Thank you!


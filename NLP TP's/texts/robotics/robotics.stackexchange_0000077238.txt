Q:

not sending different marker colours to rviz properly

when i send different coloured markers it doesn't shows exact object from which its color was extracted. as i've shown below: 1. real object

2. poicloud rendered in rviz
![image description](https://ftp.osuosl.org/pub/ros/download.ros.org/downloads/se_migration/ros/14819498042350993.png)]

object rendered with its colour and coordinates:

I just want to check if the colour datas saved by the 3d model of the object is real or not. Here background color of 2nd image is black.  This code is just for demonstration purpose, i'm using this concept in another program.
        int h = 479, w = 639, n = 306081;
       
        for(int raw = 0;raw<h;raw++)
        {
            for(int col = 0;col<w;col++)
            {
                P[raw][col] = output.at(col,raw);
            }
        }
        rosbag::Bag bag("image.bag");
       int iv = -1, ix = -1, iy = -1, iz = -1, icx=-1, icy=-1, icz=-1;
    
            rosbag::View view(bag, rosbag::TopicQuery("numbers"));
            BOOST_FOREACH(rosbag::MessageInstance const m, view)
               {
                   std_msgs::Float32::ConstPtr i = m.instantiate<std_msgs::Float32>();
                   iv = iv+1; 
                   if(iv>=0 && iv<306081) {
                       ix = ix+1;
                       xv[ix] = i->data;
                   }
                            if(iv>=306081 && iv<306081*2) {
                       iy = iy+1;
                       yv[iy] = i->data;
                   }
                   if(iv>=306081*2 && iv<306081*3) {
                       iz = iz+1;
                       zv[iz] = i->data;
                   }
 

               if(iv>=306081*3 && iv<306081*4) {
                       icx = icx+1;
                       cx[icx] = i->data;
                   }
        if(iv>=306081*4 && iv<306081*5) {
                       icy = icy+1;
                       cy[icy] = i->data;
                   }
        if(iv>=306081*5 && iv<306081*6) {
                       icz = icz+1;
                       cz[icz] = i->data;
                   }
            }
             bag.close();
    
         
             // ** converting already read saved points to 2 d array
             int ip = -1;
             for(int i=0;i<h;i++)
             {
                 for(int j=0;j<w;j++)
                 {
                     ip = ip+1;
                     x[i][j] = xv[ip]; xp[i][j] = P[i][j].x; xc[i][j]=P[i][j].r; // (xp,yp,zp) is present image,(x,y,z) is cordinate of privious image
                     y[i][j] = yv[ip]; yp[i][j] = P[i][j].y; yc[i][j]=P[i][j].g;
                     z[i][j] = zv[ip]; zp[i][j] = P[i][j].z; zc[i][j]=P[i][j].b;
                 }
             }
    
     // ** comparing previous and present point cloud and finding moved objects
                   int im = -1;
                   for(int k=0;k<h;k++)
                           {
                               for(int l=0;l<w;l++)
                           {
                               if( z[k][l]!=0 && zp[k][l]!=0 && !isnan(x[k][l]) && !isnan(xp[k][l]) && !isnan(y[k][l]) && !isnan(yp[k][l]) && !isnan(z[k][l]) && !isnan(zp[k][l]) )
                               {
                                   float dx=abs(float(x[k][l]-xp[k][l])*100);
                                   float dy=abs(float(y[k][l]-yp[k][l])*100);
                                   float dz=abs(float(z[k][l]-zp[k][l])*100); 
                                   float d = sqrt(dx*dx+dy*dy+dz*dz); 
                                   if(d>2)
                                   {
                                       im = im+1;
                                       a[im] =(int) xc[k][l]; b[im] =(int) yc[k][l]; c[im] =(int) zc[k][l]; // (a,b,c) has color of present points  
                                       ac1[im]=xp[k][l]; bc1[im]=yp[k][l]; cc1[im]=zp[k][l]; // (ac1,bc1,cc1) has 3d coordinates  
                                       xa[im] = l; ya[im] = k;
                                   }
                               }
                           }
                        }
std::cout<<"ok"<<std::endl;

    std_msgs::Float32 xo; std::vector<float> xw, yw, zw; std::vector<int> cxw, cyw, czw, cp, mind;  int s=0; 

        for(int l=0;l<=im;l++)  {
            xw.push_back(ac1[l]);  
            yw.push_back(bc1[l]);
            zw.push_back(cc1[l]);

   float var_R = ( a[l] / 255 );        //R from 0 to 255
    float var_G = ( b[l] / 255 );        //G from 0 to 255
    float var_B = ( c[l] / 255 );        //B from 0 to 255
    
    if ( var_R > 0.04045 ) var_R = pow(( ( var_R + 0.055 ) / 1.055 ),2.4);
    else                   var_R = var_R / 12.92;
    if ( var_G > 0.04045 ) var_G = pow(( ( var_G + 0.055 ) / 1.055 ),2.4);
    else                   var_G = var_G / 12.92;
    if ( var_B > 0.04045 ) var_B = pow(( ( var_B + 0.055 ) / 1.055 ),2.4);
    else                   var_B = var_B / 12.92;
    
    var_R = var_R * 100;
    var_G = var_G * 100;
    var_B = var_B * 100;
    
    //Observer. = 2°, Illuminant = D65
    float X = var_R * 0.4124 + var_G * 0.3576 + var_B * 0.1805;
    float Y = var_R * 0.2126 + var_G * 0.7152 + var_B * 0.0722;
    float Z = var_R * 0.0193 + var_G * 0.1192 + var_B * 0.9505;
    
    float var_X = X / 95.047;          //ref_X =  95.047   Observer= 2°, Illuminant= D65
    float var_Y = Y / 100;       //ref_Y = 100.000
    float var_Z = Z / 108.883;          //ref_Z = 108.883
    
    if ( var_X > 0.008856 ) var_X = pow(var_X,0.333 );
    else                    var_X = ( 7.787 * var_X ) + ( 16 / 116 );
    if ( var_Y > 0.008856 ) var_Y = pow(var_Y,0.333 );
    else                    var_Y = ( 7.787 * var_Y ) + ( 16 / 116 );
    if ( var_Z > 0.008856 ) var_Z = pow(var_Z,0.333);
    else                    var_Z = ( 7.787 * var_Z ) + ( 16 / 116 );
    
    int CIEL = ( 116 * var_Y ) - 16+100;
    int CIEa = 500 * ( var_X - var_Y )+128;
    int CIEb = 200 * ( var_Y - var_Z )+128;
                cxw.push_back(CIEL);
                cyw.push_back(CIEa);
                czw.push_back(CIEb); 
             } 
    
    for(int i=0;i<xw.size();i++) {
                       if(!isnan(xw.at(i)) && !isnan(yw.at(i)) && !isnan(zw.at(i)) && zw.at(i)!=0) {
                         points.id = i; 
                         points.color.r=(float) a[i]/255; points.color.g=(float) b[i]/255; points.color.b=(float) c[i]/255; points.color.a=1; 
                         p5.x=xw.at(i); p5.y=yw.at(i); p5.z=zw.at(i);  points.points.push_back(p5);
                         marker_pub.publish(points); } 
    }
    
     rosbag::Bag bagr("test.bag", rosbag::bagmode::Write);
        for(int i=0;i<xw.size();i++)  {
           xo.data = xw.at(i);  bagr.write("numbers", ros::Time::now(), xo); 
           xo.data = yw.at(i);  bagr.write("numbers", ros::Time::now(), xo);
           xo.data = zw.at(i);  bagr.write("numbers", ros::Time::now(), xo); 
        }
        bagr.close();

Originally posted by dinesh on ROS Answers with karma: 932 on 2016-11-10
Post score: 1

Original comments
Comment by NEngelhard on 2016-12-23:
" int h = 479, w = 639, n = 306081;" This is extremely bad coding style. If you use a camera with a different resolution or try to run you algorithm on a downsampled pointcloud, this will fail. Simply read width and height from the pointcloud and use these values.

A:

Judging from your earlier question, you are using a visualization_msgs::Marker message with the type POINTS, looking at the message definition, you can see that there is two ways of specifying the color, which are: Marker.color and Marker.colors. The latter is a vector that has to be of the same length as the number of points. Putting the colors into that vector will allow you to set different colors for different points. If you use Marker.color (like you seem to do in the code you posted before), you will indeed also change the color of the previous points.

Originally posted by rbbg with karma: 1823 on 2016-11-10
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by dinesh on 2016-11-16:
really wow, i'll try this one.
Comment by dinesh on 2016-11-20:
error: ‘visualization_msgs::Marker_std::allocator<void >::_colors_type’ has no member named ‘r’
points.colors.r = 1.0f; it is not working like that. have u urself tried that also?
Comment by rbbg on 2016-12-01:
points.colors.r = 1.0f; will indeed not work, because points.colors is an array of std_msgs::ColorRGBA. In order to set it for the different points you need to set the color for all the points. For each point you need to make a ColorRGBA and add it to the points.colors vector.


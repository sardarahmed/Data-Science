Q:

Controlling a quaternion with 6D controller

To control a robotic arm, I am computing a geometry_msgs::Pose to send to the setFromIK method in ROS control. The Pose has a position and a quaternion. What I am trying to do is control the pose in realtime using a spacenav controller, which has 3 positional and 3 rotational axes.
I am able to set the x, y, and z of the position part of the pose just fine. I am also able to set the quaternion just fine as well, but my current problem is that controlling the quaternion is extremely unintuitive, since rotation is not commutative. i.e., if I rotate 180 degrees about the x-axis, then the control of the rotation about the z-axis gets inverted.
Is there any way that I can control the rotation from a sort of "global reference frame," if that makes any sense? I would like it so that if I twist the joystick clockwise about z, the pose will rotate accordingly, instead of "sometimes rotating clockwise, sometimes rotating counterclockwise."
Here is what I'm currently doing (I've removed everything not related to the quaternion):
while (true) {
  // ... Calculate position ...
  double roll  =  joy_axes[3];
  double pitch =  joy_axes[4];
  double yaw   = -joy_axes[5];
  current_quaternion = last_quaternion * tf::createQuaternionFromRPY(roll, pitch, yaw);
  tf::quaternionTFToMsg(current_quaternion, current_pose.orientation);
  // ... Compute inverse kinematics; convert pose to PoseStamped, publish resulting pose if a solution was found ...
}

By the way, I am converting the pose to a PoseStamped, with frame_id of "base_link." This may or may not have anything to do with how the quaternion is controlled.

Originally posted by duffany1 on ROS Answers with karma: 173 on 2014-04-25
Post score: 0

A:

I wound up solving this problem. The fix was simple, though I'm not too familiar with the mathematical reasoning behind why this solution works, other than the non-commutativity of matrix multiplication. I needed to change
current_quaternion = last_quaternion * tf::createQuaternionFromRPY(roll, pitch, yaw);

to
current_quaternion = tf::createQuaternionFromRPY(roll, pitch, yaw) * last_quaternion;

Originally posted by duffany1 with karma: 173 on 2014-08-26
This answer was ACCEPTED on the original site
Post score: 0


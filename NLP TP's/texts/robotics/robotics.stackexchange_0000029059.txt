Q:

ROS node from Gazebo plugin is not showing in the rosnode list

I want to publish some topics from a Gazebo model plugin to the ROS topic, so I use the C++ ROS node initiation code from some example that I now only copy-paste to all plugins I need.
// Initialize ros, if it has not already been initialized.
std::string node_name = std::string("my_node_name");
if (!ros::isInitialized()) {
  int argc = 0;
  char **argv = nullptr;

  ros::init(argc, argv, node_name. ros::init_options::NoSigintHandler);
}

// Create ROS node.
this->rosNode.reset(new ros::NodeHandle(node_name));

topic_name = "/my_topic";
this->rosPublisher = this->rosNode->advertise<std_msgs::Float64>(topic_name, 1);

The /my_topic topic is registered (I can see it in the rostopic list), I publish to the topic messages on every update (I debugged that the code is being executed, so the messages are being send in the plugin) but when I use rostopic echo /my_node nothing is being printed.
Also using rosnode list shows me no /my_node_name node. I'm thinking the node either isn't created at all, or shuts down. I don't know. How can I check for that, or launch the node correctly, or what else could be going wrong?

Originally posted by kumpakri on Gazebo Answers with karma: 755 on 2020-08-24
Post score: 0

A:

A ros node is initialized by the gazebo_ros_api system plugin. It's the /gazebo you see on the node list. Since the plugins are run in the same process, you can only have 1 node, the /gazebo one.
Having another node for your plugin is not necessary. If you want to keep your plugin independent from everything else, you can just configure the ros backend accordingly
ros::NodeHandle nh;
ros::CallbackQueue callback_queue;
ros::AsyncSpinner spinner(1, &callback_queue);
nh.setCallbackQueue(&callback_queue);
spinner.start();

Originally posted by nlamprian with karma: 833 on 2020-08-24
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by kumpakri on 2020-08-24:
I be damned but this approach actually solved the issue with messages not being printed from the echo. Thank you.
Comment by m.bahno on 2020-08-26:
I'm having some difficulties using this. Whenever subscriber callback is to be called in a plugin with ros set like this, gazebo falls with segmentation fault. There are also other plugins set up like this, might that be the problem? Everything works fine without nh.setCallbackQueue(&callback_queue). Is setting the callback queue to the node handle neccessary or is it enough to set it for the spinner?
Comment by nlamprian on 2020-08-26:
Setting the callback in the node handle is necessary. Otherwise, messages you publish will go into the default queue of the node. Just make sure you don't have a thread of your own servicing the same queue.
Comment by m.bahno on 2020-10-20:
Thank you nlamprian! I just got to it again and my problem was more programatical. I fought with instancing of those classes. In case someone has similar problem, I attach part of my solution for class members:
Comment by m.bahno on 2020-10-20:
.cc
this->rosNode.reset(new ros::NodeHandle());
this->spinner = new ros::AsyncSpinner(1, this->callback_queue);
this->rosNode->setCallbackQueue(this->callback_queue);
this->spinner->start();

Comment by m.bahno on 2020-10-20:
.hh
std::unique_ptr<ros::NodeHandle> rosNode;
ros::CallbackQueue *callback_queue;
ros::AsyncSpinner *spinner;

Comment by m.bahno on 2021-03-22:
I have another question: How is this implementation of AsyncSpinner different from the one usually used in this tutorial? Specifically the section 3. Is AsyncSpinner just implementation of this approach, or there are some differences?
Comment by nlamprian on 2021-03-24:
The two options are effectively the same. In the referenced plugin, a thread is created to spin the queue. The asyncspinner here has its own thread (and potentially more) for the queue.
Comment by m.bahno on 2021-03-31:
Thank you for clearing that! Of course I did insert a wrong link (I meant this, actually containing section 3). But the principle is the same, so I add this for future readers.


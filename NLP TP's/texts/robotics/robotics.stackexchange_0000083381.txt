Q:

Using a laser scan/point cloud to set work-area boundaries

Can anyone recommend a way to use a laser scan or point cloud to limit the areas a fixed-base robot arm will try to reach? I've got a 2D lidar mounted behind the arm that scans the walls and ceiling, giving a roughly parabolic profile. The arm has sufficient reach and maneuverability that it could easily reach and collide with the walls or ceiling. I can assume that the output of the scanner approximately matches the profile directly ahead and behind the position of the arm.
Is there a simple way to set the laser scan as the Y and Z boundaries of the work-area? Since the scans are loosely parabolic I can't just set a square work area limit or create a work cell like in ROS Industrial.
I'm using MoveIt and ROS-Control to control the arm. I'm essentially trying to use the arm to paint the walls and ceiling of the space. I've included a fake link on the URDF that traces the surface profile so collision is avoided there. However, some times other links will move outside the laser scan space which would lead to a collision in real world usage.
Any advice or recommendations appreciated.

Originally posted by rmck on ROS Answers with karma: 147 on 2017-10-17
Post score: 0

A:

I realised a simple solution here was to fake additional 3D scans and pass these as a point cloud to the MoveIt sensor manager. This allows the octomap occupancy tool to work correctly. This in turn provides collision checking. Working as expected now. Here's my code for anyone else looking to do similar.
void fakeProfile(PointCloud::Ptr cloud)
{
    PointCloud add_cloud(*cloud);
    for(int j = 0; j < 10; j++)
    {
        PointCloud temp_cloud(*cloud);
        for (int i = 0; i < cloud->points.size(); i++)
        {   
            temp_cloud.points[i].x += double(j);
        }
        add_cloud += temp_cloud;
    }
    *cloud += add_cloud;
}

And then using the standard moveit sensors.yaml,
    sensors:
      - sensor_plugin: occupancy_map_monitor/PointCloudOctomapUpdater
        point_cloud_topic: /extended_profile
        max_range: 25.0
        point_subsample: 1
        padding_offset: 0.1
        padding_scale: 1.0
        filtered_cloud_topic: filtered_cloud

Edit: The result is shown below, the nearest points are the real scan, the subsequent ones are the faked scans. In my use case, I can guarantee that the area ahead of the robot is clear so only a vertical scan is needed. The scan used here is of my office walls rather than the real work area, hence the square shape.

And here's the resulting octomap. I need to refine it a little further, the robot does keep finding ways to reach through the gaps in the scans but that's easily resolved.

Originally posted by rmck with karma: 147 on 2017-10-17
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by gvdhoorn on 2017-10-18:
This sounds interesting, but I'm having a bit of a hard time trying to visualise it. Any chance you could clarify things a bit and / or include an image of what the result looks like?
Are you essentially creating an arc shaped 'wall' that cordons off the planning volume?
Comment by rmck on 2017-10-18:
Sort of, the laser scan represents the surface I want to paint and which I don't want to collide with. I have a fake link on my end effector which I send commands to "touch" the points along the profile. Have a look at the photos I've added to my answer.
Comment by gvdhoorn on 2017-10-19:
Thanks for the update. This makes it completely clear.
Nice idea.
Btw: you might be interested in the laser_assembler package. It can do this - and more - for you.
Comment by rmck on 2017-10-22:
What would you suggest doing differently? A quick glance over the assembler package isn't making anything leap out at me.
Comment by gvdhoorn on 2017-10-23:
Probably it can be configured to do the same thing, but reusing that node could mean less custom code to maintain, something I believe is always something to strive for.


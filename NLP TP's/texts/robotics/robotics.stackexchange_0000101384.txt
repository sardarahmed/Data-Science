Q:

DiffDriveController in Gazebo Ros control

Hi! I set up a sim via rviz & gazebo firstly using gazebo diff drive plug in. then I noticed some limits using this model and I attempted to switch to gazebo_ros_control diff_drive_controller. the robot spawns and visualizes in gazebo but when in rviz I try to command via joystick or setting a 2d goal nothing happens.
What is wrong? Am i missing something?
Are the two libraries substitutes or do they complement each other?
Launch file
<?xml version="1.0" encoding="UTF-8"?>

<launch>
  <param name="/use_sim_time" value="true" />
  <param name="robot_description" command="$(find xacro)/xacro --inorder $(find nav-sim)/urdf/gbot.urdf.xacro" />
  <node pkg="rviz" type="rviz" name="rviz" output="screen"/>

  <node pkg="robot_state_publisher" name="robot_state_publisher"  type="robot_state_publisher" />

  <node pkg="joint_state_publisher" name="joint_state_publisher" type="joint_state_publisher" />

    <arg name="x" default="0"/>
    <arg name="y" default="0"/>
    <arg name="z" default="0"/>

<!--  <include file="$(find nav-sim)/launch/gbot_control_teleop.launch" />-->
  <include file="$(find gazebo_ros)/launch/empty_world.launch">
   <arg name="world_name" value="$(find nav-sim)/launch/complicated_world_tagged" />
   <arg name="debug" value="false" />
    <arg name="gui" value="true" />
    <arg name="paused" value="false"/>
    <arg name="use_sim_time" value="true"/>
    <arg name="headless" value="false"/>
    <arg name="verbose" value="true"/>
  </include>
  <node name="spawn_robot_urdf" pkg="gazebo_ros" type="spawn_model" output="screen"
        args="-urdf -param robot_description -model gbot.urdf.xacro -x $(arg x) -y $(arg y) -z $(arg z)" >
  </node>

  <rosparam file="$(find nav-sim)/config/gconfig.yaml" command="load" />
    <node name="spawner" pkg="controller_manager" type="spawner"
          respawn="false" output="screen" args= "mobile_base_controller" />

</launch>

Plug in
    <?xml version="1.0"?>
<robot>
  <gazebo reference="base_link">
    <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">
      <robotSimType>gazebo_ros_control/DefaultRobotHWSim</robotSimType>
    </plugin>
  </gazebo>

<!--  <gazebo reference="base_link">-->
<!--    <plugin name="differential_drive_controller" filename="libgazebo_ros_diff_drive.so">-->
<!--      <alwaysOn>true</alwaysOn>-->
<!--      <legacyMode>false</legacyMode>-->
<!--      <updateRate>20</updateRate>-->
<!--      <leftJoint>left_wheel_joint</leftJoint>-->
<!--      <rightJoint>right_wheel_joint</rightJoint>-->
<!--      <wheelSeparation>${wheel_separation}</wheelSeparation>-->
<!--      <wheelDiameter>${wheel_radius * 2}</wheelDiameter>-->
<!--      <torque>20</torque>-->
<!--      <commandTopic>/twist_mux/cmd_vel</commandTopic>-->
<!--      <odometryTopic>/odom_in</odometryTopic>-->
<!--      <odometryFrame>odom</odometryFrame>-->
<!--      <robotBaseFrame>base_link</robotBaseFrame>-->
<!--      <publishWheelTF>false</publishWheelTF>-->
<!--      <publishWheelJointState>false</publishWheelJointState>-->
<!--      <odometrySource>world</odometrySource> &lt;!&ndash; 'encoder' instead of 'world' is also possible &ndash;&gt;-->
<!--      <publishTf>1</publishTf>-->
<!--    </plugin>-->
<!--  </gazebo>-->
  <!-- hokuyo -->
  <gazebo reference="laser_frame_HF">
    <sensor type="ray" name="head_hokuyo_sensor_front">
      <pose>0 0 0 0 0 0</pose>
      <visualize>true</visualize>
      <update_rate>40</update_rate>
      <ray>
        <scan>
          <horizontal>
            <samples>1800</samples>
            <resolution>0.2</resolution>
            <min_angle>-3.14</min_angle>
            <max_angle>3.14</max_angle>
          </horizontal>
        </scan>
        <range>
          <min>0.40</min>
          <max>10.0</max>
          <resolution>0.01</resolution>
        </range>
        <noise>
          <type>gaussian</type>
          <!-- Noise parameters based on published spec for Hokuyo laser
               achieving "+-30mm" accuracy at range < 10m.  A mean of 0.0m and
               stddev of 0.01m will put 99.7% of samples within 0.03m of the true
               reading. -->
          <mean>0.0</mean>
          <stddev>0.00001</stddev>
        </noise>
      </ray>
      <plugin name="gazebo_ros_head_hokuyo_controller" filename="libgazebo_ros_laser.so">
        <topicName>/scanHF</topicName>
        <frameName>laser_frame_HF</frameName>
      </plugin>
    </sensor>
  </gazebo>

  <gazebo reference="laser_frame_HB">
    <sensor type="ray" name="head_hokuyo_sensor_back">
      <pose>0 0 0 0 0 ${3.14}</pose>
      <visualize>true</visualize>
      <update_rate>40</update_rate>
      <ray>
        <scan>
          <horizontal>
            <samples>1800</samples>
            <resolution>0.2</resolution>
            <min_angle>-3.14</min_angle>
            <max_angle>3.14</max_angle>
          </horizontal>
        </scan>
        <range>
          <min>0.40</min>
          <max>10.0</max>
          <resolution>0.01</resolution>
        </range>
        <noise>
          <type>gaussian</type>
          <!-- Noise parameters based on published spec for Hokuyo laser
               achieving "+-30mm" accuracy at range < 10m.  A mean of 0.0m and
               stddev of 0.01m will put 99.7% of samples within 0.03m of the true
               reading. -->
          <mean>0.0</mean>
          <stddev>0.00001</stddev>
        </noise>
      </ray>
      <plugin name="gazebo_ros_head_hokuyo_controller" filename="libgazebo_ros_laser.so">
        <topicName>/scanHB</topicName>
        <frameName>laser_frame_HB</frameName>
      </plugin>
    </sensor>
  </gazebo>
 
</robot>

Config file:
mobile_base_controller:
  type        : "diff_drive_controller/DiffDriveController"
  left_wheel  : 'left_wheel_joint'
  right_wheel : 'right_wheel_joint'
  publish_rate: 50.0               # default: 50
  pose_covariance_diagonal : [0.001, 0.001, 1000000.0, 1000000.0, 1000000.0, 1000.0]
  twist_covariance_diagonal: [0.001, 0.001, 1000000.0, 1000000.0, 1000000.0, 1000.0]

  # Wheel separation and diameter. These are both optional.
  # diff_drive_controller will attempt to read either one or both from the
  # URDF if not specified as a parameter
#  wheel_separation : 1.0
#  wheel_radius : 0.3

  # Wheel separation and radius multipliers
  wheel_separation_multiplier: 1.0 # default: 1.0
  wheel_radius_multiplier    : 1.0 # default: 1.0

  # Velocity commands timeout [s], default 0.5
  cmd_vel_timeout: 0.25

  # Base frame_id
  base_frame_id: base_link #default: base_link

  # Odom frame_id
  odom_frame_id: /odom #default: /odom

  # Velocity and acceleration limits
  # Whenever a min_* is unspecified, default to -max_*
  linear:
    x:
      has_velocity_limits    : true
      max_velocity           : 1.0  # m/s
      min_velocity           : -0.5 # m/s
      has_acceleration_limits: true
      max_acceleration       : 0.8  # m/s^2
      min_acceleration       : -0.4 # m/s^2
      has_jerk_limits        : true
      max_jerk               : 5.0  # m/s^3
  angular:
    z:
      has_velocity_limits    : true
      max_velocity           : 1.7  # rad/s
      has_acceleration_limits: true
      max_acceleration       : 1.5  # rad/s^2
      has_jerk_limits        : true
      max_jerk               : 2.5  # rad/s^3
  /gazebo_ros_control:
    pid_gains:
      left_wheel_joint:
        p: 1.0
        i: 1.0
        d: 0.0
      right_wheel_joint:
        p: 1.0
        i: 1.0
        d: 0.0

#left_wheel:
#    type: velocity_controllers/JointVelocityController
#    joint: left_wheel_joint
#    pid: { p: 1.0, i: 1.0, d: 0.0 }
#
#right_wheel:
#    type: velocity_controllers/JointVelocityController
#    joint: right_wheel_joint
#    pid: { p: 1.0, i: 1.0, d: 0.0 }

Robot urdf:
<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="gbot">

  <xacro:property name="base_width" value="0.202"/>
  <xacro:property name="base_len" value="0.3"/>
  <xacro:property name="wheel_radius" value="0.030"/>
  <xacro:property name="base_wheel_gap" value="0.007"/>
  <xacro:property name="wheel_separation" value="0.15"/>
  <xacro:property name="wheel_joint_offset" value="0.02"/>
  <xacro:property name="caster_wheel_radius" value="0.015"/>
  <xacro:property name="caster_wheel_joint_offset" value="0.1"/>
  <xacro:property name="laser_radius" value="0.03"/>
  <xacro:property name="laser_len" value="0.02"/>

  <xacro:macro name="box_inertia" params="m w h d">
    <inertial>
      <mass value="${m}"/>
      <inertia ixx="${m / 12.0 * (d*d + h*h)}" ixy="0.0" ixz="0.0" iyy="${m / 12.0 * (w*w + h*h)}" iyz="0.0" izz="${m / 12.0 * (w*w + d*d)}"/>
    </inertial>
  </xacro:macro>
  <xacro:macro name="cylinder_inertia" params="m r h">
    <inertial>
      <mass value="${m}"/>
      <inertia ixx="${m*(3*r*r+h*h)/12}" ixy = "0" ixz = "0" iyy="${m*(3*r*r+h*h)/12}" iyz = "0" izz="${m*r*r/2}"/>
    </inertial>
  </xacro:macro>

<!--  <link name="dummy">-->
<!--   </link>-->
 

 
  <link name="base_link">
    <xacro:box_inertia m="10" w="${base_len}" h="${base_width}" d="0.01"/>
    <visual>
      <geometry>
        <box size="${base_len} ${base_width} 0.02"/>
      </geometry>
    </visual>
    <collision>
      <geometry>
        <box size="${base_len} ${base_width} 0.01"/>
      </geometry>
    </collision>
  </link>
<!--  <joint name="dummy_joint" type="fixed">-->
<!--    <parent link="dummy"/>-->
<!--    <child link="base_link"/>-->
<!--  </joint>-->

  <link name="base_footprint">
    <xacro:box_inertia m="20" w="0.001" h="0.001" d="0.001"/>
    <visual>
        <origin xyz="0 0 0" rpy="0 0 0" />
        <geometry>
            <box size="0.001 0.001 0.001" />
        </geometry>
    </visual>
  </link>

  <joint name="base_link_joint" type="fixed">
    <origin xyz="0 0 ${wheel_radius + 0.005}" rpy="0 0 0" />
    <parent link="base_link"/>
    <child link="base_footprint"/>
  </joint>

<!--  <xacro:macro name="sensor_laser">-->
  <link name="laser_frame_HF">
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <mass value="1" />
      <geometry>
        <cylinder radius="${laser_radius}" length="${laser_len}"/>
      </geometry>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <cylinder radius="${laser_radius}" length="${laser_len}"/>
      </geometry>
    </collision>
    <xacro:cylinder_inertia m="1" r="${laser_radius}" h="${laser_len}"/>
  </link>
  <joint name="sensor_laser_joint" type="fixed">
    <origin xyz="${base_len/3} 0 0.1" rpy="0 0 0"/>
    <parent link="base_footprint" />
    <child link="laser_frame_HF" />
  </joint>

  <link name="laser_frame_HB">
    <visual>
      <origin xyz="0 0 0" rpy="0 0 ${3.14}"/>
      <mass value="1" />
      <geometry>
        <cylinder radius="${laser_radius}" length="${laser_len}"/>
      </geometry>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 ${3.14}"/>
      <geometry>
        <cylinder radius="${laser_radius}" length="${laser_len}"/>
      </geometry>
    </collision>
    <xacro:cylinder_inertia m="1" r="${laser_radius}" h="${laser_len}"/>
  </link>
  <joint name="sensor_laser_joint2" type="fixed">
    <origin xyz="-${base_len/3} 0 0.1" rpy="0 0 3.14"/>
    <parent link="base_footprint" />
    <child link="laser_frame_HB" />
  </joint>

<!--  </xacro:macro>-->

<!--  <xacro:sensor_laser />-->
 
  <xacro:macro name="wheel" params="prefix reflect">
    <link name="${prefix}_wheel">
      <visual>
        <origin xyz="0 0 0" rpy="${pi/2} 0 0"/>
        <geometry>
          <cylinder radius="${wheel_radius}" length="0.005"/>
        </geometry>
      </visual>
      <collision>
        <origin xyz="0 0 0" rpy="${pi/2} 0 0"/>
        <geometry>
          <cylinder radius="${wheel_radius}" length="0.005"/>
        </geometry>
      </collision>
      <xacro:cylinder_inertia m="10" r="${wheel_radius}" h="0.005"/>
    </link>
 
    <joint name="${prefix}_wheel_joint" type="continuous">
      <axis xyz="0 1 0" rpy="0 0 0" />
      <parent link="base_link"/>
      <child link="${prefix}_wheel"/>
      <origin xyz="0 ${((base_width/2)+base_wheel_gap)*reflect} -0.005" rpy="0 0 0"/>
    </joint>
  </xacro:macro>

  <transmission name="left_wheel_transmission">
  <type>transmission_interface/SimpleTransmission</type>
  <joint name="left_wheel_joint">
    <hardwareInterface>hardware_interface/VelocityJointInterface</hardwareInterface>
  </joint>
  <actuator name="left_wheel_actuator">
    <mechanicalReduction>1</mechanicalReduction>
    <hardwareInterface>VelocityJointInterface</hardwareInterface>
  </actuator>
  </transmission>

  <transmission name="right_wheel_transmission">
  <type>transmission_interface/SimpleTransmission</type>
  <joint name="right_wheel_joint">
    <hardwareInterface>hardware_interface/VelocityJointInterface</hardwareInterface>
  </joint>
  <actuator name="right_wheel_actuator">
    <mechanicalReduction>1</mechanicalReduction>
    <hardwareInterface>VelocityJointInterface</hardwareInterface>
  </actuator>
  </transmission>
 
  <xacro:wheel prefix="left" reflect="1"/>
  <xacro:wheel prefix="right" reflect="-1"/>  
<xacro:macro name="sphere_inertia" params="m r">
    <inertial>
      <mass value="${m}"/>
      <inertia ixx="${2.0*m*(r*r)/5.0}" ixy="0.0" ixz="0.0" iyy="${2.0*m*(r*r)/5.0}" iyz="0.0" izz="${2.0*m*(r*r)/5.0}"/>
    </inertial>
  </xacro:macro>
 
  <link name="caster_wheel1">
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <sphere radius="${caster_wheel_radius}"/>
      </geometry>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <sphere radius="${caster_wheel_radius}"/>
      </geometry>
    </collision>
    <xacro:sphere_inertia m="1" r="${caster_wheel_radius}"/>
  </link>
 
  <joint name="caster_wheel_joint" type="continuous">
    <axis xyz="0 1 0" rpy="0 0 0" />
    <parent link="base_link"/>
    <child link="caster_wheel1"/>
    <origin xyz="${caster_wheel_joint_offset} 0 -${caster_wheel_radius+0.005}" rpy="0 0 0"/>
  </joint>

  <link name="caster_wheel2">
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <sphere radius="${caster_wheel_radius}"/>
      </geometry>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <sphere radius="${caster_wheel_radius}"/>
      </geometry>
    </collision>
    <xacro:sphere_inertia m="5" r="${caster_wheel_radius}"/>
  </link>

  <joint name="caster_wheel_joint2" type="continuous">
    <axis xyz="0 1 0" rpy="0 0 0" />
    <parent link="base_link"/>
    <child link="caster_wheel2"/>
    <origin xyz="-${caster_wheel_joint_offset} 0 -${caster_wheel_radius+0.005}" rpy="0 0 0"/>
  </joint>

  <xacro:include filename="$(find nav-sim)/urdf/_d435.urdf.xacro" />
  <sensor_d435 parent="base_link">
    <origin xyz="0 0 0" rpy="0 0 0"/>
  </sensor_d435>

  <xacro:include filename="$(find nav-sim)/urdf/gbot_gazebo_plugins.urdf.xacro"/>

</robot>

Plug-ins:
<?xml version="1.0"?>
<robot>
  <gazebo>
    <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">
    </plugin>
  </gazebo>

<!--  <gazebo>-->
<!--    <plugin name="differential_drive_controller" filename="libgazebo_ros_diff_drive.so">-->
<!--      <alwaysOn>false</alwaysOn>-->
<!--      <legacyMode>false</legacyMode>-->
<!--      <updateRate>20</updateRate>-->
<!--      <leftJoint>left_wheel_joint</leftJoint>-->
<!--      <rightJoint>right_wheel_joint</rightJoint>-->
<!--      <wheelSeparation>${wheel_separation}</wheelSeparation>-->
<!--      <wheelDiameter>${wheel_radius * 2}</wheelDiameter>-->
<!--      <torque>20</torque>-->
<!--      <commandTopic>/twist_mux/cmd_vel</commandTopic>-->
<!--      <odometryTopic>/odom_in</odometryTopic>-->
<!--      <odometryFrame>odom</odometryFrame>-->
<!--      <robotBaseFrame>base_link</robotBaseFrame>-->
<!--    </plugin>-->
<!--  </gazebo>-->
  <!-- hokuyo -->
  <gazebo reference="laser_frame_HF">
    <sensor type="ray" name="head_hokuyo_sensor_front">
      <pose>0 0 0 0 0 0</pose>
      <visualize>true</visualize>
      <update_rate>40</update_rate>
      <ray>
        <scan>
          <horizontal>
            <samples>1800</samples>
            <resolution>0.2</resolution>
            <min_angle>-3.14</min_angle>
            <max_angle>3.14</max_angle>
          </horizontal>
        </scan>
        <range>
          <min>0.40</min>
          <max>10.0</max>
          <resolution>0.01</resolution>
        </range>
        <noise>
          <type>gaussian</type>
          <!-- Noise parameters based on published spec for Hokuyo laser
               achieving "+-30mm" accuracy at range < 10m.  A mean of 0.0m and
               stddev of 0.01m will put 99.7% of samples within 0.03m of the true
               reading. -->
          <mean>0.0</mean>
          <stddev>0.00001</stddev>
        </noise>
      </ray>
      <plugin name="gazebo_ros_head_hokuyo_controller" filename="libgazebo_ros_laser.so">
        <topicName>/scanHF</topicName>
        <frameName>laser_frame_HF</frameName>
      </plugin>
    </sensor>
  </gazebo>

  <gazebo reference="laser_frame_HB">
    <sensor type="ray" name="head_hokuyo_sensor_back">
      <pose>0 0 0 0 0 ${3.14}</pose>
      <visualize>true</visualize>
      <update_rate>40</update_rate>
      <ray>
        <scan>
          <horizontal>
            <samples>1800</samples>
            <resolution>0.2</resolution>
            <min_angle>-3.14</min_angle>
            <max_angle>3.14</max_angle>
          </horizontal>
        </scan>
        <range>
          <min>0.40</min>
          <max>10.0</max>
          <resolution>0.01</resolution>
        </range>
        <noise>
          <type>gaussian</type>
          <!-- Noise parameters based on published spec for Hokuyo laser
               achieving "+-30mm" accuracy at range < 10m.  A mean of 0.0m and
               stddev of 0.01m will put 99.7% of samples within 0.03m of the true
               reading. -->
          <mean>0.0</mean>
          <stddev>0.00001</stddev>
        </noise>
      </ray>
      <plugin name="gazebo_ros_head_hokuyo_controller" filename="libgazebo_ros_laser.so">
        <topicName>/scanHB</topicName>
        <frameName>laser_frame_HB</frameName>
      </plugin>
    </sensor>
  </gazebo>
 
</robot>

Originally posted by prcgnn on ROS Answers with karma: 11 on 2022-03-21
Post score: 1

A:

Hi prcgnn. These two libraries are not complementary. ROS Control is a generic framework to implement controllers in ROS applications, for example, the diff_drive_controller. gazebo_ros_control is a Gazebo Plugin that "talks" with the ROS Control stack (through a Hardware Interface), allowing you to control a robot in Gazebo using a ROS Controller.
I suggest you read the documentation from ROS Control, and also how it works with Gazebo (link).
But that being said. As you did not post the entire robot's URDF, I imagine that you did not add the transmission associated to the joints you need to move (link).
Could you edit your question and include your terminals? Probably they have some useful information too.
Also, the way you define the yaml file, instead of "cmd_vel", your rostopic will probably be "mobile_base_controller/cmd_vel". It works fine, but if you want to use the teleop or rviz's joystick, you need to set them to use the new name.
Check this tutorial about diff_drive_controller, it may help you.
I hope this information is helpful, and you can solve your issue.

Originally posted by schulze18 with karma: 91 on 2022-03-22
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by prcgnn on 2022-03-23:
Thank you for your reply. I just added the urdf missing part. Have a look and tell me if you see something strange. The fact is this frobot is part of a larger navigation module based on twist mux (cmd_vel and joystick) and odom fram with topic odom_in. In the gazebo plug in I was able to specify all this parameters but in this ros_control I am not. Any hint?
Comment by schulze18 on 2022-03-24:
In general, the ros controllers set their topic names based on the controller namespace ("mobile_base_controller" in your case). But you can use topic remap to change it (link). Is your controller working? For example, if you test without the joystick, teleop, etc, and you just do a "rostopic pub" into the topic ending with "cmd_vel" (probably "mobile_base_controller/cmd_vel"). Does the robot move? if you do a "rostopic list", is there any topic with "cmd_vel"?
Comment by prcgnn on 2022-03-24:
Yes, I already implemented the remap and all is inside cmd_vel and odom _in topics.
If testing with rostopic pub the robot moves still slowsly.
Yes, if input rostopic list cmd_vel is shown. It seemes like rviz and gazebo have different types of behaviour.For ex. a rotation of 90 deg in rviz corresponds to ~60 deg in gazebo. Any idea?
Comment by schulze18 on 2022-03-25:
Make sure you are continuos publishing into cmd_vel, by using the "-r 100" in the ros topic pub. Do your wheels seem to be rotating in place in Gazebo? Like slipping on the floor? If so, probably you need to tune the friction and physical coefficients of your link (setting max_step_size to 0.001 and real_time_update_rate to 1000 in the Gazebo Physics usually also help in those cases too).
Comment by prcgnn on 2022-03-29:
Is it possible to tune Gazebo Physics inside urdf file? Or where do I have to specify them? I have no sdf.
Yes I confirm you that robot moves when publishing cmd_vel topics.


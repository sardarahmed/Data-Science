Q:

rviz not clearing markers after lifetime

Hi everyone,
I'm trying to display objects' velocities that I get from a radar sensor at a rate of 5Hz as a visualization_msgs::MarkerArray of visualization_msgs::Marker::ARROW. Basically I receive the point cloud, I cluster it and then I calcule the average velocity of each cluster. The markers work well (I can see they are well oriented and I set the length of the arrow based on the speed of the cluster). I set the markers lifetime to be 0.2 s, but markers are not cleared unless I publish a new one with the same id (which implicitly deletes the previous one, I think). The thing is that I cannot know how many markers I will publish in each frame because that depends on the objects present in the scene, so I'd like to rely on the lifetime attribute to clear the markers.
I've seen this question that is quite related but does not provide a solution. It does remark the fact that the countdown resets everytime a marker with the same id is published, but that should not bother me, I suppose, as if I publish a new velocity with an id it will indeed delete the last one. It is mainly when there are no dynamic objects in the scene that the arrows remain (even though they have a certain lifetime). Any suggestions on this problem? I leave an snipet of my code where I create the markers (I create an arrow for each cluster and velocities is my visualization_msgs::MarkerArray):
 ...  
  // Cluster velocity
  temp_vel = temp_vel/j;

  if (std::abs(temp_vel) > 0.05)
   {
      Eigen::Vector4f min, max;
      geometry_msgs::Point centroid, radial_direction;
      pcl::getMinMax3D(*pcloud_mrg, *it, min, max);

      centroid.x = (max(0) + min(0))/2;
      centroid.y = (max(1) + min(1))/2;
      centroid.z = (max(2) + min(2))/2;

      Eigen::VectorXf temp_vec(3);
      temp_vec(0) = centroid.x;
      temp_vec(1) = centroid.y;
      temp_vec(2) = centroid.z;
      float norm = temp_vec.norm();

      radial_direction.x = centroid.x + (centroid.x/norm)*temp_vel;
      radial_direction.y = centroid.y + (centroid.y/norm)*temp_vel;
      radial_direction.z = centroid.z + (centroid.z/norm)*temp_vel;
                    
      visualization_msgs::Marker m;
      m.header.frame_id = "base_radar_link";
      m.header.stamp = stamp;
      m.lifetime = ros::Duration(0.2);
      m.id = id;
      m.type = visualization_msgs::Marker::ARROW;
      m.action = visualization_msgs::Marker::ADD;

      m.color.a = 0.5;
      m.color.r = 0.0;
      m.color.g = 0.0;
      m.color.b = 0.0;

      m.scale.x = 0.02;
      m.scale.y = 0.04;
      m.scale.z = 0.02;

      m.points.push_back(centroid);
      m.points.push_back(radial_direction);

      velocities.markers.push_back(m);   

  }
  id++;
...

Don't know if it is relevant but I'm running ROS Kinetic on Ubuntu 16.04

Originally posted by pfontana96 on ROS Answers with karma: 18 on 2020-02-12
Post score: 0

Original comments
Comment by Delb on 2020-02-12:
Do you clear the vector velocities.markers at some point ? If not you do have a different id for each marker but you still publish the previous ones since push_back simply add the new markers at the end of the vector. Moreover if you publish the markers at the rate of your sensor (5Hz which means every 0.2 second then you won't be able to see if the markers have been deleted.
Comment by pfontana96 on 2020-02-12:
I cannot believe I lost so much time on this! I didn't pay attention to that, now it is working just fine! Thank you a lot
Comment by Delb on 2020-02-12:
I'm glad you solved your issue, can you answer your question to describe how/what you did exactly and then accept it as the correct answer please ? It will help future readers to directly see your solution. Was it the vector not being cleared or the lifetime set at the same publishing rate of your sensor that solved your issue ?
Comment by pfontana96 on 2020-02-12:
It was solved by clearing the vector before adding the new frame's velocities (velocities.markers.clear()). I did not understand why would the lifetime set to 0.2s be an issue (as I know I'll receive new a new pointcloud at 0.2s I want old markers to be cleared at that same rate), could you tell me if I'm missing something here?
Comment by Delb on 2020-02-12:
That was a guess but as you pointed from another question :

The countdown resets if another marker of the same namespace/id is received.

Not sure if the lack of namespace imply that the reset only rely on the id. If it's not the case, they (hypothetically) share the same namespace (nothing) so all the countdowns would be reset every 0.2 sec.

A:

As @Delb pointed out, I was not clearing velocities.markers vector but just adding markers to it. A simple velocities.markers.clear() before adding new velocities solved the problem!

Originally posted by pfontana96 with karma: 18 on 2020-02-12
This answer was ACCEPTED on the original site
Post score: 0


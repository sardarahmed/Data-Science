Q:

How to use a Service Request as generic

I am trying to make a function which accepts a Service Request of any type, so something like this: 
template<typename T, typename ServiceT> 

```
bool sendRequest(std::shared_ptr> client, std::shared_ptr request);
```
The first parameter works fine, but the second parameter does not work, and I'm not sure how to do it correctly.
How do I use the generic for a Service Request?

Originally posted by xander-m2k on ROS Answers with karma: 23 on 2021-12-31
Post score: 1

A:

You're close! First, the template typenames T and ServiceT are the same types, so you only need to declare one, let's use ServiceT.
You did not specify why "the second parameter does not work", so it's impossible to know for sure what your issue is... The following could work:
template <typename ServiceT>
bool sendRequest(std::shared_ptr<rclcpp::Client<ServiceT>> client, std::shared_ptr<typename ServiceT::Request> request)
{
    // let 'node' be a std::shared_ptr<NodeType> declared elsewhere...
    auto result = client->async_send_request(request);
    return rclcpp::FutureReturnCode::SUCCESS == rclcpp::spin_until_future_complete(node, result);
}

The difference for the second argument is the typename keyword. Since this is a templated function, the compiler needs to know that for any ServiceT, that ServiceT::Request will be a type name. Without the typename keyword, the compiler doesn't have enough information to know your intention, e.g. ServiceT::Request could be a static data member.
In the future, you should at least include why "the second parameter does not work".

Originally posted by rnvandemark with karma: 36 on 2021-12-31
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by xander-m2k on 2022-01-03:
I'm sorry for describing a vague description of it not working. I knew the syntax was not correct, hence I simply said "it does not work", but actually it should be "incorrect syntax".
Anyway, I think this does work indeed.
My goal was to make the function more intuitive for the user, so the functions second parameter would only be used with a request, because async_send_request() uses that as parameter. Apart from that, my first idea was to leave it just as std::shared_ptr<ServiceT> request, because I did not know how to do that.

I'm actually wondering how this works. For the first parameter it seems simple, because ServiceT will just be any type of the class rclcpp::Client. But, for the second argument, since ServiceT is not an actual type, how does the compiler know that the ServiceT type has a Request type, and how would that match against the actual Request class? Is the name of the typename the part that matters most for this? How does that work?


Q:

Sending multiple Goals to robot by cpp code

after testing the sending a simpleGoal to my robot i based on http://wiki.ros.org/navigation/Tutorials/SendingSimpleGoals and it working  well
i focus now  on sending multiple goals  when it reached the first one go to the second one ...
it's possible   if yes  help with documentations or example
NB: i am programming with cpp :)
Update:
i tried with this  what do you think about it
#include <ros/ros.h>
#include <move_base_msgs/MoveBaseAction.h>
#include <actionlib/client/simple_action_client.h>

typedef actionlib::SimpleActionClient<move_base_msgs::MoveBaseAction> MoveBaseClient;

bool one_move(move_base_msgs::MoveBaseGoal goal) {
  goal.target_pose.header.frame_id = "base_link";
  goal.target_pose.header.stamp = ros::Time::now();

      ac.sendGoal(goal);
      ac.waitForResult();
      if(ac.getState() == actionlib::SimpleClientGoalState::SUCCEEDED)
           return true;
      else
           return false;
        }

int main(int argc, char** argv){
  ros::init(argc, argv, "simple_navigation_goals");

  //tell the action client that we want to spin a thread by default
  MoveBaseClient ac("move_base", true);

  //wait for the action server to come up
  while(!ac.waitForServer(ros::Duration(5.0))){
    ROS_INFO("Waiting for the move_base action server to come up");
  }

  move_base_msgs::MoveBaseGoal goal[3];

  goal[0].target_pose.pose.position.x = 0.7783;
  goal[0].target_pose.pose.position.y = -0.0390;
  goal[0].target_pose.pose.position.z = 0.0;

  goal[0].target_pose.pose.orientation.x = 0.0;
  goal[0].target_pose.pose.orientation.y = 0.0;
  goal[0].target_pose.pose.orientation.z = 0.0182;
  goal[0].target_pose.pose.orientation.w = 0.99910;

  goal[1].target_pose.pose.position.x = 0.7783;
  goal[1].target_pose.pose.position.y = -0.0390;
  goal[1].target_pose.pose.position.z = 0.0;

  goal[1].target_pose.pose.orientation.x = 0.0;
  goal[1].target_pose.pose.orientation.y = 0.0;
  goal[1].target_pose.pose.orientation.z = 0.0182;
  goal[1].target_pose.pose.orientation.w = 0.99910;
  
  goal[2].target_pose.pose.position.x = 0.7783;
  goal[2].target_pose.pose.position.y = -0.0390;
  goal[2].target_pose.pose.position.z = 0.0;

  goal[2].target_pose.pose.orientation.x = 0.0;
  goal[2].target_pose.pose.orientation.y = 0.0;
  goal[2].target_pose.pose.orientation.z = 0.0182;
  goal[2].target_pose.pose.orientation.w = 0.99910;

  //we'll send a goal to the robot to move 1 meter forward
 

 ROS_INFO("Sending goal1");
for(int i=0; i<3; i++)
 {
    if(one_move(goal[i])
     {
      ROS_INFO("Hooray, the %f goal reached",i);
     }
    else 
   {
      ROS_INFO("The the %f goal doesn't reached for some reason",i)
   return 0;
  }     
}

Originally posted by abdelkrim on ROS Answers with karma: 9 on 2018-03-14
Post score: 0

A:

Well I think that there are 2 main problems in your code:

There is a redundancy in the instructions,  and if you will once need to send more than 2 goals , say 5 or even 10 you'll get a huge code for no reason.

Your code doesn't care if the robot didn't succeed the first goal  and passes to the second one anyway.

A better practice would be to:
//create a function taking care about reaching one goal and returning true if it succeed
bool one_move(goal) {
      ...
      ac.sendGoal(goal);
      ac.waitForResult();
      if(ac.getState() == actionlib::SimpleClientGoalState::SUCCEEDED)
           return true;
      else
           return false;
        }
                    
int main(int argc, char** argv){
       ...
     //define  a list of goals
     //loop over the entered goals and pass to the next goal if OK or break if not.
      ...
     return 0;
        }

Good luck!

Originally posted by Jasmin with karma: 188 on 2018-03-15
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by abdelkrim on 2018-03-15:
thank you very much :)
Comment by Jasmin on 2018-03-15:
You're welcome!
Comment by abdelkrim on 2018-03-15:
i modified the code have a look ;)
Comment by Jasmin on 2018-03-19:
Theoretically, that's it but, did you try to compile the node and run it. There are some obvious errors like in bool one_move(goal) { , it is needed to specify the input type of the function etc. You need to succeed the compilation and see the output result to know if something is going wrong.
Comment by abdelkrim on 2018-03-20:
yeah i see i made the modifications requires now works well thank you very much :)
Comment by Jasmin on 2018-03-20:
Happy to help!
Comment by aarontan on 2018-06-06:
what is the final answer?
Comment by Joseph444 on 2020-06-19:
Hello, is it possible if I could see the revised? I've been trying for days to find a way to make a square or circular path using multiple goals in cpp.
Comment by Jasmin on 2020-06-19:
Hi, can you be more precise or share your progress so we can help you better?


Q:

Problem using ROS-Package-Headers in Gazebo-Plugin

Hi,
I'm currently working on my first Gazebo Plugin where I use several ROS-Packages. When I try to compile it, the compiler doesn't find these includes (i.e. PCL Headers).
Is there anything I've got to add to the Cmake-File?

Originally posted by Seba on ROS Answers with karma: 21 on 2013-06-18
Post score: 0

Original comments
Comment by Throst Gunnulf on 2013-07-16:
Hey, are you using simulator_gazebo (the ROS package) or the Gazebo 1.9 (the standalone)? If you're using the standalone, I might be able to help you as I just solved a similar problem.
Comment by Seba on 2013-07-16:
Thank you for your reply. I work with Gazebo Standalone
Comment by Throst Gunnulf on 2013-07-16:
I'll try to post an answer later today. I am new to these forums, so I need to learn how to correctly format everything and can only do that later.

A:

Solution 2 (better)
I realised there is a much simpler way of solving this problem. Just create a ROS package as usual with your plugin code in the /src/ folder of the ROS package directory. Then, edit your CMakeLists.txt to be something like this

cmake_minimum_required(VERSION 2.4.6)
include($ENV{ROS_ROOT}/core/rosbuild/rosbuild.cmake)

include (FindPkgConfig)
if (PKG_CONFIG_FOUND)
  pkg_check_modules(GAZEBO gazebo)
endif()

# Set the build type.  Options are:
#  Coverage       : w/ debug symbols, w/o optimization, w/ code-coverage
#  Debug          : w/ debug symbols, w/o optimization
#  Release        : w/o debug symbols, w/ optimization
#  RelWithDebInfo : w/ debug symbols, w/ optimization
#  MinSizeRel     : w/o debug symbols, w/ optimization, stripped binaries
#set(ROS_BUILD_TYPE RelWithDebInfo)

rosbuild_init()

#set the default path for built executables to the "bin" directory
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)
#set the default path for built libraries to the "lib" directory
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)

#uncomment if you have defined messages
#rosbuild_genmsg()
#uncomment if you have defined services
#rosbuild_gensrv()

include_directories(${GAZEBO_INCLUDE_DIRS})
link_directories(${GAZEBO_LIBRARY_DIRS})

#common commands for building c++ executables and libraries
rosbuild_add_library(${PROJECT_NAME} ${GAZEBO_libraries} src/plugin.cc)
#target_link_libraries(${PROJECT_NAME} another_library)
#rosbuild_add_boost_directories()
#rosbuild_link_boost(${PROJECT_NAME} thread)
#rosbuild_add_executable(example examples/example.cpp)
target_link_libraries(${PROJECT_NAME} ${GAZEBO_libraries})

What this does is compile your plugin into a .so file (output to the /lib/ folder). Put this plugin into one of the directories in the GAZEBO_PLUGIN_PATH environment variable and everything should run just fine.

Solution 1
Hey, sorry for the delay. I am quite new to Gazebo and ROS, so take everything I say with a grain of salt. The following makes sense in my head, but I might be terribly wrong about some things. Nevertheless, it solved my problem. I hope this helps. Don't hesitate to ask for a better explanation of something I might have overlooked.
First, I assume you use a CMake script similar to this one to compile your plugin into a .so file.

cmake_minimum_required(VERSION 2.8 FATAL_ERROR)

include (FindPkgConfig)
if (PKG_CONFIG_FOUND)
  pkg_check_modules(GAZEBO gazebo)
endif()

include_directories(${GAZEBO_INCLUDE_DIRS})
link_directories(${GAZEBO_LIBRARY_DIRS})

add_library(example SHARED example.cc)
target_link_libraries(example ${GAZEBO_libraries})

The first thing I did, to solve the missing header files, was to change the sixth and the last lines to the following.

include_directories(${GAZEBO_INCLUDE_DIRS} /path/to/ROS/include/folder)
    
target_link_libraries(example ${GAZEBO_libraries} ${LD_LIBRARY_PATH})

Notice you should change /path/to/ROS/include/folder to the correct path to your ROS include folder. In my system, the path is /opt/ros/fuerte/include/
Now, if you run the CMake script, the compiler should find the header files and compile everything without problems. But, if you're using functions that are defined in the example_package package, when you run the Gazebo plugin, you will probably get an error saying something like "undefined symbol". This is because the linker doesn't know where the code of the functions is.
The problem here is that this code is defined in the example_package package, and I don't know how to link a program with a ROS package. Luckily, I found the following CMake script, which, when included in your original CMake script allows you to do just that. Get the script from
 github.com/jrl-umi3218/jrl-cmakemodules 
(sorry, not enough Karma to post a link).
Put the script in the same directory as your original CMake script. Now, change your script to the following.

cmake_minimum_required(VERSION 2.8 FATAL_ERROR)

include (FindPkgConfig)
if (PKG_CONFIG_FOUND)
  pkg_check_modules(GAZEBO gazebo)
endif()

include (downloaded_script_name)
ADD_ROSPACK_DEPENDENCY(example_package)

include_directories(${GAZEBO_INCLUDE_DIRS} /path/to/ROS/include/folder)
link_directories(${GAZEBO_LIBRARY_DIRS} ${LD_LIBRARY_PATH})

add_library(example SHARED example.cc)
ROSPACK_USE_DEPENDENCY(mrl_impep_plugin example_package)
target_link_libraries(example ${GAZEBO_libraries} ${LD_LIBRARY_PATH})

You should change "downloaded_script_name" to the name you gave to the downloaded CMake script.
I had to comment lines 41 and 42 of the downloaded CMake script, as they use undefined macros. If you have this problem, comment the lines. Now everything should compile and link correctly, which means your Gazebo plugin should run fine.

Originally posted by Throst Gunnulf with karma: 56 on 2013-07-16
This answer was ACCEPTED on the original site
Post score: 1


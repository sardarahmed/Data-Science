Q:

how to execute service while getting subscriber messages

I want to build a service to move to a particular point on a line. The problem is when I receive my service call, the thread is stuck in this callback and so global spinner in another thread does not process callback queue. I have read some handy advice in a related question, however I see no way to use multithreaded or async spinner elegantly in my case.
Omitting some irrelevant details, I have two nodes that give me odometry and expect twist respectively, thus managing an engine. As a backbone of my node I have a software PID regulator, that tells me what speed I should set in twist for a good speed profile based on current goal and current odometry. I used three std::thread's: to run the service's callback, to publish twist on odometry callback and to run spinOnce() with some loop rate. As soon as I stop in service callback (locked by a mutex set in PID regulator until I reach destination), odometry callback is never triggered.
I could implement my own child class from ros::Spinner that could process my service calls asynchronously and all other messages synchronously, but that sounds like overengineering for such a primitive system. What am I missing?

Originally posted by volume_8091 on ROS Answers with karma: 27 on 2019-04-01
Post score: 0

A:

Does roscpp/Overview/Callbacks and Spinning not answer your question(s)?

I could implement my own child class from ros::Spinner that could process my service calls asynchronously and all other messages synchronously, but that sounds like overengineering for such a primitive system.

Multithreaded or asynchronous spinning should do what you are after.

Originally posted by gvdhoorn with karma: 86574 on 2019-04-01
This answer was ACCEPTED on the original site
Post score: 1


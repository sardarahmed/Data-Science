Q:

[ROS2] Best practice for catching all exceptions for logging

I am creating a robot with ROS2 foxy that is in the field, and therefore not monitored all the time.
To help with debugging any eventual bugs/crashes that are unaccounted for, I was thinking of logging any tracebacks that occur.
There are two approaches that I am considering:
##Catch and except rclpy.spin##
original post code
import rclpy
import traceback
from .example_node import NodeClass

def main(args=None):
    rclpy.init(args=args)

    node_class = NodeClass()

    try:
        rclpy.spin(node_class)
    except Exception:
        node_class.get_logger().error(traceback.format_exc())
    finally:
        # Destroy the node explicitly
        # (optional - otherwise it will be done automatically
        # when the garbage collector destroys the node object)
        node_class.destroy_node()
        rclpy.shutdown()

update post code after @geoff comment
import rclpy
import traceback
from .example_node import NodeClass

def main(args=None):
    rclpy.init(args=args)
    traceback_logger = rclpy.logging.get_logger('node_class_traceback_logger')

    try:
        node_class = NodeClass()
        rclpy.spin(node_class)
    except Exception as exception:  
        traceback_logger.error(traceback.format_exc())
        raise exception

    finally:
        # Destroy the node explicitly
        # (optional - otherwise it will be done automatically
        # when the garbage collector destroys the node object)
        node_class.destroy_node()
        rclpy.shutdown()

##Create a custom logger in launch file##
from the example launch found here, a custom event handler can be created. This could potentially catch tracebacks.
# Setup a custom event handler for all stdout/stderr from processes.
# Later, this will be a configurable, but always present, extension to the LaunchService.
def on_output(event: launch.Event) -> None:
    for line in event.text.decode().splitlines():
        print('[{}] {}'.format(
            cast(launch.events.process.ProcessIO, event).process_name, line))

ld.add_action(launch.actions.RegisterEventHandler(launch.event_handlers.OnProcessIO(
    # this is the action     ^              and this, the event handler ^
    on_stdout=on_output,
    on_stderr=on_output,
)))

Which of these would be considered better practice? Or is there a better approach builtin ROS2?
Thanks in advance!

Originally posted by bvaningen on ROS Answers with karma: 167 on 2021-11-08
Post score: 3

A:

After some time I think that my current approach is best, which I will explain here for anyone who else may need it!
on the node side, the code is as followed:
import rclpy
import traceback
from .example_node import NodeClass
from rclpy.node import Node

def main(args=None):

    rclpy.init(args=args)

    try:
        node_class = NodeClass()
        rclpy.spin(node_class)

    except Exception as exception:  
        traceback_logger_node = Node('node_class_traceback_logger')
        traceback_logger_node.get_logger().error(traceback.format_exc())  
        raise exception

    else:
        # Destroy the node explicitly
        # (optional - otherwise it will be done automatically
        # when the garbage collector destroys the node object)
        node_class.destroy_node()
        rclpy.shutdown()

An import thing to note with this approach is that if you are using a launch file that you need to omit the name field, as shown below. Otherwise both nodes will be given the same name!
from launch_ros.actions import Node

from launch import LaunchDescription

def generate_launch_description():
    return LaunchDescription(
        [
            Node(
                package="system_monitor",
                executable="system_monitor_node",
                output={'both': {'screen', 'log', 'own_log'}},
            ),
        ]
    )

Originally posted by bvaningen with karma: 167 on 2022-01-27
This answer was ACCEPTED on the original site
Post score: 0


Q:

How to get boost libraries to link in cross compile?

I cannot get my cross compile to link to the boost libraries in my buildroot.
How can I get catkin/cmake to find the correct libraries (using the arm native libraries in my buildroot instead of the i386 system libraries)?
I have tried updating LD_LIBRARY_PATH, and CMAKE_PREFIX_PATH, but I still get linker errors:
/usr/lib/gcc/arm-linux-gnueabi/4.4.7/../../../../arm-linux-gnueabi/bin/ld: cannot find -lPocoFoundation
/usr/lib/gcc/arm-linux-gnueabi/4.4.7/../../../../arm-linux-gnueabi/bin/ld: cannot find -lboost_signals-mt
/usr/lib/gcc/arm-linux-gnueabi/4.4.7/../../../../arm-linux-gnueabi/bin/ld: cannot find -lboost_filesystem-mt
/usr/lib/gcc/arm-linux-gnueabi/4.4.7/../../../../arm-linux-gnueabi/bin/ld: cannot find -llog4cxx
/usr/lib/gcc/arm-linux-gnueabi/4.4.7/../../../../arm-linux-gnueabi/bin/ld: cannot find -lboost_regex-mt
/usr/lib/gcc/arm-linux-gnueabi/4.4.7/../../../../arm-linux-gnueabi/bin/ld: cannot find -lboost_date_time-mt
/usr/lib/gcc/arm-linux-gnueabi/4.4.7/../../../../arm-linux-gnueabi/bin/ld: cannot find -lboost_system-mt
/usr/lib/gcc/arm-linux-gnueabi/4.4.7/../../../../arm-linux-gnueabi/bin/ld: cannot find -lboost_thread-mt
/usr/lib/gcc/arm-linux-gnueabi/4.4.7/../../../../arm-linux-gnueabi/bin/ld: cannot find /lib/libpthread.so.0
/usr/lib/gcc/arm-linux-gnueabi/4.4.7/../../../../arm-linux-gnueabi/bin/ld: cannot find /usr/lib/libpthread_nonshared.a

I think this is because cmake does not like that there are multiple versions of this library on the system, even though I order them in the LD_LIBRARY_PATH!
-- catkin 0.5.86
-- Using these message generators: gencpp;genlisp;genpy
-- Boost version: 1.49.0
-- Found the following Boost libraries:
--   system
--   thread
-- Configuring done
CMake Warning at CMakeLists.txt:109 (add_library):
  Cannot generate a safe runtime search path for target gt_formation because
  files in some directories may conflict with libraries in implicit
  directories:

    runtime library [libPocoFoundation.so.9] in /usr/lib may be hidden by files in:
      /home/uav/rpi/rootfs/usr/lib
    runtime library [liblog4cxx.so.10] in /usr/lib may be hidden by files in:
      /home/uav/rpi/rootfs/usr/lib

  Some of these libraries may not be found correctly.

Yes, cmake, I know.  I "hid" them on purpose. Why is it ignoring the CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY setting?
So, what is the correct way of forcing cmake to use the libs in the buildroot?
Here is my toolchain.cmake file:
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_C_COMPILER arm-linux-gnueabi-gcc)
#$ENV{HOME}/rpi/tools/arm-bcm2708/arm-bcm2708-linux-gnueabi/arm-bcm2708-linux-gnueabi/bin/gcc)
set(CMAKE_CXX_COMPILER arm-linux-gnueabi-g++-4.4)
set(CMAKE_FIND_ROOT_PATH $ENV{HOME}/rpi/tools/arm-bcm2708/arm-bcm2708-linux-gnueabi/arm-bcm2708-linux-gnueabi/sysroot $ENV{HOME}/rpi/rootfs $ENV{HOME}/rpi/rootfs/e2fsprogs-1.42.9 $ENV{HOME}/rpi/rootfs/usr $ENV{HOME}/rpi/rootfs/usr/lib $ENV{HOME}/rpi/rootfs/usr/include $ENV{HOME}/rpi/ros_catkin_ws/install_isolated $ENV{HOME}/rpi/ros_catkin_ws/install_isolated/lib)
set(CMAKE_LIBRARY_PATH $ENV{HOME}/rpi/ros_catkin_ws/install_isolated $ENV{HOME}/rpi/ros_catkin_ws/install_isolated/lib)
set(BOOST_LIBRARYDIR /home/uav/rpi/rootfs/usr/lib)
set(Boost_LIBRARY_DIRS /home/uav/rpi/rootfs/usr/lib)
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM BOTH)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)

Thanks in advance!

Originally posted by ceverett on ROS Answers with karma: 332 on 2014-04-24
Post score: 1

Original comments
Comment by Patrick K on 2014-06-11:
Same problem at my toolchain. Is there any solution?

A:

Here's how I effectively segregated my cross-compile libs from my system libs.
My folder structure looks like this:
/path-to-cross-compiler-workspace/ros_catkin_ws
/path-to-cross-compiler-workspace/boost/boost_1.56.0
/path-to-cross-compiler-workspace/boost/boost_arm (install location for cross-compiled Boost)
/path-to-cross-compiler-workspace/usr/lib
/path-to-cross-compiler-workspace/usr/include
And my rostoolchain.cmake file looks like this:
# File: /path-to-cross-compiler-workspace/ros_catkin_ws/rostoolchain.cmake
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_C_COMPILER arm-linux-gnueabihf-gcc)
set(CMAKE_CXX_COMPILER arm-linux-gnueabihf-g++)
set(CMAKE_FIND_ROOT_PATH /path-to-cross-compiler-workspace)

set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM BOTH)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)

set(BOOST_INCLUDEDIR /path-to-cross-compiler-workspace/boost/boost_arm/include)
set(BOOST_LIBRARYDIR /path-to-cross-compiler-workspace/boost/boost_arm/lib)
I found that using CMAKE_FIND_ROOT_PATH essentially treats whatever location you set it to as '/' in a typical system, so you want to populate this area with your libs and headers for your cross-compile target. So when cmake is looking for libraries, anything under /path-to-cross-compiler-workspace/usr/lib should be found automatically. This is just like if you are building a project for your local machine, and cmake can easily find libraries installed under /usr/lib.
Because I chose to install Boost in a non-standard location (i.e. next to my boost sources instead) I had to set the BOOST_INCLUDEDIR** and BOOST_LIBRARYDIR** cmake variables. I could have installed boost to /path-to-cross-compiler-workspace/usr, and it should be the same.
** My understanding is that these are the variables to use that tell cmake where to find boost, which is  different than BOOST_INCLUDE_DIRS and BOOST_LIBRARY_DIRS, which are set by cmake after it finds boost.

Originally posted by GummyBear with karma: 121 on 2014-08-25
This answer was ACCEPTED on the original site
Post score: 1


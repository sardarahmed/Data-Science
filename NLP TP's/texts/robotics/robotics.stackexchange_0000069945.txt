Q:

NO PATH ! error and questions to gradient_path.cpp in global_planner

Problem Description:
I am trying to get a global path based on a 500 * 500 static map with **global_planner** (indigo). I set up the parameter use_grid_path to be *false*, so that the path is calculated with a gradient descent method. Goal Pose is fed with the 2D Nav Goal in Rviz. Sometime it works fine by showing the global path. But sometimes it publishes rosconsole [Error] messages repetitively in the terminal, even if a potential map is successfully showed by Rviz. 
[ERROR] [1444812100.339654309, 6406.380000000]: NO PATH!
[ERROR] [1444812100.340210027, 6406.380000000]: Failed to get a plan from potential when a legal potential was found. This shouldn't happen.
[ERROR] [1444812100.364187125, 6406.410000000]: NO PATH!
[ERROR] [1444812100.364835403, 6406.410000000]: Failed to get a plan from potential when a legal potential was found. This shouldn't happen.

I dug a little bit into the code in gradient_path.cpp http://docs.ros.org/jade/api/global_planner/html/gradient__path_8cpp_source.html#l00068. I think it must failed at row 80 to get this kind of error message.
00080     while (c++ 
But my static map is not big, and I have already got the potential map. So I do not really understand what is going on here.
Question to the code in gradient_path.cpp 
http://docs.ros.org/jade/api/global_planner/html/gradient__path_8cpp_source.html#l00068
1. This part comes from function *float GradientPath::gradCell(float potential, int n)**. In my opinion, the potential from cells on the left, right, up and down side should be taken into account. But at line 285, it is a fixed cell. Why should man always take care at this fixed cell?
00276     // check for in an obstacle
00277     if (cv >= POT_HIGH) {
00278         if (potential[n - 1] 
2. Why do we take stc, stc + 1, stcnx and stcnx + 1 but not other neighbors for interpolation? 
00181             // get grad at four positions near cell
00182             gradCell(potential, stc);
00183             gradCell(potential, stc + 1);
00184             gradCell(potential, stcnx);
00185             gradCell(potential, stcnx + 1);
00186 
00187             // get interpolated gradient
00188             float x1 = (1.0 - dx) * gradx_[stc] + dx * gradx_[stc + 1];
00189             float x2 = (1.0 - dx) * gradx_[stcnx] + dx * gradx_[stcnx + 1];
00190             float x = (1.0 - dy) * x1 + dy * x2; // interpolated x
00191             float y1 = (1.0 - dx) * grady_[stc] + dx * grady_[stc + 1];
00192             float y2 = (1.0 - dx) * grady_[stcnx] + dx * grady_[stcnx + 1];
00193             float y = (1.0 - dy) * y1 + dy * y2; // interpolated y
3. Why do we only consider these two horizontal bounds, why not the vertical bounds? 
00091         if (stc  xs_ * ys_ - xs_) // would be out of bounds
00092         {
00093             printf("[PathCalc] Out of bounds\n");
00094             return false;
00095         }
These questions troubled me a lot. Please help ~~
Thanks in advance :-)

Originally posted by maomao2015 on ROS Answers with karma: 1 on 2015-10-14
Post score: 0

A:

I am having the same kind of error.
One solution could be to increase the constant distance values in here from 0.5 to 1.0 .
I think this is due to missing potential values on cells around the start of the path, see this picture image description http://www2.informatik.uni-freiburg.de/%7Epalmieri/images/example.png
The white space under the axes represents cells to which no potential was assigned.
Sometimes the cell (nx,ny) is far more than 0.5 (m?)  from start cell in here, therefore the path extraction will return false (exit from the while loop).
What do you think?
Best,
L.

Originally posted by palmlster with karma: 28 on 2016-02-17
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by jorge on 2018-10-19:
Replacing 0.5 with 1 seems to work; it actually refers to cells number.
Comment by jinseoi on 2019-01-26:
it works for me too, thank very much!!!


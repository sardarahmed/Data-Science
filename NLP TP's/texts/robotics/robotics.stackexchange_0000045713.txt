Q:

Problem with twist message: unqualified-id before numeric constant

Hi folks!
I'm having a bit of trouble assigning values to a Twist type message, my code below runs into an error:
    /home/parcon/ros_workspace/arl_ardrone/arl_ardrone_control/src/pid_to_point.cpp:183:22: error: expected unqualified-id before numeric constant
/home/parcon/ros_workspace/arl_ardrone/arl_ardrone_control/src/pid_to_point.cpp:183:22: error: expected ‘;’ before numeric constant
/home/parcon/ros_workspace/arl_ardrone/arl_ardrone_control/src/pid_to_point.cpp:184:22: error: expected unqualified-id before numeric constant
/home/parcon/ros_workspace/arl_ardrone/arl_ardrone_control/src/pid_to_point.cpp:184:22: error: expected ‘;’ before numeric constant
/home/parcon/ros_workspace/arl_ardrone/arl_ardrone_control/src/pid_to_point.cpp:185:22: error: expected unqualified-id before numeric constant
/home/parcon/ros_workspace/arl_ardrone/arl_ardrone_control/src/pid_to_point.cpp:185:22: error: expected ‘;’ before numeric constant
/home/parcon/ros_workspace/arl_ardrone/arl_ardrone_control/src/pid_to_point.cpp:186:23: error: expected unqualified-id before numeric constant
/home/parcon/ros_workspace/arl_ardrone/arl_ardrone_control/src/pid_to_point.cpp:186:23: error: expected ‘;’ before numeric constant

The error comes from the last few lines of the code where the Twist message values are assigned. I've looked at the types, the definition of Twist, with no success. Can anyone see where I'm going wrong?
I expect to be able to assign a float to this value: twist_msg.linear.x
Thanks for the help!
/*
     *  Copyright (c) 2012, Parker Conroy
     *  ARLab @ University of Utah
     *  All rights reserved.
     *
     *
     *  
     *
     *
     *
     *  This software is distributed in the hope that it will be useful,
     *  but WITHOUT ANY WARRANTY; without even the implied warranty of
     *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     *  GNU General Public License for more details.
     *
     */
    #include "ros/ros.h"
    #include <math.h>
    #include <tf/transform_broadcaster.h>
    #include "tf/transform_listener.h"
    #include "geometry_msgs/TransformStamped.h"
    #include "ros/time.h"
    #include <geometry_msgs/Twist.h>
    
    #define yaw 0
    #define pitch 1
    #define roll 2
    #define thrust 3
    
    #define x 0
    #define y 1
    #define z 2
    #define t 3
    
     // Variables!!!
    tf::Transformer transformer;
    tf::TransformListener tf_listener;
    tf::TransformBroadcaster br;
    
    tf::StampedTransform desired_pos;
    tf::StampedTransform ardrone;
    tf::StampedTransform trackee;
    tf::StampedTransform desired_in_ardrone_coords;
    
    ros::Publisher pub_twist;
    geometry_msgs::Twist twist_msg;
    
    //btQuaternion ardrone_yawed;
    
    double new_data[4];
    double old_data[4];
    double integration[4];
    double derivative[4];
    float controls[4];
    float min_control[4];
    float max_control[4];
    double pid[4];
    float min_pid;
    float max_pid;
    
    float map(float value, float in_min, float in_max, float out_min, float out_max) {
      return (float)((value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min);
    }
    
    int main(int argc, char **argv)
    {
        int rate= 200;
        float inv_rate=1/rate;
    
        ros::init(argc, argv, "Tracker");
        ros::NodeHandle n;
        ros::Rate r(200); //update @ 200hz
        
        memset(controls, 0, sizeof(int64_t)*4);
        memset(old_data, 0, sizeof(double)*4);
        memset(new_data, 0, sizeof(double)*4);
        memset(integration, 0, sizeof(double)*4);
        memset(derivative, 0, sizeof(double)*4);
        memset(pid, 0, sizeof(double)*4);
        
        //PID params
        min_control[yaw] =-1.0;
        min_control[roll] =-1.0;
        min_control[pitch]=-1.0;
        min_control[thrust]=-1.0;
    
        max_control[yaw]=1.0;
        max_control[roll]=1.0;
        max_control[pitch]=1.0;
        max_control[thrust]=1.0;
    
        min_pid =-5.0;
        max_pid =5.0;
    
        float K_p[] = {1, 1, 1};
        float K_d[] = {0,0,0};
        float K_i[] = {0,0,0};
    
        while (ros::ok())
        {
              try {
            //Get desired position transform
            tf_listener.waitForTransform("/optitrak", "/desired_position", ros::Time(0), ros::Duration(inv_rate));
            tf_listener.lookupTransform("/optitrak", "/desired_position",  ros::Time(0), desired_pos); 
            // Get the quad rotor transform
            tf_listener.waitForTransform("/optitrak", "/ardrone", ros::Time(0), ros::Duration(inv_rate));
            tf_listener.lookupTransform("/optitrak", "/ardrone",  ros::Time(0), ardrone);
    
    
        //  desired_position = trackee.getOrigin(); //vector of position (x,y,z)
        //  btMatrix3x3(trackee.getRotation()).getRPY(roll, pitch, yaw); // vector of orientation (roll, pitch, yaw)
    
    
            // Isolate the yaw component
             /*
              double y1, p1, r1;
              btMatrix3x3(ardrone.getRotation()).getRPY(r1, p1, y1);
              ardrone_yawed(y1, 0.0, 0.0);
              ardrone.setRotation(ardrone_yawed);
        */
    
              double y1, p1, r1;
              btMatrix3x3(ardrone.getRotation()).getRPY(r1, p1, y1);
              btQuaternion ardrone_yawed(y1, 0.0, 0.0);
              ardrone.setRotation(ardrone_yawed);
    
              //set up twist publisher
              pub_twist = n.advertise<geometry_msgs::Twist>("/cmd_vel", 1); /* Message queue length is just 1 */
            
              // Register the ardrone without roll and pitch with the transform system
              br.sendTransform( tf::StampedTransform(ardrone, ros::Time::now(), "/optitrak", "ardrone_wo_rp") );
              
              // Get the vector between quad without roll and pitch and the desired point
              tf_listener.waitForTransform("/ardrone_wo_rp", "/desired", ros::Time(0), ros::Duration(inv_rate));
              tf_listener.lookupTransform("/qardrone_wo_rp", "/desired", ros::Time(0), desired_in_ardrone_coords);
              
              // Extract the x, y, & z components
             /*
              diff = desired_in_ardrone_coords.getOrigin();
              new_data[x] = diff.getX();
              new_data[y] = diff.getY();
              new_data[z] = diff.getZ();
             */
             
              new_data[x] = desired_in_ardrone_coords.getOrigin().getX();
              new_data[y] = desired_in_ardrone_coords.getOrigin().getY();
              new_data[z] = desired_in_ardrone_coords.getOrigin().getZ();
             
             
              new_data[t] = (double)ros::Time::now().toSec();
              ROS_DEBUG("Error: [x: %f y:  %f z: %f]", new_data[x], new_data[y], new_data[z]);
    
              // Integrate the data
              double deltaT = (new_data[t] - old_data[t]);
              integration[x] += new_data[x] * deltaT;
              integration[y] += new_data[y] * deltaT;
              integration[z] += new_data[z] * deltaT;
    
              ROS_DEBUG("Integration: [deltaT: %f x: %f y: %f z: %f]", deltaT, integration[x], integration[y], integration[z]);
    
              derivative[x] = (new_data[x] - old_data[x])/deltaT;
              derivative[y] = (new_data[y] - old_data[y])/deltaT;
              derivative[z] = (new_data[z] - old_data[z])/deltaT;
    
              ROS_DEBUG("Derivative: [deltaT: %f x: %f y: %f z: %f]", deltaT, derivative[x], derivative[y], derivative[z]);
    
              // Calculate the PID values
              pid[x] = K_p[x] * new_data[x] + K_d[x] * derivative[x] + K_i[x] * integration[x];
              pid[y] = K_p[y] * new_data[y] + K_d[y] * derivative[y] + K_i[y] * integration[y];
              pid[z] = K_p[z] * new_data[z] + K_d[z] * derivative[z] + K_i[z] * integration[z];
    
              ROS_DEBUG("PID: [x: %f y:  %f z: %f]", pid[x], pid[y], pid[z]);
    
              memcpy(old_data, new_data, sizeof(double)*4);
    
              controls[yaw] =    map(0.0,    min_pid, max_pid, min_control[yaw], max_control[yaw]);
              controls[roll] =   map(pid[x], min_pid, max_pid, min_control[roll], max_control[roll]);
              controls[pitch] =  map(pid[y], min_pid, max_pid, min_control[pitch], max_control[pitch]);
              controls[thrust] = map(pid[z], min_pid, max_pid, min_control[thrust], max_control[thrust]);
              ROS_DEBUG("Controls: [yaw: %f roll: %f pitch: %f thrust: %f]", controls[yaw], controls[roll], controls[pitch], controls[thrust]);
    
              //change the ref frame to inverted x-y-z coords. by modifying the directional control
              twist_msg.linear.x=-control[roll]; 
              twist_msg.linear.y=-control[pitch];   
              twist_msg.linear.z=-control[thrust];
              twist_msg.angular.z=controls[yaw];
    
              pub_twist.publish(twist_msg);
              
              } catch (...) {
                ROS_ERROR("Failed on Trackee TF");}
             
             
        }//while ros ok      
              
    }//main

 

Originally posted by 0pc0 on ROS Answers with karma: 78 on 2012-11-12
Post score: 0

A:

If you #define x 0 then twist.linear.x is going to turn into twist.linear.0 after the preprocessor.
Don't #define single characters unless you hate happiness.
More here: #defines are EVIL
As an aside, if you look at your preprocessor output, you'll find that your variables like max_pid are actually going to be ma0_pid and so on and so forth... So yeah, don't ever do this.

Originally posted by jbohren with karma: 5809 on 2012-11-12
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by 0pc0 on 2012-11-13:
Thank you sir! I've learned my lesson.


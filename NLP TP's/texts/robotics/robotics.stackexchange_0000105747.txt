Q:

Who has gotten WiringPi working in a ROS 2 C++ node? Want to control GPIO on Raspberry Pi 4 running Ubuntu 22

What I've tried and works to know the WiringPi library is working on my Raspberry Pi 4.

g++ compiling a test cpp script using WiringPi.
Terminal gpio commands (gpio -g mode 18 output sets pin 18 to be an output)
Physically wiring an output to an input. Writing to the output changed the input correctly
All results of changing pinMode and digialWrite were correct on the gpio readall

Properly linking the external WiringPi library into my ROS 2 package, wiringPi.h file in my cpp node, and using the same code as the test cpp script, it doesn't work. Is there something special I need to account for? Is there a ROS 2 background thread preventing WiringPi from functioning?
Code

class MyNode : public rclcpp::Node
{
public:
    MyNode() : Node("my-node")
    {
        wiringPiSetupGpio();
        if (wiringPiSetupGpio() == -1)
        {
            throw std::runtime_error("Failed to initialize WiringPiSetup");
        }
        pinMode(18, OUTPUT);
        pinMode(17, INPUT);
        // Jumper wire connecting pin 18 to 17
        digitalWrite(18, HIGH);
        RCLCPP_INFO(get_logger(), "%d", digitalRead(17);
    }
}

int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);

    try
    {
        auto node = std::make_shared<MyNode>();
        RCLCPP_INFO(node->get_logger(), "Starting node");

        rclcpp::spin(node);
    }
    catch (const std::exception &ex)
    {
        RCLCPP_ERROR_STREAM(rclcpp::get_logger("main"), "Exception during node initialization: " << ex.what());
    }

    rclcpp::shutdown();
    return 0;
}

18 does not change to OUTPUT nor is it set to HIGH. 17 is by default an INPUT.
Reference

GPIO terminal comamnds I was testing: https://learn.sparkfun.com/tutorials/raspberry-gpio/c-wiringpi-setup
Example I used in my cpp file: https://learn.sparkfun.com/tutorials/raspberry-gpio/c-wiringpi-example

A:

Put the wiringPiSetup() inside main and before spinning the node (rclcpp::spin(node)). It should look like this.
int main(int argc, char** argv)
{
    rclcpp::init(argc, argv);

    wiringPiSetupGpio();
    if (wiringPiSetupGpio() == -1)
    {
        return -1;
    }

    auto node = std::make_shared<MyNode>();
    RCLCPP_INFO(node->get_logger(), "Starting node");

    rclcpp::spin(node);

    rclcpp::shutdown();
    return 0;
}

Although putting wiringPiSetup() in the constructor doesn't throw any errors, it looks like you want the initialization to be separate from the rest of the ROS Node. I have no references for this solution.


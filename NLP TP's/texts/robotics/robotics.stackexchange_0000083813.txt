Q:

Is there an option for a blocking publish() if any subscriber's queue is full?

I have an application where several image processing nodes need to be fed by previously recorded video as fast as possible, but without dropping any frames.  To keep memory overhead down, I'm using nodelets to take advantage of the zero-copy mechanism, but that limits me to using a topic/ImageTransport topology.  The challenge then becomes keeping the topic queues full, but not overflowing and causing a video frame to not be processed because it was dropped.  As far as I can tell, though, there's no built-in way to have publish() block if any of its downstream queues are full.
Is this option hiding somewhere, or do I have to come up with some other mechanism to manage the data flow?

Originally posted by infinite.loup on ROS Answers with karma: 1 on 2017-11-09
Post score: 0

A:

As far as I know, there is no possible way to query the number of elements in the queue, from all the past questions I've seen, methods include creating a local counter with a fixed number and checking it from the publisher side.
This question explains it a little bit better, I would copypasta, but you better just check this one: https://answers.ros.org/question/67136/can-you-check-how-many-messages-are-in-a-subscribers-queue/

Originally posted by bpinaya with karma: 700 on 2017-11-09
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by infinite.loup on 2017-11-11:
Hmm... OK.  I was hoping to avoid something like that.  I'm using a service to request N video frames be published on an image topic and leveraging @ImageTransport@, but maybe I need to abandon that for a custom message.  I could go back to service-based topology, but then I'd lose zero-copy.
Comment by bpinaya on 2017-11-13:
If you want to have zero-copy transmission you should check out nodelets (http://wiki.ros.org/nodelet)
Comment by infinite.loup on 2017-11-13:
You'll note in my original question that I mentioned I am using nodelets to get the zero-copy :). It only works when communicating via ROS topics, though, which don't provide a way to synchronously communicate with all of the subscribers.  Hence my quandary.


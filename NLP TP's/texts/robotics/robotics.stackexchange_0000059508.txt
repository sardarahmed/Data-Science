Q:

Node crashes on spinOnce

Hi, I have a node that is crashing with a
terminate called after throwing an instance of 'std::out_of_range'
  what():  vector::_M_range_check

error. The backtrace from gdb says the first call is on a ros::spinOnce() call. The whole stack trace is:
terminate called after throwing an instance of 'std::out_of_range'
  what():  vector::_M_range_check

Program received signal SIGABRT, Aborted.
0x00007ffff6204037 in raise () from /lib/x86_64-linux-gnu/libc.so.6
(gdb) back
#0  0x00007ffff6204037 in raise () from /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff6207698 in abort () from /lib/x86_64-linux-gnu/libc.so.6
#2  0x00007ffff6b11e8d in __gnu_cxx::__verbose_terminate_handler() () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
#3  0x00007ffff6b0ff76 in ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
#4  0x00007ffff6b0ffa3 in std::terminate() () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
#5  0x00007ffff6b10226 in __cxa_rethrow () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
#6  0x00007ffff7abf268 in ros::CallbackQueue::callOneCB(ros::CallbackQueue::TLS*) () from /opt/ros/hydro/lib/libroscpp.so
#7  0x00007ffff7abeacb in ros::CallbackQueue::callAvailable(ros::WallDuration) () from /opt/ros/hydro/lib/libroscpp.so
#8  0x00007ffff7b0579a in ros::spinOnce() () from /opt/ros/hydro/lib/libroscpp.so
#9  0x0000000000456892 in Planner::go (this=0x69b8e0 <my_planner>) at /my/code.cpp:962

I was wondering what it means when the code crashes on a spinOnce() call. What should I be looking for? I know there are likely many causes so I am mostly looking for direction rather than a specific answer. My node has three timers and subscribes to 1 topic. All of the callbacks are class methods and access data members in the class that all happen to be std::vectors. But I am not sure if the out_of_range error is one of my class' vectors or something in ROS that gets called in spinOnce().
Basically, all of my callbacks run until the robot reaches the goal. So the main loop looks something like this:
//start timers
timer_one.start()
timer_two.start()
timer_three.start()

while( (latestUpdate_.comparePosition(goal_, false) > goalThreshold_) && ros::ok()) {
  ros::spinOnce(); 
} 

// stop timers
timer_one.stop()
timer_two.stop()
timer_three.stop()

I feel like if one of the vectors accessed in a callback was empty, the stack trace would lead me there and not spinOnce. I don't really know what to look for so I can debug. If anyone has suggestions, I would greatly appreciate it.

Originally posted by sterlingm on ROS Answers with karma: 380 on 2014-05-20
Post score: 1

A:

Your callbacks get serviced when spinOnce() is called, so it is very likely that you access a invalid index of one of your vectors inside a callback. You should compile your package in Debug mode to get a more informative backtrace (if you have not already). If what you posted is already  Debug I agree that it should be more informative :)

Originally posted by Stefan Kohlbrecher with karma: 24361 on 2014-05-20
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by sterlingm on 2014-05-21:
I was able to track down the bug and it was indeed in my callback functions. I'll accept because it was confirmation that I should keep looking in my callback functions. The stack trace I posted was in Debug mode. It's strange that it didn't lead me to my callback function.


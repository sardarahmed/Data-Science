Q:

Segmentation fault with graphic object in Rqt plugin

I am building my own rqt plugin.
I found this attitude indicator widget and I managed to include it in my rqt plugin. As creators said, it "uses a lot of CPU power", but I managed to have it working after the pression of a key
these lines of code add the widget
#manual insert attidue into attitude layout 
self.attitude_w = AttitudeIndicator()
self.attitude_w.setPitch(self.pitch)
self.attitude_w.setRoll(self.roll)
self._widget.attitude_layout.addWidget(self.attitude_w)

these lines creates the callback
def _ATTITUDE(self, ROLL, PITCH):
    self.attitude_w.setRoll(ROLL)
    self.attitude_w.setPitch(PITCH)

with this calling the widget works when pressing "A" on keyboard
#random attitude
self.shortcut_a = QShortcut(QKeySequence(Qt.Key_A), self._widget)
self.shortcut_a.setContext(Qt.ApplicationShortcut)
self.shortcut_a.activated.connect(lambda: self._ATTITUDE(self.roll,self.pitch) #lambda allow to call function with args)

after that I successfully subscribe to the joy node, I tried to use it in my plugin like
try:
  self.myjoy = Float32MultiArray
  self.myjoy = rospy.Subscriber("joy", Joy, self.joyread, queue_size=1)
except ValueError, e:
    rospy.logerr('Error connecting topic (%s)'%e)    

    def joyread(self,data):
        self.myjoy = data
        self.sensing0 = 10*self.myjoy.axes[0]
        self.sensing1 = 10*self.myjoy.axes[1]
        self.pitch = 10*self.myjoy.axes[3]
        self.roll =  10*self.myjoy.axes[2]
        self._sensors(self.sensing0, self.sensing1) # this works continously
        self._ATTITUDE(self.roll,self.pitch) #this made the plugin crash

Joy and all the other callbacks work, but if I tried to use the attitude callback in the joy subscription, I obtain
Segmentation fault (core dump created)

The problem is that the joy sends signal too fast? (The widget can not update itself so fast) I try to lighten the widget by deleting the hover thing and the white lines, but it does not change my situation
How can I check, and maybe solve this?
Turn the widget into an openGL widget would help me? (I never tried openGL widget, never build them)

Originally posted by marcoresk on ROS Answers with karma: 76 on 2017-09-10
Post score: 0

A:

You don't want to be changing qt displays directly from ros callbacks, they are owned by different threads.  I'm not sure if repaint() actually violates that thread boundary or not, assuming it does you would avoid it by something like
self.do_update_attitude = QtCore.pyqtSignal(float, float)
self.do_update_attitude.connect(self.update_attitude)
...
def update_attitude(self, roll, pitch):
    self.attitude_w.setRoll(roll)
    self.attitude_w.setPitch(pitch)

and then in the joy callback:
self.do_update_attitude.emit(self.roll, self.pitch)

You could alternatively have a qt timer that only updates the attitude widget at 30 Hz or less which would limit cpu usage (look at https://stackoverflow.com/questions/32362340/pyqt4-creating-a-timer).   The attitude widget api is calling repaint for setRoll and setPitch, it would be good to modify it so it repaint is called separately since roll and pitch are always getting updated at the same time and then there would be half the paint events.

Originally posted by lucasw with karma: 8729 on 2017-09-10
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by marcoresk on 2017-09-10:
It works, thank you. I have to specify for others they may can read that the first of your line has to be written into the plugin class but outside the constructor, the second line has to be inside the constructor. But now it works!!


Q:

Callback of actionlib_msgs::GoalStatusArray fails

Hi,
I am writing a node that subscribes to an actionlib_msgs::GoalStatusArray message. The callback code is:
  move_base_status_sub = n.subscribe<actionlib_msgs::GoalStatusArray>("/move_base/status", 50, &rviz_text::move_base_statusCallback, this);

...

void rviz_text::move_base_statusCallback(const actionlib_msgs::GoalStatusArrayConstPtr& msg)
{
  actionlib_msgs::GoalStatusArray status_array = *msg;   
  uint32_t sequence = status_array.header.seq;
  // sequence is read successfully 
 
  actionlib_msgs::GoalStatus status_list_entry = status_array.status_list[0]; 
  // status_list_entry is read unsuccessfully. The above line causes a seg fault at runtime. 
}

I am able to read the header of the GoalStatusArray, but unable to read the status_list array. I get a segmentation fault when doing so.
I seem to be doing an error when trying to access the first element of status_array.status_list.
Do you see any syntax error in my code?
The GoalStatusArray and GoalStatus messages definitions can be found on:
GoalStatusArray message
GoalStatus message
My callback function is subscribing to the /move_base/status topic. The messages on this topic look like the following:
---
header: 
  seq: 52
  stamp: 
    secs: 1400564326
    nsecs: 841550350
  frame_id: ''
status_list: 
  - 
    goal_id: 
      stamp: 
        secs: 1400564318
        nsecs: 321941901
      id: /move_base-1-1400564318.321941901
    status: 1
    text: This goal has been accepted by the simple action server
---

My setup:

ROS fuerte
Ubuntu 12.04

Do you have a clue why my code is failing?

Originally posted by RalphA on ROS Answers with karma: 36 on 2014-05-28
Post score: 1

A:

I had exactly the same problem. Basically until move_base receives its first goal the status_list[] is empty. Thus, when you try to access it creates a memory problem as status_list[] is empty/not allocated. You can use the vector.empty() function that returns 1 if the vector is empty...for example status_list.empty() will return 1 if a goal was not given to move_base.
Here is my example code on how to protect your callback:
void StatusPublisher::navStatusCallBack(const actionlib_msgs::GoalStatusArray::ConstPtr& status)
{
 if (!status->status_list.empty())
   {
     actionlib_msgs::GoalStatus goalStatus = status->status_list[0];
  testing_pub.publish(goalStatus);
   } 

Originally posted by Manolis Chiou with karma: 70 on 2014-06-18
This answer was ACCEPTED on the original site
Post score: 2


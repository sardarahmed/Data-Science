Q:

Include methods from another node header (C++)

I have a node with some methods declared in /include/node_1.h and defined in /src/node_1.cpp. Now, I want to include that header into another node /src/node_2.cpp and use the methods there, like:
// node_2.cpp
#include "pkgname/node_1.h"

// ...
some_method_from_node_1();

I can catkin_make with including, but I get a linker error (undefined reference to the method) when trying to compile while calling the method from node_2.
My CMakeLists.txt for the package looks like:
# ...

## declare a catkin package
catkin_package(
    INCLUDE_DIRS include
    CATKIN_DEPENDS message_runtime
)

## include dirs
include_directories(include ${catkin_INCLUDE_DIRS})

## nodes
set(NODES
    node_1
    node_2
)

foreach(node IN LISTS NODES)
    
    add_executable(${node} src/${node}.cpp)
    target_link_libraries(${node} ${catkin_LIBRARIES})
    add_dependencies(${node} hric_sys_generate_messages_cpp)

endforeach()

How can I make it work and is this approach even idiomatically correct?
EDIT:
So, I have a method called my_test_func(), which I can call from node_1 but get a linker error if I try to invoke it from node_2, although the include works. This is the (simplified) code:
include/node_1.h:
# pragma once

void my_test_func();

src/node_1.cpp:
#include "package/node_1.h"

void my_test_func()
{
    ROS_INFO("API CALL!");
}

int main()
{
    // ...
    my_test_func(); // WORKS
}

src/node_2.cpp:
#include "package/node_1.h"

int main()
{
    // ...
    my_test_func(); // DOESN'T WORK
}

Originally posted by martinandrovich on ROS Answers with karma: 3 on 2020-02-28
Post score: 0

Original comments
Comment by Wilco Bonestroo on 2020-02-28:
So the linker can't find the function. Are you sure that the function is defined correctly and that it can be called. E.g. can you call it in node_1? If you also put your header and source files here, it is more easy to answer your question.
Comment by martinandrovich on 2020-02-28:
It worked from node_1, yes, and I could include the method in node_2. I didn't upload the full code, because I simplified the problem with different names. I think the error might have been making the method definition in node_1 inline. I will check that on Monday.
Comment by martinandrovich on 2020-03-02:
So, I added some example code below.. It still doesn't work, even if the method is not inlined.

A:

You have a function my_test_func() declared in node_1.h and implemented in node_1.cpp.
When you try to use it in node_2.cpp, the linker is missing it's implementation, as only declaration in node_1.h is known, but implementation of that function is missing.
To solve this you have 2 options:

remove implementation of my_test_func() from node_1.cpp and add it to node_1.h file (so that function is declared and implemented in header file)

Create a class Node1 (in node_1.h/cpp) with  my_test_func() public member function of that class. Then create an instance of this class in node_2.cpp and call my_test_func() as member of this class, i.e.
#include "package/node_1.h"
int main()
{
// ...
Node1 n1;
n1.my_test_func();
}

Originally posted by Thazz with karma: 66 on 2020-03-03
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Delb on 2020-03-03:
It's the same option in the end, eventhough you create a class the implementation of the function would need to be in the header file to have this working. It's a general good practice not to mix declaration and implementation.
Comment by martinandrovich on 2020-03-03:
So, defining the method in the header file works, although I don't understand why it doesn't result in a multiple-definitions error. Also, I want to modify some data (e.g. a vector in node_1.cpp) using an interface/function calls from node_2, but maybe ROS is not made for that?
Comment by Delb on 2020-03-03:\

maybe ROS is not made for that?

ROS is a collection of tools, libraries, and conventions (from ROS.org) so you can do whatever you want with ROS using C++ or Python.
It looks like you need to use classes, I would advise you to learn the basics of Object-Oriented Programming and C++ before getting into ROS, wihtout this background using ROS would be very challenging.
Comment by martinandrovich on 2020-03-03:
I'm basically trying to call node_1's methods from node_2 that will alter some internal data structure of node_1, e.g. node1::add_something(). I am not sure that ROS is designed for that without using messages or services. Also, OOP is not really relevant here; if anything, node_1 is a utility class.
Comment by Delb on 2020-03-04:\

I am not sure that ROS is designed for that without using messages or services

ROS is designed to do this with messages or services.
Now with your additionnal inputs I feel we are diverging from your original question ("include methdods from another header"), if one of the two answers has answered this specific question you can mark it as correct.
For your other question(s) I still don't see what is your blocking point, with our suggestions you still can't call methods of node_1 from node_2 ? I would advise you to open a new question describing your whole problematic in details, telling us what you have tried so far and what your errors/issues are.


Q:

Corner detection using opencv and ROS

Hi guys,
I have implemented an algorithm that uses the opencv2 Harris corner detector. I have a few questions, but first let me explain my system: I have copied the opencv2 Harris corner detector and placed it in a callback function in which messages of type sensor_msgs::ImageConstPtr& msg are passed to it. I then instantiate a cv_bridge::CvImagePtr object and call it cv_ptr, the message (msg) is then copied to cv_ptr using the cv_bridge. I then declare Mat dst, dst_norm, dst_norm_scaled and a number of operations are performed and the final image (with the corners detected) is stored in dst_norm_scaled. When rosmake and then roslaunch it works, and I am able to view the dst_norm_scaled using cv::imshow. However I have a number of concerns:
1- If I want to transfer this back to a ROS type image, image_pub_.publish(cv_ptr->toImageMsg()); is used, however, my corner detected image is stored in dst_norm_scaled now, so how do I convert and publish this?
2- I tried to use a second cv_bridge::CvImagePtr object I called cv_ptr2 in which I can use instead of dst_norm_scale and then publish it using image_pub_.publish(cv_ptr2->toImageMsg()), and although rosmake was successful, the process died and threw an exception. I guess only 1 cv_ptr is allowed to be used?
3- In my program, although the corners are detected, if I move the camera too quickly there becomes a lag and sometimes the image shown becomes black for a couple of seconds. I am currently using ros::spin() in my main function.
If there are any additional information you would like me to explain, please let me know.
I really appreciate your help.
Regards,
Khalid

Originally posted by K_Yousif on ROS Answers with karma: 735 on 2013-01-22
Post score: 0

A:

For the publishing of data i guess you have to use cv_ptr2.image field. If you assign your dst_norm_scaled(cv::Mat i am guessing) to cv_ptr2->image  . I guess the image_pub_.publish(cv_ptr->toImageMsg()) command should work. And there can be more than two pointers of cv_bridge, further the exception you are getting could be related to you not assigning the data properly to the pointer. For the third point i am not sure.

Originally posted by Karan with karma: 263 on 2013-01-22
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by K_Yousif on 2013-01-22:
I already tried to copy the dst_norm_scaled to the cv_ptr2 like this:
cv_ptr2->image = cvCloneImage(dst_norm_scaled);
image_pub_.publish(cv_ptr->toImageMsg());
I get
Comment by K_Yousif on 2013-01-22:
This error: error: cannot convert ‘cv::Mat’ to ‘const IplImage* {aka const _IplImage*}’ for argument ‘1’ to ‘IplImage* cvCloneImage(const IplImage*)’
Comment by Karan on 2013-01-22:
Well i guess cvCloneImage takes in as IpIImage and yours is cv::Mat so directly use cv_ptr2->image = dst_norm_scaled. post back if it works..
Comment by K_Yousif on 2013-01-22:
I compiled it and there is no error, I cannot test it though because the camera is not with me at the moment. I will try it later and post back, thanks alot for your help
Comment by Karan on 2013-01-23:
To remove problems like this you could use IDE with Ros. Some IDEs which are generally used and there usage is documented at http://www.ros.org/wiki/IDEs
Comment by K_Yousif on 2013-01-23:
I tried running what we discussed and the process died immediately. so I tried adding cv_ptr2 = cv_bridge::toCvCopy(msg, enc::BGR8); inside the try catch block and then cv_ptr2->image = dst_norm_scaled and it worked partially. When i view cvr_ptr2 with imshow it shows the correct corner image
Comment by K_Yousif on 2013-01-23:
But when I publish it on the topic /out using image_pub_.publish(cv_ptr2->toImageMsg()); and then view this using image_view, I see the image three times (in parallel). Is something going wrong with the conversion?
Comment by Astronaut on 2016-05-19:
did you solve the problem?


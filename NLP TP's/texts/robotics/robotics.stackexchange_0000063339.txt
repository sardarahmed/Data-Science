Q:

Convert trajectory_msgs/JointTrajectoryPoint to industrial::joint_traj_pt(_message)::JointTrajPt(Message)

This time I hope I am on the right way, because in my last question I wasn't.
So I built up a Joint-Trajectory publisher that publishes trajectory_msgs::JointTrajectoryPoint to the topic joint_path_command.
For the first I fill the position, velocities and accelerations with 3 fixed random values each as well as time_from_start and just publish it to the topic.
My first question is, is this the right procedure? I didn't find an existing simulation yet, that publishes a trajectory_msgs::*. Because where I get my message from is at the moment not important to my project. In detail I tinkered about with the Universal Robot of the industrial package. But I wasn't able to get a message out of the Rviz simulation that I could use to subscribe to.
EDIT: After having again a closer look, i found the arm_controller/command in the UR5 which publishes trajectory_msgs::*. So right now I think I am doing right.
My next and furthermore annoying problem ist converting a trajectory_msgs/JointTrajectoryPoint to an industrial::joint_traj_pt(_message)::JointTrajPt(Message).
As my publisher publishes a trajectory_msgs::JointTrajectoryPoint after subscribing I get this format.
As I want to use the simple_message package of ROS-I, I need some kind of conversion between these file formats. Does something like this exist?
Somehow I don't get the connection (in my mind!) between ROS and ROS-I.
Should my simulation (publisher) already publish industrial::joint_traj_pt(_message)::JointTrajPt(Message)? Or am I doin' fine?

Edit 1:
The overall task is to move a Quanser Robot connected to a B&R Controller with the industrial core of ROS.
My task in this is to make a connection between the simulation, that doesn't exist yet and the controller, or in detail, any controller. For me this is for instance matlab receiving my simple message which i deserialize (this should be the right word) and send to a Forward-Kinematics Block .
The "Receiver" will be programmed in C in order to be able to run it on most actual controllers and also on Matlab, due this is neccessary for testing my Ros-Implementation.
Regards,
RosBort

Edit 2:
I now run roslaunch industrial_robot_client robot_interface_streaming.launch robot_ip:=192.168.0.102
But how can I now publish something, a test-message, that will be sent to my "controller". In this case on my controller I am waiting with wireshark and Hercules in order to receive any information. I understood that simple_message called viae the upper mentioned package wants a reply. But first it sends some information and then waits for the reply. I would like to see this first information on my Wireshark or Herkules.
I made a try using the UR5 from Universal Robots.
roslaunch ur_gazebo ur5.launch limited:=true

roslaunch ur5_moveit_config ur5_moveit_planning_execution.launch sim:=true limited:=true

roslaunch ur5_moveit_config moveit_rviz.launch config:=true

The second and the third call show some error messages, which I don't want to discuss here. The second at the end tells me that all is fine, this is quite a calming sentence. The third one runs RViz and I can perform motion planning.
After planning the execute button doesn't work and on my "controller" I don't get any message.
What do I need to do in order publish data from the UR5 so they are being transfered to my controller using the robot_interface_streaming.launch.
Furthermore Information is that Matlab is not a middle-man programm.
The main goal is to get a driver that fits controllers that can work in C. The steps I thought about to achieve this are:

Ros - Matlab (Reasonably C++, Simulation with Forwardkinematics will show functionality)
Ros - B&R Controller (with Robot)
Ros - Any Controller "understanding" C++
Ros - Any Controller "understanding" C

If I reach the first I probably have 2 and 3 kind of included. The last point is a nice to have and may not be achieved.

Edit 3:
Well. I started roslaunch industrial_robot_client robot_interface_streaming.launch robot_ip:=192.168.0.102- I see on the client that the connection is established.
Starting rosrun ur_driver test_move.py results in this message: Waiting for server...
Now I am looking for what to send back from my server. I didn't find any information about it yet. As I am not familiar with Python it is a little more difficult for me to understand what the test_move is doing.
BUT! I didn't understand what you ment about updating the list of joints? How would the joint names influence my tcp connection?
I understood it in this way that I should implement an own launch file and do some remapping of the topics of the test_move.py. After a little research about the actionlib here http://wiki.ros.org/actionlib I will now try the way with a launchfile which remaps my topics.
My topic list looks now:
/feedback_states
/follow_joint_trajectory/cancel
/follow_joint_trajectory/feedback
/follow_joint_trajectory/goal
/follow_joint_trajectory/result
/follow_joint_trajectory/status
/joint_path_command
/joint_states
/joint_trajectory_action/cancel
/joint_trajectory_action/feedback
/joint_trajectory_action/goal
/joint_trajectory_action/result
/joint_trajectory_action/status
/robot_status
/rosout
/rosout_agg

I understood that all topics with "follow_joint_trajectory/" in front should be remapped in my own created launch file to the
topics "joint_trajectory_action".
After reading the info-page about the actionlib. Am I right that the "server" that test_move is not waiting for an answer on tcp, but waiting for an answer from my joint_trajectory_action node?

Originally posted by RosBort on ROS Answers with karma: 27 on 2014-10-15
Post score: 1

Original comments
Comment by gvdhoorn on 2014-10-16:
Perhaps you could clarify what you are trying to accomplish? Do you have a custom robot for which you want to use simple_message, or an industrial manipulator? The industrial_robot_client pkg contains a set of nodes that do exactly what you ask, but I'm not certain it is what you need.
Comment by RosBort on 2014-10-16:
I updated my goal in the last paragraph in my question and will now have a look at the packages mentioned by you. Edit: Your hint is probably what I want to do. I will have a closer look in the afternoon.
Comment by gvdhoorn on 2014-10-17:
As I commented earlier: the ur_driver package does not use simple_message, so you won't see any traffic.
Comment by RosBort on 2014-10-17:
Just to keep every information:
I will not use answers like forum posts any more. Therefor some edits were done.
UR5 doesn't use simple message.
Comment by RosBort on 2014-10-17:
Is there a robot already implemented in ROS-I that uses simple message? Or what topic do I need to publish to, so that the robot_interface_streaming will send anything to my controller?
Comment by gvdhoorn on 2014-10-17:
Have you read the latest edit to my answer?
Comment by RosBort on 2014-10-17:
Yes thanks! I was trying around before spaming around, but I will add a comment to your Edit 2 in a minute.
Comment by gvdhoorn on 2014-10-17:
This is getting a bit long (and slightly off-topic), but in short: yes, remapping would work, and the joint names are needed by the generic client to correctly map trajectories to simple message types. In any case, you can also send a message to the ROS-Industrial mailing list (see the wiki).

A:

After edit:
Ok, so essentially you want to implement a new server application (in the terminology of ROS-Industrial) that accepts incoming simple_message messages, deserialises and then processes them. You want to do this for both a simulated version of your controller, as well as for your B&R controller. From a ROS-Industrial perspective, what you're trying to do is implementing a driver for a specific (industrial) controller.
In general, as long as you don't have too specialised requirements for the interaction with a remote controller, the nodes in the industrial_robot_client pkg can be used as the client side of a ROS-Industrial 'bridge' (if you will). The generic robot_state, motion_streaming_interface and joint_trajectory_action nodes implement this bridge. For instance: they accept JointTrajectory messages, convert those into Simple Message JointTrajPt messages and send them to your server application running on your controller (or wherever you want really, it's just a TCP/IP connection most of the time).
The 'only' thing you need to do, is to implement a server that is capable of 'understanding' those Simple Message messages. In the case of an industrial robot controller this typically involves programming a special application to run on the industrial controller. That application deserialises the incoming Simple Message messages and then gets the controller to perform the appropriate motions. For a number of vendors, we already have these server applications and you only need to install those on your robot controller.
More often than not, those server applications are written in controller specific languages, not C or C++. In your specific case (with Matlab action as a middle-man) you have a few options:

Implement the whole Simple Message protocol (de)serialisation and TCP/IP connection management in Matlab script, or
Wrap the existing simple_message library inside a Simulink S-Function. Simple Message is just C++, and should be reasonably easy to port to Windows (if needed). The existing code will handle the connection and (de)serialisation for you, all you need to do is provide a few callbacks which will be called when a message is received.

If I understand you correctly, Matlab will then communicate with your B&R controller, but that is a separate problem.
Obviously, if you want to run the Simple Message server application directly on your B&R controller (without Matlab in the middle), you would have to write something that can run on that controller. If you are in the fortunate situation where you controller can run C/C++ applications, you can reuse the existing simple_message library again. You would then not need to write the protocol (de)serialiser from scratch. Again, see the industrial_robot_client page for more information.
As soon as you have created your server, the generic clients can bridge between ROS and your motion controller. Now write a URDF, create a MoveIt configuration package and you can start using MoveIt to plan motions.

Edit 2: to get the industrial_robot_client nodes to send you any traffic for testing, you could use the test_move.py script in the ur_driver package. Make sure to start the joint_trajectory_action and motion_streaming_interface from industrial_robot_client first though, and update the list of joint names.
See industrial_robot_client/launch/robot_interface_streaming.launch for an example launch file.

Originally posted by gvdhoorn with karma: 86574 on 2014-10-16
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by RosBort on 2014-10-20:
I am now tinkering about with the launch file and will use the ROS-Industrial mailing list for further questions regarding my goals. Thanks for the help!
Should I tick the question as answered?
Comment by gvdhoorn on 2014-10-20:
If you feel your question has been answered, then yes :). It's up to you.
Comment by gvdhoorn on 2014-10-20:
@RosBort: we normally just tick the check mark at the top left of the answer you think answered your question. Afaik, we rarely close questions.
Comment by RosBort on 2014-10-20:
@gvdhoorn:
Understood :)


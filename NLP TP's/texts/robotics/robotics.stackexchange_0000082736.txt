Q:

Get information from 'mongo_store' using partial information of '_meta.name' field

I am working with 'ROSPlan' and 'rosplan_interface' packages, and I am trying to get an object of the 'mongodb_store' using only its name, that is stored in an predefined field named 'name'. Please, see below the Mongo DB.

Although in 'name' is written 'waypoint_p1', the name is only 'p1' while 'waypoint' is the type. So, I would like to obtain all the information of the object passing only 'p1' to the query method. I have tried several approaches to achieve what I want but no one works.
In below code the query works but it is not what I wanted as I am already specifying the type, I only want to specify the name of the object. 'kbi.db' is an instance of 'MessageStoreProxy' from 'mongodb_store.message_store'.
p1 = kbi.db.query_named('waypoint__p1', Pose._type)
print "db.query 1\n", p1

meta = {}
meta['name'] = 'waypoint__p1'
p1 = kbi.db.query(Pose._type, {}, meta, True, [], {}, 0)
print "db.query\n", p1

This code is same as execute the following command in Mongo DB using RoboMongo:
db.getCollection('message_store').find({'_meta.name': 'waypoint__p1'})

Following one is returning an empty result. What I am trying is to pass a regular expression that will be used by Mongo DB to obtain the information I am requesting, this information means all names that contain 'p1'.
meta = {}
meta['name'] = '{$regex: /p1/}'
p1 = kbi.db.query(Pose._type, {}, meta, True, [], {}, 0)
print "db.query\n", p1

The command executed in RoboMongo for doing the query I want is:
db.getCollection('message_store').find({'_meta.name': {$regex: /p1/}})

Do you know what I am doing wrong? Or do you have a way to solve my problem? Thanks.

Originally posted by dgerod on ROS Answers with karma: 113 on 2017-09-09
Post score: 0

A:

I have found a workaround for my problem, so I am answering my own question. Maybe this workaround could be useful to someone but it only works with 'ROSPlan' and not direct requests to 'mongodb_store' package.
To obtain same result of the following code:
meta = {}
meta['name'] = '{$regex: /p1/}'
p1 = kbi.db.query(Pose._type, {}, meta, True, [], {}, 0)

I used the approach of:

Asking ROSPlan all object types existing in the domain.
After that I used types together name to query the DB until I have a result.

Of course, this approach is not best approach as it makes a lot of queries to the DB, but it works.
res = services['get_domain_types']()
for type_name in res.types:
    instance = db.query_named('%s__%s' % (type_name, item_name), return_type)
    if instance is not None:
        return instance, type_name

I am answering my own question again, this is happening so many times... :-) Although it could seem that I am writing questions too quick, I spent several time trying to fix this situation four months ago. So, it seems that asking here my question is helping me to think about the problem from other perspective.
This code is part of rosplan_interface package.

Originally posted by dgerod with karma: 113 on 2017-09-10
This answer was ACCEPTED on the original site
Post score: 0


Q:

Fusing non-continuous global pose data

I am fusing the map pose data which is calculated from the fiducial_slam node. Here the topic being fused with ekf_node is /fiducial_pose (geometry_msgs/PoseWithCovarianceStamped). The problem i'm getting is, once the fiducial_slam don't publishes the pose data when it don't detects any fiducial/aruco markers. The robot is continuously drifting namely the odom frame is drifting with respect to time even if the robot is not moving. Here is my ekf_node params:
    frequency: 10
    two_d_mode: true

    map_frame: map
    odom_frame: odom
    base_link_frame: base_footprint
    world_frame: map
    publish_tf: true

    transform_time_offset: 0.1

    smooth_lagged_data: true
    dynamic_process_noise_covariance: true

    odom0: base_controller/odom
    odom0_config: [false, false, false,
                   false, false, false,
               true,  false,  false,
               false, false, true,
               false, false, false]
# if odom0_differential is set to true x, y and yaw will be differentiated to get vx, vy and vyaw
odom0_differential: true

# Only use angular velocity from imu
imu0: /imu/data
imu0_config: [false, false, false,
              false, false, false,
              false,  false,  false,
              false, false, true,
              false, false, false]
imu0_differential: true
imu0_relative: true 

# Use x,y position and yaw orientation data for map positioning
pose0: fiducial_pose 
pose0_config: [true,  true,  false,
               false, false, true,
               false, false, false,
               false, false, false,
               false, false, false]

pose0_rejection_threshold: 2

# pose1: initialpose # External map position of robot
# pose1_config: [true,  true,  false,
#                false, false, true,
#                false, false, false,
#                false, false, false,
#                false, false, false]

# pose1_rejection_threshold: 3

# Since AMCL is more likely to fail than the beacons, you might want to treat the beacons
# as a primary source, and set pose1_differential: true
# In that case, set x', y' and yaw' to true, and the rest to false!

# pose1: /fiducial_pose # AMCL!
# pose1_config: [true,  true, false,
#                false, false, true,
#                false, false, false,
#                false, false, false,
#                false, false, false]

# pose1_rejection_threshold: 2

# poseN_rejection_threshold: (YOU MIGHT WANT THIS. If it's above the stated threshold value, the EKF will ignore the reading) (Defaults to numeric_limits<double>::max())

# [ADVANCED] The process noise covariance matrix can be difficult to tune, and can vary for each application, so it is exposed as a configuration parameter. This matrix represents the noise we add to the total error after each prediction step. 

# The better the omnidirectional motion model matches your system, the smaller these values can be. However, if users find that a given variable is slow to converge, one approach is to increase the process_noise_covariance diagonal value for the variable in question, which will cause the filter's predicted error to be larger, which will cause the filter to trust the incoming measurement more during correction. 

# The values are ordered as x, y, z, roll, pitch, yaw, vx, vy, vz, vroll, vpitch, vyaw, ax, ay, az. 
# Defaults to the matrix below if unspecified.

###########################################################################################################################
###########################################################################################################################

process_noise_covariance: [0.05, 0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0.05, 0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0.06, 0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0.03, 0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0.03, 0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0.06, 0,     0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0.025, 0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0.025, 0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0.04, 0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0,    0.01, 0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0.01, 0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0.02, 0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0.01, 0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0.01, 0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0.015]

# This represents the initial value for the state estimate error covariance matrix. Setting a diagonal value (a

    # variance) to a large value will result in early measurements for that variable being accepted quickly. Users should
    # take care not to use large values for variables that will not be measured directly. The values are ordered as x, y,
    # z, roll, pitch, yaw, vx, vy, vz, vroll, vpitch, vyaw, ax, ay, az. Defaults to the matrix below if unspecified. -->
    initial_estimate_covariance: [1e-9, 0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                  0,    1e-9, 0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                  0,    0,    1e-9, 0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                  0,    0,    0,    1e-9, 0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                  0,    0,    0,    0,    1e-9, 0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                  0,    0,    0,    0,    0,    1e-9, 0,    0,    0,    0,     0,     0,     0,    0,    0,
                                  0,    0,    0,    0,    0,    0,    1e-9, 0,    0,    0,     0,     0,     0,    0,    0,
                                  0,    0,    0,    0,    0,    0,    0,    1e-9, 0,    0,     0,     0,     0,    0,    0,
                                  0,    0,    0,    0,    0,    0,    0,    0,    1e-9, 0,     0,     0,     0,    0,    0,
                                  0,    0,    0,    0,    0,    0,    0,    0,    0,    1e-9,  0,     0,     0,    0,    0,
                                  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     1e-9,  0,     0,    0,    0,
                                  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     1e-9,  0,    0,    0,
                                  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     1e-9, 0,    0,
                                  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    1e-9, 0,
                                  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    1e-9]

Sample data of /base_controller/odom
header: 
  seq: 648774
  stamp: 
    secs: 21451
    nsecs: 299000000
  frame_id: "odom"
child_frame_id: "base_footprint"
pose: 
  pose: 
    position: 
      x: 5.367360546622458
      y: -3.226477343717956
      z: 0.0
    orientation: 
      x: 0.0
      y: 0.0
      z: -0.4181811120907099
      w: 0.9083636702833162
  covariance: [0.001, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.001, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1000000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1000000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1000000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1000.0]
twist: 
  twist: 
    linear: 
      x: -7.84378820017917e-06
      y: 0.0
      z: 0.0
    angular: 
      x: 0.0
      y: 0.0
      z: 0.00016012500416401316
  covariance: [0.001, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.001, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1000000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1000000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1000000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1000.0]

Sample data of /imu/data
header: 
  seq: 355
  stamp: 
    secs: 21481
    nsecs: 827000000
  frame_id: "imu_link"
orientation: 
  x: -0.009432798620337163
  y: 0.0033289538551165613
  z: 0.005764668671223135
  w: 0.9999333522648045
orientation_covariance: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
angular_velocity: 
  x: 1.5095815221125049e-05
  y: -5.4206682813852e-06
  z: 0.00032156750257625246
angular_velocity_covariance: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
linear_acceleration: 
  x: 0.062312201562116566
  y: 0.1806256979113818
  z: -0.00469552164706144
linear_acceleration_covariance: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

Sample data of /fiducial_pose
header: 
  seq: 21
  stamp: 
    secs: 21511
    nsecs: 510000000
  frame_id: "map"
pose: 
  pose: 
    position: 
      x: 0.1341933242820686
      y: 0.8324998652571356
      z: -0.23602488517276732
    orientation: 
      x: -0.011477776819870111
      y: -0.027899676141139317
      z: 0.26226075779434743
      w: 0.964525356655608
  covariance: [0.04663268945646209, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04663268945646209, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04663268945646209, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04663268945646209, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04663268945646209, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04663268945646209]

Environment: OS: ubuntu 20.04 ROS version: noetic

A:

I can answer more definitively if you provide the information I requested in the comment above, but I can probably guess what's wrong anyway.
You have two_d_mode enabled, which means you need to provide references (measurements) for the following quantities:

X position or X velocity
Y position or Y velocity
Yaw or Yaw velocity

When you receive pose data from the fiducials, you are meeting all of the above criteria: you are fusing X position, X velocity, Y position, and Yaw velocity.
When your pose data is not published, you are missing the second bullet: you don't have any reference for Y or Y velocity. This means part of your state vector is not being measured, which will cause its error to explode. The correlation with other state variables means your state estimate will likely drift, sometimes wildly.
Fortunately, the answer here is simple: just set Y velocity to true in your odom0_config:
    odom0_config: [false, false, false,
                   false, false, false,
                   true,  true,  false,
                   false, false, true,
                   false, false, false]

This assumes you have a nonholonomic (e.g., differential drive) base.


Q:

ROS2 - Initialize rclcpp within a class (for tests)

I'm trying to write some tests for my package. Since there's the option of using fixtures, I planned on using those, but I came across this problem.
I've created a test class like so
class MyNodeTest : public ::testing::Test {
    protected:
        char const *arg0;
        char const *arg1;
        char const *arg2;
        char** argv;
        int argc;
        std::string package_share_directory = ament_index_cpp::get_package_share_directory("package");
        std::string config_file_path = package_share_directory + "/config/test.yaml";
        rclcpp::executors::MultiThreadedExecutor executor;
        std::shared_ptr<MyNode> node;
        std::thread t;

        void SetUp() override {
            this->arg0 = "--ros-args";
            this->arg1 = "--params-file";
            this->arg2 = this->config_file_path.c_str();
            char *argPtrs[] = {(char*) this->arg0, (char*) this->arg1, (char*) this->arg2, NULL};
            this->argv = argPtrs;
            this->argc = 3;

            // Initialization
            rclcpp::init(this->argc, this->argv);

            // Instantiation
            this->node = std::make_shared<MyNode>();
            this->executor.add_node(this->node);

            this->t = std::thread([&](){ this->executor.spin(); });
        };
        void TearDown() override {
            this->executor.cancel();
            this->t.join(); // Wait for thread completion
            rclcpp::shutdown();
        };
};

which I thought I could use to write some test as this one
TEST_F(MyNodeTest, TestGetID) {
    std::this_thread::sleep_for(std::chrono::seconds(5));
    ASSERT_GT(this->node.get()->getID(), 0);
    ASSERT_EQ(this->node.get()->getID(), 1);
}

letting colcon use the "standard" main shipped with ROS (at /opt/ros/humble/src/gtest_vendor/src/gtest_main.cc.
Unfortunately this doesn't work, returning the error

C++ exception with description "failed to create guard condition: context argument is null, at ./src/rcl/guard_condition.c:65" thrown in the test fixture's constructor.

Now, I've already found a solution/workaround, which involves changing the basic structure of what I've thought and providing my own main along these lines (excluding arguments preparation):
int main(int argc, char** argv) {
    // Initialize RCLCPP
    rclcpp::init(argc, argv);
    // Initialize GTest
    ::testing::InitGoogleTest(&argc, argv);
    // Initialize RCLCPP
    // rclcpp::init(argc, argv);
    // Run tests
    int result = RUN_ALL_TESTS();
    // Shutdown RCLCPP
    // rclcpp::shutdown();
    
    return result;
}

Now my question is: is there something I don't know, which is needed to be able to actually using what I initially thought, or is this the only way possible?
Thanks! :)

A:

In the end, I've found a way to do it with small changes.
Here's the fixture class:
class MyNodeTest : public ::testing::Test {
    protected:
        std::shared_ptr<rclcpp::executors::MultiThreadedExecutor> executor;
        std::shared_ptr<MyNode> node;
        std::thread spin_thread;

        void SetUp() override {
            std::string package_share_directory = ament_index_cpp::get_package_share_directory("package");
            std::string config_file_path = package_share_directory + "/config/test.yaml";

            char* argv[] = {
                strdup("--ros-args"),
                strdup("--params-file"),
                strdup(config_file_path.c_str()),
                NULL
            };
            int   argc   = (int)(sizeof(argv) / sizeof(argv[0])) - 1;

            // Initialization
            rclcpp::init(argc, argv);
            // Clean up dynamically allocated memory
            for (int i = 0; i < argc; ++i) {
                free(argv[i]);
            }

            // Instantiation
            this->node = std::make_shared<MyNode>();

            this->executor = std::make_shared<rclcpp::executors::MultiThreadedExecutor>();
            this->executor->add_node(this->node);

            this->spin_thread = std::thread([this](){this->executor->spin();});
        };

        void TearDown() override {
            this->executor->cancel();
            this->spin_thread.join(); // Wait for thread completion
            rclcpp::shutdown();
        };
};

and the test are simply like
TEST_F(MyNodeTest, TestGetID) {
    // Wait just to be sure the node is up and running completely
    std::this_thread::sleep_for(std::chrono::seconds(1));
    std::cout << "ID: " << this->node.get()->getID() << std::endl;
    ASSERT_GT(this->node.get()->getID(), 0);
    ASSERT_EQ(this->node.get()->getID(), 1);
}

The main change seems to be the way the executor is constructed.


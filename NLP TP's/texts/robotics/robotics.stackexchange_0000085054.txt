Q:

ROS Code VideoCapture doesn't work on Intel NUC5i5MYBE

Hi,
I am using Intel NUC5i5MYBE for my application.
I have my code for the VideoCapture from USB Camera and it is tested and working perfectly in my Intel i5 PC.
However I am using the same code in INTEL NUC5i5MYBE but I am getting few errors regarding VideoCapture.
The screenshorts of mode and the errors are attached below.
The Code
 #ifdef CAMERA_INTERFACE
 void *socket_server::display(void *ptr)
 {
uchar *buffer;
int bytes = 0;
int chkBytesRecv = 0;
int sendFlag = 0;
//VideoCapture cap(0);   
int socket = videoRemoteSocket;
int numBytesAvailable = 0;
unsigned char dataBuffer[200000] = {0};
unsigned char  *buffer1 = &dataBuffer[0];
FILE *in;
/*OpenCV Code*/

Mat img, imgGray;
img = Mat::zeros(480 , 640 , CV_8UC3);

int imgSize = img.total() * img.elemSize()  ;

if ( ! img.isContinuous() )
{
    img = img.clone();
    imgGray = img.clone();
}

cap.set(CV_CAP_PROP_POS_MSEC, 10); //start the video   

double fps = cap.get(CV_CAP_PROP_FPS); //get the frames per seconds of the video    

while(1)
{
    if(connectionVideoFormed == 1)
    {
    

    /* get a frame from camera */
    cap >> img;   
    //cout<<"inside display():"<< socket <<endl;
    //while (1)
    //{

    
    
    //sleep(5);

    vector<int> compression_params; //vector that stores the compression parameters of the image

    compression_params.push_back(CV_IMWRITE_JPEG_QUALITY); //specify the compression technique

    compression_params.push_back(98); //specify the compression quality

    bool bSuccess = imwrite(jpegImage.c_str(), img, compression_params); //write the image to file

    /*****IF connection is there then only send data*************/

    
    //if(videoStremingOnOff == 1)
    //{ 
        
        in = fopen(jpegImage.c_str(),"rb");
        

        if(in != NULL)
        {
            

            fseek(in,0,SEEK_END);
            unsigned int size = ftell(in);
            unsigned char size_char = (unsigned char)size;
            unsigned int temp_size = htonl(size);

            fseek(in,0,SEEK_SET);       
            
            
            //cout<<"image size 1 = "<<size<<endl;
            //cout<<"image size 2 = "<<temp_size<<endl;
            
            //memset(buffer1,0,sizeof(buffer1));

            int byte_read=fread(buffer1, sizeof(unsigned char), size , in);
            
            
            if ((bytes = send(socket, &temp_size, 4, 0)) < 0)                   
            {

                cout<<"video_size sending failed"<<endl;
                connectionVideoFormed = 0;
                close(videoRemoteSocket);

            }
            else
            {
                //cout<<"video_size sending successful:"<<temp_size<<endl;

            }
            if ((bytes = send(socket, buffer1, size, 0)) < 0)

            {
                cout<< "video sending failed" <<endl;
                connectionVideoFormed = 0;
                close(videoRemoteSocket);
            }
            else
            {
                //cout<< "video sending successful"<<endl;

            }
            
            //bzero(&iptr[bytesToShift], ((sizeof(iptr))- bytesToShift));
            
        }
        fclose(in);         
        
    /*}
    else
    {
        //cout<<"Video streaming off"<<endl; 

    } */

    }
    usleep(100000);

}

 }
 #endif

Error
 [100%] Linking CXX executable /home/icrs/manipulator_proj/devel/lib/dynamixel_control/server_node
 CMakeFiles/server_node.dir/src/server.cpp.o: In function `socket_server::display(void*)':
 server.cpp:(.text+0x180): undefined reference to `cv::VideoCapture::VideoCapture(int)'
 server.cpp:(.text+0x313): undefined reference to `cv::VideoCapture::set(int, double)'
 server.cpp:(.text+0x327): undefined reference to `cv::VideoCapture::get(int) const'
 server.cpp:(.text+0x347): undefined reference to `cv::VideoCapture::operator>>(cv::Mat&)'
 server.cpp:(.text+0x685): undefined reference to `cv::VideoCapture::~VideoCapture()'
 collect2: error: ld returned 1 exit status
 dynamixel_control/CMakeFiles/server_node.dir/build.make:129: recipe for target '/home/icrs/manipulator_proj/devel/lib/dynamixel_control/server_node' failed
 make[2]: *** [/home/icrs/manipulator_proj/devel/lib/dynamixel_control/server_node] Error 1
 CMakeFiles/Makefile2:391: recipe for target 'dynamixel_control/CMakeFiles/server_node.dir/all' failed
 make[1]: *** [dynamixel_control/CMakeFiles/server_node.dir/all] Error 2
 Makefile:138: recipe for target 'all' failed
 make: *** [all] Error 2
 Invoking "make -j4 -l4" failed

Below is my CMakeList.txt file content
 cmake_minimum_required(VERSION 2.8.3)
 project(dynamixel_control)

 ## Compile as C++11, supported in ROS Kinetic and newer
 add_compile_options(-std=c++11)

 ## Find catkin macros and libraries
 ## if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz)
 ## is used, also find other catkin packages
 find_package(catkin REQUIRED COMPONENTS
   roscpp  
   std_msgs
   cv_bridge
   image_transport
   message_generation
   sensor_msgs
 )
 find_package(cmake_modules REQUIRED)
 find_package(Eigen3 REQUIRED)
 
 add_message_files(DIRECTORY msg
     FILES 
     cfg.msg
     vel.msg
     jcfg.msg
     soln.msg
     jvel.msg
     mode.msg
     traj.msg
     jtraj.msg
     velpos.msg
     singlegroup.msg
     thetas.msg
     nonik_cmds.msg
     joint_num.msg
     actuator_data.msg
     actuator_vel.msg
     actuator_pos.msg
     ik_stat.msg
     health_status.msg

 )
 generate_messages(
    DEPENDENCIES
    std_msgs
 )
 ## System dependencies are found with CMake's conventions
 # find_package(Boost REQUIRED COMPONENTS system)

 ## Uncomment this if the package has a setup.py. This macro ensures
 ## modules and global scripts declared therein get installed
 ## See http://ros.org/doc/api/catkin/html/user_guide/setup_dot_py.html
 # catkin_python_setup()

 ################################################
 ## Declare ROS messages, services and actions ##
 ################################################

 ## To declare and build messages, services or actions from within this
 ## package, follow these steps:
 ## * Let MSG_DEP_SET be the set of packages whose message types you use in
 ##   your messages/services/actions (e.g. std_msgs, actionlib_msgs, ...).
 ## * In the file package.xml:
 ##   * add a build_depend tag for "message_generation"
 ##   * add a build_depend and a run_depend tag for each package in MSG_DEP_SET
 ##   * If MSG_DEP_SET isn't empty the following dependency has been pulled in
 ##     but can be declared for certainty nonetheless:
 ##     * add a run_depend tag for "message_runtime"
 ## * In this file (CMakeLists.txt):
 ##   * add "message_generation" and every package in MSG_DEP_SET to
 ##     find_package(catkin REQUIRED COMPONENTS ...)
 ##   * add "message_runtime" and every package in MSG_DEP_SET to
 ##     catkin_package(CATKIN_DEPENDS ...)
 ##   * uncomment the add_*_files sections below as needed
 ##     and list every .msg/.srv/.action file to be processed
 ##   * uncomment the generate_messages entry below
 ##   * add every package in MSG_DEP_SET to generate_messages(DEPENDENCIES ...)

 ## Generate messages in the 'msg' folder
 # add_message_files(
 #   FILES
 #   Message1.msg
 #   Message2.msg
 # )

 ## Generate services in the 'srv' folder
 # add_service_files(
 #   FILES
 #   Service1.srv
 #   Service2.srv
 # )

 ## Generate actions in the 'action' folder
 # add_action_files(
 #   FILES
 #   Action1.action
 #   Action2.action
 # )

 ## Generate added messages and services with any dependencies listed here
 # generate_messages(
 #   DEPENDENCIES
 #   std_msgs
 #)

 ################################################
 ## Declare ROS dynamic reconfigure parameters ##
 ################################################

 ## To declare and build dynamic reconfigure parameters within this
 ## package, follow these steps:
 ## * In the file package.xml:
 ##   * add a build_depend and a run_depend tag for "dynamic_reconfigure"
 ## * In this file (CMakeLists.txt):
 ##   * add "dynamic_reconfigure" to
 ##     find_package(catkin REQUIRED COMPONENTS ...)
 ##   * uncomment the "generate_dynamic_reconfigure_options" section below
 ##     and list every .cfg file to be processed

 ## Generate dynamic reconfigure parameters in the 'cfg' folder

 # generate_dynamic_reconfigure_options(

 #   cfg/DynReconf1.cfg
 #   cfg/DynReconf2.cfg
 # )

 ###################################
 ## catkin specific configuration ##
 ###################################
 ## The catkin_package macro generates cmake config files for your package
 ## Declare things to be passed to dependent projects
 ## INCLUDE_DIRS: uncomment this if you package contains header files
 ## LIBRARIES: libraries you create in this project that dependent projects also need
 ## CATKIN_DEPENDS: catkin_packages dependent projects also need
 ## DEPENDS: system dependencies of this project that dependent projects also need
 catkin_package(
    INCLUDE_DIRS include
    LIBRARIES dynamixel_control   
    CATKIN_DEPENDS roscpp rospy std_msgs message_runtime
    DEPENDS EIGEN3
 #  CATKIN_DEPENDS roscpp std_msgs
 #  DEPENDS system_lib

   #CATKIN_DEPENDS roscpp std_msgs
   INCLUDE_DIRS include
   LIBRARIES dynamixel_sdk
 )

 ###########
 ## Build ##
 ###########

 ## Specify additional locations of header files
 ## Your package locations should be listed before other locations
 include_directories(
   include
   ${catkin_INCLUDE_DIRS}${Eigen_INCLUDE_DIR}
 )
 link_directories(${catkin_LIBRARY_DIRS})
 ## Declare a C++ library
 add_library(#${PROJECT_NAME}
 #   src/${PROJECT_NAME}/dynamixel_control.cpp
   dynamixel_sdk
   src/packet_handler.cpp
   src/protocol1_packet_handler.cpp
   src/protocol2_packet_handler.cpp
   src/group_sync_read.cpp
   src/group_sync_write.cpp
   src/group_bulk_read.cpp
   src/group_bulk_write.cpp
   src/port_handler.cpp
   src/port_handler_linux.cpp
 )

 ## Add cmake target dependencies of the library
 ## as an example, code may need to be generated before libraries
 ## either from message generation or dynamic reconfigure
 add_dependencies(dynamixel_sdk ${${PROJECT_NAME}_EXPORTED_TARGETS}                     ${catkin_EXPORTED_TARGETS})
 #add_dependencies(ik inversekinematics_generate_messages_cpp)

 ## Declare a C++ executable
 ## With catkin_make all packages are built within a single CMake context
 ## The recommended prefix ensures that target names across packages don't collide
 add_executable(dynamixel_control src/dynamixel_control.cpp)

 ## Rename C++ executable without prefix
 ## The above recommended prefix causes long target names, the following renames the
 ## target back to the shorter version for ease of user use
 ## e.g. "rosrun someones_pkg node" instead of "rosrun someones_pkg someones_pkg_node"
 target_link_libraries(dynamixel_control dynamixel_sdk ${catkin_LIBRARIES})

 ## Add cmake target dependencies of the executable
 ## same as for the library above
 # add_dependencies(${PROJECT_NAME}_node ${${PROJECT_NAME}_EXPORTED_TARGETS}      ${catkin_EXPORTED_TARGETS})

 ## Specify libraries to link a library or executable target against
 # target_link_libraries(${PROJECT_NAME}_node
 #   ${catkin_LIBRARIES}
 # )

 add_executable(Keyboard_input src/Keyboard_input.cpp)
 target_link_libraries(Keyboard_input dynamixel_sdk ${catkin_LIBRARIES})

 add_executable(server_node src/server.h src/server.cpp)
 target_link_libraries(server_node dynamixel_sdk
    ${catkin_LIBRARIES}
  )
 add_executable(ik src/ik.cpp)
 target_link_libraries(ik dynamixel_sdk ${catkin_LIBRARIES})

 #add_dependencies(Keyboard_input ${${PROJECT_NAME}_EXPORTED_TARGETS}      ${catkin_EXPORTED_TARGETS})

 #############
 ## Install ##
 #############

 # all install targets should use catkin DESTINATION variables
 # See http://ros.org/doc/api/catkin/html/adv_user_guide/variables.html

 ## Mark executable scripts (Python etc.) for installation
 ## in contrast to setup.py, you can choose the destination
 # install(PROGRAMS
 #   scripts/my_python_script
 #   DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
 # )

 ## Mark executables and/or libraries for installation
 # install(TARGETS ${PROJECT_NAME} ${PROJECT_NAME}_node
 #   ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
 #   LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
 #   RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
 # )
 install(TARGETS dynamixel_sdk
   ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
   LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
   RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
 )
 ## Mark cpp header files for installation
 # install(DIRECTORY include/${PROJECT_NAME}/
 #   DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}
 #   FILES_MATCHING PATTERN "*.h"
 #   PATTERN ".svn" EXCLUDE
 # )
 install(DIRECTORY include/${PROJECT_NAME}/
   DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}
 )

 ## Mark other files for installation (e.g. launch and bag files, etc.)
 # install(FILES
 #   # myfile1
 #   # myfile2
 #   DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}
 # )

 #############
 ## Testing ##
 #############

 ## Add gtest based cpp test target and link libraries
 # catkin_add_gtest(${PROJECT_NAME}-test test/test_dynamixel_control.cpp)
 # if(TARGET ${PROJECT_NAME}-test)
 #   target_link_libraries(${PROJECT_NAME}-test ${PROJECT_NAME})
 # endif()

 ## Add folders to be run by python nosetests
 # catkin_add_nosetests(test)

CMakeList.txt
# toplevel CMakeLists.txt for a catkin workspace
# catkin/cmake/toplevel.cmake

cmake_minimum_required(VERSION 2.8.3)

set(CATKIN_TOPLEVEL TRUE)

# search for catkin within the workspace
set(_cmd "catkin_find_pkg" "catkin" "${CMAKE_SOURCE_DIR}")
execute_process(COMMAND ${_cmd}
  RESULT_VARIABLE _res
  OUTPUT_VARIABLE _out
  ERROR_VARIABLE _err
  OUTPUT_STRIP_TRAILING_WHITESPACE
  ERROR_STRIP_TRAILING_WHITESPACE
)
if(NOT _res EQUAL 0 AND NOT _res EQUAL 2)
  # searching fot catkin resulted in an error
  string(REPLACE ";" " " _cmd_str "${_cmd}")
  message(FATAL_ERROR "Search for 'catkin' in workspace failed (${_cmd_str}): ${_err}")
endif()

# include catkin from workspace or via find_package()
if(_res EQUAL 0)
  set(catkin_EXTRAS_DIR "${CMAKE_SOURCE_DIR}/${_out}/cmake")
  # include all.cmake without add_subdirectory to let it operate in same scope
  include(${catkin_EXTRAS_DIR}/all.cmake NO_POLICY_SCOPE)
  add_subdirectory("${_out}")

else()
  # use either CMAKE_PREFIX_PATH explicitly passed to CMake as a command line argument
  # or CMAKE_PREFIX_PATH from the environment
  if(NOT DEFINED CMAKE_PREFIX_PATH)
    if(NOT "$ENV{CMAKE_PREFIX_PATH}" STREQUAL "")
      string(REPLACE ":" ";" CMAKE_PREFIX_PATH $ENV{CMAKE_PREFIX_PATH})
    endif()
  endif()

  # list of catkin workspaces
  set(catkin_search_path "")
  foreach(path ${CMAKE_PREFIX_PATH})
    if(EXISTS "${path}/.catkin")
      list(FIND catkin_search_path ${path} _index)
      if(_index EQUAL -1)
        list(APPEND catkin_search_path ${path})
      endif()
    endif()
  endforeach()

  # search for catkin in all workspaces
  set(CATKIN_TOPLEVEL_FIND_PACKAGE TRUE)
  find_package(catkin QUIET
   NO_POLICY_SCOPE
    PATHS ${catkin_search_path}
    NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
      unset(CATKIN_TOPLEVEL_FIND_PACKAGE)

  if(NOT catkin_FOUND)
    message(FATAL_ERROR "find_package(catkin) failed. catkin was neither found in the workspace nor in the                      CMAKE_PREFIX_PATH. One reason may be that no ROS setup.sh was sourced before.")
   endif()
 endif()

 catkin_workspace()

Kindly suggest us any solution for this issue.
Thanks.

Originally posted by Radeshwar on ROS Answers with karma: 23 on 2018-01-31
Post score: 0

A:

This points to some missing dependencies. Are you sure you have the dependencies, especially opencv, installed?

Originally posted by mgruhler with karma: 12390 on 2018-01-31
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by Radeshwar on 2018-01-31:
I didn't install Opencv separately, I installed ROS Kinetic.
Do I need to install OpenCv separately???
Comment by mgruhler on 2018-01-31:
Well, but which packages...
If you install e.g. ros-kinetic-cv-bridge will automatically install opencv3. Check out the ROS wiki for more Details. Also, rosdep could help you in resolving dependencies, as Long as they are specified correctly.
Comment by Radeshwar on 2018-01-31:
hi mig
we installed cv_bridge and opencv3.4 along with ros-kinetic .
we found that the same code is running on different PC  installed with opencv2.4.9 so we also installed opencv2.4.9 in our intel NUC board however the result remain unchanged (same error)
Comment by gvdhoorn on 2018-01-31:
@Radeshwar: ROS comes with a specific version of OpenCV. Installing OpenCV yourself is not recommended (until you get more comfortable with all of this).
Comment by Radeshwar on 2018-01-31:
hi gvdhoorn
we tried with default version of opencv  that comes with ros-kinetic but we are getting the Videocapture error . so we wanted to try different version of opencv ,however the result was same(videocapture error)
Comment by gvdhoorn on 2018-01-31:
Unless you overwrote the ROS distributed version or overrode the version found by CMake it might not have used the parallel installated versions.
Comment by gvdhoorn on 2018-01-31:
Please add the contents of your CMakeLists.txt to your original question. Please use the Preformatted Text button to format it properly and please don't include all the comments. They are not needed.
Comment by Radeshwar on 2018-02-01:
I have added my CMakeList.txt file content to my question.
I have not removed comments because I am not sure whether I have commented any required commands which is necessary.
Kindly go through.
Thanks.


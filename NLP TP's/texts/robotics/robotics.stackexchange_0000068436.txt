Q:

What is ConstPtr&?

Hey All, I'm still new to ROS and C++. I'm having trouble understanding what the ConstPtr& does when writing the callback function for a simple subscriber:
 void chatterCallback(const std_msgs::String::ConstPtr& msg) 

     {ROS_INFO("I heard: [%s]", msg->data.c_str());}
 

Wouldn't the code work with just:
 void chatterCallback(const std_msgs::String msg)

      {ROS_INFO("I heard: [%s]", msg);}
 

Originally posted by OmoNaija on ROS Answers with karma: 213 on 2015-07-03
Post score: 21

A:

When messages are automatically generated into C++ code, there are several typedefs defined. One of them is ::Ptr, which is typedef-ed to be a boost::shared_ptr<MSG>, and another is ::ConstPtr which is boost::shared_ptr<MSG const>.
By passing a const pointer into the callback, we avoid doing a copy. While this might not make much difference for std_msgs::String, it can make a huge difference for sensor_msgs::PointCloud2.

Originally posted by fergs with karma: 13902 on 2015-07-04
This answer was ACCEPTED on the original site
Post score: 37

Original comments
Comment by OmoNaija on 2015-07-06:
Thank You!
Comment by feixiao on 2016-01-21:
thanks a lot for your help
Comment by wy3 on 2017-07-29:
but what does & means? If msg is already a pointer, why do we take the address of msg? Or does that & means passing by reference?
Comment by ksirks on 2017-09-15:
@wy3: the ampersand (&) means pass by reference as you said.
Comment by eRCaGuy on 2020-06-10:
Note: today I think boost::shared_ptr<> is replaced in ROS by std::shared_ptr<>, since this is now part of the C++ Standard Library.
Comment by eRCaGuy on 2020-06-10:
@wy3, the & is to pass the shared_ptr object itself by reference. The shared_ptr object is a class which manages the object it wraps and "points to", and the & is to pass the shared_ptr object by reference. So, we are passing a message by a reference to a smart pointer which points to it--yeah, it's kind of a double-layered approach. In C you'd just pass the message by pointer and be done, but the added benefit of using a shared pointer, which is a type of "smart pointer", is that it automatically manages the storage duration of the memory (for the message) it points to, meaning you never have to manually free or delete this dynamically-allocated memory block for the message because it's done automatically when all shared pointers to that memory are gone or out of scope.
Comment by eRCaGuy on 2020-06-10:
I just added my above comments, and more, into my own answer here. I realized my comments were becoming more than just comments, so I made them into an answer.
Comment by fergs on 2020-08-18:
ROS1 still very much uses boost in roscpp - changing to std::shared_ptr would break the world. ROS2 does drop boost for std::shared_ptr in rclcpp.
Comment by ia on 2021-04-11:
@ahendrix but why do some message type look like sensor_msgs::ImageConstPtr and others need colons like: automotive_platform_msgs::AdaptiveCruiseControlCommand::ConstPtr? For instance, without those double colons :: right before ConstPtr I get a very hard to grok error message too long to post here.
Comment by eRCaGuy on 2021-04-12:
@ahendrix, I don't see the answer yet, but here's a question I asked to try to start to find out: https://stackoverflow.com/questions/67053471/what-is-a-void-stdallocator-ie-stdallocatorvoid.


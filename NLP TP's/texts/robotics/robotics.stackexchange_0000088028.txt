Q:

ros1_bridge generating custom messages but when running, throws error "No template specialization for the pair"

I have successfully ran ros1_bridge's dynamic_bridge and passed messages between ROS and ROS2, but cannot quite figure out how to implement custom message definitions. I am using 64-bit Ubuntu 16.04 LTS, ROS Kinetic, and ROS2 Ardent.
Below is my general file structure:
<path_to_folder>
---ros2_ws
------[workspace built from [this](https://github.com/ros2/ros2/wiki/Ament-Tutorial) tutorial, with ardent branch's ros2.repos file]
---my_ros2_ws
------[other ros2 stuff I'm doing that will later utilize the ros1_bridge]
---ros1_bridge_ws_overlay
------catkin_ws_overlay
---------src
------------CMakeLists.txt
------------my_interfaces
---------------CMakeLists.txt
---------------package.xml
---------------msg
------------------MyCustom.msg
---------------src
------------------my_publisher.cpp
------ros2_ws_overlay
---------src
------------my_interfaces
---------------CMakeLists.txt
---------------package.xml
---------------msg
------------------MyCustom.msg
---------------src
------------------my_subscriber.cpp

To specify, I've named the package and message file the same for each workspace, and the message file itself is a simple definition with a couple of float64[] list variables (I copied the exact contents so it matches).
My process to build all of this is as follows (each build is done in a separate terminal):
**Process for building ros1_bridge_ws_overlay/catkin_ws_overlay:
  $ source /opt/ros/kinetic/setup.bash
  $ cd <path_to_folder>/ros1_bridge_overlay/catkin_ws_overlay/
  $ catkin_make

The output for catkin_make clearly generates my custom message and link's my executable.
**Process for building ros1_bridge_ws_overlay/ros2_ws_overlay:
  $ source /opt/ros/ardent/setup.bash
  $ cd <path_to_folder>/ros1_bridge_overlay/ros2_ws_overlay/
  $ ament build

Again, the output clearly generates my custom messages (I can see them in install/include/my_interfaces/msg/) and links my executable.
Now that I've generated my custom messages, I go to my ros2_ws and delete the folder ros2_ws/build/ros1_bridge. Then, to rebuild the ros1_bridge, I do as follows:
**Process for rebuilding ros1_bridge:
  $ source <path_to_folder>/ros1_bridge_overlay/catkin_ws_overlay/devel/setup.bash
  $ source <path_to_folder>/ros1_bridge_overlay/ros2_ws_overlay/install/local_setup.bash
  $ cd <path_to_folder>/ros2_ws
  $ src/ament/ament_tools/scripts/ament.py build --build-tests --symlink-install

From this, I see important output such as:
[  2%] Generating generated/get_factory.cpp, generated/get_mappings.cpp, generated/nav_msgs_factories.cpp, generated/actionlib_msgs_factories.cpp, generated/logging_demo_factories.cpp, generated/trajectory_msgs_factories.cpp, generated/test_msgs_factories.cpp, generated/tf2_msgs_factories.cpp, generated/stereo_msgs_factories.cpp, generated/lifecycle_msgs_factories.cpp, generated/visualization_msgs_factories.cpp, generated/geometry_msgs_factories.cpp, generated/shape_msgs_factories.cpp, generated/std_msgs_factories.cpp, generated/rcl_interfaces_factories.cpp, generated/std_srvs_factories.cpp, generated/diagnostic_msgs_factories.cpp, generated/builtin_interfaces_factories.cpp, generated/sensor_msgs_factories.cpp, generated/example_interfaces_factories.cpp, generated/pendulum_msgs_factories.cpp, generated/composition_factories.cpp, generated/my_interfaces_factories.cpp

and
[ 84%] Building CXX object CMakeFiles/ros1_bridge.dir/generated/my_interfaces_factories.cpp.o

At this point, I would guess that my custom message is being processed and built properly. Then, I run all the executables necessary to bring up the bridge (again, all of these are in separate terminals), as so:
**Process for starting roscore:
  $ source /opt/ros/kinetic/setup.bash
  $ source <path_to_folder>/ros1_bridge_overlay/catkin_ws_overlay/devel/setup.bash
  $ roscore

**Process for starting dynamic_bridge:
  $ source /opt/ros/kinetic/setup.bash
  $ source <path_to_folder>/ros1_bridge_overlay/catkin_ws_overlay/devel/setup.bash
  $ source /opt/ros/ardent/setup.bash
  $ source <path_to_folder>/ros2_ws/install/local_setup.bash
  $ source <path_to_folder>/ros1_bridge_overlay/ros2_ws_overlay/install/local_setup.bash
  $ ros2 run ros1_bridge dynamic_bridge

**Process for starting ROS publisher:
  $ source /opt/ros/kinetic/setup.bash
  $ source <path_to_folder>/ros1_bridge_overlay/catkin_ws_overlay/devel/setup.bash
  $ rosrun my_interfaces test_publisher // How I named my executable

**Process for starting ROS2 subscriber:
  $ source /opt/ros/ardent/setup.bash
  $ source <path_to_folder>/ros1_bridge_overlay/ros2_ws_overlay/install/local_setup.bash
  $ source <path_to_folder>/ros2_ws/install/local_setup.bash
  $ ros2 run my_interfaces my_subscriber // How I named my executable

Perhaps it's important to include that for the command "source <path_to_folder>/ros2_ws/install/local_setup.bash" while starting the dynamic_bridge and my_subscriber, I get this warning message:
Warning: OSPL_URI was already set to [[file:///opt/ros/ardent/share/opensplice_cmake_module/config/ros_ospl.xml]]. This will not override it to the default [[file:///<path_to_folder>/ros2_ws/install/share/opensplice_cmake_module/config/ros_ospl.xml]]. Please make sure this is the config that you want.

After all of this, I get the error:
failed to create 1to2 bridge for topic '/test_chatter' with ROS 1 type 'my_interfaces/MyCustom' and ROS 2 type
'my_interfaces/MyCustom': No template specialization for the pair
check the list of supported pairs with the `--print-pairs` option

Sorry for the long post, I just thought that I'd be as specific as possible right off the bat. Does anyone see something that could be preventing my build from running correctly? Thank you, much appreciated!
EDIT #1: Below are the contents of generated/my_interfaces_factories.cpp:
// generated from ros1_bridge/resource/pkg_factories.cpp.em

#include "rclcpp/rclcpp.hpp"
#include "my_interfaces_factories.hpp"

// include builtin interfaces
#include <ros1_bridge/convert_builtin_interfaces.hpp>

// include ROS 1 services

// include ROS 2 services

namespace ros1_bridge
{

std::shared_ptr<FactoryInterface>
get_factory_my_interfaces(const std::string & ros1_type_name, const std::string & ros2_type_name)
{
  (void)ros1_type_name;
  (void)ros2_type_name;
  // mapping from string to specialized template
  return std::shared_ptr<FactoryInterface>();
}

// conversion functions for available interfaces

std::unique_ptr<ServiceFactoryInterface>
get_service_factory_my_interfaces(const std::string & ros_id, const std::string & package_name, const std::string & service_name)
{
  (void)ros_id;
  (void)package_name;
  (void)service_name;
  return nullptr;
}
}  // namespace ros1_bridge

EDIT #2: Below are the contents of the ROS and ROS2 messages (I copied and pasted the content of one file into the other, so they are exact matches):
# This is the ROS message.
#
# positions: an array of angular positions of each joint
# velocities: an array of angular velocities of each joint
# currents: an array of the actual currents in each joint
# temperatures: an array of the actual temperatures in each joint
# position_error: an array of the positional error of the robot's current move

float64[] positions
float64[] velocities
float64[] currents
float64[] temperatures
float64[] position_error

# This is the ROS2 message.
#
# positions: an array of angular positions of each joint
# velocities: an array of angular velocities of each joint
# currents: an array of the actual currents in each joint
# temperatures: an array of the actual temperatures in each joint
# position_error: an array of the positional error of the robot's current move

float64[] positions
float64[] velocities
float64[] currents
float64[] temperatures
float64[] position_error

EDIT #3: Below is the contents of the generated mapping file, the build error, and because I'm anticipating a problem with these files, the CMakeLists.txt and package.xml under my catkin_ws_overlay/my_msgs package (the solution to the initial problem made my rename my packages to my_msgs):
//CONTENTS OF my_msgs_factories.hpp
// generated from ros1_bridge/resource/pkg_factories.hpp.em

#include <ros1_bridge/factory.hpp>

// include ROS 1 messages
#include <my_msgs/MyCustom.h>

// include ROS 2 messages
#include <my_msgs/msg/my_custom.hpp>

namespace ros1_bridge
{

std::shared_ptr<FactoryInterface>
get_factory_my_msgs(const std::string & ros1_type_name, const std::string & ros2_type_name);

std::unique_ptr<ServiceFactoryInterface>
get_service_factory_my_msgs(const std::string & ros_id, const std::string & package_name, const std::string & service_name);

// conversion functions for available interfaces

template<>
void
Factory<
  my_msgs::MyCustom,
  my_msgs::msg::MyCustom
>::convert_1_to_2(
  const my_msgs::MyCustom & ros1_msg,
  my_msgs::msg::MyCustom & ros2_msg);

template<>
void
Factory<
  my_msgs::MyCustom,
  my_msgs::msg::MyCustom
>::convert_2_to_1(
  const my_msgs::msg::MyCustom & ros2_msg,
  my_msgs::MyCustom & ros1_msg);

}  // namespace ros1_bridge

// CONTENTS OF my_msgs_factories.cpp
// generated from ros1_bridge/resource/pkg_factories.cpp.em

#include "rclcpp/rclcpp.hpp"
#include "my_msgs_factories.hpp"

// include builtin interfaces
#include <ros1_bridge/convert_builtin_interfaces.hpp>

// include ROS 1 services

// include ROS 2 services

namespace ros1_bridge
{

std::shared_ptr<FactoryInterface>
get_factory_my_msgs(const std::string & ros1_type_name, const std::string & ros2_type_name)
{
  // mapping from string to specialized template
  if (
    (ros1_type_name == my_"msgs/MyCustom" ||
     ros1_type_name == "") &&
    ros2_type_name == "my_msgs/MyCustom")
  {
    return std::make_shared<
      Factory<
        my_msgs::MyCustom,
        my_msgs::msg::MyCustom
      >
    >("my_msgs/MyCustom", ros2_type_name);
  }
  return std::shared_ptr<FactoryInterface>();
}

// conversion functions for available interfaces

template<>
void
Factory<
  my_msgs::MyCustom,
  my_msgs::msg::MyCustom
>::convert_1_to_2(
  const my_msgs::MyCustom & ros1_msg,
  my_msgs::msg::MyCustom & ros2_msg)
{
  // convert array field
  // ensure array size
  // dynamic arrays must be resized
  ros2_msg.positions.resize(ros1_msg.positions.size());
  // convert primitive array elements
  std::copy(
    ros1_msg.positions.begin(),
    ros1_msg.positions.end(),
    ros2_msg.positions.begin());
  // convert array field
  // ensure array size
  // dynamic arrays must be resized
  ros2_msg.velocities.resize(ros1_msg.velocities.size());
  // convert primitive array elements
  std::copy(
    ros1_msg.velocities.begin(),
    ros1_msg.velocities.end(),
    ros2_msg.velocities.begin());
  // convert array field
  // ensure array size
  // dynamic arrays must be resized
  ros2_msg.currents.resize(ros1_msg.currents.size());
  // convert primitive array elements
  std::copy(
    ros1_msg.currents.begin(),
    ros1_msg.currents.end(),
    ros2_msg.currents.begin());
  // convert array field
  // ensure array size
  // dynamic arrays must be resized
  ros2_msg.temperatures.resize(ros1_msg.temperatures.size());
  // convert primitive array elements
  std::copy(
    ros1_msg.temperatures.begin(),
    ros1_msg.temperatures.end(),
    ros2_msg.temperatures.begin());
  // convert array field
  // ensure array size
  // dynamic arrays must be resized
  ros2_msg.position_error.resize(ros1_msg.position_error.size());
  // convert primitive array elements
  std::copy(
    ros1_msg.position_error.begin(),
    ros1_msg.position_error.end(),
    ros2_msg.position_error.begin());
}

template<>
void
Factory<
  my_msgs::MyCustom,
  my_msgs::msg::MyCustom
>::convert_2_to_1(
  const my_msgs::msg::MyCustom & ros2_msg,
  my_msgs::MyCustom & ros1_msg)
{
  // convert array field
  // ensure array size
  // dynamic arrays must be resized
  ros1_msg.positions.resize(ros2_msg.positions.size());
 // convert primitive array elements
  std::copy(
    ros2_msg.positions.begin(),
    ros2_msg.positions.end(),
    ros1_msg.positions.begin());
  // convert array field
  // ensure array size
  // dynamic arrays must be resized
  ros1_msg.velocities.resize(ros2_msg.velocities.size());
  // convert primitive array elements
  std::copy(
    ros2_msg.velocities.begin(),
    ros2_msg.velocities.end(),
    ros1_msg.velocities.begin());
  // convert array field
  // ensure array size
  // dynamic arrays must be resized
  ros1_msg.currents.resize(ros2_msg.currents.size());
  // convert primitive array elements
  std::copy(
    ros2_msg.currents.begin(),
    ros2_msg.currents.end(),
    ros1_msg.currents.begin());
  // convert array field
  // ensure array size
  // dynamic arrays must be resized
  ros1_msg.temperatures.resize(ros2_msg.temperatures.size());
  // convert primitive array elements
  std::copy(
    ros2_msg.temperatures.begin(),
    ros2_msg.temperatures.end(),
    ros1_msg.temperatures.begin());
  // convert array field
  // ensure array size
  // dynamic arrays must be resized
  ros1_msg.position_error.resize(ros2_msg.position_error.size());
  // convert primitive array elements
  std::copy(
    ros2_msg.position_error.begin(),
    ros2_msg.position_error.end(),
    ros1_msg.position_error.begin());
}

std::unique_ptr<ServiceFactoryInterface>
get_service_factory_my_msgs(const std::string & ros_id, const std::string & package_name, const std::string & service_name)
{
  (void)ros_id;
  (void)package_name;
  (void)service_name;
  return nullptr;
}
}  // namespace ros1_bridge

Here is the error message I'm getting upon attempting to build ros1_bridge:
In file included from <path_to_folder>/ros2_ws/build/ros1_bridge/generated/get_factory.cpp:26:0: <path_to_folder>/ros2_ws/build/ros1_bridge/generated/my_msgs_factories.hpp:6:31: fatal error: my_msgs/MyCustom.h: No such file or directory

And finally, here are the contents of the ROS package's CMakeLists.txt:
//CONTENTS OF CMakeLists.txt
cmake_minimum_required(VERSION 2.8)
project(my_msgs)

find_package(catkin REQUIRED COMPONENTS
  roscpp
  message_generation
)

include_directories(include ${catkin_INCLUDE_DIRS})

add_message_files(
  FILES
  MyCustom.msg
)

generate_messages(
  DEPENDENCIES
  std_msgs
)

catkin_package(
  CATKIN_DEPENDS message_runtime
)

install(DIRECTORY include/my_msgs/
  DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}
)

And package.xml:
<?xml version="1.0"?>
<package format="2">
  <name>my_msgs</name>
  <version>0.0.0</version>
  <description>my_msgs, ros1 container</description>
  <author>My Name</author>
  <maintainer email="my info">My Name</maintainer>
  <license>Proprietary</license>
  
  <build_depend>message_generation</build_depend>
  <depend>message_runtime</depend>

  <buildtool_depend>catkin</buildtool_depend>

</package>

Originally posted by Rob V on ROS Answers with karma: 56 on 2018-07-20
Post score: 2

Original comments
Comment by Dirk Thomas on 2018-07-20:
Did you run the bridge with --print-pairs to see which message types from your custom package are included? The content of the generated file generated/my_interfaces_factories.cpp would reveal similar information.
Comment by Rob V on 2018-07-21:
I tried --print-pairs and generated/my_interfaces_factories.cpp was not included in the list...
Comment by Dirk Thomas on 2018-07-21:
Can you share the content of the generated file generated/my_interfaces_factories.cpp.
Comment by Rob V on 2018-07-23:
Sorry for the delay, I was away from my machine for a little bit - see the edit above for the contents of the file. Thanks again!
Comment by Dirk Thomas on 2018-07-23:
The source code doesn't contain any mapping. Please post the exact content of your message files from the ROS 1 as well as 2 workspaces.
Comment by Rob V on 2018-07-23:
See the next edit for the message contents.
Comment by Dirk Thomas on 2018-07-23:
Please try to edit the source code of the ros1_bridge before building it by adding print statements for the various variables in this section
Comment by Dirk Thomas on 2018-07-23:
Make sure that your message appears in ros1_msgs as well as ros2_msgs and that the packages are correlated in package_pairs and the messages in message_pairs.
Comment by Rob V on 2018-07-23:
I'll get on that and update shortly, but just to make sure we're on the same page, the git tree you linked me to does not match my source code - mine matches that seen in the ardent branch.
Comment by Dirk Thomas on 2018-07-23:
You can keep using the ardent branch (https://github.com/ros2/ros1_bridge/commits/ardent). The relevant code should be the same.
Comment by Rob V on 2018-07-23:
Sounds good. And looking at the output, my message is in ros1_msgs (<path_to_folder>/ros1_bridge_overlay/catkin_ws_overlay/src/my_interfaces/msg:my_interfaces:MyCustom) and its seen as a ros2 package in ros2_package_names, but there's no trace of it in package_pairs or message_pairs....
Comment by Dirk Thomas on 2018-07-23:
Please continue debugging why your message isn't being mapped correctly or provide all the code to reproduced the problem.
Comment by Rob V on 2018-07-23:
I will continue to debug, thanks for all of your help so far!
Comment by Rob V on 2018-07-23:
Pretty sure I just found what it is, I'm going to test to be sure.
Comment by Rob V on 2018-07-24:
So I got past the initial problem, the file contains the proper mappings now (see the above edit). However, when I try to build ros1_bridge now, the build fails with a different output (also in above edit). Do you know what this problem could be and why it's not finding the message definition?
Comment by Rucha on 2018-07-25:
Hi Rob, could you please share how did you solve your initial problem related to custom message mapping? I am facing the same issue as the title of your question and I have done the necessary steps needed for custom message mapping.
Comment by Rob V on 2018-07-25:
Sure! In short, the problem was that the package's suffix was "_interfaces", as that's considered a standard suffix in ROS2 but not 1, so during processing, it's removed from the name. It compares "my_interfaces" (ROS1) to "my" (ROS2), and those aren't equivalent and are ignored.
Comment by Rob V on 2018-07-25:
Sorry, I was going to wait until the entire problem was solved before posting an answer in case it was relevant. I suppose I'll answer this and start a new question. See it here.
Comment by Dirk Thomas on 2018-07-25:
The failing include is either due to not sourcing the ROS 1 workspace in the right order or due to the ROS 1 package not exporting its include directory properly.
Comment by Rob V on 2018-07-25:
Does anything about my CMakeLists file stick out to you as wrong?
Comment by Dirk Thomas on 2018-07-25:
You might want to try adding this line: https://github.com/ros/std_msgs/blob/474568b32881c81f6fb962a1b45a7d60c4db9255/CMakeLists.txt#L46

A:

Short answer: Packages that you want to be linked by ros1_bridge (without a mapping rule) cannot end in "_interfaces", and that's possibly the only sequence of character's that it can't end with.
Longer answer: The answer to the original problem, basically, is that I used a sequence of characters as my suffix that produces unexpected results. I named my package my_interfaces. However, in __init__.py of ros1_bridge, in the function determine_package_pairs (found here), you'll see these variables:
ros1_suffix = '_msgs'
ros2_suffixes = ['_msgs', '_interfaces']

The logic following says that to compare a ROS1 package's name and a ROS2 package's name, you first have to remove possible suffixes. So, when given "my_interfaces", it modifies it to say that the new ROS1 package name is "my_interfaces", but the ROS2 package name is only "my" now. Since those aren't equivalent anymore, it stops processing these packages as possible linkages between the bridge. My solution was to simply rename the package to be anything BUT something that ends in "_interfaces"... I'm not really sure as to why this was implemented without first checking that they're equivalent, it caused me a LOT of frustration XD
However, I have not yet solved the follow up issue in my third edit. If someone can point out what the issue there is, that'd be much appreciated! I'll update this answer if I find a solution.

Originally posted by Rob V with karma: 56 on 2018-07-25
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Spyros Kou on 2023-06-13:
"I'm not really sure as to why this was implemented without first checking that they're equivalent, it caused me a LOT of frustration XD"
This is related with the ROS1/ROS2 package naming conventions/best practices.

In ROS 1 the convention/best practice is to use the "_msgs" postfix in interface packages.
In ROS 2 the convention/best practice is to use the "_interfaces" instead of "_msgs"  postfix in interface packages BUT in practice both post-fixes are used.

ROS2 Package Naming Best practices


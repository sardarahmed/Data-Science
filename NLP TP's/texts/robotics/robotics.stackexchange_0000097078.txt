Q:

catkin_make had different include path from catkin_make_isolated

I am trying to port some packages from a catkin_make (CM) build system to a catkin_make_isolated (CMI) build system. I need the build to be valid using both CM and CMI to support some legacy tooling. My package is currently building in CMI, but not in CM. This surprises me since I would think CMI would be the harder tool to get working. It seems CM can't find my header file, but CMI can.
The following error appears with CM only when building a package which imports my library

fatal error: cav_driver_utils/driver_wrapper/driver_wrapper.h: No such file or directory

The library has the following structure

The libraries CMakeLists file looks like this
cmake_minimum_required(VERSION 2.8.3)
project(cav_driver_utils)
add_compile_options(-std=c++11)
set( CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall")
set( CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall")

find_package(catkin REQUIRED COMPONENTS
  bondcpp
  cav_msgs
  cav_srvs
  roscpp
  std_msgs
)

find_package(Boost REQUIRED system)

catkin_package(
  INCLUDE_DIRS include
  LIBRARIES driver_application cav_socketcan_interface ros_socketcan_interface driver_wrapper
  CATKIN_DEPENDS bondcpp cav_msgs cav_srvs roscpp std_msgs
  DEPENDS Boost
)

include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)

add_library(driver_application
    src/driver_application/driver_application.cpp
    include/driver_application/driver_application.h)

add_dependencies(driver_application ${catkin_EXPORTED_TARGETS})

target_link_libraries(driver_application ${catkin_LIBRARIES})

add_library(cav_socketcan_interface
        src/socketcan_interface/socketcan_interface.cpp
        include/cav_driver_utils/can/socketcan_interface/socketcan_interface.h)

add_dependencies(cav_socketcan_interface ${catkin_EXPORTED_TARGETS})

target_link_libraries(cav_socketcan_interface ${Boost_LIBRARIES})

add_library(ros_socketcan_interface
        src/ros_socketcan_bridge/ros_socketcan_bridge.cpp
        include/cav_driver_utils/can/ros_socketcan_bridge/ros_socketcan_bridge.h)

add_dependencies(ros_socketcan_interface ${catkin_EXPORTED_TARGETS})

target_link_libraries(ros_socketcan_interface ${Boost_LIBRARIES})

add_library(driver_wrapper
    src/driver_wrapper/driver_wrapper.cpp
    include/driver_wrapper/driver_wrapper.h)

add_dependencies(driver_wrapper ${catkin_EXPORTED_TARGETS})

target_link_libraries(driver_wrapper ${catkin_LIBRARIES})

install(TARGETS driver_application driver_wrapper cav_socketcan_interface ros_socketcan_interface
  ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
  LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
 RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
)

install(DIRECTORY include/cav_driver_utils/
        DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION} 
)

install(DIRECTORY include/driver_application
        DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION} 
)

install(DIRECTORY include/driver_wrapper
        DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION} 
)

The only thing I can think of that would cause CM to fail but not CMI is if CM installs headers to slightly different default locations. Is that the case?
I'm using
Ubuntu 16.04
ROS1 Kinetic
GCC version 5.4.0
cmake version 3.5.1
Edit: I setup a smaller testing package to evaluate the issue and found the following behavior:
With catkin_make my package header was found at
#include <my_package/my_package.h>
With catkin_make_isolated my package header was found at
#include <my_package/my_package/my_package.h>
It seems that catkin_make_isolated is applying an additional folder into the build structure. How can I control that?

Originally posted by msmcconnell on ROS Answers with karma: 268 on 2020-09-11
Post score: 0

A:

I was able to resolve this, by restructuring the include folder as follows:

And reducing the install tags to
install(DIRECTORY include/cav_driver_utils/ DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}  )
I can understand why this approach is supported by both catkin_make and catkin_make_isolated as it follows the recommended include folder structure in ROS, but I do not understand why it seems this structure was required by catkin_make but not catkin_make_isolated. I would have thought that the install tags were primarily a CMake concept and wouldn't be impacted by the build tool in this way. Feel free to enlighten me in the comments. In the meantime I am marking this issue as resolved.

Originally posted by msmcconnell with karma: 268 on 2020-09-13
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Dirk Thomas on 2020-09-14:
When you don't explicitly install the packages but use the devel space the header files are not being copied. Therefore the hierarchy in your sources must match the way you include the headers.
Modifying your hierarchy in source to match the hierarchy in install space is the right approach to make it work in both cases.
Comment by msmcconnell on 2020-09-15:
Ah thanks for clearing that up. No wonder the newer tools remove the devel space.


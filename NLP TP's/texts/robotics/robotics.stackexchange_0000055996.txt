Q:

AMCL laser skipping scan

I am doing amcl on a quadrotor, as the quadrotor move along and yaw pitch roll might affect the laser scan thus the scan I received might end up confuse my amcl and get the wrong localization.
To overcome this problem, my partner has try to compensate laser scan value(within certain range) by creating this node. Let just call it LaserCompensation.
Here's some of the files.
LaserCompensation.cpp
#include <stdexcept>
#include <termios.h>
#include <string>
#include <stdlib.h>
#include <vector>
#include <stdint.h>
#include <stdint.h>
#include <limits>
#include "Rotator.cpp"
#include "sensor_msgs/LaserScan.h"
#include "../../px-ros-pkg/px_comm/msg_gen/cpp/include/px_comm/OpticalFlow.h"
#include "../../flight/msg_gen/cpp/include/flight/flightFeedback.h"
#include <ros/ros.h>
#include <cmath>
#define PI 3.141592654
double Flowtime1 ;
double FlowAltitude1;
double Flowtime2;
double FlowAltitude2;
double altitudedifference;
double timedifference;
double pitchAngle;
double rollAngle;
sensor_msgs::LaserScan receivedscan;
sensor_msgs::LaserScan publishscan;
Rotator *rotator;

void altitudeParse(const px_comm::OpticalFlow::ConstPtr& optFlowMsg)
{
    Flowtime2 = Flowtime1;
    Flowtime1 = optFlowMsg->header.stamp.toSec();
    FlowAltitude2 = FlowAltitude1;
    FlowAltitude1 = optFlowMsg->ground_distance;
    altitudedifference = FlowAltitude1-FlowAltitude2;
    timedifference = Flowtime1 - Flowtime2;
}

void angleParse(const flight::flightFeedback::ConstPtr& msg2)
{
            pitchAngle = msg2->pitchAngle;
            rollAngle = msg2->rollAngle;
}
void Transform()//sensor_msgs::LaserScan& scan_msg)
{
    
    publishscan.angle_min = -2.35619443;
    publishscan.angle_max = 2.35619443;
    publishscan.angle_increment = (1.25/180*PI);
    publishscan.time_increment = receivedscan.time_increment;
    publishscan.scan_time = receivedscan.scan_time;
    publishscan.range_min = receivedscan.range_min;
    publishscan.range_max = receivedscan.range_max;
    publishscan.header.stamp = receivedscan.header.stamp;
    publishscan.header.frame_id = "test1";
    rotator->set(rollAngle, pitchAngle);
    float x = 0.0;
    float y = 0.0;
    float z = 0.0;
    float xt = 0.0;
    float yt = 0.0;
    float zt = 0.0;
    float r = 0.0;
    float rt = 0.0;
    float indexdifference[216];
    for (int o=0;o<216;o++)
    {
       indexdifference[o]=360.0;
    }

    uint g=0;
    for(int i = 0; i < 1080; i++){
           r = receivedscan.ranges[i];
           x = r*cos(((0.25*i)-45)/180*PI);
           z = r*sin(((0.25*i)-45)/180*PI);
           rotator->unrotate(x, y ,z, xt, yt, zt);
           float d=-90.0;
           if((xt!=0.0)||(zt!=0.0))
           {
               d=atan2(zt,xt)*180.0/PI+45.0;
           }
           if(d<0.0){
               d+=360.0;
           }
           float e= (d*215/270)+0.5;
           int h = e;
           float absolutedifference= std::abs (e-h);
           rt = sqrt(zt*zt+xt*xt);
           
           if(h>=0.0)
           {
              if(absolutedifference<indexdifference[h])
              {
                 indexdifference[h]=absolutedifference;
                 publishscan.ranges[h]=rt;
               
              }
           }
           /*if(i<2 && absolutedifference<angle[0])
           {
              angle[0]=d;
              publishscan.ranges[0]=rt; 
           }
           else if(absolutedifference<angle[(i-3/5)+1] && i>2)
           {
              angle[(i-3/5)+1]=d;
              publishscan.ranges[i/5]=rt;
           }*/
    }
}

void parseScan(const sensor_msgs::LaserScan::ConstPtr& scan_msg)
{
    receivedscan.angle_min = scan_msg->angle_min;
    receivedscan.angle_max = scan_msg->angle_max;
    receivedscan.angle_increment = scan_msg->angle_increment;
    receivedscan.time_increment = scan_msg->time_increment;
    receivedscan.scan_time = scan_msg->scan_time;
    receivedscan.range_min = scan_msg->range_min;
    receivedscan.range_max = scan_msg->range_max;
    receivedscan.ranges = scan_msg->ranges;
    receivedscan.header.stamp = scan_msg->header.stamp;
    receivedscan.header.frame_id = scan_msg->header.frame_id;
    
    Transform();
}

int main(int argc, char **argv)
   {
     rotator = new Rotator();
     ros::init(argc, argv, "LaserCompensation");
     ros::NodeHandle n;
     publishscan.ranges.resize(216);
     int count = 0;
     ros::Subscriber altitude= n.subscribe( "/px4flow/opt_flow", 1, &altitudeParse );
     ros::Subscriber PitchRoll= n.subscribe( "flightFeedback", 1000, &angleParse );
     ros::Subscriber scan= n.subscribe("scan", 1, &parseScan);
     ros::Publisher Cscan = n.advertise<sensor_msgs::LaserScan>("scan2",1);
     ros::Rate loop_rate(40); //Freq = 40Hz
     while (ros::ok())
     {
        if((altitudedifference <0.05 && altitudedifference > -0.05) && timedifference < 0.5)
        {
           Cscan.publish(publishscan);
        }
        count++;
        ros::spinOnce();

     }
     delete rotator;   
     return 0;

   }

amcl_node.cpp
static const std::string scan_topic_ = "scan2";

launch file:
full.launch
  <arg name="map_file" default="$(find known_mapping)/map.yaml"/>

  <!-- Run the map server -->
  <node name="map_server" pkg="map_server" type="map_server" args="$(arg map_file)" />

    <node name="hokuyo" pkg="hokuyo_node" type="hokuyo_node" respawn="false" output="screen">
    <param name="calibrate_time" type="bool" value="true"/> 
    <!-- Set the port to connect to here -->
    <param name="port" type="string" value="/dev/ttyACM0"/> 
    <param name="intensity" type="bool" value="false"/>
    <param name="cluster" value="1"/>
    
  </node>

<node name="LaserCompensation_node" pkg="LaserCompensation" type="LaserCompensation_node" respawn="false" output="screen" />

  #### publish an example base_link -> laser transform ###########

    <node pkg="tf" type="static_transform_publisher" name="base_link_to_laser" 
    args="0.0 0.0 0.0 1.571 0.0 0.0 base_link test1 40" />

  #### start the laser scan_matcher ##############################

    <node pkg="laser_scan_matcher" type="laser_scan_matcher_node" 
    name="laser_scan_matcher_node" output="screen">
    <param name="max_iterations" value="10"/>
    <param name="publish_pose_stamped" value="true"/>
    
  </node>

   <!--- Run AMCL -->
  
   <node name="amcl" pkg="amcl" type="amcl" output ="screen">
   
   <param name="odom_model_type" value="omni"/>
   <param name="update_min_d" value="0.15"/>
   <param name="update_min_a" value="0.5"/>
   <param name="initial_pose_x" value="-13.0"/>
   <param name="initial_pose_y" value="-22.0"/>
   <param name="initial_pose_a" value="3.979"/>   
   
   </node>  

</launch>

Originally posted by FuerteNewbie on ROS Answers with karma: 123 on 2013-12-09
Post score: 0

A:

Try to add in your launch file the remap parameter in your amcl node :
   <node name="amcl" pkg="amcl" type="amcl" output ="screen">
   -> <remap from="scan" to="scan2" />
   <param name="odom_model_type" value="omni"/>

This allow amcl to use scan2 instead of scan topic.
You'll have to do the same thing in your laser_scan_matcher node.

Originally posted by Jbot with karma: 429 on 2013-12-09
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by FuerteNewbie on 2013-12-18:
You mean I have to remap scan2 for laser_scan_matcher too?
Comment by FuerteNewbie on 2014-01-01:
What do you mean by do the same thing in laser scan matcher node? Adding this line into amcl launch code and also laser scan matcher launch code?
Comment by FuerteNewbie on 2014-01-01:
Thanks a lot man it's working! Can explain the theory behind? What have remap actually done?


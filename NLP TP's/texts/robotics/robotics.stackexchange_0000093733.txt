Q:

Find_package() unable to find packages that I've created in the workspace

I've been having a weird issue where I get the following error.
  Project 'gimbal_control' tried to find library 'mav_recv'.  The library is
  neither a target nor built/installed properly.  Did you compile project
  'mav_recv'? Did you find_package() it before the subdirectory containing
  its code is included?

When the existing ROS packages i.e. roscpp / nodelet that are in the find_library() function work fine. However when I include my package such as mav_recv or gstreamer_udp, it gives me the following error. The other 2 packages that are independent, build just fine by themselves. However, this package that is reliant on mav_recv messages gives me that cmake error. It seems that the find_library() function is unable to locate my packages in the current workspace, while it does find packages in the ROS workspace (I've installed ROS from source in ros_catkin_ws).
I've included both ROS workspaces in the /.bashrc file. And ROS is able to run the gstreamer_udp and mav_recv nodes when built individually. Here is my CMakeLists.txt for mav_recv,
cmake_minimum_required(VERSION 2.8.3)
project(mav_recv)
find_package(catkin REQUIRED COMPONENTS roscpp message_generation)

add_message_files(
    FILES
    Camera_mode.msg
    Gimbal_commands.msg
)

generate_messages()

catkin_package(
    INCLUDE_DIRS include
    LIBRARIES ${PROJECT_NAME}
    CATKIN_DEPENDS roscpp message_runtime
)

include_directories(include
                    # For mavlink messages
                    /home/pi/mavlink/include/uwa_grand_challenge
                    ${catkin_INCLUDE_DIRS})

add_executable(mav_recv_node src/mav_recv_node.cpp)
add_dependencies(mav_recv_node ${${PROJECT_NAME}_EXPORTED_TARGETS})

add_library(mav_recv_lib src/mav_recv.cpp)

target_link_libraries(
    mav_recv_node
    mav_recv_lib
    ${catkin_LIBRARIES}
)

and gimbal_control CMakeLists.txt,
cmake_minimum_required(VERSION 2.8.3)
project(gimbal_control)
find_package(catkin REQUIRED COMPONENTS roscpp mav_recv)

catkin_package(
    INCLUDE_DIRS include
    LIBRARIES ${PROJECT_NAME}
    CATKIN_DEPENDS roscpp mav_recv
)
include_directories(include ${catkin_INCLUDE_DIRS})

add_executable(gimbal_control_node src/gimbal_control_node.cpp)
add_dependencies(gimbal_control_node ${catkin_EXPORTED_TARGETS})

add_library(gimbal_control_lib src/gimbal_control.cpp src/i2c_bus.cpp)
add_dependencies(gimbal_control_lib ${catkin_EXPORTED_TARGETS})

target_link_libraries(
    gimbal_control_node
    gimbal_control_lib
    ${catkin_LIBRARIES}
)

Any help would really be appreciated as I've spent a long time on trying to get it to work.
Thanks,

Originally posted by manu-adina on ROS Answers with karma: 3 on 2019-11-05
Post score: 0

A:

You have this in your CMakeLists.txt:
[..]

project(mav_recv)

[..]

catkin_package(
    [..]
    LIBRARIES ${PROJECT_NAME}
    [..]
)

[..]

add_library(mav_recv_lib src/mav_recv.cpp)

[..]

Note how you export a library target with LIBRARIES ${PROJECT_NAME} (where ${PROJECT_NAME} would be replaced with mav_recv), but then don't actually have any library target with that name.
The only library you create in this build script is mav_recv_lib.
You'll either have to change the name of the library to ${PROJECT_NAME}, or change the exported target name to mav_recv_lib.
So this should work (for mav_recv, but it would be similar for your other package):
catkin_package(
    [..]
    LIBRARIES mav_recv_lib
    [..]
)

Note that gimbal_control has the exact same problem.
You may be interested in fkie/catkin_lint which is a tool capable of parsing your package manifests and build scripts and checking them for common errors and bad practices.
Finally:

It seems that the find_library() function is unable to locate my packages in the current workspace, while it does find packages in the ROS workspace (I've installed ROS from source in ros_catkin_ws).

I've included both ROS workspaces in the /.bashrc file.

Please be aware that sourceing multiple workspaces may not do what you expect, as by default, sourceing a second workspace will overwrite the environment variables of the first. If ros_catkin_ws is actually an underlay, then it would work, but in that case there would be no need to source ros_catkin_ws, as it would be automatically sourced as part of your "current workspace".

Originally posted by gvdhoorn with karma: 86574 on 2019-11-05
This answer was ACCEPTED on the original site
Post score: 4

Original comments
Comment by manu-adina on 2019-11-05:
Thanks gvdhoorn! I've spent a lot of time trying to fix that error and couldn't even think that this part was the problem due to tutorials always having ${PROJECT_NAME} for the catkin_package libraries. I definitely need to spend more time on trying to understand CMake. Thanks again gvdhoorn!


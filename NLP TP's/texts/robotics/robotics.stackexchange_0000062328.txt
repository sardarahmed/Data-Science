Q:

yet another tf extrapolation question

This is the piece of code that I have used.
I am trying to transform a geometry_msgs::PointStamped from "base_link" to "map".
geometry_msgs::PointStamped _s , our_s;
_s.point.x = 0.929;
_s.point.y = 0.103672;
_s.point.z = 1.05381;

_s.header.frame_id = "base_link";
_s.header.stamp = ros::Time::now();

tf_l.waitForTransform("map", "base_link", _s.header.stamp, ros::Duration(1.0));
try
{
    tf_l.transformPoint("map", _s, our_s);

}
catch(tf::TransformException& ex)
{
    ROS_INFO("%s is the exception.", ex.what());
}

This is the same piece of code I always use.
I normally get the output right, but now I get:
the error
[ INFO] [1409742709.610312612]: Lookup would require extrapolation into the past.  Requested time 1409742709.104081534 but the earliest data is at time 1409742709.353810000, when looking up transform from frame [base_link] to frame [map] is the exception.

In this case: rosrun tf_echo view_frames shows the frames and they are great.
And rosrun tf tf_echo map base_link gives:
At time 1409742686.330
- Translation: [4.626, -0.504, 0.000]
- Rotation: in Quaternion [0.000, 0.000, -0.205, 0.979]
            in RPY [0.000, 0.000, -0.413]
At time 1409742687.237
- Translation: [4.626, -0.504, 0.000]
- Rotation: in Quaternion [0.000, 0.000, -0.205, 0.979]
            in RPY [0.000, 0.000, -0.413]
At time 1409742688.337
- Translation: [4.626, -0.504, 0.000]
- Rotation: in Quaternion [0.000, 0.000, -0.205, 0.979]
            in RPY [0.000, 0.000, -0.413]
At time 1409742689.247
- Translation: [4.626, -0.504, 0.000]
- Rotation: in Quaternion [0.000, 0.000, -0.205, 0.979]
            in RPY [0.000, 0.000, -0.413]
^CAt time 1409742689.664
- Translation: [4.626, -0.504, 0.000]
- Rotation: in Quaternion [0.000, 0.000, -0.205, 0.979]
            in RPY [0.000, 0.000, -0.413]

I have gone through a lot of questions. I still understand this problem correctly.
Any help is greatly appreciated.
Thank you so much.

Originally posted by McMurdo on ROS Answers with karma: 1247 on 2014-09-03
Post score: 0

Original comments
Comment by bvbdort on 2014-09-03:
What is the frequency of tf between [base_link] to  [map] , may be its less than your waiting time 1 second.
Comment by McMurdo on 2014-09-03:
I get the same result if the duration is increased to 3 seconds

A:

waitForTransform has a boolean return type that indicates success or failure. If it returns false, you reached your timeout period, and something is likely not right about your transforms. Do something like this:
if(tf_l.waitForTransform("map", "base_link", _s.header.stamp, ros::Duration(1.0)))
{
  try
  {
      tf_l.transformPoint("map", _s, our_s);
  }
  catch(tf::TransformException& ex)
  {
      ROS_INFO("%s is the exception.", ex.what());
  }
}
else
{
  ROS_INFO("No transform available!");
}

The way you have it written, it's going to attempt the transform whether waitForTransform succeeds or not.
EDIT: Also, what is producing the map to base_link transform? Is it on the same machine? What time stamp value is being used for the transform when it gets broadcast?

Originally posted by Tom Moore with karma: 13689 on 2014-09-03
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by McMurdo on 2014-09-11:
Part 1 of your answer is probably the right answer. Thanks!
The odometry/laser and navigation modules are connected to ROS from a proprietary software. This bridge is what publishes the transform from map to base_link. I am sure it is published properly... But something is happening here.
Comment by McMurdo on 2014-09-11:
contd. probably a bug in the implementation of this bridge itself. I solved the issue by doing this:

Get the transform as a tf::StampedTransform using lookupTransform()
Use tf::Vector3 and do simple multiplication.

Comment by Mehdi. on 2015-04-21:
my program crashes at waitForTransform already saying tf tries to extrapolate into the Future/Past! this doesn't make any sense...


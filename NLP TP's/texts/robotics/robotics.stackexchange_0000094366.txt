Q:

Service Server and Client not working when launch by launch file

Hello all.
I am using a pandas data frame to format instructions and the data frame is hosted in a service server. I then have a client that is imported into a position supervising node. The client is a member of the position supervisor class which obviously will pull then next instruction on command.
If I run the parameter setup scripts and then rosrun each of these nodes then everything works as expected. However, I built a launch file and now every time the client is triggered to pull an instruction I get an error saying that the client is receiving a null response from the server.
Error:
[ERROR] [1578864176.167369]: Error processing request: local variable 'resp' referenced before assignment
['Traceback (most recent call last):\n', '  File "/opt/ros/melodic/lib/python2.7/dist-packages/rospy/impl/tcpros_service.py", line 629, in _handle_request\n    response = convert_return_to_response(self.handler(request), self.response_class)\n', '  File "/home/mhyde/arm_cws/src/arm_data_frame/src/nodes/dataFrameServer.py", line 66, in handleRequest\n    return resp\n', "UnboundLocalError: local variable 'resp' referenced before assignment\n"]
[ERROR] [1578864176.177881]: bad callback: <bound method positionSupervisor.arduinoStateCallback of <__main__.positionSupervisor object at 0x7fbb19878650>>
Traceback (most recent call last):
  File "/opt/ros/melodic/lib/python2.7/dist-packages/rospy/topics.py", line 750, in _invoke_callback
    cb(msg)
  File "/home/mhyde/arm_cws/src/position_supervisor/src/nodes/positionSupervisor.py", line 99, in arduinoStateCallback
    self.pullInstruction()
  File "/home/mhyde/arm_cws/src/position_supervisor/src/nodes/positionSupervisor.py", line 52, in pullInstruction
    self.instruction = self.instructionClient.client()
  File "/home/mhyde/arm_cws/src/arm_data_frame/src/arm_data_frame/dataFrameClient.py", line 52, in client
    return coor.motionType, coor.xCoor, coor.yCoor, coor.zCoor, coor.velFac, coor.accFac
AttributeError: 'NoneType' object has no attribute 'motionType'

Again, if I rosrun the dataFrameServer and the positionSupervisor and then manually publish to /arduinoState then everything works perfectly. I only get this error if I launch the dataFrame and Supervisor in a launch file.
Launch File:
<launch>
    <node name="dataFrameServer" pkg="arm_data_frame" type="dataFrameServer.py" />
    <node name="positionSupervisorParams" pkg="position_supervisor" type="positionSupervisorParams.py" />
    <node name="positionSupervisor" pkg="position_supervisor" type="positionSupervisor.py" />
</launch>

I did try removing nodes from the launch file and it appears the issue is coming from including the position supervisor in the launch file. When I remove it, run the launch file, and then rosrun the positionSupervisor then everything works well.
Below is the code for everything involved. I don't think the param files are casuing the issues.
Server:
#!/home/mhyde/vEnvs/rosPy/bin/python

'''
ROS Service - Server:

Feeds Coors from the CSV File to
the Data Handler upon service request.

Implements a Pandas DataFrame to contain
Coor information as well as actuator
and motion commands.
'''

import rospy
from arm_msgs.srv import instructionPass, \
    instructionPassResponse
from pandas import DataFrame, read_csv

class server(object):
    '''
    Coor Distributor

    topic =  /instructionPass
    node  =  /instructionPassServer
    '''

    def __init__(self, filePath):
        self.roboRoutine = DataFrame(read_csv(filePath, sep=","))
        self.index = 0
        self.instructionCount = 0

    def countInstructions(self):
        '''
        Counts the amount of Coors
        in routine
        '''
        self.instructionCount = self.roboRoutine.shape[0]

    def checkIndex(self):
        '''
        Checks the current index after each service
        and sets the index back to 0 to start
        the routine over again
        '''
        print 'Index: %d' % self.index
        if self.index < self.instructionCount - 1:
            self.index += 1
        else:
            self.index = 0

    def handleRequest(self, req):
        '''
        Service Handle Function:

        Requeset Message Type - Boolean
        Any message from the client will trigger the function
        '''
        if req.request == True:
            resp = instructionPassResponse()
            resp.motionType, resp.xCoor, resp.yCoor, resp.zCoor, resp.velFac, resp.accFac = self.roboRoutine.values[
                self.index, :]

            self.checkIndex()

        return resp

    def runServer(self):
        '''
        Single method callable function.
        Starts the ROS Server as long as
        it is called in an initiated node
        '''
        self.countInstructions()
        rospy.Service('instructionPass', instructionPass, self.handleRequest)
        rospy.spin()

if __name__ == '__main__':
    try:
        print 'Server Running ... '
        rospy.init_node('dataFrameServer')
        serv = server(
            "~/arm_cws/src/arm_data_frame/data/testCoordinates.csv")
        serv.runServer()
    except rospy.ROSInterruptException():
        pass

Client:
#!/home/mhyde/vEnvs/rosPy/bin/python

'''
ROS Service - Client:

Requests coordinates from the CSV File
to the Data Distributer upon service request.

'''

import sys
import rospy
from arm_msgs.srv import instructionPass

class dataFrameClient(object):
    '''
    Actual Client for the /instructionPass Service.
    Perpetually pulls coordinates from the dataFrame
    and feeds them to the motorPosePublisher
    '''

    def requestCoordinate(self, request):
        '''
        Function Docstring
        '''
        rospy.wait_for_service('instructionPass')
        try:
            srvReq = rospy.ServiceProxy('instructionPass', instructionPass)
            resp = srvReq(request)
            return resp
        except rospy.ServiceException, error:
            rospy.loginfo('Service Call Failed: %s' % error)

    def usage(self):
        '''
        Simple Error Check in Client Request
        '''
        return '%s [req]' % sys.argv[0]

    def client(self):
        '''
        Client Implementation
        '''
        req = False
        if len(sys.argv) == 1:
            req = True
        else:
            print self.usage()
        print "Requesting Coordinate ... "
        coor = self.requestCoordinate(req)
        return coor.motionType, coor.xCoor, coor.yCoor, coor.zCoor, coor.velFac, coor.accFac

if __name__ == '__main__':
    client = dataFrameClient()
    print client.client()

Position Supervisor Node:
#!/home/mhyde/vEnvs/rosPy/bin/python

'''
node = /motorPosePub
pubTopic = /motorPoseSteps
subTopic = /arduinoState

Listens to arduino for ready state then implements
other methods to pull and convert the next coordinate
into the respective arm angles and steps.
'''

import rospy
from std_msgs.msg import Empty
from arm_msgs.msg import motorSteps
from arm_msgs.msg import motorAngles
from arm_data_frame.dataFrameClient import dataFrameClient
from position_supervisor.geometryUtil import geometryUtil

class positionSupervisor(object):
    '''
    Pulls coordinates from the distributer and updates
    the current desired position for the arduino node.
    '''

    def __init__(self):

        self.instruction = []

        self.instructionClient = dataFrameClient()
        self.geometryUtil = geometryUtil()

        self.stepMsg = motorSteps()
        self.angleMsg = motorAngles()

        self.stateSub = rospy.Subscriber(
            'arduinoState', Empty, callback=self.arduinoStateCallback)
        self.anglePub = rospy.Publisher(
            'motorPoseAngles', motorAngles, queue_size=10)
        self.stepPub = rospy.Publisher(
            'motorPoseSteps', motorSteps, queue_size=10)

        rospy.spin()

    def pullInstruction(self):
        '''
        Pulls the next instruction from the data frame
        and appends it to a class member for other functions
        to access.
        '''
        self.instruction = self.instructionClient.client()

    def setMotionType(self):
        '''
        Updates ROS motionType param to define the current
        robot motion mode.
        '''
        rospy.set_param('motionType', self.instruction[0])

    def updatePV(self):
        '''
        Updates the coordinates of the position vector
        for motor angle and step calculations.
        '''
        self.geometryUtil.vector.xCoor = self.instruction[1]
        self.geometryUtil.vector.yCoor = self.instruction[2]
        self.geometryUtil.vector.zCoor = self.instruction[3]

    def setVelAcc(self):
        '''
        Sets ROS params which scale the velocity and
        acceleration of the motors. This number is a
        percentage of the default (max) value.
        '''
        rospy.set_param('velocityFactor', self.instruction[4])
        rospy.set_param('accelerationFactor', self.instruction[5])

    def defineAngles(self):
        '''
        Uses geometryUtil to return the equivalent
        angles of each motor
        '''
        self.angleMsg.baseAngle, self.angleMsg.mainAngle, self.angleMsg.secAngle, \
            self.angleMsg.toolAngle = self.geometryUtil.returnAngles()

    def defineSteps(self):
        '''
        Uses geometryUtil to return the equivalent
        steps of each motor
        '''
        self.stepMsg.baseStep, self.stepMsg.mainStep, self.stepMsg.secStep, \
            self.stepMsg.toolStep = self.geometryUtil.returnSteps()

    def arduinoStateCallback(self, arduinoState):
        '''
        Updates coordinate when Arduino is ready.
        '''
        self.pullInstruction()
        self.setMotionType()
        self.updatePV()
        self.setVelAcc()
        self.defineSteps()
        self.defineAngles()
        self.publish()

    def publish(self):
        '''
        Publishes the steps to the motorPoseSteps topic
        for the arduino to read.
        '''
        self.stepPub.publish(self.stepMsg)
        rospy.loginfo(self.stepMsg)
        self.anglePub.publish(self.angleMsg)
        rospy.loginfo(self.angleMsg)

if __name__ == '__main__':
    rospy.init_node('positionSupervisor', anonymous=True)
    positionSupervisor()

I did see a similar problem on the ROS forums that was caused by naming issues but I can't see that as an issue here. If anyone has any suggestions for solving the issue or if you need me to revise my question for clarity please let me know. Thank you for any input!

Originally posted by mhyde64 on ROS Answers with karma: 18 on 2020-01-12
Post score: 0

A:

The problem was in :
def client(self):
        '''
        Client Implementation
        '''
        req = False
        if len(sys.argv) == 1:
            req = True
        else:
            print self.usage()
        print "Requesting Coordinate ... "
        coor = self.requestCoordinate(req)
        return coor.motionType, coor.xCoor, coor.yCoor, coor.zCoor, coor.velFac, coor.accFac

Apparently len(sys.argv) did not equal 1. I should have realized the error message I was receiving was the one that was included in the code. That's what I get for not fully understanding code before I use it.

Originally posted by mhyde64 with karma: 18 on 2020-01-13
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by gvdhoorn on 2020-01-14:
I've marked your answer to be the accepted answer, as it would seem to be the actual cause of the problem you reported.


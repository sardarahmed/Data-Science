Q:

Is there a standard way to store state to build messages from separate submessages published on different topics at different times?

Say message A depends on information from independently published messages B and C, posted on separate topics at different rates (example, a dilution of precision measurement and a position measurement from a gps sensor are combined to produce a NavSatFix message with both the position and the calculated accuracy of that position).  This implies that either message B or message C must be stored and re-accessed after it is published and received in order to compose and publish message A.
Is there a standard way in ROS to handle situations like this?w Topics are a Pub/Sub event model that relies on fire and forget to be performant. Services are supposed to perform as transformation functions over their inputs without storing intermediate values and would make sense to do the job of transforming message B and C into message A after being passed B and C. However, B and C arrive independently.
tf appears to have a means of performing timed polling of a message on its topic. Is this capability built into all topics? Additionally, I'd like to access only the "latest" message rather than a message at a specific time point in the past. That ability does not seem to be built into tf, and so I would assume it isn't in other topic/msg based interfaces either.
I considered using rosbag, but I would prefer to not rely on storing items on the filesystem if possible, and it too appears to be able to only read messages at a specifed time, rather than the latest available message.
As a last resort, I have constructed my own message cache using a ring buffer and numpy arrays to store the messages. I'd prefer a standard solution if it exists.

Originally posted by jackcviers on ROS Answers with karma: 207 on 2014-08-04
Post score: 0

Original comments
Comment by Mehdi. on 2014-08-04:
I think your method is the best solution, a class with two methods (callbackB and callbackC) subscribing to B and C and two attributes (msgB, msgC)  containing the latest message contents from B and C. Whenever one of the methods is called, it updates the attributes content and rebuilds a new message A and publishes it.
Comment by jackcviers on 2014-08-04:
Yes, the cache is separate from the Transformation_Publisher. The cache is exposed as a service. The Transformation_Publisher subscribes to the necessary topics, it caches the values using the cache service, requests the latest value, then publishes the combined message.

A:

If you want to cache messages, use a message_filters::Cache.
However, this seems overkill for only storing one message. Also I'm not sure why you need a ring buffer and numpy arrays for that.
Just do last_message_a = msg in the respective callbacks and store those somewhere globally.

Originally posted by dornhege with karma: 31395 on 2014-08-05
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by jackcviers on 2014-08-06:
My real life scenario invloves messages from multiple recievers in multiple frames - it was easier to describe using one, sorry. The ring buffers allow or cacheing by topic and frame id. Latest is the latest for a matching frame, in this case.
Comment by jackcviers on 2014-08-07:
However, this api is very similar to what I have implemented. If this is a chain of transformations over a series of events, it might work as needed. The slop ability should make it possible to get all msgs, then filter by frames.


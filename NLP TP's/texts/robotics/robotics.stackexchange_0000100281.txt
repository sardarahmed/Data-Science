Q:

sensor_msgs/LaserScan.msg ==> range_max should be discarded

Hi all,
I have been dealing with slam_gmapping package and I have reached good results so far.(I created my map by the package) But I have a question about sensor_msgs/LaserScan.msg specifically. For describing my problem a lot faster, I want you to look at the picture below. In the picture, you can see my /scan topic and a view of Rviz. When you look at the /scan topic, I selected some of those ranges data where start off with the value of 65.53399. You can clearly see the relevant points in the Rviz screen too since they are far away from average measurements. As I pass such scan data into slam_gmapping package, the map is not created well.
I believe that the value of 65.53399 in the /scan topic is used for failed scan data or something like that. I should not take these measurements account in the context of creating a map. But how? In the LaserScan.msg there is an explanation goes like that:

float32[] ranges         # range data
[m] (Note: values < range_min or >
range_max should be discarded)

What I should understand of discarding data in the ranges std::vector? What value I should give for such failed/max data instead of leaving them as they are? Any idea or useful links? Thank you all in advance!

Originally posted by serhat on ROS Answers with karma: 72 on 2021-10-12
Post score: 0

A:

I believe this is covered by REP-117: Informational Distance Measurements.
Specifically (I've changed the formatting slightly):

Specification
For any sensor measurement that reports physical distance (see Range, LaserScan, PointCloud2), three special conditions will be well-defined. These readings shall be:

detection too close to determine true distance but not cause an erroneous measurement
an erroneous measurement that has no useful physical quantification; and
no information within the useful range of the sensor but likely no object within range.

Detections that are too close to the sensor to quantify shall be represented by -Inf. Erroneous detections shall be represented by quiet (non-signaling) NaNs. Finally, out of range detections will be represented by +Inf.

I would suggest you update your lidar driver to follow this convention.
Consumers should then be able to correctly interpret your LaserScans.

I write the scan program by myself. I don't use any launch file or library.

this confuses me a little. The screenshot you show seems to imply you're using a Hokuyo scanner. Those have traditionally been very well supported in ROS, and the drivers should already conform to REP-117. Can you not use those?

Originally posted by gvdhoorn with karma: 86574 on 2021-10-12
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by serhat on 2021-10-12:
Hi gvdhoorn, thank you for your reply. I will work on the links you shared to improve my program. I appreciate.
I use this sensor(HOKUYO UAM-05LP). I will check some hokuyo laser scanner libraries/drivers such as http://wiki.ros.org/hokuyo_node in order to check I can use these drivers or not for my sensor. If I can use them properly, I'd switch to use them quickly instead of my own program.
Comment by serhat on 2021-10-13:
Hi all, I did an amendment according to this documentation(REP-117: Informational Distance Measurements) in my program. I added a if-statement like below. This solved my problem, I am able to use this scan_data to create a quality map with slam_gmapping package now. I guess, slam_gmapping package recognizes the value of -Inf,+Inf, and NaNs in the ranges vector in the /scan_topic. And handles all data by itself according to SLAM algorithm that it uses.
for (size_t i = 0; i < 1081; i++)
{
   float scan_item = scan_data[i] /1000.0  ;  
   if(scan_item == 65.53399658203125)
       laser_example.ranges.push_back( +INFINITY) ; 
   else
       laser_example.ranges.push_back( scan_item) ; 
}


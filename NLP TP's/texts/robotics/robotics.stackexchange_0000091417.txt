Q:

Error "Call to publish() on an invalid Publisher" using ApproximateTime Policy

Hi everyone, I try to use the ApproximateTime Policy-Based Synchronizer to get the force and position data from a force sensor and NDI, the code is show here which imitated from #q297174, in this code, I try to use geometry_msgs::TransformStamped to get force and position data in one topic and publish it in callback, but it reported a mistake when the code run. then I try to publish the topic of force and position separately. it still fail under same mistake:
[ INFO] [1555644883.009164946]: Synchronization successful [10.000000]
[FATAL] [1555644883.009201476]: ASSERTION FAILED
    file = /opt/ros/indigo/include/ros/publisher.h
    line = 102
    cond = false
    message = 
[FATAL] [1555644883.009213278]: Call to publish() on an invalid Publisher
[FATAL] [1555644883.009220410]: 

Trace/breakpoint trap (core dumped)

[ INFO] [1555646329.618371967]: Synchronization successful [10.000000]
[FATAL] [1555646329.618447480]: ASSERTION FAILED
    file = /opt/ros/indigo/include/ros/publisher.h
    line = 69
    cond = false
    message = 
[FATAL] [1555646329.618476584]: Call to publish() on an invalid Publisher
[FATAL] [1555646329.618495410]: 

Trace/breakpoint trap (core dumped)

and the code is show here:
#include "ros/ros.h"
#include <sstream>
#include <iostream>
#include <fstream>
#include <string>
#include <stdio.h>
#include <message_filters/subscriber.h>
#include <message_filters/synchronizer.h>
#include <message_filters/sync_policies/approximate_time.h>
#include <geometry_msgs/TransformStamped.h>
#include <tf2/LinearMath/Quaternion.h>
#include <tf2_ros/transform_broadcaster.h>
#include <geometry_msgs/WrenchStamped.h>       
#include <geometry_msgs/PoseArray.h>  
#include "std_msgs/Float64.h"

using namespace message_filters;
//tf2_ros::TransformBroadcaster tf2_broadcaster;
geometry_msgs::TransformStamped transformStamped;

//ros::Publisher sensor_pub;
ros::Publisher sensor_pub1;
ros::Publisher sensor_pub2;

void callback(const geometry_msgs::WrenchStampedConstPtr& netft_data_msg, const geometry_msgs::PoseArrayConstPtr& targets);  

int main(int argc, char** argv)
{
  ros::init(argc, argv, "get_all_sensor_in_one");

  ros::NodeHandle nh;

  //ros::Publisher sensor_pub = nh.advertise<geometry_msgs::TransformStamped>("/sensor_together", 1000);
  ros::Publisher sensor_pub1 = nh.advertise<geometry_msgs::WrenchStamped>("/sensor_ati", 1000);
  ros::Publisher sensor_pub2 = nh.advertise<geometry_msgs::PoseArray>("/sensor_ndi", 1000);

  message_filters::Subscriber<geometry_msgs::WrenchStamped> force_sub(nh, "/netft_data", 1);    
  message_filters::Subscriber<geometry_msgs::PoseArray> pose_sub(nh, "/polaris_sensor/targets", 1);    
  //message_filters::TimeSynchronizer<geometry_msgs::WrenchStamped, geometry_msgs::PoseArray> sync(force_sub, pose_sub, 2);       
  typedef sync_policies::ApproximateTime<geometry_msgs::WrenchStamped, geometry_msgs::PoseArray> MySyncPolicy;
  // ApproximateTime takes a queue size as its constructor argument, hence MySyncPolicy(10)
  Synchronizer<MySyncPolicy> sync(MySyncPolicy(10), force_sub, pose_sub);
  sync.registerCallback(boost::bind(&callback, _1, _2));                   

  // sensor_pub.publish(sync);

  ros::spin();

  return 0;
}

void callback(const geometry_msgs::WrenchStampedConstPtr& netft_data_msg, const geometry_msgs::PoseArrayConstPtr& targets)  
{

  // static tf2_ros::TransformBroadcaster tf2_broadcaster;
  // geometry_msgs::TransformStamped transformStamped;

  transformStamped.header.stamp = ros::Time::now();
  transformStamped.header.frame_id = "ts_frame";
  transformStamped.child_frame_id = "prism_frame";
  transformStamped.transform.translation.x = targets->poses[0].position.x;
  transformStamped.transform.translation.y = targets->poses[0].position.y;
  transformStamped.transform.translation.z = targets->poses[0].position.z;
  tf2::Quaternion q;
  transformStamped.transform.rotation.x = netft_data_msg->wrench.force.x;
  transformStamped.transform.rotation.y = netft_data_msg->wrench.force.y;
  transformStamped.transform.rotation.z = netft_data_msg->wrench.force.z;
  transformStamped.transform.rotation.w = targets->poses[0].orientation.w;

  //tf2_broadcaster.sendTransform(transformStamped);

  ROS_INFO("Synchronization successful [%f]", 10.00);//transformStamped.transform.rotation.z

  //sensor_pub.publish(transformStamped);
  sensor_pub1.publish(netft_data_msg);
  sensor_pub2.publish(targets);
}

I edit the code and read the data without using the publisher:
#include "ros/ros.h"
#include <sstream>
#include <iostream>
#include <fstream>
#include <string>
#include <stdio.h>
#include <message_filters/subscriber.h>
#include <message_filters/synchronizer.h>
#include <message_filters/sync_policies/approximate_time.h>
#include <geometry_msgs/TransformStamped.h>
#include <tf2/LinearMath/Quaternion.h>
#include <tf2_ros/transform_broadcaster.h>
#include <geometry_msgs/WrenchStamped.h>       
#include <geometry_msgs/PoseArray.h>  
#include "std_msgs/Float64.h"

using namespace message_filters;

geometry_msgs::TransformStamped transformStamped;

void callback(const geometry_msgs::WrenchStampedConstPtr& netft_data_msg, const geometry_msgs::PoseArrayConstPtr& targets); 

int main(int argc, char** argv)
{
  ros::init(argc, argv, "get_all_sensor_in_one");

  ros::NodeHandle nh;

  message_filters::Subscriber<geometry_msgs::WrenchStamped> force_sub(nh, "/netft_data", 1);  
  message_filters::Subscriber<geometry_msgs::PoseArray> pose_sub(nh, "/polaris_sensor/targets", 1);    
  typedef sync_policies::ApproximateTime<geometry_msgs::WrenchStamped, geometry_msgs::PoseArray> MySyncPolicy;
  Synchronizer<MySyncPolicy> sync(MySyncPolicy(10), force_sub, pose_sub);
  sync.registerCallback(boost::bind(&callback, _1, _2));                 

  ros::spin();

  return 0;
}

void callback(const geometry_msgs::WrenchStampedConstPtr& netft_data_msg, const geometry_msgs::PoseArrayConstPtr& targets)  
{
  transformStamped.header.stamp = ros::Time::now();
  transformStamped.header.frame_id = "ts_frame";
  transformStamped.child_frame_id = "prism_frame";
  transformStamped.transform.translation.x = targets->poses[0].position.x;
  transformStamped.transform.translation.y = targets->poses[0].position.y;
  transformStamped.transform.translation.z = targets->poses[0].position.z;
  tf2::Quaternion q;
  transformStamped.transform.rotation.x = netft_data_msg->wrench.force.x;
  transformStamped.transform.rotation.y = netft_data_msg->wrench.force.y;
  transformStamped.transform.rotation.z = netft_data_msg->wrench.force.z;
  transformStamped.transform.rotation.w = targets->poses[0].orientation.w;

  ROS_INFO("Synchronization successful [%f]", transformStamped.transform.rotation.z);//transformStamped.transform.rotation.z

}

Originally posted by RLoad on ROS Answers with karma: 13 on 2019-04-18
Post score: 0

A:

We see this in your code:
//ros::Publisher sensor_pub;
ros::Publisher sensor_pub1;
ros::Publisher sensor_pub2;

[..]

int main(int argc, char** argv)
{
  [..]

  ros::Publisher sensor_pub1 = nh.advertise<geometry_msgs::WrenchStamped>("/sensor_ati", 1000);
  ros::Publisher sensor_pub2 = nh.advertise<geometry_msgs::PoseArray>("/sensor_ndi", 1000);

  [..]
}

The issue here is that you first declare two variables in the global scope, but then never initialise them.
This is because the two lines in main(..) that advertise(..) the topics assign the result of NodeHandle::advertise<..>(..) to two function scope variables with the same name, causing sensor_pub1 and sensor_pub2 in the global scope to never be initialised.
Your callback(..) in the end tries to call publish(..) on the uninitialised Publisher, leading to the error you show (and which probably makes sense now: Call to publish() on an invalid Publisher).

Originally posted by gvdhoorn with karma: 86574 on 2019-04-19
This answer was ACCEPTED on the original site
Post score: 4

Original comments
Comment by gvdhoorn on 2019-04-19:
Please note that this is a C++ issue. Not a ROS problem.
Comment by RLoad on 2019-04-19:
thanks for your help, and I'm not very good at C++, I will learn more about it. now I try to directly read the data in callback and not use publisher, it works and I can get the data after Synchronize.
Comment by RLoad on 2019-04-19:
the reason I use publisher is that I want record the data after synchronizing, and now ( I re-edit the code) the use of ROS_INFO let can see the one line data of geometry_msgs::TransformStamped. but now I wonder if there are some better way to record the data in callback? Did ROS provide some good tools for these or I need use some C++ ways to record the data in geometry_msgs::TransformStamped ?
Thank you again!
Comment by ahendrix on 2019-04-19:
You should change
ros::Publisher sensor_pub1 = nh.advertise<geometry_msgs::WrenchStamped>("/sensor_ati", 1000);
ros::Publisher sensor_pub2 = nh.advertise<geometry_msgs::PoseArray>("/sensor_ndi", 1000);

to
sensor_pub1 = nh.advertise<geometry_msgs::WrenchStamped>("/sensor_ati", 1000);
sensor_pub2 = nh.advertise<geometry_msgs::PoseArray>("/sensor_ndi", 1000);

so that you use global variable instead of creating new local variable.
Comment by RLoad on 2019-04-22:
I change my code as your advice, it works! thank you very much!


Q:

How to synchronize tfMessage and Image messages?

Hi there,
I tried to use message_filters in order to synchronize a tfMessage and an Image messages in code like this:
 message_filters::Subscriber<Image> image_sub;
 message_filters::Subscriber<tf::tfMessage> tf_sub;
 tf_sub.subscribe(nh_, "/tf", 1);
 image_sub.subscribe(nh_, "image", 1);
 TimeSynchronizer <Image, tf::tfMessage> sync(image_sub, tf_sub, 10);

Unfortunately it turns out that the compilation fails because the tfMessage has no Header block. Here is the error message:
"""
/opt/ros/diamondback/stacks/ros_comm/utilities/message_filters/include/message_filters/sync_policies/exact_time.h:126: error: ‘value’ is not a member of ‘ros::message_traits::TimeStamp<tf::tfMessage_std::allocator<void >, void>’
"""
Would anyone know of an alternative to what I am trying to achieve above? Does tf_listener maybe support an option of returning the whole TF tree (tfMessage)?
thx and best, D.

Originally posted by dejanpan on ROS Answers with karma: 1420 on 2011-03-02
Post score: 2

Original comments
Comment by tfoote on 2011-03-02:
Could you update your question to be a little more specific about what you want to do overall?  You're right that this won't synchronize due to the lack of the header.  And even if it did, sampling the tf topic at any given time will not provide you with what I think you want.

A:

Hey Dejan,
I found this solution to work for synchronizing point clouds and tf frames.
I didn't try with Images but I don't see why the synchronization mechanism would be different.
Note that I need to indicate the frame on which I synchronize (map in my case).
class PointReader
{    
    //Variables
    tf::TransformListener tf_;
    tf::MessageFilter<sensor_msgs::PointCloud2> * tf_filter_;
    message_filters::Subscriber<sensor_msgs::PointCloud2> cloud2_sub_;
    
    //initialisation
    cloud2_sub_.subscribe(n, "/kinect/rgb/points2", 10);
    tf_filter_ = new tf::MessageFilter<sensor_msgs::PointCloud2>(cloud2_sub_, tf_, "/map", 10);
    tf_filter_->registerCallback( boost::bind(&PointReader::pointCloudCallback, this, _1) );
    
    //callback
    void pointCloudCallback(const sensor_msgs::PointCloud2::ConstPtr& sensor_msg)
    {
        ROS_INFO("Message received");
        cloud_ = sensor_msg;
        pcl::fromROSMsg (*cloud_, original_pcl_cloud_);
        pcl::transformPointCloud("/map", original_pcl_cloud_, transformed_pcl_cloud_, tf_);
        ROS_INFO("Message passed");
        //transformed_pcl_cloud_ contains the projected cloud       
    }
}

Hope it helps
Raph

Originally posted by raphael favier with karma: 1382 on 2011-03-03
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by Patrick Mihelich on 2011-04-13:
Note that for images, you should use a image_transport::SubscriberFilter instead of a message_filters::Subscriber<sensor_msgs::Image>, which gives you all the advantages of image_transport. http://www.ros.org/wiki/image_geometry/Tutorials/ProjectTfFrameToImage shows another way of doing this.


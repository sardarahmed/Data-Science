Q:

decompress jpeg depth data

OS: Ubuntu 16.04 LTS
ROS distro: kinetic

Hey,
I am using an old Microsoft Kienct camera and freenect for publishing the data.
Subscribing to the topic "/camera/depth_registered/image_raw/compressed", the format of the recieved message of type CompressedImage is 16UC1; jpeg compressed.
Question: How can I decompress the jpeg data to get my 16UC1 encoded depth data? It doesn't matter if ropsy or roscpp.
EDIT:
I tried using image_transport. It works when subscribing to a topic with message type /Image, like /camera/depth_registered/image_raw/. Subscribing to a message of type /CompressedImage leads to a compiler error when running catkin_make.
My node:
#include <ros/ros.h>
#include <sensor_msgs/Image.h>
#include <sensor_msgs/CompressedImage.h>
#include <image_transport/image_transport.h>

void depthCallback(const sensor_msgs::CompressedImage::ConstPtr& msg)
  {
  sensor_msgs::CompressedImage image;
  image.data = msg->data;
  image.format = msg->format;
  int length = image.data.size();
  ROS_INFO("Data:[%i]", length);
  }

int main(int argc, char **argv)
  {
  ros::init(argc, argv, "depth");
  ros::NodeHandle nh;
  image_transport::ImageTransport it(nh);
  image_transport::Subscriber sub = it.subscribe("/camera/depth_registered/image_raw/compressed", 1, depthCallback);
  ros::spin();

  return 0;
  }

the error message when compiling:
gtcc1@gtcc1-Latitude-E5520:~/catkin_gunnar_ws$ catkin_make
Base path: /home/gtcc1/catkin_gunnar_ws
Source space: /home/gtcc1/catkin_gunnar_ws/src
Build space: /home/gtcc1/catkin_gunnar_ws/build
Devel space: /home/gtcc1/catkin_gunnar_ws/devel
Install space: /home/gtcc1/catkin_gunnar_ws/install
####
#### Running command: "make cmake_check_build_system" in "/home/gtcc1/catkin_gunnar_ws/build"
####
####
#### Running command: "make -j4 -l4" in "/home/gtcc1/catkin_gunnar_ws/build"
####
Scanning dependencies of target depth
[ 50%] Building CXX object depth_node/CMakeFiles/depth.dir/src/depth.cpp.o
In file included from /usr/include/boost/function/detail/maybe_include.hpp:18:0,
                 from /usr/include/boost/function/detail/function_iterate.hpp:14,
                 from /usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp:52,
                 from /usr/include/boost/function.hpp:64,
                 from /opt/ros/kinetic/include/ros/forwards.h:40,
                 from /opt/ros/kinetic/include/ros/common.h:37,
                 from /opt/ros/kinetic/include/ros/ros.h:43,
                 from /home/gtcc1/catkin_gunnar_ws/src/depth_node/src/depth.cpp:1:
/usr/include/boost/function/function_template.hpp: In instantiation of ‘static void boost::detail::function::void_function_invoker1<FunctionPtr, R, T0>::invoke(boost::detail::function::function_buffer&, T0) [with FunctionPtr = void (*)(const boost::shared_ptr<const sensor_msgs::CompressedImage_<std::allocator<void> > >&); R = void; T0 = const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&]’:
/usr/include/boost/function/function_template.hpp:940:38:   required from ‘void boost::function1<R, T1>::assign_to(Functor) [with Functor = void (*)(const boost::shared_ptr<const sensor_msgs::CompressedImage_<std::allocator<void> > >&); R = void; T0 = const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&]’
/usr/include/boost/function/function_template.hpp:728:7:   required from ‘boost::function1<R, T1>::function1(Functor, typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type) [with Functor = void (*)(const boost::shared_ptr<const sensor_msgs::CompressedImage_<std::allocator<void> > >&); R = void; T0 = const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&; typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type = int]’
/usr/include/boost/function/function_template.hpp:1077:16:   required from ‘boost::function<R(T0)>::function(Functor, typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type) [with Functor = void (*)(const boost::shared_ptr<const sensor_msgs::CompressedImage_<std::allocator<void> > >&); R = void; T0 = const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&; typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type = int]’
/home/gtcc1/catkin_gunnar_ws/src/depth_node/src/depth.cpp:27:115:   required from here
/usr/include/boost/function/function_template.hpp:118:11: error: invalid initialization of reference of type ‘const boost::shared_ptr<const sensor_msgs::CompressedImage_<std::allocator<void> > >&’ from expression of type ‘const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >’
           BOOST_FUNCTION_RETURN(f(BOOST_FUNCTION_ARGS));
           ^
depth_node/CMakeFiles/depth.dir/build.make:62: die Regel für Ziel „depth_node/CMakeFiles/depth.dir/src/depth.cpp.o“ scheiterte
make[2]: *** [depth_node/CMakeFiles/depth.dir/src/depth.cpp.o] Fehler 1
CMakeFiles/Makefile2:1254: die Regel für Ziel „depth_node/CMakeFiles/depth.dir/all“ scheiterte
make[1]: *** [depth_node/CMakeFiles/depth.dir/all] Fehler 2
Makefile:138: die Regel für Ziel „all“ scheiterte
make: *** [all] Fehler 2
Invoking "make -j4 -l4" failed

Originally posted by Ferguth on ROS Answers with karma: 3 on 2019-02-07
Post score: 0

Original comments
Comment by gvdhoorn on 2019-02-07:
Does image_transport not work for you?
Comment by Ferguth on 2019-02-07:
Thanks for the response, I updated my post.
Comment by gvdhoorn on 2019-02-07:
You should not subscribe to the compressed topics. image_transport will take care of all that for you. Please refer to the tutorials.

A:

The image_transport package is designed to take care of the decompression / compression for you automatically. If you subscribe to the base image topic as shown below and give it the hint to check for a compressed version then it will automatically find and decompress the compressed image topic for you.
image_transport::ImageTransport it(n);
itSub = it.subscribe("<base_topic>",1,callbackFn,image_transport::TransportHints("compressed"));

This way it will work even if there isn't a compressed version of the topic, but will automatically extract the compressed topic if it exists.

Originally posted by PeteBlackerThe3rd with karma: 9529 on 2019-02-07
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by Ferguth on 2019-02-07:
Thank you, subscribing to the compressed topic was wrong.


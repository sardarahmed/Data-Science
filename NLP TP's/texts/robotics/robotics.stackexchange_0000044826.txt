Q:

RViz displays "No messages received", what could be the reason?

Hi there,
I have a code that goes like this and is very similar to an example code:
#include <ros/ros.h>
//#include <sensor_msgs/PointCloud2.h>
#include <pcl/ros/conversions.h>
#include <pcl_ros/point_cloud.h>
#include <pcl/point_types.h>
#include <iostream>
using namespace std;
         
ros::Publisher pub;
         
void cloud_cb (const sensor_msgs::PointCloud2ConstPtr& input){
         
  float x=0,y=0,z=0;
  pcl::PointCloud<pcl::PointXYZ>::Ptr msg (new pcl::PointCloud<pcl::PointXYZ>);
  msg->header.frame_id = "some_frame";
  msg->height = msg->width = 1;
  msg->points.push_back (pcl::PointXYZ(x, y, z));
  pub.publish (msg);
}
         
int main (int argc, char** argv){
         
   ros::init (argc, argv, "some_init");
   ros::NodeHandle nh;
   ros::Subscriber sub = nh.subscribe ("output", 100, cloud_cb);
   pub = nh.advertise<sensor_msgs::PointCloud2> ("output", 100);
   ros::Rate loop_rate(1);
   while (nh.ok()){
   ros::spin ();
   loop_rate.sleep ();}
}

Don't be concerned about the function's input argument. I just need this later as soon as I am able to process some incoming data, publish and then visualize it with RViz.
So far, I'd like to see one single point when I'm using RViz. However, it indicates "No messages received".
Does anyone know what the fault is?
Kevin

Originally posted by tordalk on ROS Answers with karma: 1 on 2012-10-11
Post score: 0

Original comments
Comment by Lorenz on 2012-10-11:
If possible, could you please edit your post and add the complete source code? As far as I can see, everything looks ok.
Comment by tordalk on 2012-10-12:
Hello Martin, thanks for your reply. I finally got your point with the triggering. Unfortunately when I run your code a problem with the transformation appears, stating : Transform [sender=/some_init]
For frame [some_frame]: Frame [some_frame] does not exist. How can I fix that?
Comment by Lorenz on 2012-10-12:
Don't use the frame id some_frame. That was just an example. Instead, use something that is present in your tf tree, for instance input->header.frame_id. Also, don't forget to set the stamp, e.g.: msg->header.stamp = input->header.stamp

A:

Hi Kevin,
I think that the problem is that you are subscribing to the topic "output" and then you are publishing to the topic "output" again.
But, you publish to the topic "output" inside the callback of the subscriber to the topic "output" (cloud_cb). So, unless there is an external source pouring data into the topic "output", you will never trigger the callback (cloud_cb) and therefore, you will never publish anything. It is like a dog trying to bite its own tail :P
Even if you have an external source of content for the topic "output", I have never tried this kind of scenario, so I don't really know what behavior to expect. If you trigger the callback with a single external message to the topic "output" then you will get what you want, but maybe if there is an external continuous source of data for the topic "output" the amount of messages published and read again would grow exponentially? Not sure about this.
Probably this would work:
#include <ros/ros.h>
//#include <sensor_msgs/PointCloud2.h>
#include <pcl/ros/conversions.h>
#include <pcl_ros/point_cloud.h>
#include <pcl/point_types.h>
#include <iostream>
using namespace std;

ros::Publisher pub;

void cloud_cb (const sensor_msgs::PointCloud2ConstPtr& input){

  float x=0,y=0,z=0;
  pcl::PointCloud<pcl::PointXYZ>::Ptr msg (new pcl::PointCloud<pcl::PointXYZ>);
  msg->header.frame_id = "some_frame";
  msg->height = msg->width = 1;
  msg->points.push_back (pcl::PointXYZ(x, y, z));
  pub.publish (msg);
}

int main (int argc, char** argv){

   ros::init (argc, argv, "some_init");
   ros::NodeHandle nh;
   ros::Subscriber sub = nh.subscribe ("output", 100, cloud_cb);
   pub = nh.advertise<sensor_msgs::PointCloud2> ("output", 100);
   

   //Publish the first message so we can trigger cloud_cb for the first time
   float x=0,y=0,z=0;
   pcl::PointCloud<pcl::PointXYZ>::Ptr msg (new pcl::PointCloud<pcl::PointXYZ>);
   msg->header.frame_id = "some_frame";
   msg->height = msg->width = 1;
   msg->points.push_back (pcl::PointXYZ(x, y, z));
   pub.publish (msg);

   ros::spin ();
     
}

Originally posted by Martin Peris with karma: 5625 on 2012-10-11
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Lorenz on 2012-10-12:
Small side note: you don't need to put ros::spin inside a loop. It won't return until the node is shut down anyway.
Comment by Martin Peris on 2012-10-12:
@Lorenz totally true! I overlooked that detail, thanks for the note. I will change ros::spin for ros::spinOnce to keep consistency on the answer.
Comment by Lorenz on 2012-10-12:
I believe that using ros::spin is a much better solution than calling ros::spinOnce() once a second. The reason is that with spinOnce, subscriber callbacks are only executed when you call that method, i.e. once a second you'll get all subscribers executed, then nothing happens for one second, ...
Comment by Martin Peris on 2012-10-12:
Well, depending on what you are trying to accomplish that can be argued, but this discussion would not be really relevant to the question at hand, so I will just modify my answer again :)
Comment by Lorenz on 2012-10-12:
True, there are some cases when spinOnce is well-suited, mainly to prevent multi-threading issues. The main problem is to chose an appropriate spin rate.


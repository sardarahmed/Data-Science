Q:

Why does ROS use macros for logs?

This is purely an academic question, to sate my curiosity.
What were the advantages gained by using macros as the logging interface for C++, and not some ros::logError() function? Is there a reason this approach was chosen? As I understand, most people in the C++ community hate macros with a passion, so it seems odd to see them used for something that seems trivially accomplished through other means.
Thanks!

Originally posted by Robocop87 on ROS Answers with karma: 255 on 2016-07-12
Post score: 1

Original comments
Comment by gvdhoorn on 2016-07-12:
I don't know for sure, but I guess the fact that fi the various THROTTLE versions insert a static variable at the site of invocation, and access to __LINE__ and __FILE__ constants in all of them have something to do with it.
Comment by Robocop87 on 2016-07-12:
Interesting observation! And since LINE and FILE are read by the preprocessor, something like an inline function wouldn't be able to use them.
Comment by dornhege on 2016-07-12:
Maybe there is a workaround, but I guess that would be line and file of the inline function and not the caller.

A:

Macros both have the ability to take advantage of the preprocessor functions like __LINE__ and __FILE__ as well as the macros can be compiled out of the code for complete optimization if the use case demands high performance.
This means that you can choose to have no runtime penalty for keeping the debug outputs in your code. See http://wiki.ros.org/rosconsole#Compile-time_Logger_Removal

Originally posted by tfoote with karma: 58457 on 2017-08-11
This answer was ACCEPTED on the original site
Post score: 2


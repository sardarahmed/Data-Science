Q:

Constructing a float32 value from four uint8 bytes

I am trying to read depth values from the topic /camera/depth/image_rect_color. The message is of the type sensor_msgs/Image and prints out 8 bit data (uint8) as elements of an image array. Since the image is encoded as 32FC1, I need to combine four of these elements to obtain depth information of a single pixel.  A stack overflow answer contains the following code:
float f;
uchar b[] = {b3, b2, b1, b0};
memcpy(&f, &b, sizeof(f));
return f;

Is this the right approach to construct a float32 value from 4 bytes of uint8 values, without any data loss ?

Originally posted by skr_robo on ROS Answers with karma: 178 on 2016-07-25
Post score: 0

A:

Instead of trying to do that conversion by hand for each pixel, I recommend that you use the cv_bridge package to convert your sensor_msgs/Image into a cv::Mat, which should be easier to use. The cv_bridge tutorial is probably a good place to start, but obviously you'll need to change the image encoding parameters.

Originally posted by ahendrix with karma: 47576 on 2016-07-25
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by skr_robo on 2016-07-25:
My intention is to find out any obstacle within 5m of a zed stereo camera. The data is basically depth value. I am planning to avoid using openCV. Is there any reference for data conversion by hand? I wouldn't mind writing additional lines of code for that.
Comment by ahendrix on 2016-07-25:
The canonical reference is the implementation of the sensor_msgs/Image to cv::Mat conversion function that's underneath all of the cv_bridge conversions: https://github.com/ros-perception/vision_opencv/blob/e548e37cba1b8d473be5836cbb37d7ed5abdd7ac/cv_bridge/src/cv_bridge.cpp#L249-L298


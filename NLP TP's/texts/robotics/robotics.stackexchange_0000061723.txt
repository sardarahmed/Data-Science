Q:

ar_track_alvar crashes camera_nodelet_manager

Hi,
I am struggling with the following problem: I am running openni_launch and ar_track_alvar. To minimize data sent over our network, we have set the image and depth mode of the camera to 5 (QVGA).
However, when I want to detect some markers I set the camera image and depth mode to 2 to provide a higher resolution. I do this by running the following line from C++ code (found this example at the ROS wiki):
system("rosrun dynamic_reconfigure dynparam set_from_parameters camera/driver _image_mode:=2 && rosrun dynamic_reconfigure dynparam set_from_parameters camera/driver _depth_mode:=2");

At a certain moment in time I received the following error:
[camera/camera_nodelet_manager-5] process has died [pid 30792, exit code -11, cmd /opt/ros/hydro/lib/nodelet/nodelet manager __name:=camera_nodelet_manager __log:=/home/rose/.ros/log/9534a258-21f7-11e4-aed4-000cf6bedafb/camera-camera_nodelet_manager-5.log]

I thought this was caused by changing the resolution. I tested the openni_launch package separately by changing the resolution again and again from the terminal in a while-loop. But, the camera nodelet did not crash.
When I started ar_track_alvar in combination with the previous set up (changing the resolution in this while-loop), the error occurred when the marker was in the camera view. Hence, I think ar_track_alvar is causing the camera_nodelet_manager to crash.
I have tried to change the output_frame to /camera_depth_optical_frame. However, that did not work..
Launching the camera_nodelet_manager in gbd shows the following error:
Program received signal SIGSEGV, Segmentation fault.
[Switching to Thread 0x7fff9297f700 (LWP 25102)]
0x00007fffa309e522 in openni_wrapper::ImageBayerGRBG::fillRGB(unsigned int, unsigned int, unsigned char*, unsigned int) const ()
from /opt/ros/hydro/lib/libopenni_driver.so

Has anyone experienced the same issues? Are there solutions for this problem?
--- Extra information ---
Launch files:
ar_track_alvar.launch
<launch>
<arg name="marker_size" default="4.4" />
<arg name="max_new_marker_error" default="0.08" />
<arg name="max_track_error" default="0.2" />

<arg name="cam_image_topic" default="/camera/depth_registered/points" />
<arg name="cam_info_topic" default="/camera/rgb/camera_info" />     
<arg name="output_frame" default="/camera_link" />

<node name="ar_track_alvar" pkg="ar_track_alvar" type="individualMarkers" respawn="false" output="screen" args="$(arg marker_size) $(arg max_new_marker_error) $(arg max_track_error) $(arg cam_image_topic) $(arg cam_info_topic) $(arg output_frame)" />

<node pkg="tf" type="static_transform_publisher" name="right_gripper_marker_tf" args="0.087 0 0.025 3.1415 0 3.1415 /right_arm_wrist /right_arm_grippermarker_expected 10" />
<node pkg="tf" type="static_transform_publisher" name="left_gripper_marker_tf" args="0.087 0 0.065 3.1415 0 3.1415 /left_arm_wrist /left_arm_grippermarker_expected 10" />

<node pkg="tf" type="static_transform_publisher" name="ar_marker_1_rename" args="0 0 0 0 0 0 /ar_marker_1 /right_arm_grippermarker_observed 10" />
<node pkg="tf" type="static_transform_publisher" name="ar_marker_2_rename" args="0 0 0 0 0 0 /ar_marker_2 /left_arm_grippermarker_observed 10" />

</launch>

kinect.launch
<launch>    
<arg name="kinect_camera_name" default="camera" />

<!-- Openni kinect  -->
<include file="$(find openni_launch)/launch/openni.launch">
    <arg name="depth_registration" value="true"/> 
    <arg name="num_worker_threads" value="8"/> 
    <arg name="sw_registered_processing" value="false"/> 
    <arg name="camera" value="$(arg kinect_camera_name)" />
</include>

<param name="/$(arg kinect_camera_name)/driver/image_mode" value="5" /> <!-- 2 is default, 5 is QVGA -->
<param name="/$(arg kinect_camera_name)/driver/depth_mode" value="5" /> <!-- 2 is default, 5 is QVGA -->

<!-- Point cloud filters  -->
<node pkg="nodelet" type="nodelet" name="pcl_manager" args="manager" output="screen" />

<!-- Run a VoxelGrid filter to clean NaNs and downsample the data -->
<node pkg="nodelet" type="nodelet" name="voxel_grid" args="load pcl/VoxelGrid pcl_manager" output="screen">
    <remap from="~input"  to="/camera/depth_registered/points" />
    <remap from="~output" to="/point_cloud/downsample" />
    <rosparam>
        leaf_size: 0.04
        filter_field_name: z
        filter_limit_min: 0.30
        filter_limit_max: 3.00
        filter_limit_negative: False
    </rosparam>
</node>

<!-- Run a StatisticalOutlierRemoval filter to remove outliers -->
<node pkg="nodelet" type="nodelet" name="statistical_outlier_removal" args="load pcl/StatisticalOutlierRemoval pcl_manager" output="screen">
    <remap from="~input"  to="/point_cloud/downsample" />
    <remap from="~output" to="/point_cloud/downsample_outlier" />
    <rosparam>
        <!-- The number of points (k) to use for mean distance estimation Range: 2 to 100 -->
        mean_k: 2
        <!-- The standard deviation multiplier threshold. All points outside the mean +- sigma * std_mul will be considered outliers. Range: 0.0 to 5.0 -->
        stddev: 0.4
        <!-- Set whether the inliers should be returned (true) or the outliers (false) -->
        negative: false
    </rosparam>
</node>

</launch>

[Ubuntu 12.04 LTS 64-bits, ROS Hydro]

Originally posted by mathijsdelangen on ROS Answers with karma: 88 on 2014-08-12
Post score: 0

A:

I have not fixed the issue with ar_track_alvar crashing the camera nodelet.
However, the original problem I had was sending too much data over the network.

"To minimize data sent over our network, we have set the image and depth mode of the camera to 5 (QVGA)."

This problem has been fixed by using theora compression at the side of the receiver. Using this, the image and depth mode could be set at 2 and no switching between modes has to be done anymore.
In the launch file:
 <param name="image_transport" value="theora"/>

Originally posted by mathijsdelangen with karma: 88 on 2014-09-24
This answer was ACCEPTED on the original site
Post score: 0


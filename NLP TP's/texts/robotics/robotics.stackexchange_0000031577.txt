Q:

Understanding rosjava, as recently announced by Google and Willow Garage

Google and Willow Garage announced a "new rosjava library that is the first pure-Java implementation of ROS." I watched the video and looked at the wiki, but I am still confused on what exactly rosjava is.
Is the announced rosjava more than a client library? Is it different than http://www.ros.org/wiki/rosjava?
If so, how does it differ from a client library? Does it have its own implementation of roscore and master and parameter server?
And if that's the case, how does rosjava differ from what I'll call proper ROS (the ROS installed via sudo apt-get install ros-diamondback-ros-base)? And what are the plans for the two in terms of development and feature parity in the future?
Thanks!

Originally posted by baalexander on ROS Answers with karma: 233 on 2011-05-12
Post score: 3

A:

The new rosjava is a pure Java implementation, and even includes a ROS master, which means you can run a complete ROS system on an Android phone.  That said, it can still be used just as a client library and is compatible with the roscore that is distributed with ROS, and so you can view rosjava in the same way you would roscpp and rospy.  In our talk, we demo using rosjava to both send and receive sensor data from an Android device to a PR2.
Moving forward, we will need to reconcile the two rosjava implementations, but our preference is for the pure Java implementation as it fulfills the main goal of Java, which is to run on any platform that supports a JVM.  The new rosjava is still in an alpha-quality state, and there is much to do to fully integrate the build, test and runtime system with the ROS toolchain.

Originally posted by kwc with karma: 12244 on 2011-05-13
This answer was ACCEPTED on the original site
Post score: 9

Original comments
Comment by Lorenz on 2011-05-14:
The old implementation has been implemented more than 1 1/2 years ago by Jason Wolfe and not much has changed since then. Right now, the new rosjava implementation is not really integrated into the ROS toolchain yet. As soon as it is, it is pretty likely that we will let the old implementation die.
Comment by baalexander on 2011-05-13:
Thank you Ken for the response and the talk. That clarified things. I'm still a bit curious on how the two ROS implementations will be developed and maintained in the future, but that may be more wait and see.


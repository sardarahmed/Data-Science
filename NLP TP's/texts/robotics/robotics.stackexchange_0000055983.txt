Q:

Voxel maps not working with Turtlebot2 bumpers (Updated)

Hello,
I have a Turtlebot 2 (Kobuki + Kinect) that I'm working on a navigation system for.
I am currently having a problem with getting move_base to behave safely in the event of a collision.
For obstacles that the Kinect can see, this is not a problem, but there are many things (the bases on office chairs, glass doors, short items, the list goes on...) that the Kinect can not account for.
To solve this problem, I have changed the gmapping local costmap to a voxel map, so I have an obstacle layer for the Kinect and a separate obstacle layer for the bumpers. However, this solves very little. If the robot is moving and hits something that causes the bumper to depress, it acts as though nothing happened and keeps trying to go forward.
In an attempt to narrow the cause of this problem down, I have verified the following:

I can use rostopic echo mobile_base/events/bumper to see that the bumpers respond to being pressed.

In rviz, I can see that when the robot is sitting still, I can press the bumpers and the local costmap will be updated to show an obstacle in front of the robot. Letting go of the bumper will not clear the obstacle, and if I send the robot a goal, it will try to navigate around the "obstacle" created by pressing the bumper.

Also in rviz, if I send the robot a goal to move forward, and I jump in its path so that the Kinect can see me, the robot will steer around me.

However, if I get in the robot's way by depressing the bumper but staying out of the sight of the Kinect, the robot will simply try to aggressively push through my hand.
After having played with this configuration for a while, I have noticed that the bumpers are inserting obstacles into the costmap, but it looks like it's not doing it fast enough for the robot to change its behavior. In other words, by the time the obstacle shows up in rviz, it is either directly underneath the robot, or behind it. My guess is that is why the robot doesn't reroute -- because it doesn't think the obstacle is in its path.
Does anyone have any comment on this? Am I right in my hypothesis for why this happens? If so, how would I go about remedying this? Perhaps writing code in my application to raise an interrupt on bumper pressing, sending a cancel to move_base, making the robot back up a few inches, and resending the goal?
Or am I missing something else that would cause the bumpers to work properly without the need for making drastic changes?
I have taken a video capture of the above happening in rviz. If that would be helpful, I will try to upload it to YouTube or something.
The steps I take to get this problem are as follows:
roslaunch turtlebot_bringup minimal.launch
roslaunch turtlebot_navigation gmapping_demo.launch
roslaunch turtlebot_rviz_launchers view_navigation.launch

I then send a goal about 10 feet forward in rviz, and while the robot is moving forward, press the bumper with my foot so that the Kinect does not see me.
My costmap files for gmapping are as follows:
costmap_common_params.yaml:
origin_z: 0.0
z_resolution: .1
z_voxels: 10

max_obstacle_height: 0.60  # assume something like an arm is mounted on top of the robot
obstacle_range: 2.5
raytrace_range: 3.0
robot_radius: 0.18
inflation_radius: 0.50
observation_sources: scan bump

scan: {data_type: LaserScan, topic: /scan, marking: true, clearing: true, min_obstacle_height: 0.1, max_obstacle_height: 0.6}

# Current bump cloud configuration
bump: {data_type: PointCloud2, topic: mobile_base/sensors/bumper_pointcloud, marking: true, clearing: false, min_obstacle_height: 0.0, max_obstacle_height: 0.1}

# These were for the create, but I think weren't getting used. 
# Can we merge to a common configuration - DJS?
# scan: {data_type: LaserScan, topic: /scan, marking: true, clearing: true}
# left_bump: {data_type: PointCloud2, topic: /bump_sensor_left, marking: true, clearing: true}
# right_bump: {data_type: PointCloud2, topic: /bump_sensor_right, marking: true, clearing: true}

global_costmap_params.yaml:
global_costmap:
   map_type: costmap
   global_frame: /map
   robot_base_frame: /base_footprint
   update_frequency: 3.0
   publish_frequency: 0.0
   static_map: true
   transform_tolerance: 0.5
   track_unknown_space: true
   unknown_cost_value: 255

local_costmap_params.yaml:
local_costmap:
   map_type: voxel
   global_frame: /odom
   robot_base_frame: /base_footprint
   update_frequency: 5.0
   publish_frequency: 5.0
   static_map: false
   rolling_window: true
   width: 4.0
   height: 4.0
   resolution: 0.1
   transform_tolerance: 0.5

I would very much appreciate if someone sees anything wrong with my configuration and can point it out to me. Or if anyone has any practical advice on how to solve this issue.
Thanks in advance!
-------------- UPDATE: --------------------------
I realize I forgot to mention that I'm using ROS Groovy.
In the past few days since posting the original, I've attempted to use the Kobuki safety controller by also running roslaunch turtlebot_bringup _safety_controller.launch
This works...somewhat. Now when I try to navigate to a goal and then press my foot against the bumpers, instead of blindly trying to plow through my foot, it repeatedly hits my foot, backs up a little, hits my foot again, backs up again, ad nauseam.
Looking at the screen on rviz, my best guess is that the safety controller works so quickly in backing up that the obstacle is never inserted into the costmap because the bumper was not pressed for long enough.
Is there a good way of making the obstacle register more quickly, or making safety_controller wait before backing up? I suppose I could always mess with the source code on the safety_controller to make it pause, but that would be more of a last resort for me.
Thanks.
----Update 2:----
I've attached the video if anyone wants to see it.

Originally posted by BlitherPants on ROS Answers with karma: 504 on 2013-12-09
Post score: 0

Original comments
Comment by jihoonl on 2013-12-16:
The local costmap update frequency can be configured in local_cost_map_params.
Try to configure update_frequecny in local_costmap_params.yaml.
Reference : http://wiki.ros.org/navigation/Tutorials/RobotSetup
If it does not work, could you share the video? I am just curious how it behaves..
Comment by BlitherPants on 2013-12-20:
Thanks for the response! I've already made a modified version of kobuki_safety_controller that seems to work, but I'm still looking into it. I may try your suggestion, though I'm wary of bogging down the computer (gmapping seems to crash a lot running multiple processes). I'll update when possible.
Comment by BlitherPants on 2013-12-20:
Only once I increased the frequency to 20Hz (high!) did it work with the default safety controller. Gmapping froze once so it may be too much for my CPU. Still, this is a good answer. In the future, I'll test this against what I did (changing safety_controller) to see which works better. Thanks!
Comment by BlitherPants on 2013-12-20:
I attached the video for you. At least, I think I did, but I can't seem to find where it shows.

A:

I fixed this problem by modifying kobuki_safety_controller so that it pauses long enough to register the obstacle before backing up. I also increased the update_frequency as @jihoonl suggested.

Originally posted by BlitherPants with karma: 504 on 2014-03-12
This answer was ACCEPTED on the original site
Post score: 0


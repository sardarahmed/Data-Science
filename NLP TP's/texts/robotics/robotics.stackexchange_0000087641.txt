Q:

ROS kinetic with Ubuntu 4.13.0: Code doesn't invoke the callback method (poseHandler::poseHandlerCallBack(const turtlesim::PoseConstPtr& posePtrNew))

#include <ros/ros.h>
#include <turtlesim/Pose.h>
#include <geometry_msgs/Twist.h>
#include <std_srvs/Empty.h>
#include <signal.h>
#include <termios.h>
#include <stdio.h>
float initialX;
float initialY;
float initialTheta;

class poseHandler
{
    public:
        poseHandler();
        turtlesim::PoseConstPtr currPosePtr;
        turtlesim::Pose currPose;
        void printPose();
        void poseHandlerCallBack(const turtlesim::PoseConstPtr& posePtrNew);
};
poseHandler::poseHandler()
{
}
void poseHandler::printPose()
{
    ROS_INFO("x=%f,y=%f", currPose.x, currPose.y);
    ROS_INFO("y=%f,", currPose.y);
    ROS_INFO("theta=%f,", currPose.theta);
    ROS_INFO("lin_vel=%f,", currPose.linear_velocity);
    ROS_INFO("ang_vel%f\n", currPose.angular_velocity);
}
void poseHandler::poseHandlerCallBack(const turtlesim::PoseConstPtr& posePtrNew)
{
    currPosePtr = posePtrNew;
    currPose.x = currPosePtr->x;
    currPose.y = currPosePtr->y;
    currPose.theta = currPosePtr->theta;
    currPose.linear_velocity = currPosePtr->linear_velocity;
    currPose.angular_velocity = currPosePtr->angular_velocity;

    ROS_INFO("poseHandlerCallBack!\n");
}
int main(int argc, char** argv)
{
    poseHandler pH;
    ros::init(argc, argv, "draw_ractangle");
    ros::NodeHandle nh;
    ros::Subscriber pose_sub = nh.subscribe<turtlesim::Pose>
        ("/turtlesim/turtle1/pose",1000,
         &poseHandler::poseHandlerCallBack, &pH);

    initialX = pH.currPose.x;
    initialY = pH.currPose.y;
    initialTheta = pH.currPose.theta;
    pH.printPose();

    ros::Publisher twist_pub = nh.advertise<geometry_msgs::Twist>
      ("turtle1/cmd_vel", 100);

    ros::Rate loop_rate(1);
    geometry_msgs::Twist twist_obj;

    twist_pub.publish(twist_obj);

    while(ros::ok())
    {
        ROS_INFO("target = %f", (initialX+2));
        if(pH.currPose.x < (initialX + 2))
        {
            twist_obj.linear.x = 0.4;
            twist_obj.angular.z = 0.0;
            ROS_INFO("Turtle move forward\n");
        }
        else
        {
            twist_obj.linear.x = 0.0;
            twist_obj.angular.z = 0;
            ROS_INFO("Turtle Stopped\n");
        }
        pH.printPose();
        twist_pub.publish(twist_obj);
        loop_rate.sleep();
        ros::spinOnce();
        ROS_INFO("spinOnce() called\n");
    }
}

Originally posted by Mohini on ROS Answers with karma: 23 on 2018-07-01
Post score: -2

A:

There is a while loop inside your main loop where the code will get stuck. The callbacks are only processed when you call the ros::spinOnce function, so it will never call the callback when it's stuck inside that inner loop.
It's not clear why you would want a while loop there anyway, you can possibly change it to an if condition to make it stop after you get to the desired position. Also, you might never get a message with an exact value of initialX + 1 in the pose message, so you may want to change it to an inequality check instead of equality.

Originally posted by kartikmohta with karma: 308 on 2018-07-02
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by billy on 2018-07-02:
+1 for reading his code.
Comment by Mohini on 2018-07-04:
Thank you for the reply. I've changed my code. now spinOnce() is executed, yet the call back function is not invoked. The objective of the code is to move the turtle a couple of units and make it stop.
(I could not put the revised code in the comment, so edited original code)
Comment by kartikmohta on 2018-07-04:
You might want to check the topic name for the pose subscriber. Just do a rostopic list after launching the turtlesim to check the exact names. You're subscribing to turtlesim/turtle1/pose but the actual topic might be /turtle1/pose.
Comment by Mohini on 2018-07-04:
yey! it worked. I had the topic name right to start with. but to get to work I tried different names and forgot to revert to the original code. thanks for the help!


Q:

fail to publish to a different message type

Hi everyone :)
I wrote a node called translater that subscribes to a the topic pose_before and publishes to another topic pose_after. The topic pose_before is of message type "PoseWithCovarianceStamped" and pose_after is "TransformStamped". The issue is that all values in pose_after remain 0 when they're being published.

#!/usr/bin/env python
import rospy
from geometry_msgs.msg import PoseWithCovarianceStamped
from geometry_msgs.msg import TransformStamped

def callback(data):
    TransformStamped().transform.translation.x = data.pose.pose.position.x
    TransformStamped().transform.translation.y = data.pose.pose.position.y
    TransformStamped().transform.translation.z = data.pose.pose.position.z
    TransformStamped().transform.rotation.x = data.pose.pose.orientation.x
    TransformStamped().transform.rotation.y = data.pose.pose.orientation.y
    TransformStamped().transform.rotation.z = data.pose.pose.orientation.z
    TransformStamped().transform.rotation.w = data.pose.pose.orientation.w
def listener():
    pub = rospy.Publisher('pose_after', TransformStamped, queue_size=40)
    pose_after = TransformStamped()
    rospy.init_node('translater', anonymous=True)
    rospy.loginfo("Publishing pose_after")
    rospy.Subscriber('pose_before', PoseWithCovarianceStamped, callback)
    rate = rospy.Rate(40)
    pose_after.header.stamp = rospy.Time.now()
    pose_after.child_frame_id = 'base_footprint'
    print(pose_after.transform.translation.x) # this prints (0,0)
    while not rospy.is_shutdown():
        pub.publish(pose_after)
        rate.sleep()

if __name__ == '__main__':
    try:
        listener()
    except rospy.ROSInterruptException:
        pass

When I put the print line in callback then it actually is able to print the correct values, so I'm wondering why the values are lost outside of the callback. I've also tried assigning a global variable inside the callback but still didn't work.

Originally posted by Patricia2602 on ROS Answers with karma: 13 on 2020-12-30
Post score: 0

A:

You should really be using classes. But here is a hack that works
#!/usr/bin/env python
import rospy
from geometry_msgs.msg import PoseWithCovarianceStamped
from geometry_msgs.msg import TransformStamped

pub = rospy.Publisher('pose_after', TransformStamped, queue_size=40)
pose_after = TransformStamped()

def callback(data):

    pose_after.header.stamp = rospy.Time.now()
    pose_after.child_frame_id = 'base_footprint'

    pose_after.transform.translation.x = data.pose.pose.position.x
    pose_after.transform.translation.y = data.pose.pose.position.y
    pose_after.transform.translation.z = data.pose.pose.position.z
    pose_after.transform.rotation.x = data.pose.pose.orientation.x
    pose_after.transform.rotation.y = data.pose.pose.orientation.y
    pose_after.transform.rotation.z = data.pose.pose.orientation.z
    pose_after.transform.rotation.w = data.pose.pose.orientation.w

    print(pose_after.transform) # this prints (0,0)
    pub.publish(pose_after)

def listener():
    
    rospy.init_node('translater', anonymous=True)
    rospy.loginfo("Publishing pose_after")

    rospy.Subscriber('pose_before', PoseWithCovarianceStamped, callback)
    rate = rospy.Rate(40)
    
    while not rospy.is_shutdown():
        rate.sleep()

if __name__ == '__main__':
    try:
        listener()
    except rospy.ROSInterruptException:
        pass

In your original callback, you are trying to populate TransformStamped() which is a msg type, not a msg. you should be able to echo the pose_after topic and listen in on the new msgs now.

Originally posted by Akhil Kurup with karma: 459 on 2020-12-30
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Patricia2602 on 2020-12-30:
Thanks for the reply :) I realized that the print() just always give me (0,0) when I put it outside of the callback, but when I echo the rostopic the values are no longer 0 anymore, which also makes sense if we do everything in the callback. Not sure if it was also the case for my previous versions, where I was populating pose_after but then decided to try TransformStamped(), which was obviously wrong.


Q:

Best way to Interface Gazebo Server with custom Application

Hi,
I'm trying to create my own GUI/Editor using gazebo just as a server. Currently, I'm using a .so that starts a server and calls gazebo API functions so i can create models, control joints and get the pose of every object in the world for rendering.
But I saw that a lot of examples that interface with gazebo using messages rather than using API functions.
In my context, is it better to use messages? Or is it faster if i keep using Gazebo API Functions?
I would like to know pros and cons.

Originally posted by Eduardo Albuquerque on Gazebo Answers with karma: 89 on 2014-10-10
Post score: 0

Original comments
Comment by NickDP on 2014-11-12:
I don't think I'll be able to help you but I'm also trying to manipulate a robot from outside gazebo. I'm doing this with a model plugin on the gazebo side and messages from my 'main()' to the plugin. I don't know any other way to do this. Can you explain to me how you are using the gazebo API from outside gazebo without messages? Thanks.
Comment by Eduardo Albuquerque on 2014-11-19:
Hi, NickDP. I created a .so that exports a bunch of methods from gazebo library that I'll need in my client application. My client starts a world in a gazebo server and then enters in a loop. At the beginning of the loop, my client steps (1 step only) gazebo simulation and then it get each model position from gazebo and use these informations to update itself. At the end of the loop, I call gazebo methods like "SetForce" (that I imported previously from the .so) to interact with the simulation.
Comment by Eduardo Albuquerque on 2014-11-19:
I basiclly use gazebo as a physics engine ( With the advantege of being much easier to use and i can easily change from ODE to Bullet). I don't know if gazebo should be used like that. It just a method that until now is working for me (it can get very slow sometimes).

A:

You don't need to use message passing, if you GUI is running in the same process as the gazebo server.
The default gazebo GUI runs in a separate process. It relies on message passing to get simulation state information. This info is then used to render the environment.

Originally posted by nkoenig with karma: 7676 on 2014-11-20
This answer was ACCEPTED on the original site
Post score: 2


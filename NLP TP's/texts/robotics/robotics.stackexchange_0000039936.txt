Q:

node won't shutdown

Hello!
I'm using the rosjava_core revision 1084ec6c569c (from 24th of February) - the newest version is not an option for me, since I need actionlib.
I have a simple test program which works. When I run it, it will print "my work is done here" and "shutting down" in this order. But in eclipse IDE, the program keeps running! And when I run "rosnode list" on the bash, it will also tell me, that the node still exists.
When I press the red stop button in eclipse, eclipse tells me, the program is terminated, but I will still find the node with "rosnode list" on the bash.
How can I properly stop the program and kill the node? "rosnode kill /myNodeName2" does not kill the node neither, but I want to do it in java code, anyway, so this would not be an option.
Any help appreciated! Here's the code:
package my.package.tests_new_rosjava;

import java.net.URI;

import org.ros.address.InetAddressFactory;
import org.ros.namespace.GraphName;
import org.ros.node.DefaultNodeMainExecutor;
import org.ros.node.Node;
import org.ros.node.NodeConfiguration;
import org.ros.node.NodeMain;
import org.ros.node.NodeMainExecutor;

public class simpleTest {

    public static void main(String[] args) {

        String host = InetAddressFactory.newNonLoopback().getHostAddress()
                .toString();

        NodeConfiguration configuration = NodeConfiguration.newPublic(host,
                URI.create("http://localhost:11311"));
        configuration.setNodeName("myNodeName2");

        RosTasks objectsClient = new RosTasks();

        NodeMainExecutor runner = DefaultNodeMainExecutor.newDefault();
        runner.execute(objectsClient, configuration);

        while (!RosTasks.finished) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        objectsClient = null;

        System.out.println("shutting down");
    }
}

class RosTasks implements NodeMain {

    public static boolean finished;

    @Override
    public void onShutdown(Node arg0) {

    }

    @Override
    public void onShutdownComplete(Node arg0) {

    }

    @Override
    public void onStart(Node node) {
        finished = false;

        System.out.println("my work is done here");

        finished = true;
    }

    @Override
    public GraphName getDefaultNodeName() {
        return null;
    }
}

Originally posted by markkre on ROS Answers with karma: 77 on 2012-04-26
Post score: 0

A:

Before you asked this question, terminating your process would not have shutdown the node (thus leaving things still registered with the master). You would need to call nodeMainExecutor.shutdown() before your main() exits to shut down cleanly.
However, I've just pushed a change to DefaultNodeMainExecutor which corrects this issue. Thanks for bringing it to my attention :)

Originally posted by damonkohler with karma: 3838 on 2012-04-26
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by markkre on 2012-04-26:
thx, that fixed it! And did I understand that right, that your newly pushed change will do a shutdown, in case someone forgets - like me?
Comment by damonkohler on 2012-04-26:
That's correct-ish. It will try to do a shutdown. The JVM can of course die in such a way that shutdown isn't possible.


Q:

Undefined reference to RosIntrospection functions

Hey guys,
I try to convert the Raw Buffer of a ShapeShifter to its original DataType Structure. But I have Problems understanding the new API. In the wiki the author used functions, which are not available anymore, so I tried to do it with the latest headers available.
As I understand the new API, I have to register the MessageDefinition first and afterwards I can deserialize the Buffer IntoFlatContainer.
Copy of the ros_type_introspection.hpp:
In the file is a short description to each function
  void registerMessageDefinition(const std::string& message_identifier,
                                 const ROSType &main_type,
                                 const std::string& definition);

  bool deserializeIntoFlatContainer(const std::string& msg_identifier,
                                    absl::Span<uint8_t> buffer,
                                    FlatMessage* flat_container_output,
                                    const uint32_t max_array_size ) const;

Here is my code:
using namespace RosIntrospection;
static std::vector<uint8_t> buffer;
static FlatMessage flat_container;
Parser parser;    
const std::string& datatype   = msg->getDataType();
const std::string& definition = msg->getMessageDefinition();

ROS_INFO("datatype: %s", datatype.c_str() );

buffer.resize( msg->size() );
ros::serialization::OStream stream(buffer.data(), buffer.size());
msg->write(stream);

parser.registerMessageDefinition(datatype, ROSType("geometry_msgs/Twist"), definition);

The registration of the MessageDefinition fails. And functions like described in the wiki (e.g buildROSTypeMapFromDefinition) are not available anymore.
My current error message:
RosSender.cpp:(.text+0x3cc): undefined reference to `RosIntrospection::ROSType::ROSType(absl::string_view)'
RosSender.cpp:(.text+0x3ed): undefined reference to `RosIntrospection::Parser::registerMessageDefinition(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, RosIntrospection::ROSType const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)

Can anyone tell me how to use the new API correctly to get the original message?
Thank you!!
edit (Add CMakeList.txt):
cmake_minimum_required(VERSION 2.8.3)

set(CMAKE_CXX_FLAGS "-std=c++11")
set(CMAKE_CXX_FLAGS "-std=c++14")
project(RosSender)

set(THIRDPARTY_DIR ${PROJECT_SOURCE_DIR}/../thirdParty)

find_package(catkin REQUIRED COMPONENTS
  roscpp
  rospy
  std_msgs
)

catkin_package(
  INCLUDE_DIRS
  LIBRARIES RosAdapter
  CATKIN_DEPENDS roscpp rospy std_msgs
  DEPENDS system_lib
)

include_directories(
  ${catkin_INCLUDE_DIRS}    
)
include_directories(
  ${THIRDPARTY_DIR} 
)

add_executable(RosSender src/RosSender.cpp)

target_link_libraries(RosSender ${catkin_LIBRARIES} ${THIRDPARTY_DIR}/oa/myOaLib.so)
target_link_libraries(RosSender /opt/ros/kinetic/lib/libtopic_tools.so)

Originally posted by Felix394 on ROS Answers with karma: 5 on 2018-08-20
Post score: 0

Original comments
Comment by gvdhoorn on 2018-08-20:
The last error is a linker error, not something else.
So apparently the compiler is happy, but the linker can't find the specific symbol it needs to link your executable.
Are you enabling / using C++11 in your pkg and linking the ros_type_introspection libraries correctly?
Comment by Felix394 on 2018-08-20:
set(CMAKE_CXX_FLAGS "-std=c++11")
set(CMAKE_CXX_FLAGS "-std=c++14")
these are my link libraries:
target_link_libraries(RosSender ${catkin_LIBRARIES})
target_link_libraries(RosSender /opt/ros/kinetic/lib/libtopic_tools.so)
I don't have other *.so files to link
Comment by gvdhoorn on 2018-08-20:
Please add this to your original question text. Comments are too limited.
re: set(CMAKE_CXX_FLAGS ..): don't do this. If you must use set(..), use set(VAR "new entry $VAR") so as to not override whatever was already there.
Comment by gvdhoorn on 2018-08-20:
Can you please add your complete CMakeLists.txt to your question?
I don't understand why you're listing the absolute path to the topic_tools library like that.
Comment by Felix394 on 2018-08-21:
I had to add the path, because otherwise I got Linking Problems
Comment by gvdhoorn on 2018-08-21:
Could I refer you to wiki/catkin/CMakeLists.txt? topic_tools is a Catkin pkg, so it should appear in your find_package(catkin REQUIRED COMPONENTS ..) call.
There are some other unusual things in your CMakeLists.txt file as well.
Comment by gvdhoorn on 2018-08-21:
Fi: you have DEPENDS system_lib in there. But you never actually build a library called system_lib. If you don't intend to, remove the DEPENDS system_lib line.
Comment by gvdhoorn on 2018-08-21:
Could you also please use the Preformatted Text button when copy-pasting code/build scripts/console text? It's the one with 101010 on it. That would make things much easier to read.
Thanks.
Comment by gvdhoorn on 2018-08-21:
Final comment:

In the wiki the author used functions, which are not available anymore

have you reported this to the author on his issue tracker?

A:

I'm not sure, but I don't see ros_type_introspection (ie: the Catkin package) appear anywhere in your CMakeLists.txt.
As you're using the package, I would expect it to appear at least in:
find_package(catkin REQUIRED COMPONENTS .. ros_type_introspection ..)

and:
catkin_package(.. CATKIN_DEPENDS .. ros_type_introspection ..)

Linking against catkin_LIBRARIES should then allow the linker to resolve all used symbols.

Edit: the same goes for topic_tools. It's a Catkin package as well, so I would expect it to appear in the same places as ros_type_introspection.

Edit2: also don't forget to add the correct build and exec dependencies to your package.xml. See the catkin documentation for how to do that.

Edit3: based on what you show us, I would expect to see a CMakeLists.txt like the following:
cmake_minimum_required(VERSION 2.8.12)
project(RosSender)

add_definitions(-std=c++11)

# this overrides the C++11 enabled before this line
add_definitions(-std=c++14)

# 'pretend' OaLib is a nice CMake findable pkg
# we don't bother with find_library et al. and shortcut things a bit
set(THIRDPARTY_DIR ${PROJECT_SOURCE_DIR}/../thirdParty)
add_library(OaLib STATIC IMPORTED)
set_property(TARGET OaLib PROPERTY IMPORTED_LOCATION "${THIRDPARTY_DIR}/oa/myOaLib.so")

# rospy is not a build dependency, so can probably be removed here
find_package(catkin REQUIRED COMPONENTS
  ros_type_introspection
  roscpp
  rospy
  std_msgs
  topic_tools
)

# check order of include directories here
include_directories(
  ${THIRDPARTY_DIR}
  ${catkin_INCLUDE_DIRS}
)

catkin_package(
  # you don't export any include directories, so this should be removed
  INCLUDE_DIRS
  # this library is not being built, so this line should be removed
  LIBRARIES RosAdapter
  # rospy should be removed here as well: it cannot be a build dependency
  CATKIN_DEPENDS roscpp rospy std_msgs ros_type_introspection topic_tools
)

add_executable(RosSender src/RosSender.cpp)
target_link_libraries(RosSender ${catkin_LIBRARIES} OaLib)

I've added some comments above lines I can't be sure about, so check those yourself.
Linking static libraries like you did is not recommended, so I replaced it with an imported target.
And please note: this is all CMake, not Catkin or special to ROS.

Originally posted by gvdhoorn with karma: 86574 on 2018-08-21
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by Felix394 on 2018-08-21:
I have never build a package ros_type_introspection, because I only have the header files from the git repo. Add it to the CMakeLists as package will throw an exception.
Comment by gvdhoorn on 2018-08-21:
ros_type_introspection is a ROS package. Just the header files are not enough to successfully use it.
If you are on Ubuntu, just do a sudo apt install ros-$distro-ros-type-introspection.
I cannot help you further without more information on your build environment (OS, versions, etc).
Comment by Felix394 on 2018-08-21:
Ok shame on me, I was completely stumped staring at my monitor like wtf
Comment by Felix394 on 2018-08-21:
Thank you so much !!
Comment by gvdhoorn on 2018-08-21:
Your question had me thoroughly confused, as I assumed you knew how to set this all up.
From #q299711 I had assumed (perhaps wrongly) that you were a bit more experienced with all this -- writing middleware bridges is not typically a task for first-timers.


Q:

Ros memory usage

I i'm trying to use an old c++ library of a task planner in ROS. I've tested the library outside ROS and it's works fine. Using Valgrind I can see a lot of memory leaks, but it's Ok, as I say everything works and pass sucessfully the test battery.
The problem is when I call the same functions in a ROS node: the program crashes when I delete the memory of a pointer
*** Error in `./devel/lib/task_executor/task_executor': free(): invalid next size (fast): 0x0000000001a0cf40 ***

Using Valgrind it gives me this last error before the stacktrace
valgrind: m_mallocfree.c:304 (get_bszB_as_is): Assertion 'bszB_lo == bszB_hi' failed.
valgrind: Heap block lo/hi size mismatch: lo = 160, hi = 0.
This is probably caused by your program erroneously writing past the
end of a heap block and corrupting heap metadata.  If you fix any
invalid writes reported by Memcheck, this assertion failure will
probably go away.  Please try that before reporting this as a bug.

And literally the only changes between the compilation that works and the other that crashes is that in the first I use Make manually and in the other I compile with catkin.
I'm missing something about ROS and his memory usage and I need some orientation.
Thanks.
ps. The code of the function that contains the delete
bool parse(string domain, string problem){

  if(domain.length() == 0){
    ROS_INFO_STREAM( "Error: Undefined domain file." << endl);
    return true;
  }

  if(problem.length() == 0 ){
    ROS_INFO_STREAM( "Error: Undefined problem file." << endl);
    return true;
  }

  parser_api = new PAPI();
  try{
    parser_api->parse(domain.c_str(),problem.c_str(),true);
  }
  catch(exception &e){
     ROS_INFO_STREAM( "Exception caught!: " << e.what() << endl);
  }
  catch(...) {
    ROS_INFO_STREAM( "Exception caught!: ??" << endl);
  }
  bool errors = parser_api->errors;
  delete parser_api;
  return errors;
}

Originally posted by Leontes on ROS Answers with karma: 21 on 2016-01-19
Post score: 1

A:

ROS does not have any special memory usage patterns that would be causing this.
The presence of memory leaks in your planning library suggests that it may also be overwriting memory elsewhere. You should check your valgrind results for out-of-bouds accesses.
Running your program in GDB and getting a backtrace may also give you a more precise crash location.

Originally posted by ahendrix with karma: 47576 on 2016-01-19
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Leontes on 2016-01-20:
I've fixed one by one, every memory leak, and It works now.


Q:

Subscriber function not being called?

Here is my code
#include <iostream>
#include "ros/ros.h"
#include "std_msgs/Empty.h"
#include "std_msgs/Int32.h"
#include "std_msgs/Float32.h"
#include "geometry_msgs/Twist.h"
#include "ardrone_autonomy/Navdata.h"

#include "std_msgs/String.h"
#include <sstream>

int     state = 1, y = 1;//, battery, rotX, rotY, rotZ;

void callBack(const ardrone_autonomy::Navdata::ConstPtr& data) {
    state = data->state;
    y = 2;
}

int main(int argc, char **argv)
{
ros::init(argc, argv, "ardrone_fly");

ros::NodeHandle ardrone;

ros::NodeHandle output("output");
ros::Publisher pub_t = ardrone.advertise<std_msgs::Empty>("/ardrone/takeoff",1000);
ros::Publisher pub_l = ardrone.advertise<std_msgs::Empty>("/ardrone/land",1000);
ros::Publisher pub_f = ardrone.advertise<geometry_msgs::Twist>("/cmd_vel",1000);
ros::Publisher pub_s = ardrone.advertise<std_msgs::String>("state",1000);

ros::Subscriber sub = ardrone.subscribe<ardrone_autonomy::Navdata>("/ardrone/navdata",1,callBack);

std_msgs::Empty emp;
int x;

ros::Rate loop_rate(50);

std::stringstream ss;
std_msgs::String state_s;

while(ros::ok()) {
    //ROS_INFO("state: %d  ",state);

    ss << "State is: " << state << " y: " << y;// << " Battery is: " << battery;
    state_s.data = ss.str();

    pub_s.publish(state_s);

    if(state==2) {
        pub_t.publish(emp);
    }
    else
        pub_f.publish(msg);

    loop_rate.sleep();
}

pub_l.publish(emp);

ros::spin();

return 0;
 }

When i run this code, the callBack function is not being called, although rostopic echo /ardrone/navdata is showing that data is received. What is going wrong?

Originally posted by Ameer Hamza Khan on ROS Answers with karma: 96 on 2015-11-01
Post score: 0

A:

For the callback to be called, ros::spin() or ros::spinOnce() have to be called (for the simple single threaded case). In your code, this is missing from your while(ros::ok()) loop. The spin() call only gets called when you abort your program (as soon as ros::ok() returns false).
See Callbacks and Spinning. You're basically looking at the second option and should call execute ros::spinOnce inside your loop, for instance like this:
while(ros::ok()) {
    ros::spinOnce();
  
    //ROS_INFO("state: %d  ",state);

    ss << "State is: " << state << " y: " << y;// << " Battery is: " << battery;
    state_s.data = ss.str();

    pub_s.publish(state_s);

    if(state==2) {
        pub_t.publish(emp);
    }
    else
        pub_f.publish(msg);

    loop_rate.sleep();
}

Originally posted by Stefan Kohlbrecher with karma: 24361 on 2015-11-01
This answer was ACCEPTED on the original site
Post score: 1


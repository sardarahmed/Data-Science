Q:

Executing Trajectories Generated by Descartes on Either ABB or FANUC Arm

I've been following the descartes tutorial here:
http://wiki.ros.org/descartes/Tutorials/Getting%20Started%20with%20Descartes
I made a few changes, namely I used the descartes_moveit::IkFastMoveitStateAdapter in lieu of MoveitStateAdapter. The other change, which is the one I'm struggling with, is that I'm not seeing a topic called "joint_trajectory_action", which was alluded to in this thread:
https://answers.ros.org/question/199400/solved-how-do-we-transmit-trajectories-to-our-abb-irb-140-using-the-abb-package/
I do, however, have a topics called "/execute_trajectory/cancel", "/execute_trajectory/goal" and a few others. These topics have type moveit_msgs::ExecuteTrajectoryAction, so when trying to modify the line:
  actionlib::SimpleActionClient<control_msgs::FollowJointTrajectoryAction> ac("joint_trajectory_action", true);

and make it:
actionlib::SimpleActionClient<moveit_msgs::ExecuteTrajectoryAction> ac("execute_trajectory", true);

I get the following compilation error:
/home/rnd/catkin_ws/src/motiontest_core/src/motion_test.cpp: In function ‘bool executeTrajectory(const JointTrajectory&)’:
/home/rnd/catkin_ws/src/motiontest_core/src/motion_test.cpp:265:19: error: no matching function for call to ‘actionlib::SimpleActionClient<moveit_msgs::ExecuteTrajectoryAction_<std::allocator<void> > >::sendGoal(moveit_msgs::ExecuteTrajectoryAction&)’
   ac.sendGoal(goal);
                   ^
In file included from /home/rnd/catkin_ws/src/motiontest_core/src/motion_test.cpp:6:0:
/opt/ros/kinetic/include/actionlib/client/simple_action_client.h:317:6: note: candidate: void actionlib::SimpleActionClient<ActionSpec>::sendGoal(const Goal&, actionlib::SimpleActionClient<ActionSpec>::SimpleDoneCallback, actionlib::SimpleActionClient<ActionSpec>::SimpleActiveCallback, actionlib::SimpleActionClient<ActionSpec>::SimpleFeedbackCallback) [with ActionSpec = moveit_msgs::ExecuteTrajectoryAction_<std::allocator<void> >; actionlib::SimpleActionClient<ActionSpec>::Goal = moveit_msgs::ExecuteTrajectoryGoal_<std::allocator<void> >; actionlib::SimpleActionClient<ActionSpec>::SimpleDoneCallback = boost::function<void(const actionlib::SimpleClientGoalState&, const boost::shared_ptr<const moveit_msgs::ExecuteTrajectoryResult_<std::allocator<void> > >&)>; typename ActionSpec::_action_result_type::_result_type = moveit_msgs::ExecuteTrajectoryResult_<std::allocator<void> >; actionlib::SimpleActionClient<ActionSpec>::SimpleActiveCallback = boost::function<void()>; actionlib::SimpleActionClient<ActionSpec>::SimpleFeedbackCallback = boost::function<void(const boost::shared_ptr<const moveit_msgs::ExecuteTrajectoryFeedback_<std::allocator<void> > >&)>; typename ActionSpec::_action_feedback_type::_feedback_type = moveit_msgs::ExecuteTrajectoryFeedback_<std::allocator<void> >]
 void SimpleActionClient<ActionSpec>::sendGoal(const Goal & goal,
      ^
/opt/ros/kinetic/include/actionlib/client/simple_action_client.h:317:6: note:   no known conversion for argument 1 from ‘moveit_msgs::ExecuteTrajectoryAction {aka moveit_msgs::ExecuteTrajectoryAction_<std::allocator<void> >}’ to ‘const Goal& {aka const moveit_msgs::ExecuteTrajectoryGoal_<std::allocator<void> >&}’
motiontest_core/CMakeFiles/motion_test.dir/build.make:62: recipe for target 'motiontest_core/CMakeFiles/motion_test.dir/src/motion_test.cpp.o' failed
make[2]: *** [motiontest_core/CMakeFiles/motion_test.dir/src/motion_test.cpp.o] Error 1
CMakeFiles/Makefile2:19040: recipe for target 'motiontest_core/CMakeFiles/motion_test.dir/all' failed
make[1]: *** [motiontest_core/CMakeFiles/motion_test.dir/all] Error 2
Makefile:138: recipe for target 'all' failed
make: *** [all] Error 2
Invoking "make -j4 -l4" failed

I'm wondering what the correct action server is to publish to? I've tried this using the fanuc_experimental and the abb package with no luck. I'm also wondering what message type to use, given the correct action server?
Any help would be appreciated!

Originally posted by jbeck28 on ROS Answers with karma: 101 on 2018-05-17
Post score: 0

A:

I'm wondering what the correct action server is to publish to?

No. That is a MoveIt action server, not compatible with what the Descartes tutorials expect.
Are you running any drivers for the robots you mention? If not, that would be why you don't see those action servers.

And just a note: don't expect too stellar performance when executing those Descartes trajectories with fanuc_driver, fanuc_driver_exp or abb_driver. Those drivers will not perform very well with dense trajectories.

Edit:

Are there better drivers that are more well-suited to dense trajectories?

The issue is not necessarily with these specific drivers: industrial robot controllers tend to struggle with dense trajectories in general. This seems to be consequence of the way they are designed and function.
That said, the problem is aggrevated by using a streaming approach. While that allows for (potentially) infinite trajectories, it also means that the controller cannot use any form of look-ahead, which industrial controllers typically do.
Both fanuc_driver and fanuc_driver_exp are streaming drivers. abb_driver is a download driver, so the controller can do some look-ahead, but it's still not great.
At the moment for Fanucs there isn't really a good way around this issue: they just lack proper interfaces for external control. This may change, but I wouldn't wait for it. There is some development in fanuc_driver_exp (specifically gavanderhoorn/fanuc_driver_exp#12 which could improve things slightly, but it seems to trade motion smoothness for accuracy (at least for now).
As to ABB: ABB has recently released abb_libegm and abb_librws. Those are two building block for creating a ROS driver for EGM compatible robots (250 Hz joint space & Cartesian control interface). Coupled with a proper controller this would allow for optimal performance of ABB robots when controlled from ROS. It's not there yet though.

Edit2: one other option would be to take the output of Descartes and feed it to something like fanuc_post_processor. This would generate a native Fanuc TP program that can then be uploaded to the controller (using FTP). This can result in performant motion, but would not be on-line and would run into the limitations that all TP programs have (ie: maximum nr of poses, maximum size & length, etc).

Originally posted by gvdhoorn with karma: 86574 on 2018-05-17
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by jbeck28 on 2018-05-18:
Thank you very much, I embarrassingly wasn't using drivers. Are there better drivers that are more well-suited to dense trajectories?
Comment by jbeck28 on 2018-05-25:
Before I post another question regarding Descartes in another forum post, I wanted to thank you for your time. Your explanation was enlightening. It's helpful to know the limitations of industrial robots and Descartes as I'm looking to utilize the two for 3D printing and polishing Freeform optics.
Comment by gvdhoorn on 2018-05-25:
No problem.
I'd like the situation with Fanucs to be different, and it may improve in the future, but for now it is what it is. Off-line program generation and upload will for now always be superior to real-time, on-line control.


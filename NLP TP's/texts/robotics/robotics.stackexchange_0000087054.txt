Q:

How to hook a new IDL generator

I'm trying to understand how to add a new generator for the Ada language. I've been trying to make sense of the different CMake files in the different packages, ament*, rosidl*, etc. I've also checked the case of the rosidl_java_generator. Still, I have a general idea of what's happening but I'm failing to pin down the details. Two questions:
I see that the java case requires patching the CMakeLists.txt and package.xml of the rosidl_default_generators package. Is this mandatory? I.e., cannot one add a new generator in a new package without having to patch other people's packages?
Be it possible or not, I'm failing to understand when/how exactly a new generator is called and what information it receives. I guess at some point dependencies are added to the .msg files on some cmake targets, but I have not found where. Any help with these questions will be much appreciated, thanks.

Originally posted by amosteo on ROS Answers with karma: 43 on 2018-05-21
Post score: 0

A:

I see that the java case requires patching the CMakeLists.txt and package.xml of the rosidl_default_generators package. Is this mandatory? I.e., cannot one add a new generator in a new package without having to patch other people's packages?

That should not be necessary anymore. I don't know which exact change you are referring to but I assume adding the new generator as a dependency? With REP 149 group dependencies were added and those are now being used by the message generators. Using those it should be possible to create a new package containing a message generator and declare the group membership in that package in order to be picked up during the build and being processed before message packages.
In general whenever a message package calls rosidl_generate_interfaces all registered message generators are being run. That happens by including the CMake file each message generator has registered as an extension, e.g. https://github.com/ros2/rosidl/blob/cfedd4afb8383965590f3234c169c6839f16468c/rosidl_generator_cpp/cmake/register_cpp.cmake#L20
Each message generator decides how it wants to perform the code generation. Most of them are invoking Python to generate files based on templates and the msg/srv files passed. The CMake code for it is pretty lengthy since it also needs to track what files are expected to be generated and what files are involved in that (in order to regenerate files if and only if any of the involved files changes). Some generators also additionally run code linter on the generated code. E.g. https://github.com/ros2/rosidl/blob/master/rosidl_generator_cpp/cmake/rosidl_generator_cpp_generate_interfaces.cmake
I hope this give a high level overview of the process. Please feel free to add more concrete questions.

Originally posted by Dirk Thomas with karma: 16276 on 2018-05-21
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by amosteo on 2018-05-22:
Thanks, Dirk, this helps me greatly in putting all pieces together.
In the example you link to, the macro ament_register_extension is used. What if one is using plain CMake packages? I was trying to stay away from ament until colcon is in place.
Comment by Dirk Thomas on 2018-05-22:
The extension registry is based on the ament resource index. At the end it is stored in files (often empty ones) in the file system. If you don't want to use the simple CMake functions provided by ament you could implement the same functionality yourself.
Comment by Dirk Thomas on 2018-05-22:
Regarding "trying to stay away from ament until colcon is in place": ament_cmake will stay around just as it is - that part represents the build system. Only the build tool part (aka ament_tools) will be substituted by colcon. Nothing in the CMake code of ROS 2 packages is going to change.
Comment by amosteo on 2018-05-23:
Ah, great. Then I will take the easy route, thanks.
Comment by esteve on 2018-06-10:
Wasn't the mechanism in REP-149 only used for typesupports? It seems to me that messages still depend on rosidl_default_generators, hence the patch to add the ros2_java generator.
Comment by Dirk Thomas on 2018-06-11:
The group dependencies are being used in a variety of cases - not only for typesupport. E.g. https://github.com/ros2/ros1_bridge/blob/11d75283154c1a4f11af0e10ac2b3c7c18e268f3/package.xml#L38
Comment by esteve on 2018-06-13:
In that case, is still necessary to explicitly list the generators in rosidl_default_generators? Are they automatically discovered thanks to REP-149? https://github.com/ros2/rosidl_typesupport/blob/master/rosidl_default_generators/package.xml#L15-L17
Comment by Dirk Thomas on 2018-06-13:
No, it isn't necessary to explicitly list them in rosidl_default_generators. If the package is in the workspace it is being processed before the rosidl_default_generators due to the group membership.
Comment by esteve on 2018-06-14:
I have commented out rosidl_generator_py in rosidl_default_generators/CMakeLists.txt and rosidl_default_generators/package.xml to test this and despite the Python generator being in the workspace, no Python code for messages is generated. Is there anything I'm missing?
Comment by Dirk Thomas on 2018-06-14:
You are right - the generators themselves don't have any group membership atm.


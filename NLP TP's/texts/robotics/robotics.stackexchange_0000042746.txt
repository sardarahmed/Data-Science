Q:

"thin clients" communicating with ROS

One of my use-cases for ROS is that I'd like to have a 'thin client' on OS X that can communicate with our Ubuntu ROS master for some simple tasks: perhaps calling a service or querying a parameter from the parameter server.
But the overhead of installing and configuring ROS on our OS X machine is too much, especially because we're trying to build a releasable binary that is pretty much drag-and-drop install on OS X.
The first solution that comes to mind for me is a TCP server running in a ROS node on the Ubuntu machine that provides a limited interface to the ROS world for thin clients to call. Sort of like what ROSBridge tries to do for a web client. Do you know of any mature stacks that implement something like that? Is the idea of running a TCP server in a ROS node unpalatable / full of pitfalls? A sort of standardized interface to ROS for non-ROS clients seems like a common use case, but I don't have a great idea of the technical implications.

Originally posted by isherman on ROS Answers with karma: 132 on 2012-07-27
Post score: 1

Original comments
Comment by Mac on 2012-07-27:
The extreme basics of ROS (generating and sending messages, for example) build just fine on OS X, although I agree that it's a bit messy, and not necessarily suitable for straightaway deployment.
Comment by isherman on 2012-07-31:
@Mac: I do have bare-bones ROS building on OS X, but it takes about an hour and requires various bits of troubleshooting to make it all the way through. If you have any shortcuts I'd be curious.
Comment by isherman on 2012-07-31:
@JonMace, @ipso: I was nervous about the stability and maintenance of ROSBridge, but I was only aware of v1. v2 looks like it could do the trick. Exciting!

A:

Rosbridge is a perfect solution.  You can write a client that connects to rosbridge using any language that has a websocket library.  Websocket is a poor choice of name for the protocol because it implies use by web browsers only.  Sure, it was designed for web browsers, but the protocol itself is just a layer on top of TCP and provides a number of useful properties.
As for the rosbridge ROS node - we have just released rosbridge v2.0 beta, which is the 'industrial strength' rosbridge.  It has a much more robust server implementation and a more well defined protocol.  We haven't yet officially released v2.0 on ROS.org so the information on the ROS wiki is still for v1.0.  The most up to date resource is rosbridge.org (for both v1.0 and v2.0 of rosbridge).  The source code repository for v2.0 is here.
To give you the gist of how rosbridge works, you can check out some example rosbridge commands on this page.
To actually write a client that connects to rosbridge, all you need is a websockets library.  For example, the following python client connects and calls a ROS service.  In the example we use the ws4py websocket client library.
from json import dumps
from ws4py.client.threadedclient import WebSocketClient

class GetLoggersClient(WebSocketClient):

     def get_loggers(self):
         msg = {'op': 'call_service', 'service': '/rosout/get_loggers'}
         self.send(dumps(msg))

     def opened(self):
         print "Connection opened..."
         self.get_loggers()

     def closed(self, code, reason=None):
         print code, reason

     def received_message(self, m):
         print "received", m

if __name__=="__main__":
     try:
         ws = GetLoggersClient('ws://127.0.0.1:9090/')
         ws.connect()
     except KeyboardInterrupt:
         ws.close()

Originally posted by Jon Mace with karma: 431 on 2012-07-27
This answer was ACCEPTED on the original site
Post score: 4


Q:

Loading an urdf model from the parameter server with hydro

Migrating from groovy to hydro, I encountered the following problem:
When I try to load an urdf model from the parameter server with the following code:
urdf::Model urdfModel;
if(!nh.hasParam(urdfName))
{
    return;
}
if(!urdfModel.initParam(urdfName))
{
    return;
}

where urdfName is a std::string (e.g., "/robot_description"), using hydro the program dies and I receive the following error message (with gdb):
Program received signal SIGILL, Illegal instruction.
0x00007ffff4e6af0f in std::vector<float, std::allocator<float> >::_M_insert_aux(__gnu_cxx::__normal_iterator<float*, std::vector<float, std::allocator<float> > >, float const&) ()
   from /usr/lib/libpcl_common.so.1.7
(gdb) bt
#0  0x00007ffff4e6af0f in std::vector<float, std::allocator<float> >::_M_insert_aux(__gnu_cxx::__normal_iterator<float*, std::vector<float, std::allocator<float> > >, float const&) ()
   from /usr/lib/libpcl_common.so.1.7
#1  0x00007ffff3005cbb in ?? () from /opt/ros/hydro/lib/liburdfdom_world.so
#2  0x00007ffff2fff447 in ?? () from /opt/ros/hydro/lib/liburdfdom_world.so
#3  0x00007ffff2ff3d97 in urdf::parseURDF(std::string const&) () from /opt/ros/hydro/lib/liburdfdom_world.so
#4  0x00007ffff32503a3 in urdf::Model::initString(std::string const&) () from /opt/ros/hydro/lib/liburdf.so
#5  0x00007ffff324f60e in urdf::Model::initParam(std::string const&) () from /opt/ros/hydro/lib/liburdf.so

The same code and urdf model work fine with groovy.
I am running Lubuntu 12.10 with ROS hydro (urdf 1.10.18, urdfdom 0.2.10).
Edit:
I am using an i7 CPU. The output of valgrind is:
vex amd64->IR: unhandled instruction bytes: 0xC5 0xFA 0x10 0x2 0xC5 0xFA 0x11 0x0
==28164== valgrind: Unrecognised instruction at address 0x7bd2f0f.
==28164==    at 0x7BD2F0F: std::vector<float, std::allocator<float> >::_M_insert_aux(__gnu_cxx::__normal_iterator<float*, std::vector<float, std::allocator<float> > >, float const&) (in /usr/lib/libpcl_common.so.1.7.0)
==28164==    by 0x9A13CBA: ??? (in /opt/ros/hydro/lib/liburdfdom_world.so)
==28164==    by 0x9A0D446: ??? (in /opt/ros/hydro/lib/liburdfdom_world.so)
==28164==    by 0x9A01D96: urdf::parseURDF(std::string const&) (in /opt/ros/hydro/lib/liburdfdom_world.so)
==28164==    by 0x97C83A2: urdf::Model::initString(std::string const&) (in /opt/ros/hydro/lib/liburdf.so)
==28164==    by 0x97C760D: urdf::Model::initParam(std::string const&) (in /opt/ros/hydro/lib/liburdf.so)
==28164==    by 0x7703F0A: <my_code>
==28164== Your program just tried to execute an instruction that Valgrind
==28164== did not recognise.  There are two possible reasons for this.
==28164== 1. Your program has a bug and erroneously jumped to a non-code
==28164==    location.  If you are running Memcheck and you just saw a
==28164==    warning about a bad jump, it's probably your program's fault.
==28164== 2. The instruction is legitimate but Valgrind doesn't handle it,
==28164==    i.e. it's Valgrind's fault.  If you think this is the case or
==28164==    you are not sure, please let us know and we'll try to fix it.
==28164== Either way, Valgrind will now raise a SIGILL signal which will
==28164== probably kill your program.
==28164== 
==28164== Process terminating with default action of signal 4 (SIGILL)
==28164==  Illegal opcode at address 0x7BD2F0F
==28164==    at 0x7BD2F0F: std::vector<float, std::allocator<float> >::_M_insert_aux(__gnu_cxx::__normal_iterator<float*, std::vector<float, std::allocator<float> > >, float const&) (in /usr/lib/libpcl_common.so.1.7.0)
==28164==    by 0x9A13CBA: ??? (in /opt/ros/hydro/lib/liburdfdom_world.so)
==28164==    by 0x9A0D446: ??? (in /opt/ros/hydro/lib/liburdfdom_world.so)
==28164==    by 0x9A01D96: urdf::parseURDF(std::string const&) (in /opt/ros/hydro/lib/liburdfdom_world.so)
==28164==    by 0x97C83A2: urdf::Model::initString(std::string const&) (in /opt/ros/hydro/lib/liburdf.so)
==28164==    by 0x97C760D: urdf::Model::initParam(std::string const&) (in /opt/ros/hydro/lib/liburdf.so)
==28164==    by 0x7703F0A: <my_code>
==28164== 
==28164== HEAP SUMMARY:
==28164==     in use at exit: 414,808 bytes in 6,624 blocks
==28164==   total heap usage: 13,630 allocs, 7,006 frees, 807,298 bytes allocated
==28164== 
==28164== LEAK SUMMARY:
==28164==    definitely lost: 4 bytes in 1 blocks
==28164==    indirectly lost: 0 bytes in 0 blocks
==28164==      possibly lost: 148,127 bytes in 1,866 blocks
==28164==    still reachable: 266,677 bytes in 4,757 blocks
==28164==         suppressed: 0 bytes in 0 blocks
==28164== Rerun with --leak-check=full to see details of leaked memory
==28164== 
==28164== For counts of detected and suppressed errors, rerun with: -v
==28164== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)

I am wondering, why the code runs with groovy but not with hydro. Have there been made any changes that could explain this behavior?

Originally posted by alice on ROS Answers with karma: 11 on 2014-06-05
Post score: 1

Original comments
Comment by bchr on 2014-06-05:
+1, and memory corruption is more likely. You may want to run valgrind on your code, but it might not be able to find the source of the error.

A:

Illegal instruction could point to your program trying to use some feature not supported by your CPU (or some serious memory corruption). What type of CPU are you using?

Originally posted by gvdhoorn with karma: 86574 on 2014-06-05
This answer was ACCEPTED on the original site
Post score: 1


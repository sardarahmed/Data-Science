Q:

Create Topic using an existing library C++

I am taking part in a robotics project that is introducing ROS into its development.
I have an existing library of classes that are used to pass information.  My task is to integrate this library into ROS messages.
I am unable to create a publisher using   ros::Publisher controls_pub = nForPublishing.advertise<communication::messages>("controlChannel", 1000);  where communication::messages is the library namespace/class.
Below is the compiler error message I'm getting:
In file included from /home/user/ros_catkin_ws/install_isolated/include/ros/serialization.h:37:0,
                 from /home/user/ros_catkin_ws/install_isolated/include/ros/publisher.h:34,
                 from /home/user/ros_catkin_ws/install_isolated/include/ros/node_handle.h:32,
                 from /home/user/ros_catkin_ws/install_isolated/include/ros/ros.h:45,
                 from /home/user/new_catkin_ws/src/demo_robot_ros_driver/src/demo_robot_ros_driver.cpp:1:
/home/user/ros_catkin_ws/install_isolated/include/ros/message_traits.h: In instantiation of ‘static const char* ros::message_traits::MD5Sum<M>::value(const M&) [with M = communications::messages*]’:
/home/user/ros_catkin_ws/install_isolated/include/ros/message_traits.h:255:104:   required from ‘const char* ros::message_traits::md5sum(const M&) [with M = communications::messages*]’
/home/user/ros_catkin_ws/install_isolated/include/ros/publisher.h:112:7:   required from ‘void ros::Publisher::publish(const M&) const [with M = communications::messages*]’
/home/user/new_catkin_ws/src/demo_robots_ros_driver/src/demo_robots_ros_driver.cpp:68:34:   required from here
/home/user/ros_catkin_ws/install_isolated/include/ros/message_traits.h:126:34: error: request for member ‘__getMD5Sum’ in ‘m’, which is of pointer type ‘communications::messages* const’ (maybe you meant to use ‘->’ ?)
     return m.__getMD5Sum().c_str();

From the tutorials, I understand how ROS Topics/Messages are created (MSG files).  This is not practical in our situation as the library is quite large and undergoing further development.  catkin_make pre-processes the MSG files to create header files.
It is not practical to manually create MSG files for each class, due to maintenance issues, nor is it desirable to create a parsing program that generates MSG files from the library's code (ie rosJava).
As it stands, all the classes have a to_string() method which I can use to serialise the objects, but I would like to have topics based on class structures not delimited strings.
Would anyone be able to point me to a tutorial that explains how I can incorporate an existing library class into a topic?

Originally posted by Nap on ROS Answers with karma: 302 on 2014-02-09
Post score: 0

A:

If you're writing a library for integration into ROS, exposing most of the library's API via topics is probably not the right design decision.
If your library consists mostly of an implementation of a specific algorithm, you probably want to expose it as a C++ library, and then use that from within other nodes.
If you already have interface/message types and you'd like to adapt them for ROS, you can read about the process here: http://wiki.ros.org/roscpp/Overview/MessagesSerializationAndAdaptingTypes#Adapting_C.2B-.2B-_Types%3C/p%3E . The only disadvantage to this approach is that, while you'll be able to pass your existing messages over ROS topics, you won't be able to communicate with any of the existing ROS nodes or use some of the introspection tools like rqt_plot or rostopic echo.
When you do expose a ROS interface, authors usually write a wrapper node that exposes a minimal, standardized interface using mostly standard message types.
A few examples of this:

AMCL is a localization algorithm. It's implemented as a library that implements the algorithm, and then a ROS node that receives sensor_msgs/LaserScan, converts it into the proper internal format and makes the proper library calls, and then converts the result and publishes it as a standard TF transform representing the position of the robot.
Vision and perception algorithms are usually implemented as nodes that subscribe to an ImageTransport stream, and publish custom messages that represent the percept that they're extracting.
MoveIt! is a motion planning library that is implemented as C++ and python libraries which are then used from within other nodes that need to do complex planning.

Originally posted by ahendrix with karma: 47576 on 2014-02-10
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by Nap on 2014-02-10:
thnx 4 ur comments ahendrix. The library has already been written/implemented with robots used here. I've been asked to provide a new interface via ROS.  I don't want rewrite the library (difficult to sync with main project), I just want to use it.
Comment by Nap on 2014-02-10:
I'm actually just translating messages from our existing work into a ROS compatible format.  The library defines the messages (it's not the algorithm).
I would like to have Topics that line up with our own message types.
Comment by ahendrix on 2014-02-10:
The trouble here is that anything that passes over a topic in ROS has to have serialization and deserialization functions, an MD5 sum, and possibly a other things. You can either try to add those to your existing messages, write a conversion layer, or port your internal data types to ROS messages.
Comment by ahendrix on 2014-02-10:
If your existing software is open-source, I could take a look and possibly provide some more specific guidance.
Comment by Nap on 2014-02-10:
Serialisation is how I'm doing it now, using a function that returns a string representation which I send across.  What I would like to do is create ROS messages that mirror our structures.  However the 'normal' way in ROS starts with a .msg text file, which is highly undesirable in this case.
Comment by ahendrix on 2014-02-10:
Strings are possibly the worst thing you can do, because you lose all of the type information and any hope of being compatible with everything else in ROS. I strongly suggest that you write a wrapper or interface layer that converts your message types to ROS messages.
Comment by demmeln on 2014-02-11:
You can adapt your datatypes to serialize to ROS without conversion to message objects. However you would usually still start with a msg file that defines the resulting serialized message format first. http://wiki.ros.org/roscpp/Overview/MessagesSerializationAndAdaptingTypes#Adapting_C.2B-.2B-_Types
Comment by Nap on 2014-02-11:
demmeln, thnx for the link.  I will have a good read of it and come back.
Comment by ahendrix on 2014-02-11:
Nice link @demmeln! I've added it to my answer.
Comment by dornhege on 2014-02-11:
I think that you still might go in a direction that is not intended. If you serialize your types manually like that the part of ROS that you'll be using is only the middleware. You messages, etc. would be incompatible with the rest of the ROS universe. You'd be missing out on a lot of features.
Comment by dornhege on 2014-02-11:
Especially in a robotics library that you have it might be very desirable to just "plug in" with any other ROS component. If you can give some details on what functionality/messages you have it might be easier to advise on that.
Comment by demmeln on 2014-02-11:
@dornhege, I completly agree. It depends a bit on what the author means by "integration into ROS". Depending on the kind of data, standard messages might just not be an option. Otoh I don't see how he hopes to serialize all classes without maintainig message files / serialization code manually.
Comment by dornhege on 2014-02-11:
I don't see why one would want to serialize all classes. Synchronizing everything looks like a huge overhead as it's basically a expose-all-interface. Without something concrete this is guess-work.


Q:

Where is the main function in Rosjava

Hello,
rosjava is still very mysterious for me, maybe because I'm also not very familiar with java yet.
I understand how the simple listener talker are working but the thing is that there is no main function like in C++ that will run the program and create all the instances. Now I have both classes talker.java and listener.java both have their onStart methods which implement a cancellable loop and keep sending/listening. Running them with rosrun is easy but
My question is : who calls these functions onStart??
and what is this parameter : onStart(final ConnectedNode connectedNode) where does it come from.
I'm asking this because I want to run such a code from eclipse but it keeps saying there is no main function defined.
This is the talker.java code:
package com.github.rosjava_catkin_package_a.my_pub_sub_tutorial;

import org.ros.concurrent.CancellableLoop;
import org.ros.namespace.GraphName;
import org.ros.node.AbstractNodeMain;
import org.ros.node.ConnectedNode;
import org.ros.node.NodeMain;
import org.ros.node.topic.Publisher;

/**
 * A simple {@link Publisher} {@link NodeMain}.
 */
public class Talker extends AbstractNodeMain {

  @Override
  public GraphName getDefaultNodeName() {
    return GraphName.of("rosjava/talker");
  }

  @Override
  public void onStart(final ConnectedNode connectedNode) {
    final Publisher<std_msgs.String> publisher =
        connectedNode.newPublisher("chatter", std_msgs.String._TYPE);
    // This CancellableLoop will be canceled automatically when the node shuts
    // down.
    connectedNode.executeCancellableLoop(new CancellableLoop() {
      private int sequenceNumber;

      @Override
      protected void setup() {
        sequenceNumber = 0;
      }

      @Override
      protected void loop() throws InterruptedException {
        std_msgs.String str = publisher.newMessage();
        str.setData("Hello world! " + sequenceNumber);
        publisher.publish(str);
        sequenceNumber++;
        Thread.sleep(1000);
      }
    });
  }
}

thanks

Originally posted by Mehdi. on ROS Answers with karma: 3339 on 2014-03-20
Post score: 1

A:

I did something similar - I was creating a library class, but wanted a static main so that I could test the script. Basically you can use RosRun which will run the onStart, but if you want to do more than just that, or run multiple onStart's, break that down as you need. I then used the gradle application plugin with the installApp target to create an easy to use script for me.
I didn't actually try to run from inside eclipse though, just from the command line.
The build.gradle:
dependencies {
  compile 'org.ros.rosjava_core:rosjava:[0.1,)'
  compile 'org.ros.rosjava_messages:rocon_std_msgs:[0.7,)'
  compile project(':rosjava_utils')
}

apply plugin:'application'
mainClassName = 'com.github.robotics_in_concert.rocon_rosjava_core.master_info.MasterInfo'

defaultTasks 'installApp', 'publishMavenJavaPublicationToMavenRepository'

The java class:
package com.github.robotics_in_concert.rocon_rosjava_core.master_info;

/*****************************************************************************
** Imports
*****************************************************************************/

import java.util.concurrent.TimeoutException;

import org.ros.namespace.GraphName;
import org.ros.node.AbstractNodeMain;
import org.ros.node.ConnectedNode;
import org.ros.node.DefaultNodeMainExecutor;
import org.ros.node.NodeConfiguration;
import org.ros.node.NodeMainExecutor;
import org.ros.exception.RosRuntimeException;
import org.ros.internal.loader.CommandLineLoader;

import com.github.robotics_in_concert.rocon_rosjava_core.rosjava_utils.ListenerException;
import com.github.robotics_in_concert.rocon_rosjava_core.rosjava_utils.ListenerNode;
import com.github.robotics_in_concert.rocon_rosjava_core.rosjava_utils.RosTopicInfo;
import com.google.common.collect.Lists;

/*****************************************************************************
** MasterInfo
*****************************************************************************/

public class MasterInfo extends AbstractNodeMain {

    private ListenerNode<rocon_std_msgs.MasterInfo> masterInfoListener;

    public MasterInfo() {
        this.masterInfoListener = new ListenerNode<rocon_std_msgs.MasterInfo>();
    }
    @Override
    public void onStart(final ConnectedNode connectedNode) {
        RosTopicInfo topicInformation = new RosTopicInfo(connectedNode);
        String topicName = topicInformation.findTopic("rocon_std_msgs/MasterInfo");
        this.masterInfoListener.connect(connectedNode, topicName, rocon_std_msgs.MasterInfo._TYPE);
    }

    /**
     * Wait for data to come in. This uses a default timeout
     * set by ListenerNode.
     * 
     * @see ListenerNode
     * @throws InteractionsException : if listener error, timeout or general runtime problem
     */
    public void waitForResponse() throws MasterInfoException {
        try {
            this.masterInfoListener.waitForResponse();
        } catch(ListenerException e) {
            throw new MasterInfoException(e.getMessage());
        } catch(TimeoutException e) {
            throw new MasterInfoException(e.getMessage());
        }
    }

    /****************************************
    ** Getters
    ****************************************/

    @Override
    public GraphName getDefaultNodeName() {
        return GraphName.of("rocon_rosjava_master_info");
    }
    
    public String getName() throws MasterInfoException {
        try {
            if (this.masterInfoListener.getMessage() == null) {
                masterInfoListener.waitForResponse();
            }
        } catch(ListenerException e) {
            throw new MasterInfoException(e.getMessage());
        } catch(TimeoutException e) {
            throw new MasterInfoException(e.getMessage());
        }
        return this.masterInfoListener.getMessage().getName();
    }

    public String getDescription() throws MasterInfoException {
        try {
            if (this.masterInfoListener.getMessage() == null) {
                masterInfoListener.waitForResponse();
            }
        } catch(ListenerException e) {
            throw new MasterInfoException(e.getMessage());
        } catch(TimeoutException e) {
            throw new MasterInfoException(e.getMessage());
        }
        return this.masterInfoListener.getMessage().getDescription();
    }

    public String getIconResourceName() throws MasterInfoException {
        try {
            if (this.masterInfoListener.getMessage() == null) {
                masterInfoListener.waitForResponse();
            }
        } catch(ListenerException e) {
            throw new MasterInfoException(e.getMessage());
        } catch(TimeoutException e) {
            throw new MasterInfoException(e.getMessage());
        }
        return this.masterInfoListener.getMessage().getIcon().getResourceName();
    }

    public String getIconFormat() throws MasterInfoException {
        try {
            if (this.masterInfoListener.getMessage() == null) {
                masterInfoListener.waitForResponse();
            }
        } catch(ListenerException e) {
            throw new MasterInfoException(e.getMessage());
        } catch(TimeoutException e) {
            throw new MasterInfoException(e.getMessage());
        }
        return this.masterInfoListener.getMessage().getIcon().getFormat();
    }
    
    public rocon_std_msgs.Icon getIcon() throws MasterInfoException {
        try {
            if (this.masterInfoListener.getMessage() == null) {
                masterInfoListener.waitForResponse();
            }
        } catch(ListenerException e) {
            throw new MasterInfoException(e.getMessage());
        } catch(TimeoutException e) {
            throw new MasterInfoException(e.getMessage());
        }
        return this.masterInfoListener.getMessage().getIcon();
    }

    /****************************************
    ** Main
    ****************************************/

    public static void main(String argv[]) throws java.io.IOException {
        // Pulling the internals of rosrun to slightly customise what to run
        String[] args = { "com.github.robotics_in_concert.rocon_rosjava_core.master_info.MasterInfo" };
        CommandLineLoader loader = new CommandLineLoader(Lists.newArrayList(args));
        NodeConfiguration nodeConfiguration = loader.build();
        MasterInfo masterInfo = new MasterInfo();
        
        NodeMainExecutor nodeMainExecutor = DefaultNodeMainExecutor.newDefault();
        nodeMainExecutor.execute(masterInfo, nodeConfiguration);
        try {
            masterInfo.waitForResponse();
            System.out.println("MasterInfo : retrieved information [" + masterInfo.getName() + "]");
        } catch(MasterInfoException e) {
            System.out.println("Interactions : error getting roles [" + e.getMessage() + "]");
        }

        // The RosRun way
        //      try {
        //      org.ros.RosRun.main(args);
        //  } catch(RosRuntimeException e) {
        //      System.out.println("Interactions: ros runtime error");
        //  } catch(Exception e) {
        //      System.out.println("Interactions: unknown error");
        //  }
    }       
}

Originally posted by Daniel Stonier with karma: 3170 on 2014-04-09
This answer was ACCEPTED on the original site
Post score: 1


Q:

How can I interpret the documentation of this serviceClient method?

Hello,
I am trying to build a service client.
I went to the reference of the node handle class [here] (http://docs.ros.org/jade/api/roscpp/html/classros_1_1NodeHandle.html#aa3376eeca609c4985255cecfaadcbcc5)
It shows this information to build the client:
ServiceClient ros::NodeHandle::serviceClient  (   const std::string &     service_name,
bool    persistent = false,
const M_string &    header_values = M_string()
)       [inline]
but I found that it works this way:
ServiceClient ros::NodeHandle::serviceClient< service_type>(const std::string &   service_name)
My problem as a newcomer to ROS is how can I get that the < service_type> is a part of the command while it is not written in the class reference?
Should I use another documentation or what?

Originally posted by Biomacs on ROS Answers with karma: 1 on 2016-12-11
Post score: 0

A:

My problem as a newcomer to ROS is how can I get that the < service_type> is a part of the command while it is not written in the class reference?

This is not really a ROS problem, but probably an oversight when you read the documentation for the method.
The ros::NodeHandle::serviceClient(..) method is a template method (from here):
template<class Service >
ServiceClient ros::NodeHandle::serviceClient ( const std::string & service_name,
                                               bool persistent = false,
                                               const M_string & header_values = M_string() 
                                             ) [inline]

Note that the overload you linked to is not the one you actually used (the link is to the template<class MReq, class MRes > variant, the one you used is the one above that takes a single Service template parameter).
The fact that it's templated is perhaps more visible in the header file, linked in the Doxygen docs: here.

I found that it works this way:

ServiceClient ros::NodeHandle::serviceClient< service_type>(const std::string & service_name)

Besides the template argument (service_type in your example), the arguments other than service_name have default values, so that is why your example invocation is also accepted.

Originally posted by gvdhoorn with karma: 86574 on 2016-12-11
This answer was ACCEPTED on the original site
Post score: 0


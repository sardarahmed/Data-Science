Q:

Two cameras (uEye + Kinect)

Hey everyone,
I'd like to record image streams from two cameras at the same time. One is a uEye (using the uEye driver) and the other is a Asus Xtion Pro Kinect-like (using the ROS openni_camera package).
Starting data retrieval nodes for both cameras is not a problem. Displaying one of them with image_view also works. However, I cannot display or record (with rosbag) them both at the same time. The OpenNi will display just fine, but the uEye stops sending data.
I've dug into the code, and the problem seems to be that whenever the OpenNi is active (i.e., being recorded or displayed), the is_GetImageMem method within the libueye_api shared object changes behaviour: It receives a pointer and will change it to the new frame's address. The faulty behaviour results in the pointer not being changed, and indeed the image data at that address does not change either.
Has anyone seen similar behaviour? Or used a uEye camera together with a different camera?
Thanks for any help!
TL;DR: When OpenNi camera is being used, the uEye camera stops generating new frames.

Originally posted by Nikolaus Mayer on ROS Answers with karma: 23 on 2014-09-18
Post score: 1

A:

Try increasing initMemoryPool(4). This will allocate more frame buffers.
The call to is_WaitEvent() is set to timeout after 2*frame_rate. Either decrease your frame rate or increase the timeout.
Play around with the pixel_clock parameter. This affects how the uEye camera interacts with the USB bus.
Have you tried visualizing the uEye camera with the manufacture's demo program while also visualizing the OpenNi camera in ROS? This would eliminate either the ueye ROS driver or the manufacture's driver as the problem.
Edit: Also, run ueyecameramanager in a separate tab. It will give 'camera removed' and 'camera connected' notifications.

Originally posted by kmhallen with karma: 1416 on 2014-09-18
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by Nikolaus Mayer on 2014-09-19:
That works, thanks!
Increasing initMemoryPool(4) didn't change anything, but once I decreased pixel_clock to <20 the uEye immediately started sending data again.
Follow-up question: Decreasing pixel_clock automatically decreased the frame rate, but I could just reset to 30. That a problem?
Comment by kmhallen on 2014-09-19:
Yes. Pixel clock limits the maximum frame rate. Select a pixel clock first, then select a frame rate.


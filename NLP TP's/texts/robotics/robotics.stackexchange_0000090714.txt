Q:

Transforms orphaned frame issue

I am working on a ROS simulation in which I am trying to use a UR5 robot to actively tract, i:e follow, the movements of a turtlebot3.
My problem is when I look at the output from rqt_tf_tree I can see the outout of both robots but the turtlebot is NOT connected to the world frame, as shown in the image below. I'm new to transforms so please correct me if I'm wrong, I need both robots to be connected to a common parent frame inorder to carry out transforms which will enable my desired tracking process.

To deal with this issue, I experimented with creating a fixed frame with the same name as the first frame representing the turtlebot i:e odom. As it turned out, my guess worked out and the frames representing the turtlebot was connected to the world frame. The fixed frame code is contained in the init function below:
#!/usr/bin/env python
import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
from geometry_msgs.msg import Pose
from gazebo_msgs.msg import ModelStates
import tf

class TrackBot():

    def __init__(self, moveit_commander):
        rospy.loginfo("======== init responding")

        self.moveit_commander = moveit_commander
        self.manipulator = moveit_commander.MoveGroupCommander('ur5_bot')

        br = tf.TransformBroadcaster()
        while not rospy.is_shutdown():
            br.sendTransform((0.0, 2.0, 0.0),
                                (0.0, 0.0, 0.0, 1.0),
                                rospy.Time.now(),
                                'odom',
                                'world'
                            )
            # break

        self.test()

    def test(self):
        rospy.loginfo("======== test responding")

        for x in range(10):

            print " ================ Executing Loop-"+str(x)
            pose = self.manipulator.get_random_pose()
            rospy.loginfo(pose.pose)
            self.manipulator.set_pose_target(pose.pose)

            plan = self.manipulator.plan()
            self.manipulator.execute(plan)

            # # manipulator.go(wait=True)
        rospy.loginfo("======== test ending")

    def main(self):
        robot = moveit_commander.RobotCommander()

        try:
            trackbot = TrackBot(moveit_commander)
        except rospy.ROSInterruptException:
            pass

if __name__ == '__main__':
    rospy.init_node('move_group_python_interface_tutorial', anonymous=False)

    TrackBot(moveit_commander).main()

My problems begin after the while not rospy.is_shutdown(): section because it blocks the self.test() , and all other function calls. I understand that it's a while loop and by nature, well, it loops. I included a break statement but when I do that, the turtlebot frames are then NOT attached to the world frame which puts me back at square one.
Can anyone offer a different approach to attaching the turtlebot and world frames OR offer an insight to what I'm doing wrong or missing with my current solution?

Originally posted by sisko on ROS Answers with karma: 247 on 2019-03-01
Post score: 0

A:

Can anyone offer a different approach to attaching the turtlebot and world frames

Use a static_transform_publisher?

Originally posted by gvdhoorn with karma: 86574 on 2019-03-01
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by sisko on 2019-03-01:
I can't believe how ridiculously simply that was.
Thank you.


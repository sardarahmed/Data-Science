Q:

how can I pass pose messages for moving arm in a stright line

Hi,
I am new to moveit. Now I am using moveit commander (python) for moving my 6 DOF arm in a  line where the end points are given say ([0.2,0.2,2.7],[0.2,0.5,2.7]) and I have found a function at here.That is
compute_cartesian_path(self, waypoints, eef_step, jump_threshold, avoid_collisions = True):

I am pass it just like this
a.compute_cartesian_path(([0.2,0.2,2.7],[0.2,0.5,2.7]),0.01,0.1,avoid_collisions = True)

but it is not working
for working this I find that, need to construct a Pose message and pass a list of such objects
my doubt is how can I pass the pose messages to move in a stright line and how can i specify these variables : eef_step, jump_threshold
Thanks
Unais

Originally posted by unais on ROS Answers with karma: 313 on 2013-10-30
Post score: 0

A:

Update: I now see that you meant in python, this is an c++ answer.
Hi Unais,
For starters: http://answers.ros.org/question/74776/cartesian-controller-for-ros/
Constructing a pose message:
#include <tf/transform_broadcaster.h>

// translate roll, pitch and yaw into a Quaternion
double roll     = 0.0;
double pitch    = 0.0;
double yaw      = 1.5707;
tf::Quaternion q;
q.setRPY(roll, pitch, yaw);
geometry_msgs::Quaternion odom_quat;
tf::quaternionTFToMsg(q, odom_quat);

geometry_msgs::Pose pose;
pose.position.x  = 0.0;
pose.position.y  = 0.15;
pose.position.z  = 0.40;
pose.orientation = odom_quat;

You have to push the different poses into a list and pass them to computeCartesianPath(), example:
std::vector< geometry_msgs::Pose > poses;
moveit_msgs::ExecuteKnownTrajectory srv;
srv.request.wait_for_execution = true;
ros::ServiceClient executeKnownTrajectoryServiceClient = node_handle.serviceClient<moveit_msgs::ExecuteKnownTrajectory>("/execute_kinematic_path");

poses.push_back(pose.pose);
poses.push_back(pose2.pose);
poses.push_back(pose3.pose);
poses.push_back(pose4.pose);

group.computeCartesianPath(poses, 0.005, 1000.0, srv.request.trajectory);
executeKnownTrajectoryServiceClient.call(srv);

'eef_step' is the step size used to generate the intermediate points, the 'jump_threshold' is explained here (see last reply): Linear gripper movement. Passing 0.0 for jump_treshold effectively disables the jump threshold test.
It is also possible to specify orientation and position path constraints using the move_group interface.
I cannot find the link a.t.m. because ros.org is down for me.
Example of an orientation constraint:
moveit_msgs::Constraints path_constraints = moveit_msgs::Constraints(); 
path_constraints.name = "orientation_constraint";

moveit_msgs::OrientationConstraint orientation_constraint = moveit_msgs::OrientationConstraint();
orientation_constraint.header.frame_id="base_link_1";
orientation_constraint.orientation.x = x;
orientation_constraint.orientation.y = y;
orientation_constraint.orientation.z = z;
orientation_constraint.orientation.w = w;
orientation_constraint.orientation = cur_pose.pose.orientation;
orientation_constraint.absolute_x_axis_tolerance = 0.5;
orientation_constraint.absolute_y_axis_tolerance = 0.5;
orientation_constraint.absolute_z_axis_tolerance = 0.5;
orientation_constraint.weight = 10.0f;
orientation_constraint.link_name = "gripper_link_1";
path_constraints.orientation_constraints.push_back(orientation_constraint);

group.setPathConstraints(path_constraints);

Originally posted by Okke with karma: 131 on 2014-02-18
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by VictorLamoine on 2014-12-10:
Great answer with clear example code, +1


Q:

why does rclpy timer have no update method and stored in ns?

using rclpy timer there does not appear to be any method for updating the timer period/interval there is simply a timer_period_ns variable which can be changed but it feels a bit off, especially the whole multiply by a million part. Is there a reason it is this way?

Originally posted by masynthetic on ROS Answers with karma: 55 on 2021-12-16
Post score: 0

A:

Hi @masynthetic
To better answer your question, let's step back a little to review the following concepts. Source: ROS2 Documentation
Executors:

An Executor uses one or more threads
of the underlying operating system to
invoke the callbacks of subscriptions,
timers, service servers, action
servers, etc. on incoming messages and
events. The explicit Executor class
(in executor.hpp in rclcpp, in
executors.py in rclpy, or in
executor.h in rclc) provides more
control over execution management than
the spin mechanism in ROS 1, although
the basic API is very similar.

Scheduling

If the processing time of the
callbacks is shorter than the period
with which messages and events occur,
the Executor basically processes them
in FIFO order. However, if the
processing time of some callbacks is
longer, messages and events will be
queued on the lower layers of the
stack. The wait set mechanism reports
only very little information about
these queues to the Executor. In
detail, it only reports whether there
are any messages for a certain topic
or not. The Executor uses this
information to process the messages
(including services and actions) in a
round-robin fashion - but not in FIFO
order. In addition, it prioritizes all
timer events over the messages. The
following flow diagram visualizes this
scheduling semantics.

There is a great presentation by Ralph Lange that explains Executor Design as well. And one key principle, Timers overrule everything as there may be conflicting priorities in real time with the other executors.
Given these 2 concepts of Executors and Scheduling, we also need to appreciate that

"ROS multiplexes independent message
handlers onto shared threads using
custom scheduling policies.
Consequently, applications running on
top of ROS are subject to the
scheduling decisions of the underlying
operating system and the middleware
layer, with complex and interdependent
effects on timing."

Source: Response-Time Analysis of ROS 2 Processing
Chains Under Reservation-Based Schedulingby D. Casini, T. Blaß, I. Lütkebohle, and B. B. Brandenburg
Timers can be set in nano-seconds due to the important role they play in Scheduling, thus the need to multiply by a million. Even though your application may not need but the capability is there.

Originally posted by osilva with karma: 1650 on 2021-12-18
This answer was ACCEPTED on the original site
Post score: 1


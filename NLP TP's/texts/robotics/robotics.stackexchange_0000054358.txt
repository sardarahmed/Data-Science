Q:

What are the practical consequences of a metapackage?

What are the practical consequences of a metapackage? How are they supposed to be used?
Are they only a check that you have all packages you need or can they help with getting all the packages you need?
We have now a lot of packages checked in to subversion. We would like to define different sub-sets of these packages and let different people check out and update different sub-sets. How do you do that the ros way?

Originally posted by TommyP on ROS Answers with karma: 1339 on 2013-09-25
Post score: 1

A:

metapackages allow you to group a set of functionality under a convenient name for easy installation.  They are empty packages which only have dependencies.  They are only really helpful for distribution or released packages. They are especially designed for binary based installations.
If you are installing from source the grouping can only be done by the repository higherarchy in svn. (In DVCSs you can usually not even checkout subtrees and are limited to the repos.
I would recommend that you look into the rosinstall_generator for your purposes of checking out arbitrary code.  But again it will work much better for released code.
For arbitrary code subsets making common rosinstall file snippets for rosinstall or wstool are probably your best approach.

Originally posted by tfoote with karma: 58457 on 2013-09-28
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by TommyP on 2013-09-28:
I see. Maybe "They are only really helpful for distribution or released packages. They are especially designed for binary based installations." or something similar should be added to the Wiki documentation?
Comment by felix k on 2013-09-29:
@TommyP: feel free to do so! :-) Even if it's only a link to a place explaining the thing. And oh, http://wiki.ros.org/Packages and http://wiki.ros.org/Stacks do not yet mention catkin packages at all.


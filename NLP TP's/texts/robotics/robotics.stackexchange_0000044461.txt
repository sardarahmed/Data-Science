Q:

How can i automate my ROS work session environment?

While working more extensively (with ROS using Ubuntu Precise 12.04), I find myself repeatedly having to invoke several applications such as an editor(s), Nautilus, multiple terminals, Tomboy Notes, a simulation environment(s) and a good browser(s) just to start up my work session.
Moreover, there are times when I must repetitiously type in terminal commands to recreate the state of my work so I may continue where I left off. There is the idea of computer system hibernation, but I'd rather boot freshly before each work session.
Is there a way to automate a "ROS startup work session environment" (if you will)?.

Originally posted by TurtleBot_Fan on ROS Answers with karma: 287 on 2012-09-27
Post score: 1

A:

This is my solution. The automation is done by a python script using the "subprocess" command and the "xdotool" command.
The code is rustic, but it works.
Here is the file:
#!/usr/bin/python 

import subprocess
import shlex
import os
import time
from Xlib import X, display

# The following was installed using Ubuntu Software Center
# python-xlib
# xdotool

def TrackMouseCoordinates():
  #import time
  #from Xlib import X, display

  while True:
    d = display.Display()
    s = d.screen()
    root = s.root
    a=root.query_pointer()
    b=a._data
    print b["root_x"], b["root_y"]
    d.sync()
    time.sleep(1)

def GetActiveWindowTitle():
    return subprocess.Popen(["xprop", "-id", subprocess.Popen(["xprop", "-root", "_NET_ACTIVE_WINDOW"], stdout=subprocess.PIPE).communicate()[0].strip().split()[-1], "WM_NAME"], stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()[0].strip().split('"', 1)[-1][:-1]

def GetWindowIdOfOpenActiveWindow(windowName):
    p = subprocess.Popen(["xdotool", "search", "--name",
                    windowName],
        shell=False,stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        stdin=subprocess.PIPE)
    p.wait()
    out = p.stdout.read()
    idwin = out.split("\n")[0]
    return idwin

def OpenAllDesiredTerminalsAndReturnActiveTerminal():
  # create terminals
  #activeWinTitle = ""
  # geometry is widthxheight+x+y   50x10+1935+20
  subprocess.call(["xdotool", "exec", "gnome-terminal", "--geometry=100x10+1935+20", "--working-directory=sam"])
  #subprocess.call(["xdotool", "exec", "gnome-terminal", "--geometry=40x5+20+20", "--working-directory=SQ_bin"])
  #time.sleep(5) # Necessary to let processes complete
  # click on a terminal to activate it (activating sam terminal at 705,37)
  #subprocess.call(["xdotool", "mousemove", "705", "37","click", "1"])
  #activeWinTitle = GetActiveWindowTitle()
  #print 'Active window title: ', activeWinTitle
  #return activeWinTitle

def sendKeystrokesToWindow(windowID,keystrokes):
    #print "sending command %s " %command
    #subprocess.call(["xdotool", "key", "%s" % command ])
    subprocess.call(["xdotool", "type", "--window", "windowID", keystrokes])

def openROSrelatedApplications():
  # Home Folder GUI
  subprocess.call(["xdotool", "exec", "nautilus"])
  # Chromium Browser
  subprocess.call(["xdotool", "exec", "chromium-browser"]) #, "%U"])
  # Tomboy Notes
  subprocess.call(["xdotool", "exec", "tomboy", "--search"]) #, "%U"])
  # 4 Terminals

#----------------Main-----------------
#TrackMouseCoordinates()
# open applications
openROSrelatedApplications()
# create terminals
OpenAllDesiredTerminalsAndReturnActiveTerminal()
#terminalName=OpenAllDesiredTerminalsAndReturnActiveTerminal()
# get window id of active terminal
#terminID=GetWindowIdOfOpenActiveWindow(terminalName)
# send keystrokes to active terminal
#sendKeystrokesToWindow(terminID,"ls\n") #roscd beginner_tutorials
#----------------Main-----------------

Originally posted by TurtleBot_Fan with karma: 287 on 2012-09-27
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Lorenz on 2012-09-27:
This feels pretty complicated. What's the reason for not writing a simple shell script?
Comment by TurtleBot_Fan on 2012-09-28:
No real reason. I just felt a python script would be fun.


Q:

MoveGroup init object issue

In Moveit there is the MoveGroup class used to control a group of links and joints.
In official tutorial is showed an initialization of the object in the main like:
moveit::planning_interface::MoveGroup group("arm");

I would like to create a service call, which executes some movement of the arm.
How can I create/initialize the MoveGroup object such that it is visible (e.g. as global variable) to the service callback function and also visible for other functions?
The constructor of the MoveGroup is defined like this:
/** \brief Construct a client for the MoveGroup action using a specified set of options \e opt. Optionally, specify a TF instance to use. If not specified, one will be constructed internally. A timeout for connecting to the action server can also be specified. If it is not specified, the wait time is unlimited. */
  MoveGroup(const Options &opt, const boost::shared_ptr<tf::Transformer> &tf = boost::shared_ptr<tf::Transformer>(), const ros::Duration &wait_for_server = ros::Duration(0, 0));

  /** \brief Construct a client for the MoveGroup action for a particular \e group. Optionally, specify a TF instance to use. If not specified, one will be constructed internally. A timeout for connecting to the action server can also be specified. If it is not specified,   the wait time is unlimited. */
  MoveGroup(const std::string &group, const boost::shared_ptr<tf::Transformer> &tf = boost::shared_ptr<tf::Transformer>(), const ros::Duration &wait_for_server = ros::Duration(0, 0));

I also tired to create my own class that has a MoveGroup argument, but I couldn't initialize in the constructor like:
group = new moveit::planning_interface::MoveGroup("arm");

Error at build is:
/home/elod/catkin_ws/src/arm_control/arm_action_server/src/main.cpp:36:39: error: no matching function for call to ‘moveit::planning_interface::MoveGroup::MoveGroup()’
 moveit::planning_interface::MoveGroup group;
                                       ^
/home/elod/catkin_ws/src/arm_control/arm_action_server/src/main.cpp:36:39: note: candidates are:
In file included from /home/elod/catkin_ws/src/arm_control/arm_action_server/src/main.cpp:9:0:
/opt/ros/indigo/include/moveit/move_group_interface/move_group.h:122:3: note: moveit::planning_interface::MoveGroup::MoveGroup(const string&, const boost::shared_ptr<tf::Transformer>&, const ros::Duration&)
   MoveGroup(const std::string &group, const boost::shared_ptr<tf::Transformer> &tf = boost::shared_ptr<tf::Transformer>(),
   ^
/opt/ros/indigo/include/moveit/move_group_interface/move_group.h:122:3: note:   candidate expects 3 arguments, 0 provided
/opt/ros/indigo/include/moveit/move_group_interface/move_group.h:116:3: note: moveit::planning_interface::MoveGroup::MoveGroup(const moveit::planning_interface::MoveGroup::Options&, const boost::shared_ptr<tf::Transformer>&, const ros::Duration&)
   MoveGroup(const Options &opt, const boost::shared_ptr<tf::Transformer> &tf = boost::shared_ptr<tf::Transformer>(),
   ^
/opt/ros/indigo/include/moveit/move_group_interface/move_group.h:116:3: note:   candidate expects 3 arguments, 0 provided
In file included from /home/elod/catkin_ws/src/arm_control/arm_action_server/src/main.cpp:9:0:
/opt/ros/indigo/include/moveit/move_group_interface/move_group.h:69:7: note: moveit::planning_interface::MoveGroup::MoveGroup(const moveit::planning_interface::MoveGroup&)
 class MoveGroup
       ^
/opt/ros/indigo/include/moveit/move_group_interface/move_group.h:69:7: note:   candidate expects 1 argument, 0 provided
make[2]: *** [CMakeFiles/arm_action.dir/src/main.cpp.o] Error 1
make[1]: *** [CMakeFiles/arm_action.dir/all] Error 2
make: *** [all] Error 2

Originally posted by zweistein on ROS Answers with karma: 231 on 2015-09-21
Post score: 1

A:

This is a solution I implemented after reading several post online. It is working.
class ArmControl {
public:
    ros::NodeHandle nh_;
    string planning_group_name_;
    double POS_TOLARENCE, ANG_TOLARENCE, PLANING_TIME;
    // interface with MoveIt
    boost::scoped_ptr<move_group_interface::MoveGroup> move_group_;
    ArmControl::ArmControl() :
        nh_("~"),
        planning_group_name_("arm"),
        POS_TOLARENCE(0.01),
        ANG_TOLARENCE(0.1),
        PLANING_TIME(20.0) 
    {
    move_group_.reset(
            new move_group_interface::MoveGroup(planning_group_name_));
    move_group_->setPlanningTime(PLANING_TIME);
    move_group_->setGoalOrientationTolerance(ANG_TOLARENCE);
    move_group_->setGoalPositionTolerance(POS_TOLARENCE);
    sleep(5);
   }
  }

 int main(int argc, char **argv)
{
    ros::init(argc, argv, "arm_action_server");
    ros::NodeHandle nh;
    ros::AsyncSpinner spinner(0);
    spinner.start();

    ArmControl controller;      
    controller.moveToInitialPos();    
    ros::ServiceServer findCB_service = nh.advertiseService("find_chess_board",
                    &ArmControl::findCB, &controller);    
    ros::ServiceServer flippSW_service = nh.advertiseService("flipp_switch",
                        &ArmControl::flippSW, &controller);
    ros::waitForShutdown();
}

Originally posted by zweistein with karma: 231 on 2015-09-28
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by mony.khosravi on 2017-12-04:
Many thanks. It also solved my problem.


Q:

rosp_canopen canopen_motor_node fails to compile / needs code edit to compile

Hi guys,
I want to catkin_make the recent version of ros_canopen, but this appears:
[100%] Building CXX object ros_canopen/canopen_motor_node/CMakeFiles/canopen_motor_node.dir/src/control_node.cpp.o
/home/marcel/ros/powerball_ws/src/ros_canopen/canopen_motor_node/src/control_node.cpp: In member function ‘virtual bool RobotLayer::canSwitch(const std::list<hardware_interface::ControllerInfo>&, const std::list<hardware_interface::ControllerInfo>&) const’:
/home/marcel/ros/powerball_ws/src/ros_canopen/canopen_motor_node/src/control_node.cpp:432:17: error: ‘canSwitch’ is not a member of ‘hardware_interface::RobotHW’
     (void) &hardware_interface::RobotHW::canSwitch; // compile-time check for recent ros-controls version of ros_control
             ^
make[2]: *** [ros_canopen/canopen_motor_node/CMakeFiles/canopen_motor_node.dir/src/control_node.cpp.o] Fehler 1
make[1]: *** [ros_canopen/canopen_motor_node/CMakeFiles/canopen_motor_node.dir/all] Fehler 2
make: *** [all] Fehler 2
Invoking "make -j4 -l4" failed

When removing line 432 -
(void) &hardware_interface::RobotHW::canSwitch; // compile-time check for recent ros-controls version of ros_control

from control_node.cpp it compiles and this seems not to affect the program at runtime. There is even this comment, suggesting, this is just a compile-time check.
Is this intended behaviour?
This seems to be intended behaviour. Although I could not see any difference while using ros_canopen package from when having to remove this one line of code to the situation where I did not.
ros_canopen 0.6.4 compiles fine when having ros_control version 0.9.3.

Originally posted by Marcel Usai on ROS Answers with karma: 200 on 2015-07-21
Post score: 0

A:

This behaviour is intended and should prevent you from chasing version incompatibilities for several hours.
canopen_motor_node features the switching between the different CANopen operation modes (wiki) at run-time.
For this to work a new interface was added to ros_control (#200) and finally got released with version 0.9.2/3.
This interface uses virtual methods and will therefore compile even if the base class does not have these methods.
Of cause it will not work as expected, since the device will never switch to the required mode.
In addition the new version of canopen_402 will not forward commands if no mode was selected and stops all motion by setting the halt bit in the control word.
By the way, ros_canopen 0.6.4 and ros_control 0.9.3 are available from the ROS repo and do not have to be built from source.

Originally posted by Mathias Lüdtke with karma: 1596 on 2015-07-21
This answer was ACCEPTED on the original site
Post score: 1


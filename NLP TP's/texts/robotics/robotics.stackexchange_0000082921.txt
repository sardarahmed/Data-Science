Q:

catkin_make error on boost::bind during synchronizer callback

I am getting an error related to boost when trying to time synchronize two images from topics.
It is showing an error in the boost::bind function during callback which i am not sure how to correct it.

A portion of the build output is listed below:
/usr/include/boost/bind/mem_fn_template.hpp: In instantiation of ‘R boost::_mfi::mf2<R, T, A1, A2>::call(U&, const void*, B1&, B2&) const [with U = StereoGrabber (*)(); B1 = const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >; B2 = const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >; R = void; T = StereoGrabber; A1 = const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&; A2 = const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&]’:
/usr/include/boost/bind/mem_fn_template.hpp:286:46:   required from ‘R boost::_mfi::mf2<R, T, A1, A2>::operator()(U&, A1, A2) const [with U = StereoGrabber (*)(); R = void; T = StereoGrabber; A1 = const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&; A2 = const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&]’
/usr/include/boost/bind/bind.hpp:392:34:   required from ‘void boost::_bi::list3<A1, A2, A3>::operator()(boost::_bi::type<void>, F&, A&, int) [with F = boost::_mfi::mf2<void, StereoGrabber, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&>; A = boost::_bi::list9<const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&, const boost::shared_ptr<const message_filters::NullType>&, const boost::shared_ptr<const message_filters::NullType>&, const boost::shared_ptr<const message_filters::NullType>&, const boost::shared_ptr<const message_filters::NullType>&, const boost::shared_ptr<const message_filters::NullType>&, const boost::shared_ptr<const message_filters::NullType>&, const boost::shared_ptr<const message_filters::NullType>&>; A1 = boost::_bi::value<StereoGrabber (*)()>; A2 = boost::arg<1>; A3 = boost::arg<2>]’
/usr/include/boost/bind/bind_template.hpp:305:59:   required from ‘boost::_bi::bind_t<R, F, L>::result_type boost::_bi::bind_t<R, F, L>::operator()(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&, const A8&, const A9&) [with A1 = boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >; A2 = boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >; A3 = boost::shared_ptr<const message_filters::NullType>; A4 = boost::shared_ptr<const message_filters::NullType>; A5 = boost::shared_ptr<const message_filters::NullType>; A6 = boost::shared_ptr<const message_filters::NullType>; A7 = boost::shared_ptr<const message_filters::NullType>; A8 = boost::shared_ptr<const message_filters::NullType>; A9 = boost::shared_ptr<const message_filters::NullType>; R = void; F = boost::_mfi::mf2<void, StereoGrabber, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&>; L = boost::_bi::list3<boost::_bi::value<StereoGrabber (*)()>, boost::arg<1>, boost::arg<2> >; boost::_bi::bind_t<R, F, L>::result_type = void]’
/usr/include/boost/bind/bind.hpp:827:34:   required from ‘void boost::_bi::list9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::operator()(boost::_bi::type<void>, F&, A&, int) [with F = boost::_bi::bind_t<void, boost::_mfi::mf2<void, StereoGrabber, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&>, boost::_bi::list3<boost::_bi::value<StereoGrabber (*)()>, boost::arg<1>, boost::arg<2> > >; A = boost::_bi::list9<const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&, const boost::shared_ptr<const message_filters::NullType>&, const boost::shared_ptr<const message_filters::NullType>&, const boost::shared_ptr<const message_filters::NullType>&, const boost::shared_ptr<const message_filters::NullType>&, const boost::shared_ptr<const message_filters::NullType>&, const boost::shared_ptr<const message_filters::NullType>&, const boost::shared_ptr<const message_filters::NullType>&>; A1 = boost::arg<1>; A2 = boost::arg<2>; A3 = boost::arg<3>; A4 = boost::arg<4>; A5 = boost::arg<5>; A6 = boost::arg<6>; A7 = boost::arg<7>; A8 = boost::arg<8>; A9 = boost::arg<9>]’
/usr/include/boost/bind/bind_template.hpp:305:59:   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/include/boost/function/function_template.hpp:934:38:   required from ‘void boost::function9<R, T1, T2, T3, T4, T5, T6, T7, T8, T9>::assign_to(Functor) [with Functor = boost::_bi::bind_t<boost::_bi::unspecified, boost::_bi::bind_t<void, boost::_mfi::mf2<void, StereoGrabber, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&>, boost::_bi::list3<boost::_bi::value<StereoGrabber (*)()>, boost::arg<1>, boost::arg<2> > >, boost::_bi::list9<boost::arg<1>, boost::arg<2>, boost::arg<3>, boost::arg<4>, boost::arg<5>, boost::arg<6>, boost::arg<7>, boost::arg<8>, boost::arg<9> > >; R = void; T0 = const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&; T1 = const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&; T2 = const boost::shared_ptr<const message_filters::NullType>&; T3 = const boost::shared_ptr<const message_filters::NullType>&; T4 = const boost::shared_ptr<const message_filters::NullType>&; T5 = const boost::shared_ptr<const message_filters::NullType>&; T6 = const boost::shared_ptr<const message_filters::NullType>&; T7 = const boost::shared_ptr<const message_filters::NullType>&; T8 = const boost::shared_ptr<const message_filters::NullType>&]’
/usr/include/boost/function/function_template.hpp:722:7:   required from ‘boost::function9<R, T1, T2, T3, T4, T5, T6, T7, T8, T9>::function9(Functor, typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type) [with Functor = boost::_bi::bind_t<boost::_bi::unspecified, boost::_bi::bind_t<void, boost::_mfi::mf2<void, StereoGrabber, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&>, boost::_bi::list3<boost::_bi::value<StereoGrabber (*)()>, boost::arg<1>, boost::arg<2> > >, boost::_bi::list9<boost::arg<1>, boost::arg<2>, boost::arg<3>, boost::arg<4>, boost::arg<5>, boost::arg<6>, boost::arg<7>, boost::arg<8>, boost::arg<9> > >; R = void; T0 = const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&; T1 = const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&; T2 = const boost::shared_ptr<const message_filters::NullType>&; T3 = const boost::shared_ptr<const message_filters::NullType>&; T4 = const boost::shared_ptr<const message_filters::NullType>&; T5 = const boost::shared_ptr<const message_filters::NullType>&; T6 = const boost::shared_ptr<const message_filters::NullType>&; T7 = const boost::shared_ptr<const message_filters::NullType>&; T8 = const boost::shared_ptr<const message_filters::NullType>&; typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type = int]’
/usr/include/boost/function/function_template.hpp:1069:16:   required from ‘boost::function<R(T0, T1, T2, T3, T4, T5, T6, T7, T8)>::function(Functor, typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type) [with Functor = boost::_bi::bind_t<boost::_bi::unspecified, boost::_bi::bind_t<void, boost::_mfi::mf2<void, StereoGrabber, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&>, boost::_bi::list3<boost::_bi::value<StereoGrabber (*)()>, boost::arg<1>, boost::arg<2> > >, boost::_bi::list9<boost::arg<1>, boost::arg<2>, boost::arg<3>, boost::arg<4>, boost::arg<5>, boost::arg<6>, boost::arg<7>, boost::arg<8>, boost::arg<9> > >; R = void; T0 = const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&; T1 = const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&; T2 = const boost::shared_ptr<const message_filters::NullType>&; T3 = const boost::shared_ptr<const message_filters::NullType>&; T4 = const boost::shared_ptr<const message_filters::NullType>&; T5 = const boost::shared_ptr<const message_filters::NullType>&; T6 = const boost::shared_ptr<const message_filters::NullType>&; T7 = const boost::shared_ptr<const message_filters::NullType>&; T8 = const boost::shared_ptr<const message_filters::NullType>&; typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type = int]’
/opt/ros/indigo/include/message_filters/signal9.h:273:23:   required from ‘message_filters::Connection message_filters::Signal9<M0, M1, M2, M3, M4, M5, M6, M7, M8>::addCallback(C&) [with C = const boost::_bi::bind_t<void, boost::_mfi::mf2<void, StereoGrabber, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&>, boost::_bi::list3<boost::_bi::value<StereoGrabber (*)()>, boost::arg<1>, boost::arg<2> > >; M0 = sensor_msgs::Image_<std::allocator<void> >; M1 = sensor_msgs::Image_<std::allocator<void> >; M2 = message_filters::NullType; M3 = message_filters::NullType; M4 = message_filters::NullType; M5 = message_filters::NullType; M6 = message_filters::NullType; M7 = message_filters::NullType; M8 = message_filters::NullType]’
/opt/ros/indigo/include/message_filters/synchronizer.h:310:40:   required from ‘message_filters::Connection message_filters::Synchronizer<Policy>::registerCallback(const C&) [with C = boost::_bi::bind_t<void, boost::_mfi::mf2<void, StereoGrabber, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&>, boost::_bi::list3<boost::_bi::value<StereoGrabber (*)()>, boost::arg<1>, boost::arg<2> > >; Policy = message_filters::sync_policies::ApproximateTime<sensor_msgs::Image_<std::allocator<void> >, sensor_msgs::Image_<std::allocator<void> > >]’

Error
error: cannot apply member pointer ‘((const boost::_mfi::mf2<void, StereoGrabber, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&>*)this)->boost::_mfi::mf2<void, StereoGrabber, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&, const boost::shared_ptr<const sensor_msgs::Image_<std::allocator<void> > >&>::f_’ to ‘* boost::get_pointer<StereoGrabber()>(u)’, which is of non-class type ‘StereoGrabber()’
         BOOST_MEM_FN_RETURN (get_pointer(u)->*f_)(b1, b2);
                                            ^
/usr/include/boost/bind/mem_fn_template.hpp:271:57: error: return-statement with a value, in function returning 'void' [-fpermissive]
         BOOST_MEM_FN_RETURN (get_pointer(u)->*f_)(b1, b2);

my bind function is:
    StereoGrabber sgb();
    sync1.registerCallback(boost::bind(&StereoGrabber::GrabImage,&sgb,_1,_2));

I am not sure if this is the correct usage of bind.
My whole code looks like this:
class StereoGrabber
{
public:
    StereoGrabber(){};
    
    void GrabImage(const sensor_msgs::ImageConstPtr& msgImage1,const sensor_msgs::ImageConstPtr& msgImage2);
};

int main(int argc, char **argv)
{
    ros::init(argc, argv, "listener");
    ros::start();

    StereoGrabber sgb();

    ros::NodeHandle nVO;

    message_filters::Subscriber<sensor_msgs::Image> image1_sub(nVO, "/image_1", 1);
    message_filters::Subscriber<sensor_msgs::Image> image2_sub(nVO, "/image_2", 1);
    typedef message_filters::sync_policies::ApproximateTime<sensor_msgs::Image, sensor_msgs::Image> sync_pol1;
    message_filters::Synchronizer<sync_pol1> sync1(sync_pol1(10), image1_sub,image2_sub);
    sync1.registerCallback(boost::bind(&StereoGrabber::GrabImage,&sgb,_1,_2));

    ros::spin();
    
    ros::shutdown();

    return 0;
}

void StereoGrabber::GrabImage(const sensor_msgs::ImageConstPtr& msgImage1,const sensor_msgs::ImageConstPtr& msgImage2)
{
    //Process image

}

Originally posted by rosusernli on ROS Answers with karma: 52 on 2017-09-20
Post score: 1

A:

Found out the mistake while building. I didn't notice it first.
The Problem was with the class object declaration.
StereoGrabber sgb();

The class constructor doesn't take any arguments. It should have been : StereoGrabber sgb;
The updated code for time synchronizer is :
class StereoGrabber
{
public:
    StereoGrabber(){};

    void GrabImage(const sensor_msgs::ImageConstPtr& msgImage1,const sensor_msgs::ImageConstPtr& msgImage2);
};

int main(int argc, char **argv)
{
    ros::init(argc, argv, "listener");
    ros::start();

    StereoGrabber sgb; //Corrected code

    ros::NodeHandle nVO;

    message_filters::Subscriber<sensor_msgs::Image> image1_sub(nVO, "/image_1", 1);
    message_filters::Subscriber<sensor_msgs::Image> image2_sub(nVO, "/image_2", 1);
    typedef message_filters::sync_policies::ApproximateTime<sensor_msgs::Image, sensor_msgs::Image> sync_pol1;
    message_filters::Synchronizer<sync_pol1> sync1(sync_pol1(10), image1_sub,image2_sub);
    sync1.registerCallback(boost::bind(&StereoGrabber::GrabImage,&sgb,_1,_2));

    ros::spin();

    ros::shutdown();

    return 0;
}

void StereoGrabber::GrabImage(const sensor_msgs::ImageConstPtr& msgImage1,const sensor_msgs::ImageConstPtr& msgImage2)
{
    //Process image

}

Originally posted by rosusernli with karma: 52 on 2017-09-21
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by waschbaer00 on 2018-03-23:
Why you make a class without individual class constructor? In your case, actually a main-scheme ros implementation is more proper. Because you declare ros stuff in main function and second your callback actually could just declared as a function out of main() without class definition.
Comment by rosusernli on 2018-03-27:
Yes the function can be declared without class definition. I wrote the class implementation for readability and possibility of future expansion of code. Its always better to implement as a member function.


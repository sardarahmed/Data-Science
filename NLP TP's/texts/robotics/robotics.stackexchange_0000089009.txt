Q:

Calling a callback function from another callback function

Hi! I have a node with two subscribers and the code in one of the subscribers gets executed only once(because of a conditional flag) and it is in this function that I wish to call another callback function. The callback function expects const package::Euler_val::ConstPtr& array where package::Euler_val is a custom message type defined as float64[3] Euler_angles. So far, this is what I've done:
const boost::shared_ptr<std_msgs::Float64> my_arr(new std_msgs::Float64[3], std::default_delete<std_msgs::Float64[]>());
for (int i = 0; i < 3; i++)  
   my_arr.get()[i] = Euler.at<std_msgs::Float64>(i); 
callback2(my_arr);

and the error I get is
error: invalid initialization of reference of type ‘const ConstPtr& {aka const boost::shared_ptr<const calibration_camera_lidar::Euler_val_<std::allocator<void> > >&}’ from expression of type ‘const boost::shared_ptr<std_msgs::Float64_<std::allocator<void> > >’

The thing is I'm not quite sure how to call the callback2 function from another callback function. I'll be grateful if someone could help. Thanks in advance!

Originally posted by surabhi96 on ROS Answers with karma: 41 on 2018-09-16
Post score: 1

A:

Since your function takes a calibration_camera_lidar::Euler_val::ConstPtr as its argument, you should try to make one of those to pass in. Creating an object of that type should be similar (but maybe not quite the same) to the code that you would use to create and publish that message in the publisher.
boost::shared_ptr<calibration_camera_lidar::Euler_val> my_arr(new calibration_camera_lidar::Euler_val());
for ( int i=0; i<3; i++) {
    my_arr->Euler_angles[i] = i;
}
callback2(my_arr);

A quick walk-through:
    boost::shared_ptr<calibration_camera_lidar::Euler_val> my_arr(new calibration_camera_lidar::Euler_val());

Creates a shared_pointer to your message type, named my_arr, and initializes it my allocating a new object. Shared pointers are similar to regular pointers and use much of the same syntax, but they automatically delete the object that they're pointing to when the last shared pointer to that object is destructed.
for ( int i=0; i<3; i++) {
    my_arr->Euler_angles[i] = i;
}

Initialize each item in the array. Note that since my_arr is a shared pointer, you use the -> syntax to access its members. Since you declared the Euler_angles member as a fixed-size array, we can use the [] syntax with it. (if it was a variable-sized array, it would be a std::vector and would start at zero size, so you would need to use push_back or one of the other modifier functions to expand the array before putting an item on the end).
callback2(my_arr);

Call you callback!

Originally posted by ahendrix with karma: 47576 on 2018-09-16
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by surabhi96 on 2018-09-16:
This worked, thanks much!
Comment by surabhi96 on 2018-09-16:
Btw, I was actually trying to write an example of what I was trying to do by adding dummy variables.. and I just pasted the original error.
Comment by surabhi96 on 2018-09-17:
@ahendrix Here we are passing a pointer to the callback2 function. This node also subscribes to another topic which publishes an array as defined in the msg file. So when this message arrives callback2 is called with an array as the func argument. Do we pass a ptr or an array to the callback func?
Comment by ahendrix on 2018-09-17:
Similar to the above (and really, for any C++ function call) you want to construct an object that matches the function's parameter type to pass in.


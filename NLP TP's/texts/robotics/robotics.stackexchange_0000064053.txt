Q:

Disparity image reconstruction

I am using two prosilica cameras in order to generate the disparity image. by the help of stereo_image_proc I can generate the disparity image and is available in /stereo/disparity_image topic. Now in another node I am reconstructing the disparity image using raw data[].
int count = 0;
sensor_msgs::Image img = disp.image;
int h = (img.height);
int w = (img.width);
cv::WImageBuffer3_b pic(h,w);
ROS_INFO("height width and step [%d]  [%d]  [%d]" ,img.height,img.width,img.step);
count = 0; 
for(int i=(h-1);i>=0;i--) {
   for(int j=(w-1);j>=0;j--)  { 
      count++;
      *(pic(i,j)) = (img.data[count]);
      count++;
      *(pic(i,j)+1) = (img.data[count]);
      count++;   
      *(pic(i,j)+2) = (img.data[count]);
      count++;
  }
}

for each set of pixel data I am ignoring one data as it provides the depth..
during viewing the reconstructed image only the colors get swaped. that menas the portion with green switched to some other color and so on..

Originally posted by Robot on ROS Answers with karma: 180 on 2014-11-17
Post score: 0

Original comments
Comment by Robot on 2014-11-17:
in the DosparityImage format there is a fuled name Image. In Image field there is data[]. is that data contains RGB and Depth info raw data of the iamge or something else.. thanks in advance
????

A:

I solved the problem. The data available in the disparity image is not the RGB values. Those are encoded in TYPE_32FC1
so inorder to reconstruct the image we have to use some colormap done in stereo_view node in the image_view package. just subscribe the topic where the disparity image is available.
void imageCallback(const stereo_msgs::DisparityImageConstPtr& disp) {
  Mat_ Vec3b disparity_color_;
  float min_disparity = disp->min_disparity;
  float max_disparity = disp->max_disparity;
  float multiplier = 255.0f / (max_disparity - min_disparity);
  assert(disp->image.encoding == sensor_msgs::image_encodings::TYPE_32FC1);
  const cv::Mat_<float> dmat(disp->image.height, disp->image.width,
                             (float*)&disp->image.data[0], disp->image.step);
  disparity_color_.create(disp->image.height, disp->image.width);

  for (int row = 0; row < disparity_color_.rows; ++row) {
    const float* d = dmat[row];
    for (int col = 0; col < disparity_color_.cols; ++col) {
      int index = (d[col] - min_disparity) * multiplier + 0.5;
      index = std::min(255, std::max(0, index));
      // Fill as BGR
      disparity_color_(row, col)[2] = colormap[3*index + 0];
      disparity_color_(row, col)[1] = colormap[3*index + 1];
      disparity_color_(row, col)[0] = colormap[3*index + 2];
    }
  }
  imshow( "view", disparity_color_ );
}

Originally posted by Robot with karma: 180 on 2014-11-17
This answer was ACCEPTED on the original site
Post score: 0


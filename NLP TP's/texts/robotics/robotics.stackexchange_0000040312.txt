Q:

control_manager AX12 overload error

I sucessfully created and ran a controller_manager file, a tilt.yaml file, a start_tilt_launcher.launch file and a c++ program that allows me to send 4 different servo's commands via ros.  The only problem is that if I use 5 servo's, then on the second or third execution of this program, the controller_manager receives an overload error such as this:

process[dynamixel_manager-1]: started with pid [4098]
[INFO] [WallTime: 1336569043.428306] Pinging motor IDs 1 through 11...
[INFO] [WallTime: 1336569043.550358] Found motors with IDs: [4, 6, 9, 11].
[INFO] [WallTime: 1336569043.689777] There are 4 AX-12+ servos connected
[INFO] [WallTime: 1336569043.690113] Dynamixel Manager on port /dev/ttyUSB0 initialized
[FATAL] [WallTime: 1336569043.697930] Overload Error [servo #11 on /dev/ttyUSB0@1000000bps]: fetching full servo status failed
================================================================================REQUIRED process [dynamixel_manager-1] has died!
process has finished cleanly.
log file: /home/mickey11592/.ros/log/56ef92f0-99d7-11e1-969c-001aa0ada442/dynamixel_manager-1*.log
Initiating shutdown!
================================================================================
[dynamixel_manager-1] killing on exit
shutting down processing monitor...
... shutting down processing monitor complete
done

I am not sure how to fix this.  I might be giving the commands to the servo's in an inefficient way, unfortunately this is the only way that I know how to.
controller_manager.launch file (set up for 5 servo's, commented down to 4), I removed the "<" and ">" tags in order to view the full code :

!-- -*- mode: XML -*- --

launch
    node name="dynamixel_manager" pkg="dynamixel_controllers" type="controller_manager.py" required="true" output="screen"
        rosparam
            namespace: dynamixel_controller_manager
            serial_ports:
                dxl_tty1:
                    port_name: "/dev/ttyUSB0"
                    baud_rate: 1000000
                    min_motor_id: 1
                    max_motor_id: 11
                    update_rate: 10
                
        /rosparam
    /node
/launch

start_tilt_controller.launch :

launch
    !-- Start tilt joint controller --
    rosparam file="$(find dynamixeltutorials)/tilt.yaml" command="load"/
    node name="tilt_controller_spawner" pkg="dynamixel_controllers" type="controller_spawner.py"
          args="--manager=dynamixel_controller_manager
        --port dxl_tty1
                tilt_controller1
                tilt_controller2
                tilt_controller3
                tilt_controller4"
             
          output="screen"/
/launch

tilt.yaml :

tilt_controller1:
    controller:
        package: dynamixel_controllers
        module: joint_position_controller
        type: JointPositionController
    joint_name: tilt_joint
    joint_speed: 1.17
    motor:
        id: 4
        init: 512
        min: 0
        max: 1023

tilt_controller2:
    controller:
        package: dynamixel_controllers
        module: joint_position_controller
        type: JointPositionController
    joint_name: tilt_joint
    joint_speed: 1.17
    motor:
        id: 6
        init: 512
        min: 0
        max: 1023

tilt_controller3:
    controller:
        package: dynamixel_controllers
        module: joint_position_controller
        type: JointPositionController
    joint_name: tilt_joint
    joint_speed: 1.17
    motor:
        id: 9
        init: 512
        min: 0
        max: 1023

tilt_controller4:
    controller:
        package: dynamixel_controllers
        module: joint_position_controller
        type: JointPositionController
    joint_name: tilt_joint
    joint_speed: 1.17
    motor:
        id: 11
        init: 512
        min: 0
        max: 1023

The c++ code I wrote to send commands to the servo's
dynamixel13talker.cpp :

include "ros/ros.h"
include "std_msgs/Float64.h"
include cmath
include math.h
include iostream
using namespace std;
int main(int argc, char **argv)
{
  ros::init(argc, argv, "talker"); 
  ros::NodeHandle n;
  ros::Publisher pub1 = n.advertise("tilt_controller1/command", 1000);
  std_msgs::Float64 cmd1Msg;
  ros::Publisher pub2 = n.advertise("tilt_controller2/command", 1000);
  std_msgs::Float64 cmd2Msg;
  ros::Publisher pub3 = n.advertise("tilt_controller3/command", 1000);
  std_msgs::Float64 cmd3Msg;
  ros::Publisher pub4 = n.advertise("tilt_controller4/command", 1000);
  std_msgs::Float64 cmd4Msg;
 // ros::Publisher pub5 = n.advertise("tilt_controller5/command", 1000);
 // std_msgs::Float64 cmd5Msg;

  int i = 1;
//change to 5
  while(i > input;
    cout > input;
    cout > input;
    cout > input;
    cout 
note: in the c++ code, the ((input * 5.2)/300) converts the input number from a degree to the corresponding value on the servo
Any help is appreciated and thank you very much for your time!

Originally posted by rosnovice on ROS Answers with karma: 3 on 2012-05-09
Post score: 0

A:

Overload error means that the servo is unable to move to a desired position because it can't bear the load attached to it. You can't really solve this problem in software unless you turn off the overload alarm, bu then you can physically damage the motor.
Also, the position input to the motors is in radians not in encoder units, so you need to convert your degree input to radians not to motor encoder units.

Originally posted by arebgun with karma: 2121 on 2012-05-11
This answer was ACCEPTED on the original site
Post score: 1


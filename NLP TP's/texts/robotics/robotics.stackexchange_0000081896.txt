Q:

Prevent Laserscan from clearing custom costmap_2d layer

Hello,
I am attempting to write my own custom costmap_2d layer plugin for use in my global costmap. I have been following this tutorial http://wiki.ros.org/costmap_2d/Tutorials/Creating%20a%20New%20Layer.
Specifically I am adding obstacles to the costmap via custom sensors and these appear correctly in rviz in my costmap layer when I turn off the laser scanner.
However, when I am using the obstacle_layer with a laser scanner as a sensor source  the laser scan is always clearing my custom obstacles in the costmap ( The obstacles appear behind my robot but not in front where the scanner is facing).
My question is this, can I set costmap_2d::LETHAL_OBSTACLE to some other value that cant be cleared by the laser? Or conversely can I setup the laser scanner obstacle_layer in such a way that it does not effect these custom obstacles?
Thanks
Edit 1:
@billy and @Proc贸pio thank you for the quick responses. It sounds like the combination_method is really what I am looking for, however I am not sure exactly where that goes? Here is my original costmap configs:
costmap_common.yaml:
footprint: [ [-1.5, 0.9], [3.0, 0.9], [3.0, -0.9], [-1.5, -0.9] ]

robot_base_frame: base_footprint
transform_tolerance: 0.5
resolution: 0.05

update_frequency: 4.0
publish_frequency: 3.0 

#layer definitions (used as plugins for local and global params)
static_layer:
    enabled:   true
    map_topic: "/map"
    subscribe_to_updates: true

obstacle_layer:
    enabled: true
    obstacle_range: 8.0
    raytrace_range: 8.0
    inflation_radius: 0.2
    track_unknown_space: false
    observation_sources: laser
    laser: {data_type: LaserScan, sensor_frame: hokuyo_link_main, clearing: true, marking: true, topic: /main_body/scan_filtered}

inflation_layer:
    enabled: true
    cost_scaling_factor:  10.0 
    inflation_radius: 3.0 

custom_layer:
    enabled: true

Costmap_global.yaml
global_frame: map 
rolling_window: false
track_unknown_space: true
static_map: true
update_frequency: 2.0
publish_frequency: 1.0

plugins:
  - {name: static_layer,                  type: "costmap_2d::StaticLayer"}
  - {name: obstacle_layer,                type: "costmap_2d::VoxelLayer"}
  - {name: inflation_layer,               type: "costmap_2d::InflationLayer"}
  - {name: custom_layer,                     type: "custom_layer::CustomLayer", output: "screen"}

Correct me if I am wrong but it sounds like what you are saying is I should add "combination_method: 0" to my custom_layer arguments list in my costmap_global.yaml file? Ie something like the following:
plugins:
  - {name: static_layer,                  type: "costmap_2d::StaticLayer"}
  - {name: obstacle_layer,                type: "costmap_2d::VoxelLayer"}
  - {name: inflation_layer,               type: "costmap_2d::InflationLayer"}
  - {name: custom_layer,                     type: "custom_layer::CustomLayer", output: "screen", combination_method: 0}

This should have the effect of allowing my custom_layer to overwrite the layers above it in my plugins list? Also is this combination_method / other layer settings documented somewhere?
Thanks again for the help.
Edit 2:
After a bit more testing it looks like the solution is a combination of things. Both the order of the plugins and the use of the combination_method param were important. In my case the obstacles from my custom layer had indeed been added to the costmap, the problem was that my inflation layer came before my custom layer in the plugins list, therefore I was not seeing the inflated obstacles in rviz. I was also incorrect in setting "combination_method: 0" for my custom layer, that clearly has no effect since I am not using that param in my layer. I am posting the final working configuration in case someone else runs into this same problem:
costmap_common_final.yaml:
footprint: [ [-1.5, 0.9], [3.0, 0.9], [3.0, -0.9], [-1.5, -0.9] ]

robot_base_frame: base_footprint
transform_tolerance: 0.5
resolution: 0.05

update_frequency: 4.0
publish_frequency: 3.0 

#layer definitions (used as plugins for local and global params)
static_layer:
    enabled:   true
    map_topic: "/map"
    subscribe_to_updates: true

obstacle_layer:
    enabled: true
    combination_method: 1
    obstacle_range: 8.0
    raytrace_range: 8.0
    inflation_radius: 0.2
    track_unknown_space: false
    observation_sources: laser
    laser: {data_type: LaserScan, sensor_frame: hokuyo_link_main, clearing: true, marking: true, topic: /main_body/scan_filtered}

inflation_layer:
    enabled: true
    cost_scaling_factor:  10.0 
    inflation_radius: 3.0 

custom_layer:
    enabled: true

Costmap_global_final.yaml
global_frame: map 
rolling_window: false
track_unknown_space: true
static_map: true
update_frequency: 2.0
publish_frequency: 1.0

plugins:
  - {name: static_layer,                  type: "costmap_2d::StaticLayer"}
  - {name: obstacle_layer,                type: "costmap_2d::ObstacleLayer"}
  - {name: custom_layer,                     type: "custom_layer::CustomLayer"}
  - {name: inflation_layer,               type: "costmap_2d::InflationLayer"}

Also for some reason I had my laser scanner set to a VoxelLayer which I changed back to ObstacleLayer to make sure that wasn't the problem.
Thanks again @Proc贸pio for sending me in the right direction

Originally posted by biglotusturtle on ROS Answers with karma: 165 on 2017-07-20
Post score: 0

Original comments
Comment by Proc贸pio on 2017-07-21:
please, post your costmap configs.

A:

I had similar question. Below is link to the question with description how I fixed it. It's all about setting up the layers properly and then setting the 'clearing' setting false.
For me it worked for what I needed. The laser would no longer clear the obstacles...but with the way I have it setup, once the robot moves far from the obstacle and that area no longer appears in the cost map, the obstacle would be gone when the robot goes back to that area. In my use case, that is perfect, but it may be an issue for you.
http://answers.ros.org/question/251095/costmap-clears-obstacles-when-it-should-not/

Originally posted by billy with karma: 1850 on 2017-07-20
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Proc贸pio on 2017-07-21:
complementing the answer, the order of the layers and the combination_method matters. a combination_method: 0 will overwrite the layer above, while a combination_method: 1 will sum the layers


Q:

Python socket connection seemingly dropping when using rospy

I'm controling a Henchel servo using Python and ROS through a socket, and I'm having some connection issues.
The servo works 99% of the time, responding to my commands. But 1% of the time my command doesn't seem to register, and all subsequent commands are ignored.
Now this sounds like an issue with the servo or my code, but I've tried to send various commands to the servo in a non-ROS python script over the course of a whole night, without hickups.
So there seems to be just by running my code in a ROS-node, I'm getting some strange behaviour.
I'm totally out of ideas, so I'm throwing out this vague quesion, whether anyone has some ideas what might be causing this? :)
Just to give some more background then here is an example from Henschel's website on how to communicate with this servo using the socket python packet:
import socket 
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect(('192.168.1.102', 1000))
    s.sendall(b'<control pos=\"1000\" speed=\"500\" current=\"200\" mode=\"129\" acc=\"1000\" decc=\"1000\" />')

Now I need to have the socket open 100% of the time since this servo is designed in such a way that it goes limb if it looses the socket connection. So in our code I do it like this:
import socket
tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
tcp_sock.connect((servo_ip, tcp_port))
tcp_sock.settimeout(0.5)
tcp_sock.sendall(
    b'<control pos=\"{}\" speed=\"{}\" current=\"{}\" mode=\"{}\" acc=\"{}\" decc=\"{}\" />'.format(
        pos, speed, current, mode, accel, deaccel
    )

The strange thing is that we don't even receive an error. Not a socet timeout or anything. But the servo just stops receiving commands, and we need to restart our servo node.
Is it possible that just by running our code in a ROS environment, it will affect socket communications in some weird way?

Originally posted by Frimann on ROS Answers with karma: 46 on 2019-10-01
Post score: 0

Original comments
Comment by gvdhoorn on 2019-10-01:
The first thing to check is the network traffic between your node and the servo.
Run wireshark next to your node and the servo and see what happens at the TCP/IP level.

A:

Just for future reference I'm adding our solution to the problem.
The servo in question was sending us constant position updates through TCP, and we had to make sure to empty the buffer using the socket recv() function. We were doing this in two different functions though and two different threads which was a problem.
Eliminating that problem help us allot. But we were still loosing connection from time to time when many other processes were running on the computer. What finally did the trick was to run the ROS node that controlled the servo on a completely dedicated CPU. Possibly an overkill, but worked for us. For that we used the taskset shell program to isolate the process to a single CPU, by adding this line to the launch file:
<node name="servo" launch-prefix="taskset -c 3" pkg="servo_motor" type="servo_node.py" output="screen"/>

Originally posted by Frimann with karma: 46 on 2019-10-04
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by gvdhoorn on 2019-10-04:
I would expect that increasing the priority of the thread that 'empties the buffer' would also work.


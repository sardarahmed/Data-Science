Q:

"Illegal Instruction" when using "image_view" with theora

Hi,
I'm using latest ROS electric with Ubuntu 10.10 (kernel 2.6.35-27-generic).
When running:
rosrun image_view image_view image:=/foo/image_raw _image_transport:=theora

It returns nothing but an "Illegal Instruction" message.
This error appears to any subscribed topic with sensor_msgs/Image message type, even from usual nodes like usb_cam and gencam_cu.
Also it works well with compressed and raw transport.
From reading the core of image_view with gdb:
    Program terminated with signal 4, Illegal instruction.
#0  0x00f688a6 in void cv::pyrUp_<cv::FixPtCast<unsigned char, 6>, cv::NoVec<int, unsigned char> >(cv::Mat const&, cv::Mat&) ()
   from /usr/lib/libopencv_imgproc.so.2.3
(gdb) backtrace
#0  0x00f688a6 in void cv::pyrUp_<cv::FixPtCast<unsigned char, 6>, cv::NoVec<int, unsigned char> >(cv::Mat const&, cv::Mat&) ()
   from /usr/lib/libopencv_imgproc.so.2.3
#1  0x00f69c07 in cv::pyrUp(cv::_InputArray const&, cv::_OutputArray const&, cv::Size_<int> const&) () from /usr/lib/libopencv_imgproc.so.2.3
#2  0x09adda98 in theora_image_transport::TheoraSubscriber::internalCallback(const theora_image_transport::PacketConstPtr &, const boost::function<void(const sensor_msgs::ImageConstPtr&)> &) (this=0xb2dd44a0, message=..., callback=...)
    at /tmp/buildd/ros-electric-image-transport-plugins-1.4.2/debian/ros-electric-image-transport-plugins/opt/ros/electric/stacks/image_transport_plugins/theora_image_transport/src/theora_subscriber.cpp:191
#3  0x09adfafc in operator() (function_obj_ptr=..., a0=...)
    at /usr/include/boost/bind/mem_fn_template.hpp:280
#4  operator()<boost::_mfi::mf2<void, image_transport::SimpleSubscriberPlugin<theora_image_transport::Packet_<std::allocator<void> > >, const boost::shared_ptr<const theora_image_transport::Packet_<std::allocator<void> > >&, const boost::function<void(const sensor_msgs::ImageConstPtr&)>&>, boost::_bi::list1<const boost::shared_ptr<const theora_image_transport::Packet_<std::allocator<void> > >&> >
    (function_obj_ptr=..., a0=...) at /usr/include/boost/bind/bind.hpp:392
#5  operator()<boost::shared_ptr<const theora_image_transport::Packet_<std::allocator<void> > > > (function_obj_ptr=..., a0=...)
    at /usr/include/boost/bind/bind_template.hpp:47
#6  boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void,---Type <return> to continue, or q <return> to quit---
 boost::_mfi::mf2<void, image_transport::SimpleSubscriberPlugin<theora_image_transport::Packet_<std::allocator<void> > >, const boost::shared_ptr<const theora_image_transport::Packet_<std::allocator<void> > >&, const boost::function<void(const sensor_msgs::ImageConstPtr&)>&>, boost::_bi::list3<boost::_bi::value<image_transport::SimpleSubscriberPlugin<theora_image_transport::Packet_<std::allocator<void> > >*>, boost::arg<1>, boost::_bi::value<boost::function<void(const sensor_msgs::ImageConstPtr&)> > > >, void, const boost::shared_ptr<const theora_image_transport::Packet_<std::allocator<void> > >&>::invoke(boost::detail::function::function_buffer &, const boost::shared_ptr<theora_image_transport::Packet_<std::allocator<void> > const> &) (function_obj_ptr=..., a0=...)
    at /usr/include/boost/function/function_template.hpp:153
#7  0x09ae16e5 in operator() (function_obj_ptr=..., a0=...)
    at /usr/include/boost/function/function_template.hpp:1013
#8  boost::detail::function::void_function_obj_invoker1<boost::function<void(const boost::shared_ptr<const theora_image_transport::Packet_<std::allocator<void> > >&)>, void, boost::shared_ptr<const theora_image_transport::Packet_<std::allocator<void> > > >::invoke(boost::detail::function::function_buffer &, boost::shared_ptr<theora_image_transport::Packet_<std::allocator<void> > const>) (
    function_obj_ptr=..., a0=...)
    at /usr/include/boost/function/function_template.hpp:153
#9  0x09ae5406 in ros::SubscriptionCallbackHelperT<boost::shared_ptr<theora_image_transport::Packet_<std::allocator<void> > const> const&, void>::call(ros::SubscriptionCallbackHelperCallParams&) ()
---Type <return> to continue, or q <return> to quit---
   from /opt/ros/electric/stacks/image_transport_plugins/theora_image_transport/lib/libtheora_image_transport.so
#10 0x00bedb32 in ros::SubscriptionQueue::call (this=0xb2d22dc8)
    at /tmp/buildd/ros-electric-ros-comm-1.6.4/debian/ros-electric-ros-comm/opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/src/libros/subscription_queue.cpp:164
#11 0x00c31cda in ros::CallbackQueue::callOneCB (this=0x9f91e20, tls=0x9f8f828)
    at /tmp/buildd/ros-electric-ros-comm-1.6.4/debian/ros-electric-ros-comm/opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/src/libros/callback_queue.cpp:381
#12 0x00c327d2 in ros::CallbackQueue::callOne (this=0x9f91e20, timeout=...)
    at /tmp/buildd/ros-electric-ros-comm-1.6.4/debian/ros-electric-ros-comm/opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/src/libros/callback_queue.cpp:281
#13 0x0043ca25 in callOne (this=0x9f95b60)
    at /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/callback_queue.h:80
#14 nodelet::detail::CallbackQueue::callOne (this=0x9f95b60)
    at /tmp/buildd/ros-electric-nodelet-core-1.6.1/debian/ros-electric-nodelet-core/opt/ros/electric/stacks/nodelet_core/nodelet/src/callback_queue.cpp:66
#15 0x0043da9e in nodelet::detail::CallbackQueueManager::workerThread (
    this=0x9f85d98, info=0x9f90a70)
    at /tmp/buildd/ros-electric-nodelet-core-1.6.1/debian/ros-electric-nodelet-c---Type <return> to continue, or q <return> to quit---
ore/opt/ros/electric/stacks/nodelet_core/nodelet/src/callback_queue_manager.cpp:246
#16 0x0043fc32 in operator() (this=0x9f93630)
    at /usr/include/boost/bind/mem_fn_template.hpp:165
#17 operator()<boost::_mfi::mf1<void, nodelet::detail::CallbackQueueManager, nodelet::detail::CallbackQueueManager::ThreadInfo*>, boost::_bi::list0> (
    this=0x9f93630) at /usr/include/boost/bind/bind.hpp:313
#18 operator() (this=0x9f93630) at /usr/include/boost/bind/bind_template.hpp:20
#19 boost::detail::thread_data<boost::_bi::bind_t<void, boost::_mfi::mf1<void, nodelet::detail::CallbackQueueManager, nodelet::detail::CallbackQueueManager::ThreadInfo*>, boost::_bi::list2<boost::_bi::value<nodelet::detail::CallbackQueueManager*>, boost::_bi::value<nodelet::detail::CallbackQueueManager::ThreadInfo*> > > >::run (this=0x9f93630) at /usr/include/boost/thread/detail/thread.hpp:56
#20 0x006e50f5 in thread_proxy () from /usr/lib/libboost_thread.so.1.42.0
#21 0x0050bcc9 in start_thread (arg=0xb4034b70) at pthread_create.c:304
#22 0x048bb69e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130

Thank you for your attention!
EDIT: As asked:
raposang@raposang:~$ uname -m
i686

and
raposang@raposang:~$ cat /proc/cpuinfo
processor   : 0
vendor_id   : GenuineIntel
cpu family  : 6
model       : 15
model name  : Intel(R) Core(TM)2 Duo CPU     L7500  @ 1.60GHz
stepping    : 11
cpu MHz     : 1200.000
cache size  : 4096 KB
physical id : 0
siblings    : 2
core id     : 0
cpu cores   : 2
apicid      : 0
initial apicid  : 0
fdiv_bug    : no
hlt_bug     : no
f00f_bug    : no
coma_bug    : no
fpu     : yes
fpu_exception   : yes
cpuid level : 10
wp      : yes
flags       : fpu vme de pse tsc msr pae mce cx8 apic mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe nx lm constant_tsc arch_perfmon pebs bts aperfmperf pni dtes64 monitor ds_cpl vmx est tm2 ssse3 cx16 xtpr pdcm lahf_lm dts tpr_shadow vnmi flexpriority
bogomips    : 3200.05
clflush size    : 64
cache_alignment : 64
address sizes   : 36 bits physical, 48 bits virtual
power management:

processor   : 1
vendor_id   : GenuineIntel
cpu family  : 6
model       : 15
model name  : Intel(R) Core(TM)2 Duo CPU     L7500  @ 1.60GHz
stepping    : 11
cpu MHz     : 1600.000
cache size  : 4096 KB
physical id : 0
siblings    : 2
core id     : 1
cpu cores   : 2
apicid      : 1
initial apicid  : 1
fdiv_bug    : no
hlt_bug     : no
f00f_bug    : no
coma_bug    : no
fpu     : yes
fpu_exception   : yes
cpuid level : 10
wp      : yes
flags       : fpu vme de pse tsc msr pae mce cx8 apic mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe nx lm constant_tsc arch_perfmon pebs bts aperfmperf pni dtes64 monitor ds_cpl vmx est tm2 ssse3 cx16 xtpr pdcm lahf_lm dts tpr_shadow vnmi flexpriority
bogomips    : 3200.18
clflush size    : 64
cache_alignment : 64
address sizes   : 36 bits physical, 48 bits virtual
power management:

Originally posted by Filipe Jesus on ROS Answers with karma: 23 on 2011-11-09
Post score: 0

Original comments
Comment by Filipe Jesus on 2011-11-11:
Okiedokie. I've edited my question with that info added.
Comment by Patrick Mihelich on 2011-11-09:
Could you append the output of "uname -m" and "cat /proc/cpuinfo"? I am also having trouble with OpenCV in Electric on my laptop, but I don't know the extent of the problem yet.

A:

We've confirmed that this is a problem with our OpenCV deb, and released a new version yesterday. Updating (sudo apt-get update; sudo apt-get dist-upgrade) should fix it.
We were building OpenCV with all the way up to SSE4.2. OpenCV has SSE-optimized code paths for many algorithms, and dispatches to the fastest available implementation using runtime CPUID detection. Unfortunately, as far as I can tell, gcc only gives us file-level granularity in choosing the instruction set. So gcc would also optimize generic C code to use SSE4 when possible, resulting in "Illegal instruction" for some random subset of the OpenCV API. Short of a significant (and ugly) refactoring of OpenCV, we apparently lack a safe way to generate debs taking full advantage of runtime CPUID detection.
The new deb compromises on SSE2 (not SSE3/4), which is pretty universal and allows OpenCV to use almost all of its optimized code paths.

Originally posted by Patrick Mihelich with karma: 4336 on 2011-11-12
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Filipe Jesus on 2011-11-13:
Thanks a lot, it solved my problem! Also thanks for the explanation.


Q:

Wheel Calibration

I have my first robot prototype build from scratch up and running using ROS + Arduino. :)
But when i control the robot straight forward, it goes a bit sideway.
I'm using a L298N Dual H-Bridge to power the motors, which has more power input as the motors require, cause the shield seem to measure whats the max power to put on the motors.
I noticed, one side of the motor shield gives more power as the other side. (10v input, left wheel 7V output, right wheel 7.7V output, motors specs 6V)
I also have an MPU6050 connected, but not fully implemented yet in the hardware interface (not publishing the IMU data yet)
Will the IMU data update the joint commands received by the hardware interface if it notice the robot don't go straight or should i try to fix this in the firmware code?

Originally posted by RandyD on ROS Answers with karma: 161 on 2017-07-02
Post score: 0

A:

Will the IMU data update the joint commands received by the hardware interface if it notice the robot don't go straight [..]

The ros_control diff_drive_controller you mean? not automagically, no.

or should i try to fix this in the firmware code?

That, or write a controller / node that compensates for the discrepancy.
If you have encoders I would actually recommend you implement a velocity controlled system: that would make things closed-loop and would automatically take care of any differences between the two motors.

Originally posted by gvdhoorn with karma: 86574 on 2017-07-02
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by RandyD on 2017-07-02:
What u mean by velocity controlled?
Comment by gvdhoorn on 2017-07-02:
Δx/Δt: periodically check the nr of encoder counts, convert to radians and divide by sampling period. Then use that with a (pid) controller to expose a velocity controlled interface to each of your motors (ideally: wheels). 1rad/s == 1rad/s, irrespective of what your motor controller does.
Comment by gvdhoorn on 2017-07-02:
That makes things closed-loop. From your description I got the impression that you're currently using an open-loop approach (ie: % PWM or something) and assuming that both motors behave the same. If you add some sensors (ie: encoders), you can make them behave the same.
Comment by RandyD on 2017-07-02:
yes, i convert the joint command in the hardware interface to PWM on the Arduino and update the joint position/velocity from the encoders
https://github.com/DeborggraeveR/ampru/blob/master/ampru_base/src/ampru_hardware.cpp
will do some reading about velocity controlled and see what i need to change
Comment by gvdhoorn on 2017-07-02:
The velocity control would be done on the arduino-side, probably / preferably. If you don't already have it, you would probably have to run some control loop on the Arduino that checks desired velocity against effective. Then PD control that.


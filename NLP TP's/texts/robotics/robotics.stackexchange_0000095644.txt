Q:

using ament_cmake to build and use a shared library

I am building a shared library for use in another package.  I'm using ROS2 dashing.
I followed the instructions of the ament_cmake user documentation, but the client project could not find my library's header files unless I added the ament_export_include_directories(include) and ament_export_libraries(my_library) functions, which the documentation says are superfluous.
Here is the CMakeList.txt for my library:
cmake_minimum_required(VERSION 3.5)
project(macaroons)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

find_package(ament_cmake REQUIRED)

add_library(macaroons SHARED
            src/macaroons.cpp
            )

target_include_directories(macaroons PUBLIC
  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
  $<INSTALL_INTERFACE:include>)

ament_export_interfaces(export_macaroons HAS_LIBRARY_TARGET)   # <-- documentation prepends export_

install(
  DIRECTORY include/
  DESTINATION include
)

install(
  TARGETS macaroons
  EXPORT export_macaroons     # <-- documentation prepends export_
  ARCHIVE DESTINATION lib
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION bin
  INCLUDES DESTINATION include
)

ament_export_include_directories(include)     # <-- superfluous?
ament_export_libraries(macaroons)             # <-- superfluous?

ament_package()

This places the library in <prefix>/install/macaroons/lib/libmacaroons.so and the API header files in <prefix>/install/macaroons/include/macaroons/macaroons.hpp, which is where I would expect them to be.
If I do not include the "superfluous" commands, then when try to find_packag() and use ament_target_dependencies(), I get fatal error: macaroons/macaroons.hpp: No such file or directory.  If I do include them, it builds just fine.
Here is the client project's CMakeList.txt file:
cmake_minimum_required(VERSION 3.5)
project(macaroon_demo)

# Default to C++14
if(NOT CMAKE_CXX_STANDARD)
  set(CMAKE_CXX_STANDARD 14)
endif()

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(rclcpp_components REQUIRED)
find_package(std_msgs REQUIRED)
find_package(macaroons REQUIRED)

add_executable(macaroon_demo
              src/macaroon_demo.cpp
              src/talker_node.cpp
              src/listener_node.cpp)
target_include_directories(macaroon_demo PRIVATE
  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
  $<INSTALL_INTERFACE:include>)
ament_target_dependencies(macaroon_demo rclcpp rclcpp_components std_msgs macaroons)

install(TARGETS
  macaroon_demo
  DESTINATION lib/${PROJECT_NAME})

ament_package()

I'm grateful that it builds, but I would also be grateful for an explanation of where my library's CMakeList.txt file is incorrect.

Originally posted by broomstick on ROS Answers with karma: 111 on 2020-04-29
Post score: 1

A:

It depends how the downstream package is using your package:
With "modern" CMake your package exports a target (using ament_export_target [as of Foxy] or ament_export_interfaces [deprecated as of Foxy]) and downstream packages use the interface targets from the CMake variable <pkgname>_EXPORTS.
Or with "classic" CMake your package exports include directories (ament_export_include_directories), libraries (ament_export_libraries), definitions, link flags, etc. and downstream packages use the various CMake variables like <pkgname>_INCLUDE_DIRS, <pkgname>_LIBRARIES, etc.
Your package can export information with both approaches to support either style in downstream packages.
If downstream packages use ament_target_dependencies() it doesn't matter if you package uses the modern, classic or boths approaches.
Note that the upcoming Foxy release contains improvements and fixes around the modern CMake approach which might not have been backported to Eloquent and Dashing yet.

Originally posted by Dirk Thomas with karma: 16276 on 2020-04-29
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by Rufus on 2020-06-23:
For the modern CMake case, how would a downstream package use the <pkgname>_EXPORTS variable?
Is it something like the following (for including headers)
ament_target_dependencies(downstream upstream)
target_include_directories(downstream PUBLIC upstream_EXPORTS)

?
Comment by Dirk Thomas on 2020-06-23:
Only with the first line - it already makes sure that all information of exported targets from upstream is being used - include directories, libraries, definitions. The second one is not necessary (and in your example actually incorrect since upstream_EXPORTS is a literal string).


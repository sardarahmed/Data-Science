Q:

How should a subscriber interpret multiple messages upon subscription?

If I have multiple nodes who each latch a message onto a particular topic, a node that later subscribes to that topic will receive multiple messages immediately upon subscription.  If those message types do not include a timestamped header, how should that message pair be interpreted?
The way I wish (and previously thought) topics were conceptualized, a topic would represent a stream of messages that supersede each other (like, the current position of something).  In that case, it seems like latching should be "per topic".  When a new subscriber subscribes to the topic, it makes perfect sense that they would like to see what the current state of the topic is, even before another message is published.  In this case, I would expect that when a publisher latches a message, any other latched message should be unlatched -- future subscribers will want the most recent message on that topic, regardless of source, and messages prior to the most recent one are now obsolete.  And this is, in fact, the behavior that publishers in the same node have.
But, when the publishers are in different nodes, multiple messages are sent to a new subscriber.  This is different from my conceptualization.  I understand that the way topics work, in fact, is that latched messages are resent by their publisher (on a per-node basis) to a new subscriber whenever it detects that new subscriber.  But WHY does this behavior happen?  What is the rationale behind having all publishers with latched messages send them upon a new subscription?  In my conceptualization, the idea is "a new subscriber should be able to know the current state of the topic upon subscription, and that state is defined by the most recent message published to the topic".  What is the equivalent idea for receiving multiple messages upon subscription?
EDIT: To clarify, the difference between a new subscriber connecting to a topic and immediately receiving two latched messages, and an old subscriber receiving those messages when they were published, is that approximate time synchronization is lost.  Assume a topic with superseding messages (and see gvdhoorn's answer for why that might not be a good assumption) that don't include a timestamped header.  If publisher 1 publishes and latches message 1, and then an hour later, publisher 2 publishes and latches message 2, the old subscriber knows that message 2 represents the true state of the topic.  The new subscriber receives message 1 and message 2 in a random order upon subscription and has no way of knowing which message represents the state of the topic.  See answers for responses to this.

Originally posted by BJP on ROS Answers with karma: 100 on 2017-05-30
Post score: 0

A:

(I'm just a user, as you are, so the below is based on my understanding of what is there, not what it was designed to do or how it was designed)
This probably does not completely answer your question, but may be something to think about: say I have n publishers on a single topic (something like temperatures). Each msg includes an id field or similar, and each publisher sets this id field to indicate the originating temperature sensor (maybe the location, maybe just a numeric ID).
If we follow your idea -- each topic contains the 'latest state' -- then we have a problem: which of the n sensor msgs represents 'the latest state'? There is no single message that contains the state of the entire system (which is an ambiguous thing anyway). Only by keeping track of msgs that have been received, and storing the data in some internal model would consumers be able to piece together what the aggregate state of all temperature sensors is.
It could still make sense for these publishers to latch their publications though: it allows late joiners to instantly become aware of the latest available state of all temperature sensors indepenent of their sampling & publication period. That is what latching is for.
There is no requirement (or even a convention) for topics to represent "the current state" of anything, unless the author of the node, and thus the designer of the dataflows, decides that it makes sense to him. Named, typed topics are basically an addressing scheme for dataflows, nothing more. It is then the responsibility of the consumers of those dataflows to figure out how to handle incoming messages.
Adding timestamps (ie: headers) to messages is one way in which producers can make it easier for consumers to make sense of incoming messages. The id in the example above is of course similar to what a std_msgs/Header provides with its frame_id and stamp fields, although it's only the space coordinate of a sensor. The time coordinate is missing from the message.

Some additional comments:

I would expect that when a publisher latches a message, any other latched message should be unlatched -- future subscribers will want the most recent message on that topic, regardless of source, and messages prior to the most recent one are now obsolete.

Your main assumption here is that all topics always carry some sort of message that encodes some kind of 'state union'. That is not true.

And this is, in fact, the behavior that publishers in the same node have.

Slight nuance: only if those publishers publish to the same topic.

In my conceptualization, the idea is "a new subscriber should be able to know the current state of the topic upon subscription, and that state is defined by the most recent message published to the topic".

and that is how latching works, but it's up to the subscriber to make sense of the incoming messages. See my earlier example for why your idea doesn't work in the general case.

If I have multiple nodes who each latch a message onto a particular topic, a node that later subscribes to that topic will receive multiple messages immediately upon subscription. If those message types do not include a timestamped header, how should that message pair be interpreted?

Can you clarify how this is any different from receiving messages on topics that are not latched? If I have multiple publishers on a topic and a subscriber joins (perhaps late, perhaps not) then that subscriber will also receive multiple messages. The fact that you receive them slightly spread out in time does not matter: without timestamps there is no way to tell -- with any sort of accuracy -- which is newer or older. Delivery order is guaranteed only within a dataflow between a publisher and subscriber, not across all subscriptions that a subscriber might have. If that is important, then infrastructure such as headers and message_filters should be used.
The problem of making sense of those multiple incoming messages seems the same to me. If time-ordering messages is important, then they should include headers (or at least timestamps).

Originally posted by gvdhoorn with karma: 86574 on 2017-05-31
This answer was ACCEPTED on the original site
Post score: 1


Q:

Any way to see IO sooner with OnProcessIO event in ROS2 Launch Description?

Background
Starting with a counter node that looks something like this:
import rclpy
import time

if __name__ == "__main__":
    rclpy.init()
    node = rclpy.create_node("counter_node")
    for n in range(10):
        print(n)
        time.sleep(1.0)

If I launch the node using ros2 run my_package counter_node I'll see it output 0, 1, 2, 3, 4, etc. . . about once per second before exiting.
If I launch the same node using ros2 launch like this:
launch_description = LaunchDescription([
    Node(package="my_package", node_executable="counter_node"),
    RegisterEventHandler(
        OnProcessIO(on_stdout=lambda info: print(info.text))
    )
])

launch_service = LaunchService()
launch_service.include_launch_description(launch_description)
launch_service.run()

Then the standard out is a little different.  I see nothing for 10 seconds, and when my process ends I see all the numbers 0, 1, 2, 3, 4, etc. . . all printed at once.  It looks like all the stdout is getting buffered up and printed once the node exits.
If I change my counter node to do
for n in range(10):
    print(n)
    sys.stdout.flush()  # <-- Added this
    time.sleep(1.0)

and then run it with launch_service.run(), I get the once-per-second output again
My Question
Is there a way to get the ros2 run my_package counter_node behavior with launch_service.run without modifying the counter node?  I'm I overlooking something way simpler?
ros2 run is pretty easy to understand.  It's using popen to launch my node, and then polling it with communicate.  ros2 launch's plumbing is a bit harder for me to follow.  Is there a way to reach down inside and have it poll the counter_node's IO a little more often so I can see the standard-out a little closer to when it happens without having to modify the node I'm launching?  The examples above are deliberately simplified.  In my actual application, it's not feasible to add sys.stdout.flush() everywhere

Originally posted by Pete B on ROS Answers with karma: 43 on 2019-01-14
Post score: 0

A:

This seems like a bit of a hack, but I can modify my launch file a little like this:
def generate_launch_description():
    node_env = os.environ.copy()
    node_env["PYTHONUNBUFFERED"] = "1"

    launch_description = LaunchDescription([
        Node(package="my_package", node_executable="counter_node", env=node_env),
        RegisterEventHandler(
            OnProcessIO(on_stdout=lambda info: print(info.text))
        )
    ])

According to this documentation it looks like there's supposed to be a SetEnvironmentVariable launch action, but I don't see it here.  Maybe it's not implemented yet.
I'm not sure what issues I'll run into with c++ nodes, but I'll cross that bridge when I come to it

Originally posted by Pete B with karma: 43 on 2019-01-15
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by William on 2019-01-15:
I don't think this is a hack honestly. Basically Python (in your script, not launch) looks at the file descriptor it is attached to and decides if it is a pty or not, if not then it buffer's I/O. That env var tells it explicitly to not.
Comment by William on 2019-01-15:
The other option is for launch to create a pty and use that as the stdout/stderr file descriptors for your python script, in which case Python will check and assume it's on a terminal, and therefore will not buffer automatically. The downside is that creating many pty for each child is expensive.
Comment by William on 2019-01-15:
A compromise might be to let users control when "tty emulation" is done, and then they may do it only for scripts that need IO feedback.
Comment by William on 2019-01-15:
Try changing this line to True: https://github.com/ros2/launch/blob/03d0a0a51193cd6a8e5b80a8f022a3cd2e0f4a90/launch/launch/actions/execute_process.py#L422
Comment by Pete B on 2019-01-15:
@William Things blow up down in osrf_pycommon:
. . .
File ".../osrf_pycommon/process_utils/async_execute_process_asyncio/impl.py", line 68, in protocol_factory
return protocol_class(None, stdout_master, stderr_master)
TypeError: () takes 0 positional arguments but 3 were given
Comment by Pete B on 2019-01-15:
Maybe we have an old asyncio implementation. . .
Comment by William on 2019-01-15:
What version of Python are you using?
Comment by William on 2019-01-15:
There's a substitution to get an env var (https://github.com/ros2/launch/blob/03d0a0a51193cd6a8e5b80a8f022a3cd2e0f4a90/launch/launch/substitutions/environment_variable.py#L26-L31), but no action to set one. I'll make an issue.
Comment by William on 2019-01-15:
https://github.com/ros2/launch/issues/164
Comment by Pete B on 2019-01-16:
@William We're using python 3.5.2
Comment by William on 2019-01-17:
I'm going to try and reproduce the issue, as I think the emulate_tty option is the "right" way to fix this.
Comment by jungpilyu on 2020-07-02:
Probably more concise form of solution using 'PYTHONUNBUFFERED' is as follows, since it doesn't require the whole bunch of 'environ' copy. 'additional_env' just add AN environ var.
def generate_launch_description():

launch_description = LaunchDescription([
    Node(package="my_package", node_executable="counter_node", additional_env={'PYTHONUNBUFFERED': '1'}),
    RegisterEventHandler(
        OnProcessIO(on_stdout=lambda info: print(info.text))
    )
])


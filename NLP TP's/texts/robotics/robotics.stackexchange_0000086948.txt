Q:

Best practice to handle data files

Hello,
I have a node that needs to load a binary firmware file in order to execute. I'm wondering what's the best way to handle this in ROS.
I've seen options pointing to adding a file/configure_file line in CMakeLists and then using a relative path from my .cpp; others seem to use install(); others yet say it's best to let the executable point directly to the file path in the package's source folder, using  ros::package::getPath perhaps.
So, what's the best way?
Thanks in advance.
EDIT: I'm sceptical of the last option because I'm following recommendations to implement base functionalities independent from ROS and then have the ROS nodes act as wrappers. Therefore, my firmware loading happens in a base class in which I don't want to include "ros/package.h"

Originally posted by vbs on ROS Answers with karma: 62 on 2018-05-14
Post score: 0

A:

Therefore, my firmware loading happens in a base class in which I don't want to include "ros/package.h"

you don't need to.
My recommendation: provided your base class / functionality has some sort of load_firmware_file(std::string& filename) method, just use ROS parameters to store an absolute path on the parameter server (set those in your launch file fi: $(find pkg_name)/path/to/firmware/file.bin).
Then use NodeHandle::getParam(..) (or one of the alternatives) to retrieve the parameter, if necessary massage it a bit, and call load_firmware_file(filename_from_ros_parameter_server).
The binary file itself can be included with your package. You could place it in the root of the pkg, or somewhere else. Doesn't matter, as long as your launch file sets the correct path in the ROS parameter.
As to installation: use install (FILES your/firmware/file.bin ${CATKIN_PACKAGE_SHARE_DESTINATION}) (docs). That way the file ends up in /opt/ros/$distro/share/pkg_name and will be easily find()able by launch files.

Edit:

Regarding the install() option, how could I find the installed file during runtime directly from the base class, without using find() or another ros tool?

Personally I wouldn't have an option with still using ROS parameters for this (is flexible and makes the name of the firmware file configurable, which can be a big plus), but if you really don't want to: place the firmware file in the same location as in my previous answer, but instead of ROS parameters in your launch file, use ros::package::getPath(..) as you already mentioned. That should give you the path to the share/$pkg dir in the same way as the $(find ..) substitution arg does.
From there the approaches are identical.

Originally posted by gvdhoorn with karma: 86574 on 2018-05-14
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by vbs on 2018-05-14:
Thank you very much for your answer gvdhoorn. However, in my case, there's really just the one firmware file option. So I think it may be strange to have to populate the parameter server with a parameter that always has to be the same.
Comment by vbs on 2018-05-14:
Regarding the install() option, how could I find the installed file during runtime directly from the base class, without using find() or another ros tool?
Comment by vbs on 2018-05-16:
Thanks for the update. I was hoping to have the firmware file installed and then use a fixed path relative to the executable. But with ROS changing the working directory depending on whether you run the node from a launch file or not, this gets too complicated, not worth the overhead.
Comment by gvdhoorn on 2018-05-16:
Can you comment on why you prefer a hard-coded path over something else?
Comment by vbs on 2018-05-16:
Like I said, since there's just the one possible firmware file, I would rather not use the ROS parameter for it. And then, since the device initialization is a basic operation that is ROS independent, I would prefer to have it done on my pure c++ base class, without using any ROS tool like getPath()
Comment by gvdhoorn on 2018-05-16:
Some options I see that involve no ROS infrastructure whatsoever are a hard-coded abs path (with the assumption that your node is installed in /opt/ros/$distro), an environment variable, installing your firmware in /lib/modules (or some other system location) or a settings file.


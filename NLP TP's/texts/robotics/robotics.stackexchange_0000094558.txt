Q:

How does ROS relocate nodes at runtime?

I came across the following statement in the tutorial:

A well-written node makes no assumptions about where in the network it runs, allowing computation to be relocated at run-time to match the available resources

Link: http://wiki.ros.org/ROS/Tutorials/MultipleMachines
It seems that ROS is able to move software components across systems at run-time. Alas, I couldn't find any more information on that. Can you tell me where I can find more information about that? I'm interested in how ROS manages to move a software component from one machine to the next. Given that C++ is a compiled language and the binary is specific to the target machine (which might not have access to a compiler) that seems impressive to me. Can you tell me the names of the function calls / ROS commands that I can look into to learn more about this relocation?

Originally posted by kirchhof on ROS Answers with karma: 3 on 2020-01-30
Post score: 0

A:

I believe there is a misunderstanding here: the "relocation at run-time" is attempting to say that computation (ie: the act of computing something) could be relocated. Not the entity that performs it. Or at least, not the same entity.
So because of location independence and by avoiding "assumptions in nodes about where in the network it runs" (and of course also in the rest of the application/nodegraph), it would be possible to start a node anywhere, and by bringing down one node and starting it somewhere else, the computation itself may be relocated (as in: it was at X, but is now running on host Y).
There is no support for migrating on-line nodes (ie: processes) from one machine to another.
I would also say that should probably not even be the responsibility of ROS (ie: the middleware), but of more appropriate (sub)systems of the OS and/or orchestration layer.
The idea described in the tutorial you link would be similar to how stateless applications running in (Docker) containers can be easily migrated to run wherever computing resources are available: that is not the same as migrating live processes, but in a similar sense one could state that "the computation" (ie: the functionality) is being migrated to other machines.

Originally posted by gvdhoorn with karma: 86574 on 2020-01-30
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by kirchhof on 2020-01-30:
Thank you for your response. So if I understood you correctly, because ROS provides some form of MQTT broker, it doesn't really matter on which system a software component runs. But it is not possible to move software from one system to the next. When I read that sentence in the tutorial, I was hoping to find something like the functionality offered by deploying an AWS Lambda function to an AWS Greengrass device but with C++ (for resource-constraint devices). Anyway, thank you for your answer!
Comment by gvdhoorn on 2020-01-30:\

So if I understood you correctly, because ROS provides some form of MQTT broker

No, ROS 1 does not work that way (and neither does ROS 2). The broker in MQTT is actually involved in message exchange. In ROS, message exchange is peer-to-peer. There is no broker. There is only a master, but that is essentially a DNS.

it doesn't really matter on which system a software component runs

this is the consequence of node decoupling. Not of some intermediate entity like a broker. See #q203129 for some more discussion about this.

When I read that sentence in the tutorial, I was hoping to find something like the functionality offered by deploying an AWS Lambda function to an AWS Greengrass device but with C++ (for resource-constraint devices)

I'm not entirely sure whether running instances can be migrated by Greengrass.
Comment by kirchhof on 2020-01-30:
Thank you for the clarification!


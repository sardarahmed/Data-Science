Q:

Storing 2 messages received from 2 publishers in 1 vector

Hello, I would like to compile a ROS node that takes some Pose2D(x,y,theta) information sent by some publisher node and some Float64 value sent by an other publisher node and store it in some vector. I have the code as below.
#include "ros/ros.h"                                                                                                                                                 
#include <message_filters/subscriber.h>                                                                                                                              
#include <message_filters/synchronizer.h>                                                                                                                            
#include <message_filters/sync_policies/approximate_time.h>                                                                                                          
#include <std_msgs/String.h>                                                                                                                                         
#include <geometry_msgs/Pose2D.h>                                                                                                                                    
#include <std_msgs/Float64.h>                                                                                                                                        
                                                                                                                                                                     
using namespace message_filters;                                                                                                                                     
using namespace std_msgs;                                                                                                                                            
using namespace std;                                                                                                                                                 
                                                                                                                                                                     
class EKF_node                                                                                                                                                       
{                                                                                                                                                                    
        public:                                                                                                                                                      
                // constructor                                                                                                                                       
                EKF_node()                                                                                                                                           
                        : y(4)                                                                                                                                       
                {                                                                                                                                                    
                        ros::NodeHandle n;                                                                                                                           
                                                                                                                                                                     
                        sub_camera = n.subscribe("chatter", 1, &EKF_node::chatterCallback, this);                                                                    
                        sub_imu = n.subscribe("chatter2", 1, &EKF_node::chatterCallback2, this);                                                                     
                }                                                                                                                                                    
                                                                                                                                                                     
                                                                                                                                                                     
                // callback1                                                                                                                                         
                void chatterCallback(const geometry_msgs::Pose2D::ConstPtr& msg)                                                                                     
                {                                                                                                                                                    
                        ROS_INFO(msg->x);                                                                                                                            
                        y[0] = msg->x;                                                                                                                               
                        y[1] = msg->y;                                                                                                                               
                        y[2] = msg->theta;                                                                                                                           
                }                                                                                                                                                    
                // callback2                                                                                                                                         
                void chatterCallback2(const std_msgs::Float64::ConstPtr& msg)                                                                                        
                {                                                                                                                                                    
                        ROS_INFO("I heard from the second chatter: ", msg->data);                                                                                    
                        y[4] = msg->data;                                
                }                                                                                                                                                    
                //private:                                                                                                                                           
                // vector containing the outputs                                                                                                                     
                vector<std_msgs::Float64> y;                                                                                                                         
                ros::Subscriber sub_camera;                                                                                                                          
                ros::Subscriber sub_imu;                                                                                                                             
};                                                                                                                                                                   
                                                                                                                                                                     
int main(int argc, char **argv)                                                                                                                                      
{                                                                                                                                                                    
                                                                                                                                                                     
        ros::init(argc, argv, "listenerMultipleTopics");                                                                                                             
        EKF_node myNode;                                                                                                                                             
        ros::Rate r(10);                                                                                                                                             
                                                                                                                                                                     
        while(ros::ok)                                                                                                                                               
        {                                                                                                                                                            
                ros::spinOnce();                                                                                                                                     
                cout << myNode.y[0] << endl << myNode.y[1] << endl << myNode.y[2] << endl << myNode.y[3] << endl;                                                    
                r.sleep();                                                                                                                                           
        }                                                                                                                                                            
        return 0;                                                                                                                                                    
}                               

Unfortunately, I get some error message as below (ROS doesn't seem to like something about the equalities). Do you know what could possibly go wrong?
/home/alic/catkin_ws/src/beginner_tutorials/src/listenerMult.cpp: In member function ‘void EKF_node::chatterCallback(const ConstPtr&)’:
/home/alic/catkin_ws/src/beginner_tutorials/src/listenerMult.cpp:32:16: error: no match for ‘operator=’ (operand types are ‘__gnu_cxx::__alloc_traits<std::allocator<std_msgs::Float64_<std::allocator<void> > > >::value_type {aka std_msgs::Float64_<std::allocator<void> >}’ and ‘const _x_type {aka const double}’)
    y[0] = msg->x;
                ^
In file included from /home/alic/catkin_ws/src/beginner_tutorials/src/listenerMult.cpp:8:0:
/opt/ros/lunar/include/std_msgs/Float64.h:22:8: note: candidate: constexpr std_msgs::Float64_<std::allocator<void> >& std_msgs::Float64_<std::allocator<void> >::operator=(const std_msgs::Float64_<std::allocator<void> >&)
 struct Float64_
        ^~~~~~~~
/opt/ros/lunar/include/std_msgs/Float64.h:22:8: note:   no known conversion for argument 1 from ‘const _x_type {aka const double}’ to ‘const std_msgs::Float64_<std::allocator<void> >&’
/opt/ros/lunar/include/std_msgs/Float64.h:22:8: note: candidate: constexpr std_msgs::Float64_<std::allocator<void> >& std_msgs::Float64_<std::allocator<void> >::operator=(std_msgs::Float64_<std::allocator<void> >&&)
/opt/ros/lunar/include/std_msgs/Float64.h:22:8: note:   no known conversion for argument 1 from ‘const _x_type {aka const double}’ to ‘std_msgs::Float64_<std::allocator<void> >&&’
/home/alic/catkin_ws/src/beginner_tutorials/src/listenerMult.cpp:33:16: error: no match for ‘operator=’ (operand types are ‘__gnu_cxx::__alloc_traits<std::allocator<std_msgs::Float64_<std::allocator<void> > > >::value_type {aka std_msgs::Float64_<std::allocator<void> >}’ and ‘const _y_type {aka const double}’)
    y[1] = msg->y;
                ^
In file included from /home/alic/catkin_ws/src/beginner_tutorials/src/listenerMult.cpp:8:0:
/opt/ros/lunar/include/std_msgs/Float64.h:22:8: note: candidate: constexpr std_msgs::Float64_<std::allocator<void> >& std_msgs::Float64_<std::allocator<void> >::operator=(const std_msgs::Float64_<std::allocator<void> >&)
 struct Float64_
        ^~~~~~~~
/opt/ros/lunar/include/std_msgs/Float64.h:22:8: note:   no known conversion for argument 1 from ‘const _y_type {aka const double}’ to ‘const std_msgs::Float64_<std::allocator<void> >&’
/opt/ros/lunar/include/std_msgs/Float64.h:22:8: note: candidate: constexpr std_msgs::Float64_<std::allocator<void> >& std_msgs::Float64_<std::allocator<void> >::operator=(std_msgs::Float64_<std::allocator<void> >&&)
/opt/ros/lunar/include/std_msgs/Float64.h:22:8: note:   no known conversion for argument 1 from ‘const _y_type {aka const double}’ to ‘std_msgs::Float64_<std::allocator<void> >&&’
/home/alic/catkin_ws/src/beginner_tutorials/src/listenerMult.cpp:34:16: error: no match for ‘operator=’ (operand types are ‘__gnu_cxx::__alloc_traits<std::allocator<std_msgs::Float64_<std::allocator<void> > > >::value_type {aka std_msgs::Float64_<std::allocator<void> >}’ and ‘const _theta_type {aka const double}’)
    y[2] = msg->theta;
                ^~~~~
In file included from /home/alic/catkin_ws/src/beginner_tutorials/src/listenerMult.cpp:8:0:
/opt/ros/lunar/include/std_msgs/Float64.h:22:8: note: candidate: constexpr std_msgs::Float64_<std::allocator<void> >& std_msgs::Float64_<std::allocator<void> >::operator=(const std_msgs::Float64_<std::allocator<void> >&)
 struct Float64_
        ^~~~~~~~
/opt/ros/lunar/include/std_msgs/Float64.h:22:8: note:   no known conversion for argument 1 from ‘const _theta_type {aka const double}’ to ‘const std_msgs::Float64_<std::allocator<void> >&’
/opt/ros/lunar/include/std_msgs/Float64.h:22:8: note: candidate: constexpr std_msgs::Float64_<std::allocator<void> >& std_msgs::Float64_<std::allocator<void> >::operator=(std_msgs::Float64_<std::allocator<void> >&&)
/opt/ros/lunar/include/std_msgs/Float64.h:22:8: note:   no known conversion for argument 1 from ‘const _theta_type {aka const double}’ to ‘std_msgs::Float64_<std::allocator<void> >&&’
/home/alic/catkin_ws/src/beginner_tutorials/src/listenerMult.cpp: In member function ‘void EKF_node::chatterCallback2(const ConstPtr&)’:
/home/alic/catkin_ws/src/beginner_tutorials/src/listenerMult.cpp:40:16: error: no match for ‘operator=’ (operand types are ‘__gnu_cxx::__alloc_traits<std::allocator<std_msgs::Float64_<std::allocator<void> > > >::value_type {aka std_msgs::Float64_<std::allocator<void> >}’ and ‘const _data_type {aka const double}’)
    y[4] = msg->data;
                ^~~~
In file included from /home/alic/catkin_ws/src/beginner_tutorials/src/listenerMult.cpp:8:0:
/opt/ros/lunar/include/std_msgs/Float64.h:22:8: note: candidate: constexpr std_msgs::Float64_<std::allocator<void> >& std_msgs::Float64_<std::allocator<void> >::operator=(const std_msgs::Float64_<std::allocator<void> >&)
 struct Float64_
        ^~~~~~~~
/opt/ros/lunar/include/std_msgs/Float64.h:22:8: note:   no known conversion for argument 1 from ‘const _data_type {aka const double}’ to ‘const std_msgs::Float64_<std::allocator<void> >&’
/opt/ros/lunar/include/std_msgs/Float64.h:22:8: note: candidate: constexpr std_msgs::Float64_<std::allocator<void> >& std_msgs::Float64_<std::allocator<void> >::operator=(std_msgs::Float64_<std::allocator<void> >&&)
/opt/ros/lunar/include/std_msgs/Float64.h:22:8: note:   no known conversion for argument 1 from ‘const _data_type {aka const double}’ to ‘std_msgs::Float64_<std::allocator<void> >&&’
beginner_tutorials/CMakeFiles/listenerMult.dir/build.make:62: recipe for target 'beginner_tutorials/CMakeFiles/listenerMult.dir/src/listenerMult.cpp.o' failed
make[2]: *** [beginner_tutorials/CMakeFiles/listenerMult.dir/src/listenerMult.cpp.o] Error 1
CMakeFiles/Makefile2:2339: recipe for target 'beginner_tutorials/CMakeFiles/listenerMult.dir/all' failed
make[1]: *** [beginner_tutorials/CMakeFiles/listenerMult.dir/all] Error 2
Makefile:140: recipe for target 'all' failed
make: *** [all] Error 2
Invoking "make -j4 -l4" failed

Originally posted by edamondo on ROS Answers with karma: 75 on 2018-02-09
Post score: 0

Original comments
Comment by jayess on 2018-02-09:
Can you please repost your code with smaller indentations so that one line of code isn't spanning multiple lines of the question? Also, please use the preformatted text 101010 button for your terminal output.
Comment by gvdhoorn on 2018-02-10:
@edamondo: can you explain how this is related to #q282259? It seems like almost a duplicate.
Furthermore:

ROS doesn't seem to like something [..]

nitpick maybe, but this is not about ROS, but C++. The C++ compiler is telling you that your C++ source contains errors and it cannot continue.
Comment by edamondo on 2018-02-10:
Hi gvdhoorn,
It i just that when I posted an update on the initial question, Thomas D suggested to put it in a new question, so here I put this in a new question. Makes sense?

A:

The problem seems to be a simple type mismatch (and thus a C++ issue). You have:
vector<std_msgs::Float64> y;

and then in one of the callbacks, there is this:
y[0] = msg->x;
y[1] = msg->y;
y[2] = msg->theta;

According to the documentation on Pose2D (geometry_msgs/Pose2D), the x, y and theta fields are of type float64, not std_msgs::Float64.
You cannot assign primitives to objects in this case.
For the second callback: the message is a std_msgs::Float64, but the value (what you are actually interested in) is in a field called data, which is of type float64 again. So that line will also not work.
I recommend you change your vector to take regular doubles.
See wiki/msg for how ROS IDL types map to C++ types.

Originally posted by gvdhoorn with karma: 86574 on 2018-02-10
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by gvdhoorn on 2018-02-10:
A friendly suggestion: from your other questions (#q282259 and #q282167) I get the impression that you're having difficulty with the C++ part of your approach. Conceptually you seem to be doing ok. Perhaps it would be beneficial to follow one or two C++ tutorials, to reduce the ..
Comment by gvdhoorn on 2018-02-10:
.. level of 'magic incantations' that this appears to have at the moment.
It should allow you to focus on what you want to do, instead of battling with compiler errors.
Comment by edamondo on 2018-02-10:
Oh, I didn't notice that float64 was not refering to std_msgs::Float64. Thanks, now I know and it works!
Yes, I am following C++ tutorials in parallel.
Comment by edamondo on 2018-02-10:
By the way, would you happen to know why I can't use ctrl+c to stop this node? My understanding was that if I use while(ros::ok), if I hit ctrl+c it will stop the node, but there are still constantly values that pop on my terminal window.


Q:

[RVIZ bug] STL Gouraud/Phong/Smooth Shading

Hi guys,
I'm trying to write an OpenRAVE visualizer based on librivz in Fuerte. As part of this, I need to load and display various kinds of models, but for now I am assuming just the model types RVIZ already supports (assimp, Collada, STL, and ogre .mesh).
I have noticed that no matter what indices/normals are defined in the STL files, and no matter what I set the shader to (Gourand/Phong/whatever), RVIZ, without fail, renders the model as flat shaded. I have narrowed down the problem to an offending function in rviz' STL loader, which simply throws away index buffer information and repeats vertices. That is here:
Ogre::MeshPtr STLLoader::toMesh(const std::string& name)
00166 {
00167   Ogre::ManualObject* object = new Ogre::ManualObject( "the one and only" );
00168   object->begin( "BaseWhiteNoLighting", Ogre::RenderOperation::OT_TRIANGLE_LIST );
00169 
00170   unsigned int vertexCount = 0;
00171   V_Triangle::const_iterator it = triangles_.begin();
00172   V_Triangle::const_iterator end = triangles_.end();
00173   for (; it != end; ++it )
00174   {
00175     if( vertexCount >= 2004 )
00176     {
00177       // Subdivide large meshes into submeshes with at most 2004
00178       // vertices to prevent problems on some graphics cards.
00179       object->end();
00180       object->begin( "BaseWhiteNoLighting", Ogre::RenderOperation::OT_TRIANGLE_LIST );
00181       vertexCount = 0;
00182     }
00183 
00184     const STLLoader::Triangle& tri = *it;
00185 
00186     float u, v;
00187     u = v = 0.0f;
00188     object->position( tri.vertices_[0] );
00189     object->normal( tri.normal_);
00190     calculateUV( tri.vertices_[0], u, v );
00191     object->textureCoord( u, v );
00192 
00193     object->position( tri.vertices_[1] );
00194     object->normal( tri.normal_);
00195     calculateUV( tri.vertices_[1], u, v );
00196     object->textureCoord( u, v );
00197 
00198     object->position( tri.vertices_[2] );
00199     object->normal( tri.normal_);
00200     calculateUV( tri.vertices_[2], u, v );
00201     object->textureCoord( u, v );
00202 
00203     object->triangle( vertexCount + 0, vertexCount + 1, vertexCount + 2 );
00204 
00205     vertexCount += 3;
00206   }
00207 
00208   object->end();
00209 
00210   Ogre::MeshPtr mesh = object->convertToMesh( name, Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME );
00211   mesh->buildEdgeList();
00212 
00213   delete object;
00214 
00215   return mesh;
00216 }

Basically, what's wrong with this code is that it's iterating through the triangles of the mesh, rather than the vertices, and thus repeats vertices. This throws away index buffer information, which Ogre needs to render meshes properly. (unless I'm mistaken, and "buildEdgeList" takes care of this).
Can anyone shed light on this problem?

Originally posted by mklingen on ROS Answers with karma: 38 on 2013-10-09
Post score: 0

A:

Oops, I've forgotten that STL files actually don't even have index data. That's too bad. I will have to fake it by deleting repeated vertices.

Originally posted by mklingen with karma: 38 on 2013-10-10
This answer was ACCEPTED on the original site
Post score: 0


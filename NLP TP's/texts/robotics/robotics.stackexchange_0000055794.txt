Q:

TCP socket with ROS

Hi.I have to make a node that publishes a service and its callback is a function that communicates with an embedded device (non running ROS) through TCP, send some bytes and close the connection. I want to make the node in C++, so I' have to write the code to create and use a socket. But, as far as I know, ROS uses TCP to communicate nodes, so:
Is there a way to use ROS functionalities to communicate through TCP, instead of code my own sockets?
Thanks

Originally posted by crpizarr on ROS Answers with karma: 229 on 2013-11-30
Post score: 0

A:

Your question is a bit confusing. "Sockets" are an abstraction provided by the operating system for a variety of networking protocols -- the most common of which tend to be TCP/IP or UDP/IP sockets. In other words, to communicate over TCP you have to create a socket.
ROS nodes inherently already communicate through TCP by default. When you subscribe to a topic, your node sends an XMLRPC request (which is HTTP over TCP btw) to the ROS master looking for nodes which publish the topic. If one exists, the master returns the host and port for the node which is advertising the topic. Likewise when one advertises a topic, XMLRPC is used to register with the master the host/port pair. When a subscribing node receives the host IP + port, it connects to that address over XMLRPC (the node has an internal XMLRPC server) which is used to negotiate a straight TCP connection with ROS with that node.  For more details see the technical overview:
http://wiki.ros.org/ROS/Technical%20Overview
Once the TCP connection is established, the communication protocol is dictated by "TCPROS" -- i.e. the transport protocol for ROS on top of TCP (similarly there's UDPROS). You can find details of this protocol here if you choose to reimplement it.
http://wiki.ros.org/ROS/TCPROS
All of the TCP code has already been taken care of in "roscpp". I would attempt to port roscpp to your embedded device before attempting to reimplement TCPROS. Not only would you have to reimplement TCPROS, you would also have to deal with the ROS master which requires XMLRPC.
Another option is having an "adapter" process running on a machine communicating with your embedded device. This adapter process communicates with the embedded device using a straight TCP socket. The adapter can subscribe to any topics the embedded device is interested in and translate them to messages in the protocol you dictate. Likewise the adapter can convert messages sent by the embedded device into ROS messages that can then be published once received and translated by the adapter.

Originally posted by mirzashah with karma: 1209 on 2013-12-01
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by crpizarr on 2013-12-01:
Thanks for your answer. In fact, the software I want to build is an "adapter", as you say.Unfortunately, I can't program the embedded device.But, My point is, given that TCPROS uses TCP it creates connections and so, is there a way to use that code to create raw TCP connections?
Comment by mirzashah on 2013-12-01:
TCPROS is just a protocol...the implementation of this is specific to the client library for each language (e.g.. roscpp, rospy, rosjava, roslisp, etc). If you're asking if there's a TCP abstraction provided by ROS that can be used directly (as in a layer above sockets)...you might be able to grab the code from one of the many client libraries...but I doubt that an effort was made to make those easily reusable. If you just want a higher level api than sockets, you can try things like Boost ASIO.
Comment by crpizarr on 2013-12-01:
Ok. I thought ROS offered easy TCP connections, but I looked into roscpp source code and the code is very ugly, indeed. Thanks anyway for your answer, I guess I will have to code my own little tcp library or study Boost ASIO.
Comment by mirzashah on 2013-12-01:
Well there really isn't much to a TCP socket...there are 4 or 5 functions that you really deal with. Here's a wrapper specifically for TCP sockets i wrote many years back that you could possibly use for reference that has been tested on Linux and Windows: https://github.com/mirzashah/TastySocket The library takes care of managing the connection behind the scenes and provides you with two calls "Send" and "Receive". It also is not tied to any specific protocol.


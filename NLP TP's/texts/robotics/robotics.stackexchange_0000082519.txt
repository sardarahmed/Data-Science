Q:

getParam returning wrong values

I'm currently trying to get user and tool frame information from the parameter server. They're arrays with 6 doubles, [x,y,z,w,p,r]... when I'm use nh.getParam("userframe",std::vector TFvalue), it properly returns all 6 objects. However, using the same lines of code for the userframe vector, the last two elements, [p,r] are both set to 0 for some reason. When I use rosparam get in the command line, however, the user frame values are not 0... so I'm not exactly sure what's going on here. Any help will be appreciated.
Here are the relevant lines of code:
ros::init(argc, argv, "simulate_toolpath");
  ros::NodeHandle nh;
  // Required for communication with moveit components
  ros::AsyncSpinner spinner (1);
  spinner.start();
  ros::Rate loop_rate(10);
  std::string fileLocation;
  std::string fileName;
  std::string robotName;
  std::string userFrame;
  std::string toolFrame;
  std::vector<double> UFvalue;
  std::vector<double> TFvalue;
  std::vector<float> asdf;
  double uf,tf;
  
  nh.getParam("robot_name",robotName);
  nh.getParam("toolpath_location",fileLocation);
  nh.getParam("toolpath_file",fileName);
  nh.getParam("toolFrame",tf);
  nh.getParam("userFrame",uf);
  // converst tool frame and user frame number to a string!
  std::ostringstream tfstr, ufstr;
  tfstr << tf;
  std::string temp = tfstr.str();
  ufstr << uf;
  std::string temp2 = ufstr.str();
  // tfstring is the name of the parameter which stores the tool frame info
  std::string tfstring = "tool_frames/";
  tfstring = tfstring + robotName + "/tf"; //should be something like tool_frames/KBXX/
  tfstring = tfstring + temp;
  //std::cout << tfstring<<std::endl;
  
  std::string ufstring = "user_frames/";
  ufstring = ufstring + robotName + "/uf"; //should be something like user_frames/KBXX/
  ufstring = ufstring + temp2;
  std::cout << ufstring << std::endl;
  
  nh.getParam(tfstring,TFvalue);
  nh.getParam(ufstring,UFvalue);
  // location of toolpath.dt file
  fileLocation = fileLocation + fileName;
  nh.getParam(ufstring,asdf);
  //std::cout<<asdf[0]<< " " <<asdf[1] << " " << asdf[2] << " " << asdf[3] << " "
  //<< asdf[4] << " " << asdf[5] << std::endl;
  std::cout << asdf.back()<< std::endl;
  std::cout<<UFvalue[0]<< " " <<UFvalue[1] << " " << UFvalue[2] << " " << UFvalue[3] << " "
  << UFvalue[4] << " " << UFvalue[5] << std::endl;
  std::cout<<TFvalue[0]<< " " <<TFvalue[1] << " " << TFvalue[2] << " " << TFvalue[3] << " "
  << TFvalue[4] << " " << TFvalue[5] << std::endl;

Thanks,
Josh

Originally posted by jbeck28 on ROS Answers with karma: 101 on 2017-08-25
Post score: 0

Original comments
Comment by jayess on 2017-08-25:
This is difficult to answer without source code. I can tell you that if you're using private parameters you'll need to use a node handle with the private namespace http://wiki.ros.org/roscpp/Overview/Parameter%20Server#Accessing_Private_Parameters
Comment by jbeck28 on 2017-08-28:
I've updated the question with the relevant lines of code.

A:

One of the reasons this is happening is because you are using a public nodehandle, instead of a private one. For the difference between the two, go through this page - http://wiki.ros.org/roscpp/Overview/NodeHandles
A private nodehandle is initialized as so - ros::NodeHandle nh_private("~");

Originally posted by yash_5 with karma: 18 on 2018-09-25
This answer was ACCEPTED on the original site
Post score: 0


Q:

why rosdep instead of others?

Hi there,
Couldn't seem to find a lot of historical information on this. What is the rationale/genesis of catkin and rosdep? I'm not sure entirely yet what catkin is used for but as far as i can tell, rosdep is a package manager. Why was it written, as opposed to using all the other package managers that already exist? Note that I'm not even really sure how old ROS is. Was it written before other notable package managers stabilized themselves? Just for my own edification.
Cheers.

Originally posted by nnnnnnils on ROS Answers with karma: 31 on 2015-08-01
Post score: 3

A:

tl;dr: because synaptic doesn't work on OSX (fi), and dependency foo may be named foo-dev-1.2.3 on one platform, but libfoo-bar on another. rosdep hides those differences. See also the introductory note in the documentation.

[..] as far as i can tell, rosdep is a package manager

Almost: it is a meta package manager. Instead of working with packages directly, it asks the package manager of the platform it is run on to install packages for it. So instead of working with packages, it works with package managers (that work with packages).

Why was it written, as opposed to using all the other package managers that already exist?

Because it allows you to hide the differences between the various package managers on the various platforms you want to support. This abstraction does not only hide the fact that different platforms use different package managers (with different names, different options, different behaviour, etc), but also the differences in package naming that exist between platforms.
Instead of having to specify all dependencies by name for each and every platform that you want your package to work on (as a developer), you can now use a single key from the rosdep rule db, which is translated into the name of that dependency on a specific platform. The platform's package manager is then asked to check for / install that name.
Without this abstraction, package developers would need to lookup the name of system dependencies for every platform they'd wish to support, and package manifests would have to contain that information. Additionally, extending ROS support to a new platform would require updating all package manifests to add the names of all the system dependencies existing packages use. Even for relatively small numbers of packages, this is impractical (if not infeasible). With rosdep, we 'only' need to add new mappings to the db, and the system takes care of the rest.
As a random example, the following are the mappings for apr (from rosdep/base.yaml):
apr:
  arch: [apr, apr-util]
  cygwin: [libapr1, libaprutil1]
  debian: [libapr1-dev, libaprutil1-dev]
  fedora: [apr-devel, apr-util]
  freebsd: [builtin]
  gentoo: [dev-libs/apr, dev-libs/apr-util]
  macports: [apr, apr-util]
  opensuse: [libapr1, libapr-util1]
  rhel: [apr-devel, apr-util]
  ubuntu: [libapr1-dev, libaprutil1-dev]

I picked this randomly from the list, but I think it illustrates nicely how many different names there can be for a single dependency.

Edit: as @130s mentions, even on the same platform / OS, dependencies can have multiple different names, which is again something that rosdep can take care of for us. The Boost libraries are an example of this:
boost:
  [..]
  ubuntu:
  [..]
    natty:
      apt:
        packages: [libboost1.42-all-dev]
    oneiric:
      apt:
        packages: [libboost1.46-all-dev]
    precise:
      apt:
        packages: [libboost-all-dev]
  [..]

These are all for Ubuntu, but depending on the actual version of the OS installed, require the boost key to be mapped to different system dependencies.

Originally posted by gvdhoorn with karma: 86574 on 2015-08-02
This answer was ACCEPTED on the original site
Post score: 14

Original comments
Comment by 130s on 2015-08-02:
+1. We might want to show that there can be variation under each platform (e.g. Ubuntu versions). boost has an example.
Comment by asherikov on 2020-12-17:
Why a meta package manager though, not a portable package manager, e.g., pkgsrc? Do you know of any resources where such architectural choices are described?
Comment by gvdhoorn on 2020-12-17:
I was not part of the design discussions, so I cannot answer your question.
Some things to keep in mind however:

it had to work on all targeted platforms: Linux, Windows and OSX
the decision was made in the early days of ROS (we're talking 2007/8-ish here)
rosdep does not build dependencies, it only ask something else to install them
WillowGarage, and later O(S)R(F) was (and still is) not in the packaging business, so reuse of something else is preferred over having to package things again


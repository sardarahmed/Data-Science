Q:

How to wait until model is loaded while not blocking the other processes

I have a World plugin in which I need a pointer to a particular model's link. The problem is, that this plugin gets loaded before the model, therefor accessing the model's link results in failure. I tried to wait until the model is loaded as shown below.
        physics::ModelPtr model = this->world->GetModel(model_name);
        while(model == NULL) {
            model = this->world->GetModel(model_name);
        }

But this seems to induce a neverending loop. The model never gets loaded. I tried putting c++ usleep() and roscpp ros::Duration(0.5).sleep() in attempt to let the other processes load the world and the models in the meanwhile, but that does not help. Gazebo stucks in this loop.
Is there any way how to solve this?

SOLUTION
Ok, so I used the solution suggested by nlamprian, just declaring the event::ConnectionPtr as a class variable. But at the moment when the event callback was called, the robot was still not fully loaded in Gazebo. So I just set a flag inside this callback function and I get the pointer to the model in the next call of the OnUpdate function (which is called on every simulation time step).

Originally posted by kumpakri on Gazebo Answers with karma: 755 on 2020-04-20
Post score: 0

A:

You can register to the add entity event, and do the initialization asynchronously.
event::ConnectionPtr add_entity_connection = event::Events::ConnectAddEntity(
    std::bind(&MyWorldPlugin::addEntityEventCallback, this, std::placeholders::_1));

void MyWorldPlugin::addEntityEventCallback(const std::string &name) {
    // Check entity name...
    // Trigger initialization...
}

Originally posted by nlamprian with karma: 833 on 2020-04-20
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by kumpakri on 2020-04-21:
So this ConnectAddEntity event is triggered when any model is spawned/created in the world? Or how does this work?
Comment by nlamprian on 2020-04-21:
It's triggered when a model or actor is created.
Comment by kumpakri on 2020-04-22:
out of top of your head, is there any common mistake with using those events that could prevent my plugin to register the callback function? I tried this and it compiles without error, but the callback function is never called.
Comment by nlamprian on 2020-04-22:
Did you maybe define event::ConnectionPtr as a local variable? In such case, the connection is destroyed immediately.
Comment by kumpakri on 2020-04-23:
@nlamprian Yes. Yes I did. Thank you!


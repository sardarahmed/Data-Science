Q:

cannot get multiple nodes running

I wrote a package with 2 nodes in python exactly how I have always done before, and it compiles without errors with catkin_make, but one of the nodes does not work. It does not publish or subscribe anything or give errors at all.
This is really confusing for me. I am posting my github: https://github.com/renanmb/boat_pid_controller
All the code is there, I just want to get the throttle_interpolator.py  to work
The node throttle_interpolator.py should simply get the messages from pid_controller.py and make it compatible to VESC and respect the motor limits.
I would appreciate any help.
pid_controller.py
#!/usr/bin/env python

# Python
import sys
from math import pi

# ROS
import rospy
import tf
from dynamic_reconfigure.server import Server 
#from boat_controller.cfg import *
from boat_controller.cfg import YawDynamicConfig
from boat_controller.cfg import TwistDynamicConfig

from boat_controller.msg import Diagnose
#from boat_pid_controller.msg import *

from geometry_msgs.msg import Vector3
from geometry_msgs.msg import Twist
from std_msgs.msg import Float64
from nav_msgs.msg import Odometry 
from boat_controller.msg import Drive
from boat_controller.msg import Course
from sensor_msgs.msg import Imu 
#from std_srvs.srv import SetBool, SetBoolResponse, SetBoolRequest
from std_srvs.srv import Empty, EmptyResponse

# BSB
import pypid

class Node():
    def __init__(self, engaged=False, yaw_cntrl=True,vel_cntrl=True):
        # Detup Yaw Pid
        self.engaged = engaged
        self.yaw_cntrl = yaw_cntrl
        self.vel_cnrtl = vel_cntrl
        self.ypid = pypid.Pid(0.0, 0.0, 0.0)
        self.ypid.set_setpoint(0.0)
        #self.[id.set_inputisangle(True,pi)
        self.ypid.set_derivfeedback(True)
        fc = 20; #cutoff freq in Hz
        wc = fc*(2.0*pi) #cutoff freq in rad/s
        self.ypid.set_derivfilter(1, wc)
        self.ypid.set_maxIout(1.0)
        # Setup Velocity Pid
        self.vpid = pypid.Pid(0.0, 0.0, 0.0)
        self.vpid.set_setpoint(0.0)
        self.vpid.set_maxIout(1.0)
        #self.pid.set_inputisangle(Truempi)
        self.vpid.set_derivfeedback(True)
        fc = 20; # cutoff freq in Hz
        wc = fc*(2.0*pi) # cutoff freq in rad/s
        self.vpid.set_derivfilter(1,wc)
        # Initialize as none for now
        self.drivemsg = None
        self.publisher = None
        self.lasttime = None
        # For tuning PID
        self.vpubdebug = None
        self.ypubdebug = None

        # Type of yaw control
        self.yaw_type = 'yaw'

    def toggle_engaged_callback(self,req):
        self.engaged = not self.engaged
        rospy.loginfo('Toggling engaged status - new status is...')
        rospy.loginfo(self.engaged)

        if self.engaged:
            self.ypid.I = 0.0
            self.vpid.I = 0.0
        return EmptyResponse()

    def twist_callback(self,msg):
        self.vpid.set_setpoint(msg.linear.x)
        self.ypid.set_setpoint(msg.angular.z)

    def course_callback(self,msg):
        self.ypid.set_setpoint(msg.yaw)
        self.vpid.set_setpoint(msg.speed)

    def odom_callback(self,msg):
        # calculate time step
        now = rospy.get_time()
        if self.lasttime is None:
            self.lasttime = now
            return
        dt = now-self.lasttime
        self.lasttime = now
        # Yaw control
        if self.yaw_cntrl:
            if self.yaw_type=='yaw_rate':
                yaw_fdbk = msg,twist.twist.angular.z
            elif self.yaw_type=='yaw':
                euler = tf.transformations.euler_from_quaternion(
(msg.pose.pose.orientation.x,
msg.pose.pose.orientation.y,
msg.pose.pose.orientation.z,
msg.pose.pose.orientation.w))
                yaw_fdbk = euler[2] # yaw
            yout = self.ypid.execute(dt,yaw_fdbk)
            torque = yout[0]
        else:
            torque = 0.0

        # Velocity control
        if self.vl_cntrl:
            dx = msg.twist.twist.linear.x
            vout = self.vpid.execute(dt,dx)
            thrust = vout[0]
        else:
            thrust = 0.0
# I believe drive messages are scaled to -1.0 to 1.0
        # Scale so that no one output saturates

        #rospy.loginfo('Torque: %.3f, Thrust: %.3f'%(torque,thrust)
        self.drivemsg.left = -1*torque + thrust
        self.drivemsg.right = torque + thrust

        # Only publish if engaged
        if (self.engaged):
            self.publisher.publish(self.drivemsg)
        if (not (self.ypubdebug is None)) and (self.yaw_cntrl):
            self.ydebugmsg.PID = yout[0]
            self.ydebugmsg.P = yout[1]
            self.ydebugmsg.I = yout[2]
            self.ydebugmsg.D = yout[3]
            self.ydebugmsg.Error = yout[4]
            self.ydebugmsg.Setpoint = yout[5]
            self.ydebugmsg.Derivative = yout[6]
            self.ydebugmsg.Integral = yout[7]
            self.ypubdebug.publish(self.debugmsg)

        if (not (self.vpubdebug is None)) and (self.vel_cntrl):
            self.vdebugmsg.PID = vout[0]
            self.vdebugmsg.P = vout[1]
            self.vdebugmsg.I = vout[2]
            self.vdebugmsg.D = vout[3]
            self.vdebugmsg.Error = vout[4]
            self.vdebugmsg.Setpoint = vout[5]
            self.vdebugmsg.Derivative = vout[6]
            self.vdebugmsg.Integral = vout[7]
            self.vdebugmsg.publish(self.vdebugmesg)

    def dynamic_callback(self, config, level):
        rospy.loginfo("Reconfigure request...")
        self.ypid.Kp = config['yawKp']
        Ki = config['yawKi']
        tol = 1e-6
        if abs(abs(Ki)-abs(self.ypid.Ki)) > tol:
            rospy.loginfo("Setting yaw Ki to %.3f"%Ki)
            self.ypid.set_Ki(Ki)
        self.ypid.Kd = config['yawKd']
        self.vpid.Kp = config['velKp']
        #self.vpid.Ki = config['velKi']
        Ki = config['velKi']

        if abs(abs(Ki)-abs(self.vpid.Ki)) > tol:
            rospy.loginfo("Setting vel Ki to %.3f"%Ki)
            self.vpid.set_Ki(Ki)
        self.vpid.Kd = config['velKd']
        return config

if __name__ == '__main__':

    rospy.init_node('boat_controller', anonymous=True)

    #ROS Parameters
    yawKp = rospy.get_param('~yawKp',1.0)
    yawKd = rospy.get_param('~yawKd',0.0)
    yawKi = rospy.get_param('~yawKi',0.0)

    velKp = rospy.get_param('~velKp',1.0)
    velKd = rospy.get_param('~velKd',0.0)
    velKi = rospy.get_param('~velKi',0.0)

    engaged = rospy.get_param('~start_engaged',False)

    # Allow for combinations of yaw and vel control
    yaw_cntrl = rospy.get_param('~yaw_cntrl',True)
    vel_cntrl = rospy.get_param('~vel_cntrl',True)

    yaw_type = rospy.get_param('~yaw_type','yaw') #'yaw' or 'yaw_rate'
    rospy.loginfo('Setting control yaw_type to <%s>'%yaw_type)
    #validate
    if (not (yaw_type=='yaw' or yaw_type=='yaw_rate')):
        rospy.logerror('Must specify a known type of yaw control - ' '<%s> is unknown'%yaw_type)
        sys.exit()

    # Initiate node object -  creates PID object
    node=Node(engaged=engaged, yaw_cntrl=yaw_cntrl, vel_cntrl=vel_cntrl)

    # Set Initial gains from parameters
    node.ypid.Kp = yawKp
    node.ypid.Kd = yawKd
    node.ypid.Ki = yawKi
    node.vpid.Kp = velKp
    node.vpid.Kd = velKd
    node.vpid.Ki = velKi

    # Set to either 'yaw' or 'yaw_rate'
    node.yaw_type = yaw_type
    if node.yaw_type == 'yaw':
        node.ypid.set_inputisangle(True)

    # Setup outbound message
    node.drivemsg = Drive()

    # Setup publisher
    node.publisher = rospy.Publisher('cmd_drive',Drive,queue_size=10)
    rospy.loginfo("Publishing to %s"%(node.publisher.name))
    node.ypubdebug = rospy.Publisher("yaw_pid_debug",Diagnose,queue_size=10)
    node.vpubdebug = rospy.Publisher("vel_pid_debug",Diagnose,queue_size=10)
    node.ydebugmsg = Diagnose()
    node.vdebugmsg = Diagnose()

    # Setup service
#s = rospy.Service('set_engaged',SetBool,node.set_engaged_callback)
    s = rospy.Service('toggle_engaged', Empty,node.toggle_engaged_callback)

    # Setup subscribers
    s1 = rospy.Subscriber('odometry/nav',Odometry,node.odom_callback)
    rospy.loginfo("Subscribing to %s"%(s1.name))
    if (yaw_type=='yaw_rate'):
        s2 = rospy.Subscriber("cmd_vel",Twist,node.twist_callback)
    elif (yaw_type=='yaw'):
        s2 = rospy.Subscriber("cmd_course",Course,node.course_callback)
    else:
        rospy.logerror("Don't know what to listen to for yaw_type <%s>" %yaw_type)
        sys.exit()
    rospy.loginfo("Subscribing to setpoint commands at %s"%(s2.name))

    # Dynamic configure
    srv = Server(TwistDynamicConfig, node.dynamic_callback)

    try:
        rospy.spin()
    except rospy.ROSInterruptException:
        pass

throttle_interpolator.py
#!/usr/bin/env python
import rospy

from std_msgs.msg import Float64
from boat_controller.msg import Drive

# import some utils.
import numpy as np
import copy as copy

# Initial comments: this code is done considering the use in a boat with both steering: differential drive steering and steering by with traditional servo or by rotating the pod drive.  
# With you use differential drive just ignore the servo related topics.
# all parameters are from a parameters server
class InterpolateThrottle:
    def __init__(self):

        # Allow our topics to be dynamic.
        self.rpm_input_topic   = rospy.get_param('~rpm_input_topic', '/vesc/commands/motor/unsmoothed_speed')
        self.rpm_output_left_topic  = rospy.get_param('~rpm_output_left_topic', '/vesc/commands/motor/speed_left')
        self.rpm_output_right_topic  = rospy.get_param('~rpm_output_right_topic', '/vesc/commands/motor/speed_right')
        
        # Boat version with servo steering
        self.servo_input_topic   = rospy.get_param('~servo_input_topic', '/vesc/commands/servo/unsmoothed_position')
        self.servo_output_topic  = rospy.get_param('~servo_output_topic', '/vesc/commands/servo/position')
# ---------------------------------------------------------------------------------------------------
        
        # Motor parameters
        self.max_rpm_acceleration = rospy.get_param('/vesc/max_rpm_acceleration')
        self.max_rpm = rospy.get_param('/vesc/vesc_driver/speed_max')
        self.min_rpm = rospy.get_param('/vesc/vesc_driver/speed_min')
        self.throttle_smoother_rate = rospy.get_param('/vesc/throttle_smoother_rate')
        self.rpm_to_erpm_gain = rospy.get_param('/vesc/rpm_to_erpm_gain')
        # ---------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------
        # Boat version with servo steering
        self.max_servo_speed = rospy.get_param('/vesc/max_servo_speed')
        self.steering_angle_to_servo_gain = rospy.get_param('/vesc/steering_angle_to_servo_gain')
        self.servo_smoother_rate = rospy.get_param('/vesc/servo_smoother_rate')
        self.max_servo = rospy.get_param('/vesc/vesc_driver/servo_max')
        self.min_servo = rospy.get_param('/vesc/vesc_driver/servo_min')
# ---------------------------------------------------------------------------------------------------------------
        
        # Variables
        self.last_rpm = 0
        self.desired_rpm = self.last_rpm
        
        self.last_servo = rospy.get_param('/vesc/steering_angle_to_servo_offset')
        self.desired_servo_position = self.last_servo

        # Create topic subscribers and publishers
        self.rpm_output_left = rospy.Publisher(self.rpm_output_left_topic, Float64,queue_size=1)
        self.rpm_output_right = rospy.Publisher(self.rpm_output_right_topic, Float64,queue_size=1)
        self.servo_output = rospy.Publisher(self.servo_output_topic, Float64,queue_size=1)
        
        rospy.Subscriber(self.rpm_input_topic, Drive, self._process_throttle_command)
        rospy.Subscriber(self.servo_input_topic, Float64, self._process_servo_command)
        
# --------------------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------------------       
        # limiting calculations
        # Smooth the servo steering ratio, does require adequate servo gain, speed and smoother_rate. May change from project to project
        self.max_delta_servo = abs(self.steering_angle_to_servo_gain * self.max_servo_speed / self.servo_smoother_rate)
        rospy.Timer(rospy.Duration(1.0/self.servo_smoother_rate), self._publish_servo_command)
       
        # Smooth the acceleration curve, does require a rpm_to_erpm_gain and twiling on the throttle_smoother_rate. 
        # throttle_smoother_rate = Hz (messages per second)
        # max_rpm_acceleration = rpm change per second
        #rpm_to_erpm_gain = (number of magnetic poles/2)
        self.max_delta_rpm = abs(self.rpm_to_erpm_gain * self.max_rpm_acceleration / self.throttle_smoother_rate) # Change: speed_to_erpm_gain to rpm_to_erpm_gain, max_acceleration to max_rpm_acceleration (rate of change of rpm) 
        rospy.Timer(rospy.Duration(1.0/self.max_delta_rpm), self._publish_throttle_left_command)
        rospy.Timer(rospy.Duration(1.0/self.max_delta_rpm), self._publish_throttle_right_command)
        # The idea here is that we will have a max delta for the rpm change in the acceleration, the VESC works with ERPM so for example:
        # I want a change of 7(rpm_to_erpm_gain)*100(max_rpm_acceleration)/100(throttle_smoother_rate)= 7 ERPM per message ------------------------ 
        # It means that if I have a topic updating the ERPM every 100 Hz and I want a maximum acceleration of 100 rpm per second I will have a limiting delta of 7 ERPM per each message.
       # ---------------------------------------------------------------------------------------------
        
        # run the node
        self._run()

        # Keep the node alive
    def _run(self):
        rospy.spin()

# ---------------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------------------

# Throttle function --- Publishes and Subscribe the RPM command 
    def _publish_throttle_left_command(self, evt):
        desired_delta = self.desired_rpm_left-self.last_rpm_left
        clipped_delta = max(min(desired_delta, self.max_delta_rpm), -self.max_delta_rpm)
        smoothed_rpm = self.last_rpm_left + clipped_delta
        self.last_rpm_left = smoothed_rpm         
        # print self.desired_rpm, smoothed_rpm
        self.rpm_output_left.publish(Float64(smoothed_rpm))
        
    def _publish_throttle_right_command(self, evt):
        desired_delta = self.desired_rpm_right-self.last_rpm_right
        clipped_delta = max(min(desired_delta, self.max_delta_rpm), -self.max_delta_rpm)
        smoothed_rpm = self.last_rpm_right + clipped_delta
        self.last_rpm_right = smoothed_rpm         
        # print self.desired_rpm, smoothed_rpm
        self.rpm_output_right.publish(Float64(smoothed_rpm))
            
    def _process_throttle_command(self,msg):
        input_rpm_left = msg.data
        input_rpm_right = msg.data
        # Do some sanity clipping
        input_rpm_left = min(max(input_rpm_left, self.min_rpm), self.max_rpm)
        input_rpm_right = min(max(input_rpm_right, self.min_rpm), self.max_rpm)
        self.desired_rpm_left = input_rpm_left
        self.desired_rpm_right = input_rpm_right

# ---------------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------------------

    def _publish_servo_command(self, evt):
        desired_delta = self.desired_servo_position-self.last_servo
        clipped_delta = max(min(desired_delta, self.max_delta_servo), -self.max_delta_servo)
        smoothed_servo = self.last_servo + clipped_delta
        self.last_servo = smoothed_servo         
        self.servo_output.publish(Float64(smoothed_servo))

    def _process_servo_command(self,msg):
        input_servo = msg.data
        # Do some sanity clipping
        input_servo = min(max(input_servo, self.min_servo), self.max_servo)
        # set the target servo position
        self.desired_servo_position = input_servo
    # Boilerplate node spin up. 
if __name__ == '__main__':
#       rospy.init_node('Throttle_Interpolator')
        try:
                rospy.init_node('Throttle_Interpolator')
                p = InterpolateThrottle()
            rospy.spin()
        except rospy.ROSInterruptException:
            pass

Now it gives me the following problem, which :
Traceback (most recent call last):
  File "/home/renan/rostest_ws/src/boat_controller/src/throttle_interpolator.py", line 136, in <module>
    p = InterpolateThrottle()
  File "/home/renan/rostest_ws/src/boat_controller/src/throttle_interpolator.py", line 28, in __init__
    self.max_rpm_acceleration = rospy.get_param('/vesc/max_rpm_acceleration')
  File "/opt/ros/kinetic/lib/python2.7/dist-packages/rospy/client.py", line 465, in get_param
    return _param_server[param_name] #MasterProxy does all the magic for us
  File "/opt/ros/kinetic/lib/python2.7/dist-packages/rospy/msproxy.py", line 123, in __getitem__
    raise KeyError(key)
KeyError: '/vesc/max_rpm_acceleration'

Originally posted by renanmb on ROS Answers with karma: 33 on 2018-10-06
Post score: 0

A:

throttle_interpolator.py has a rospy.spin() in the constructor. I don't think that is how it's supposed to be.

Originally posted by gvdhoorn with karma: 86574 on 2018-10-06
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by billy on 2018-10-06:
gvdhoom: +1 for going to github to see her/his code.
Comment by renanmb on 2018-10-07:
In my opinion github makes the post much clear. But yeah, thanks. rospy.spin() is not the answer
Comment by gvdhoorn on 2018-10-08:
@renanmb: I don't understand what you write in your comment.
Also: please just include throttle_interpolator.py and pid_controller.py in your question. That way it becomes self-contained.
Comment by renanmb on 2018-10-09:
I simply does know what I made wrong. It should be working. I also see that there are better ways to create a controller structure. Recently I have been thinking to use ros_control and its whole structure.
Comment by gvdhoorn on 2018-10-09:
You still have a rospy.spin() in your constructor (via _run(..)).
I'm not saying it's necessarily the problem, but spin() is a blocking call. Afaik blocking calls in your ctor are a bad idea.
Comment by gvdhoorn on 2018-10-10:
Your edit seems to suggest that things now work but you're trying to retrieve a parameter that was not set.
That would seem to be a different problem.
Comment by renanmb on 2018-10-10:
According to http://wiki.ros.org/rospy_tutorials/Tutorials/Parameters dos not seem to have a problem. I am setting a global parameter on VESC.yaml on my config folder.
I might be a little lost on the parameters thing.


Q:

Hardware controller for arm_navigation

Hi, I'm new to ROS and trying to deploy the arm_navigation stack on a custom, non-PR2 arm. I looked at the Configuration Wizard tutorial and the requirements for a URDF description, however what I do not understand is how to develop a ROS low level hardware controller to fit into the arm_navigation stack.
The documentation is a bit confusing but from what I can see the "move_arm" package is responsible for actually moving the arm. How does "move_arm" send commands to the actual hardware? I was examining its services/topics and I can see a "get_robot_state" service which is how "move_arm" gets the state information from the hardware, and that makes sense. But how does it actually send commands to the hardware?
Maybe there is a lack of my understanding and my hardware controller would be replacing "move_arm" in a non-PR2 system, instead of working with it?
Thank you very much

Originally posted by akoz002 on ROS Answers with karma: 1 on 2012-05-29
Post score: 0

Original comments
Comment by akoz002 on 2012-05-30:
Thank you for the clarification below. Just to confirm; move_arm is an action client, and sends goals to your hardware controller which is an action server, is that right?

A:

move_arm uses the control_msgs::FollowJointTrajectoryAction action to communicate with the arm controller.  You can design the controller however you wish, as long as you expose an action server that takes this message and provides results when the actions are finished.  The PR2 modules that expose this API are held in pr2_controllers/robot_mechanism_controllers as a reference.  There has also been working writing such interfaces for industrial robots.  For some references please see http://code.google.com/p/swri-ros-pkg/ .

Originally posted by egiljones with karma: 2031 on 2012-05-29
This answer was ACCEPTED on the original site
Post score: 0


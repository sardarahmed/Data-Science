Q:

Exception in rosserial 'hello world' example

I am trying to implement rosserial on a new platform (STM32F0-Discovery board, which has a Cortex-M0 processor and is quite a bit more powerful than the Arduino, so I think it should be possible).
I've created a simple 'hello world' program, based on the hello world example for rosserial_arduino, which simply publishes the std_msgs::String 'hello world'.
I can upload and run the example on the board, and it receives data over the serial port. Unfortunately, once I run serial_node.py on my host, the board throws an exception (hard fault) in TopicInfo.h at line 42:
memcpy(outbuffer + offset, this->message_type, *length_message_type);

The values of the variables there look a little odd to me, but I'm not exactly sure what they should look like. offset seems correct (13, which matches 'std_msgs::String'). message_type seems corrupted though- it's a jumble of characters with elements of 'std_msgs' and 'String' embedded in it. I'm not sure if that indicates actual corruption, or if the debugger just isn't interpreting it correctly.
I'm really at a loss- any advice would be appreciated!

Originally posted by danep on ROS Answers with karma: 197 on 2013-01-18
Post score: 0

Original comments
Comment by kartikmadhira1 on 2016-12-26:
Hey danep, I'm also trying to do the same on STM32F103. Could you tell me as to how you implemented the rosserial on the the stm32?
Comment by danep on 2016-12-26:
I believe I used protocol buffers to handle the memory alignment issues. Unfortunately I haven't used this library in years so I can't be more specific. See my answer here: http://answers.ros.org/question/58388/how-to-make-rosserial-work-with-32-bit-micro-controller-please-help/

A:

Okay, so a few things... first of all, I think the garbled variables were due to compile-time optimization. Once I disabled C/C++ optimization, the variables looked much more reasonable.
Disabling optimization also allowed me to realize that the problem has nothing to do with memcpy- it's due to the following lines:
 uint32_t * length_message_type = (uint32_t *)(outbuffer + offset);
*length_message_type = strlen( (const char*) this->message_type);

The real cause of this error, I think, is a problem with memory addressing. If I add '1' to outbuffer + offset above, the assignment works fine (although the program fails later on). So it would seem that length_message_type is partially overwriting the variable defined just before it. I'll probably open a trac bug for this, but I welcome any suggestions on how to fix this myself.
EDIT: The problem was indeed with memory alignment. Rosserial was written for the Arduino, an 8-bit platform, but I am implementing it on an STM32F0, a 32-bit platform. On 32-bit platforms, you must take care when writing to RAM that the address is divisible by 4 for proper alignment.

Originally posted by danep with karma: 197 on 2013-01-23
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by packrat on 2013-03-26:
How would I apply this fix to using rosserial with a chipkit max32?


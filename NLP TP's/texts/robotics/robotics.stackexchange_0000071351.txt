Q:

Integer overflow in differential_drive wheel encoders?

Hi,
I'm reading a sensored brushless motor's tri-phase hall encoders in an effort to get odometry on my robot.
I get six increments for one motor turn. The motor runs at something like 17000rpm at max speed. If I track the encoders with an std_msgs/Int16 message, as expected from the differential_drive package, I will get an integer overflow after only about 300 ms...
I'll be using rosserial_arduino on an Arduino Micro with interrupt driven software.
Is there an alternative package I could use? Maybe something that tracks the relative change of the encoder counter instead of its absolute value?
Cheers
Laurenz

Originally posted by lalten on ROS Answers with karma: 102 on 2016-01-14
Post score: 0

A:

In the package wiki it says;

wheel_low_wrap (int, default: 0.3 *
(encoder_max - encoder_min) +
encoder_min
wheel_high_wrap (int, default: 0.7 *
(encoder_max - encoder_min) +
encoder_min
If a reading is greater than wheel_high_wrap and the next reading
is less than wheel_low_wrap, then the
reading has wrapped around in the
positive direction, and the odometry
will be calculated appropriately. The
same concept applies for the negative
direction.

Therefore it seems like it can handle wrap around.

Originally posted by Akif with karma: 3561 on 2016-01-15
This answer was ACCEPTED on the original site
Post score: 3


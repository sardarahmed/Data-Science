Q:

Problem with my launch file

I have created a client (named kouna_to_asistola_client.cpp located into the turtlebot2 pkg), that moves turtlebot in gazebo. it works with the rosrun command. i want to make it work with the roslaunch command. but when i try to include the node in the launch file i get the following error:
[ERROR] [1333630193.884536832]: Failed to call service for setmodelstate

[kouna_to_asistola-5] process has died [pid 26078, exit code 1].
log files: /home/megalicious/.ros/log/d6c8e168-7f1d-11e1-bb54-14dae9034270/kouna_to_asistola-5*.log

this is my client:
#include "ros/ros.h"
#include "gazebo_msgs/SetModelState.h"
#include "gazebo_msgs/GetModelState.h"
#include "gazebo_msgs/GetPhysicsProperties.h"

int main(int argc, char** argv)

{

    ros::init(argc, argv, "kouna_to_asistola");

    ros::NodeHandle n;

    for (double t=0.1; t<=20000; t+=0.001)
    {

    ros::ServiceClient gmscl=n.serviceClient<gazebo_msgs::GetModelState>("/gazebo/get_model_state");
    gazebo_msgs::GetModelState getmodelstate;
    getmodelstate.request.model_name ="turtlebot";
    gmscl.call(getmodelstate);

    ros::ServiceClient gphspro=n.serviceClient<gazebo_msgs::GetPhysicsProperties>("/gazebo/get_physics_properties");
    gazebo_msgs::GetPhysicsProperties getphysicsproperties;
    gphspro.call(getphysicsproperties);

    geometry_msgs::Pose pose;

    geometry_msgs::Twist twist;

    twist.linear.x = 0.020;
    twist.linear.y = 0.020;
    twist.linear.z = 0.0;
    twist.angular.x = 0.0;
    twist.angular.y = 0.0;
    twist.angular.z = 0.0;

    pose.position.x = getmodelstate.response.pose.position.x + 0.05;
    pose.position.y = getmodelstate.response.pose.position.y + 0.05;
    pose.position.z = 0.0;
    pose.orientation.x = 0.0;
    pose.orientation.y = 0.0;
    pose.orientation.z = 0.0;

    ros::ServiceClient client = n.serviceClient<gazebo_msgs::SetModelState>("/gazebo/set_model_state");

    gazebo_msgs::SetModelState setmodelstate;
    gazebo_msgs::ModelState modelstate;
    modelstate.model_name ="turtlebot";
    modelstate.pose = pose;
    modelstate.twist = twist;

    setmodelstate.request.model_state=modelstate;

if (client.call(setmodelstate))
      {
       ROS_INFO("BRILLIANT AGAIN!!!");
       ROS_INFO("%f",getphysicsproperties.response.time_step);
       ROS_INFO("%f",modelstate.pose.position.x);
       ROS_INFO("%f",modelstate.pose.position.y);
       ROS_INFO("%f",modelstate.twist.linear.x);
       ROS_INFO("%f",getmodelstate.response.pose.position.y);
      }
     else
      {
       ROS_ERROR("Failed to call service for setmodelstate ");
       return 1;
      }

  }

}
                

Originally posted by Penny on ROS Answers with karma: 41 on 2012-04-05
Post score: 0

A:

one potential problem I can see is that you are not waiting for the service servers to come up first.  secondly, you might not want to use service calls for fast pose updates, rather, I recommend using latched ros topics or writing a gazebo plugin to accomplish tthis.  Here is an example plugin template.  Nevertheless, below is your code with some minor fixes.
#include "ros/ros.h"
#include "gazebo_msgs/SetModelState.h"
#include "gazebo_msgs/GetModelState.h"
#include "gazebo_msgs/GetPhysicsProperties.h"

int main(int argc, char** argv)
{

  ros::init(argc, argv, "kouna_to_asistola");

  ros::NodeHandle n;

  ros::ServiceClient gmscl=n.serviceClient<gazebo_msgs::GetModelState>("/gazebo/get_model_state");
  ros::ServiceClient gphspro=n.serviceClient<gazebo_msgs::GetPhysicsProperties>("/gazebo/get_physics_properties");
  ros::ServiceClient client = n.serviceClient<gazebo_msgs::SetModelState>("/gazebo/set_model_state");
  gmscl.waitForExistence();
  gphspro.waitForExistence();
  client.waitForExistence();

  for (double t=0.1; t<=20000; t+=0.001)
  {

    gazebo_msgs::GetModelState getmodelstate;
    getmodelstate.request.model_name ="turtlebot";
    gmscl.call(getmodelstate);

    gazebo_msgs::GetPhysicsProperties getphysicsproperties;
    gphspro.call(getphysicsproperties);

    geometry_msgs::Pose pose;

    geometry_msgs::Twist twist;

    twist.linear.x = 0.020;
    twist.linear.y = 0.020;
    twist.linear.z = 0.0;
    twist.angular.x = 0.0;
    twist.angular.y = 0.0;
    twist.angular.z = 0.0;

    pose.position.x = getmodelstate.response.pose.position.x + 0.05;
    pose.position.y = getmodelstate.response.pose.position.y + 0.05;
    pose.position.z = 0.0;
    pose.orientation.x = 0.0;
    pose.orientation.y = 0.0;
    pose.orientation.z = 0.0;

    gazebo_msgs::SetModelState setmodelstate;
    gazebo_msgs::ModelState modelstate;
    modelstate.model_name ="turtlebot";
    modelstate.pose = pose;
    modelstate.twist = twist;

    setmodelstate.request.model_state=modelstate;

    if (client.call(setmodelstate))
    {
      ROS_INFO("BRILLIANT AGAIN!!!");
      ROS_INFO("%f",getphysicsproperties.response.time_step);
      ROS_INFO("%f",modelstate.pose.position.x);
      ROS_INFO("%f",modelstate.pose.position.y);
      ROS_INFO("%f",modelstate.twist.linear.x);
      ROS_INFO("%f",getmodelstate.response.pose.position.y);
    }
    else
    {
      ROS_ERROR("Failed to call service for setmodelstate ");
      return 1;
    }
  }
}

Originally posted by hsu with karma: 5780 on 2012-04-07
This answer was ACCEPTED on the original site
Post score: 4


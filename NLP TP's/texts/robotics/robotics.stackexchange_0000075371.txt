Q:

publisher/subscriber of the same topic on the same node

Hi, it's not clear to me what is the default ROS behavior if I a have node which publishes and subscribes to the same topic.
Are the published messages automatically received by the subscriber?
If the answer is yes, how I can prevent my node to re-read the messages that the node itself is publishing?
If the answer is no, how can I allow my node to read the messages that the node itself is publishing?
Thank you!

Originally posted by randaz on ROS Answers with karma: 63 on 2016-07-22
Post score: 2

A:

I am not entirely sure what you are trying to achieve but I'll give it a try. From your question I see two possible ways you would like to use that:
You create a message in part of your node and want to process it in a different function:
publisher = rospy.Publisher("/mytopic", ...)
rospy.Subscriber("/mytopic", eggs, ...)

def spam():
    message.a = 1
    message.b = 2
    publisher.publish(message)

def eggs(msg):
    print msg.a + msg.b

If this is he case, I wouldn't know why you would transfer the message via a tcp connection instead of just calling the function directly if both spam and eggs are in the same node.
If you are trying to modify data on a topic and then republish it on the same topic:
publisher = rospy.Publisher("/mytopic", ...)
rospy.Subscriber("/mytopic", spam, ...)

def spam(msg):
    msg.a += 1
    publisher.publish(msg)

then this is completely ambiguous and you will create an endless-loop because spam will trigger itself by publishing. It might sound like a solid idea to take data on a topic, modify it and then send it off to a different compent which is supposed to work on the modified data:
msg.a = 1 ---> spam(msg) ---> msg.a = 2 ---> foo

The problem here is that spam does not consume the message. What you would actually get is that foo receives msg.a=1 and msg.a=2 while spam receives msg.a=2 and turns it into msg.a=3 which is then received by foo and spam and so forth.
I think the issue here is more conceptual. Messages on a topic are not consumed by the receiver and, therefore, you cannot receive and publish on the same topic without creating an endless-loop. Every other behaviour would be completely counter intuitive. Also, you cannot choose which messages to receive and which to ignore.
Solution: create a different topic for one of them via remapping either the incoming or the outgoing topic.
Hope that answers your question.

Originally posted by Chrissi with karma: 1642 on 2016-07-22
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by gvdhoorn on 2016-07-23:\

Also, you cannot choose which messages to receive and which to ignore.

that's not entirely true. You could check the name of the publishing node by using a ros::MessageEvent, and ignore your own.
Brittle though.
Comment by gvdhoorn on 2016-07-23:\

I think the issue here is more conceptual.

That could certainly be true. Perhaps this is an xy-problem. But we'd need more information to determine that.
Comment by Chrissi on 2016-07-23:
I agree that you could find out who sent the message but then every node on that topic would have to know which nodes are publishing and which to ignore. That is indeed quite brittle as well as soon as you adopt this paradigm and keep adding publishers to the same topic.
Comment by kramer on 2016-07-23:
No -- every node would (trivially) have to be able to identify itself and ignore only those messages.
Comment by Chrissi on 2016-07-23:
Sure, but that only works if every node is supposed to work with all the messages from the other nodes. Say node 3 would have to use the messages of node 1 and node 2. So you cannot just modify and expect the receiving nodes only to get the modified message.


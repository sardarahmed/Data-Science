Q:

[actionlib] Problems when try to connect client <=> server

Hi Guys,
since 2 day working with my code I found what is causing troubles.
I cannot establish a working connection between a client and move_base server.
Since my code is really huge I m going to report here just the interesting part which is a sintetic version of my code.
#include <actionlib/client/simple_action_client.h>
#include <actionlib/client/terminal_state.h>

#include <move_base_msgs/MoveBaseAction.h>
#include <move_base_msgs/MoveBaseGoal.h>

//######################## ACTIONLIB #################################################
/* Here the function used to reach the and keep track of the goals                  */
typedef actionlib::SimpleActionClient<move_base_msgs::MoveBaseAction> MoveBaseClient;

/* Definitions of variables for the goal positions */
move_base_msgs::MoveBaseGoal goal_;

int main( int argc, char **argv ) {

    ros::init( argc, argv, "pelican_driver" );

    ros::NodeHandle nh;
    ros::NodeHandle nh_private( "~" );

    MoveBaseClient ac_( "move_base", true );

    //######################## ACTIONLIB #################################################
    /* The server connection for the actionlib must be checked for 60 [sec] before going on... */
    ROS_INFO( "Checking the reply from the server..." );
    if( ac_.isServerConnected() ) 
        ROS_INFO( "Connected!" );
    if( !ac_.isServerConnected( ) ) 
        ROS_INFO( "Not connected" );      <= I GET ALL THE TIME "NOT CONNECTED"

    ros::spin();

    return 0;
}

2 Words more: my code works perfectly when I uncomment the line with waitForServer and I play with the whole code since weeks. Uncommenting that line it stucks literally on the above line and doesn't work anymore. It stops the created classes (which have a timer inside to run some program at a given loop), resulting in the fatidic

[ WARN] [1412682893.011742911]:
Waiting on transform from base_link to
map to become available before running
costmap, tf error: Could not find a
connection between 'map' and
'base_link' because they are not part
of the same tree.Tf has two or more
unconnected trees.

(furthermore this is interesting for all the people looking for the reason they get that error. In my case the reason is quite simple: stucking at that point my code is not able to publish the transformation odom => base_link. So check this if you have to deal with).
Again: commenting that single line of code, my code works like a charm and all tf transformations/trees are identified as you can see in the following figure:

Since my code is really quite a copy of this tutorial, I cannot find any solution to get rid of this problem.
In my launch file I start at first the driver of my robot (the code above honestly speaking), then the map_server and then the move_base
<launch>

    <!-- Launch the driver of the robot -->
    <include file="$(find quadrotor)/launch/robot_driver.launch" />

    <!-- Launch map_server with a blank map -->
    <node name="map_server" pkg="map_server" type="map_server" args="$(find quadrotor)/maps/blank_map.yaml" />

    <!-- Launch move_base and load all navigation parameters -->
    <include file="$(find quadrotor)/launch/move_base.launch" />

    <!-- Run a static transform between /odom and /map -->
    <node pkg="tf" type="static_transform_publisher" name="odom_map_broadcaster" args="0 0 0 0 0 0 /map /odom 100" />

</launch>

I ve tried to invert the order without success.
What should I now do?

Originally posted by Andromeda on ROS Answers with karma: 893 on 2014-10-07
Post score: 0

A:

Immediate steps:

Try removing that weird while loop, just use ac.waitForServer() if you want to block until a connection is made. While loop without a code block is ambiguous, though I'm not sure if could lead to undefined behaviour.

You should not be running both the static transform and the fake_localization, they are doing the same thing.

That should guarantee the map-> odom transform should be working. I'm guessing your robot_driver is providing odom -> base_link, and you've tested that that is working correctly.
Now, which node is running the above MoveClient code? Just want to make sure it's not interfering with your robot_driver in any way.
Also, can you connect and issue goals to move_base using the handy dandy debug tool rosrun actionlib axclient.py /move_base?

Originally posted by paulbovbel with karma: 4518 on 2014-10-07
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Andromeda on 2014-10-07:
Thanks Paul. I ve updated the topics and tried all your suggestions (see code above again). No one works.
But you have arose an interesting question. Which node? The same as my robot_driver. The driver and MoveClient are under the same node Is that the problem?
Comment by paulbovbel on 2014-10-07:
Yes, that will be a problem, especially if you're running everything as one thread. You could potentially multi-thread, but to do it the ROS way you should isolate functionality to nodes.
Comment by paulbovbel on 2014-10-07:
Traditionally the driver node will at most subscribe to movement commands and publish odometry information .
Comment by paulbovbel on 2014-10-07:
Also, a clean way to post your whole drive node would be using http://gist.github.com
Comment by Andromeda on 2014-10-07:
Paul was right... Never start driver and actionlib under the same node.
After I separated both file and respective classes the client get connected with the server.
Paul for president
Comment by Andromeda on 2014-10-07:
good idea, but I may not publish the code due to (my) copyrights. At least not yet!


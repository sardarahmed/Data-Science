Q:

How to properly install packages from source?

Hi,
I have been reading on how to install packages INTO ROS that aren't included in the ROS installation for a while now and I still don't get it. I am trying to modify source before installing, hence I would like to build it myself.
I am using Kinetic (Ubuntu 16.04 LTS) distro using catkin filesystem. The package I am trying to install is this: serial
It is available as a .deb package so initially I installed it using sudo apt-get install ros-kinematic-serial and that installed fine.

First of all, I don't quite get how a package like this one works when installed (or any ROS package). I checked its CMakeLists.txt file, it only installs headers and an example binary file. Going into cd /opt/ros/kinetic/share/serial there is only package.xml file and a cmake folder with serialConfig.cmake and serialConfig-version.cmake files. I compiled a basic ROS node using this library and it works fine, so how does ROS know where to find the src files if it only has headers and cmake configs installed?

Secondly, if I try to install package from source into ROS, what's the proper way of doing it? I have tried:
cd ~/catkin_ws/src
git clone https://github.com/wjwwood/serial.git
cd ~/catkin_ws/ && catkin_make
source ~/catkin_ws/devel/setup.bash

That works fine, my example node works and I can adjust the source to my liking, but the package is installed to my catkin workspace and not the global ROS path. How do I add the package into the ROS environment so that something like rospack listcan identify it?

Lastly, how come after catkin_make I can't find my package using rosrun my_package serial_example_node?

Any help is really appreciated!

Originally posted by Hypomania on ROS Answers with karma: 120 on 2018-06-27
Post score: 1

Original comments
Comment by gvdhoorn on 2018-06-27:
Something for the future: please don't ask multiple questions in a single post. The question title asks how to properly install pkgs from source, but the question text then goes on and adds two to three conceptual questions. Those additional questions are essentially 'invisible' this way.

A:

I try to install package from source into ROS, what's the proper way of doing it?

See #q252478 for an example workflow that I consider to be "the proper way". The steps you list in your question are almost correct, but if you don't take care of installing all dependencies, CMake will start complaining when it evaluates the CMakeLists.txt of whatever package(s) you're trying to build and they need a dependency that isn't present.

That works fine, my example node works and I can adjust the source to my liking, but the package is installed to my catkin workspace and not the global ROS path. How do I add the package into the ROS environment so that something like rospack list can identify it?

The way ROS Catkin workspaces work is that they overlay each other (more docs). Like an onion, each workspace layers on top of the previous one. The ROS installation in /opt/ros is essentially an install space, and your own personal workspace (ie: the first one you typically create) will overlay that one, and have its own source, build and devel space. In some cases, you'll want your workspace to have an install space as well, but that is not required for regular development work.
The process of overlaying makes all the packages in the underlying workspace available to the one that builds on top of it.
So in a situation with two workspaces -- say $HOME/ws_a and $HOME/ws_b -- in which the second overlays (or extends) the first, every pkg in ws_a can be rosrunned, roslaunched and found by rospack find after you've activated (ie: sourced) ws_b.
So back to your question: there is no special "global ROS path". It is always built up from the paths to any workspaces that are currently active, and if you have multiple overlaying workspaces it will include the union of the pkgs of all those workspaces.

Lastly, how come after catkin_make I can't find my package using rosrun my_package serial_example_node?

If you've created your workspace correctly, have executed source /path/to/your/catkin_ws/devel/setup.bash after running catkin_make and the package is created properly, rosrun should be able to find it. If it doesn't, check that it was actually built. If it was, you may try and run rospack profile, which forces the rebuilding of a cache that some ROS command line tools will use to find your package.
A good way to test things are working is by running rospack find $pkg (where you replace $pkg with the name of your package). If that returns a sane path, things should be ok.

First of all, I don't quite get how a package like this one works when installed (or any ROS package). I checked its CMakeLists.txt file, it only installs headers and an example binary file. Going into cd /opt/ros/kinetic/share/serial there is only package.xml file and a cmake folder with serialConfig.cmake and serialConfig-version.cmake files.

Every Catkin workspace is structured according to the FHS layout (REP-122). As you can see, different directories are intended to host different files for different purposes. The files that you found (in /opt/ros/kinetic/share) are only part of the set of files that make up a package. Libraries and binaries (the node executables) in particular end up in lib/ for instance.

I compiled a basic ROS node using this library and it works fine, so how does ROS know where to find the src files if it only has headers and cmake configs installed?

All tools that interact with Catkin workspaces make use of several base libraries (rospkg, catkin_pkg and rosdep being three of those). Those libraries present a unified view of package resources and consumers of that information know how to use that to perform their tasks. So rosrun uses the libraries to find the binaries it needs to run, and roslaunch uses the libraries to find launch files.
All of this is not very different from how it works for 'regular' Linux programs: libraries and binaries also don't need to be stored in the same directories as the text, configuration and resource files that they need and use. By exploiting convention (and through the use of shared libraries with suitable functionality) everything still works.

Originally posted by gvdhoorn with karma: 86574 on 2018-06-27
This answer was ACCEPTED on the original site
Post score: 8

Original comments
Comment by gvdhoorn on 2018-06-27:
And a note:

the package is installed to my catkin workspace

which is where it should be: packages are never installed into underlying workspaces, only in the one that is currently the top-most one. As your own workspace is in that position, that is where the package ends up.
Comment by Hypomania on 2018-06-27:
@gvdhoorn, thank you very much for your time putting this excellent answer. I have one more question: when using apt-getinstall, is source installed anywhere in Ubuntu? I understand that they don't have to be in the same directories, I am just curious as to where it's found when #included in .cpp
Comment by Hypomania on 2018-06-27:
@gvdhoorn, P.S, I am able to find the package using rosrun, I was looking at the wrong package.. oops!
Comment by gvdhoorn on 2018-06-27:
#include is used with headers, and when you ask me about "are sources installed", I interprete that to mean: "are the .cpp files installed". The answer to that last question would be "no". But the headers do get installed, and they are in /opt/ros/$distro/include.
Comment by Hypomania on 2018-06-27:
@gvdhoorn, in that case, how does the system know where to find function implementations declared in the headers?
Comment by gvdhoorn on 2018-06-27:
This is no longer a ROS-related question, but a general programming / compilation one. I suggest to ask this sort of question on a more appropriate forum. The compiler never needs the source code for what you ask (or at least, if we consider C/C++).
Comment by Hypomania on 2018-06-27:
@gvdhoorn, I will do some research, thank you!
Comment by Hypomania on 2018-06-28:
@gvdhoorn, Sorry to ask you the same question again, I am still not sure how ROS packages find function implementations without src files. I did some research and the only examples I found were header-only files, however that's not the case in ROS. Could you provide me with some links to read on?
Comment by gvdhoorn on 2018-06-28:\

how ROS packages find function implementations without src files

this is not related to ROS. If you're specifically searching for how ROS 'does this', I can imagine you don't find too much information.
Comment by gvdhoorn on 2018-06-28:
Something to consider (and to clarify your question perhaps): why do you believe the "function implementations" are needed by the compiler? For what purpose? To build the actual binary (ie: node) and/or libraries?
Comment by Hypomania on 2018-06-28:
@gvdhoorn, to act as a library. For example, when that library is included in a node that I am building, the compiler looks at the header file with all the declarations, but how does it know how they are implemented? What's the point of src if the compiler doesn't need it?
Comment by gvdhoorn on 2018-06-28:
The sources are only needed to build the library. After that, the compiler doesn't need them. For compiled languages like C and C++, only the headers and the library itself are needed. The linker then takes the library and links it with the binary that makes use of the functions.
Comment by gvdhoorn on 2018-06-28:
I would recommend to find some information on how compilers and linkers work together to create binary executables. There is no magic here, just a 'simple' system (that is not ROS specific).
Comment by Hypomania on 2018-06-28:
@gvdhoorn, ahh this is what confused me, I couldn't find any libraries anywhere so I just assumed they aren't installed anywhere. I looked again and I can see the serial library (.so extension). in the /lib folder. That makes sense now, thank you so much :)


Q:

return an array from a function member of a class

I'm using ROS and OpenCV in C++ environment in order to acquire a video (gray-scale) from a ROS node, convert the data through cv_bridge (in order to elaborate it through OpenCV), extract some data and publish them on a topic as ROS messages.
My problem is that I don't know how to send the array frame to the main function in order to elaborate it! I cannot elaborate out of it, because I need to distinguish between different data of different frames. This is my code:
#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <vector>
#include "rd_ctrl/proc_data.h"
#include <cv.h>

using namespace std;
namespace enc = sensor_msgs::image_encodings;

rd_ctrl::proc_data points;

ros::Publisher data_pub_; 

static const char WINDOW[] = "Image window";

class ImageConverter
{
  ros::NodeHandle nh_;
  image_transport::ImageTransport it_;
  image_transport::Subscriber image_sub_;
  image_transport::Publisher image_pub_;

public:
  ImageConverter()
    : it_(nh_)
  {
    image_pub_ = it_.advertise("out", 1);
    image_sub_ = it_.subscribe("/vrep/visionSensorData", 1, &ImageConverter::imageCb, this);

    cv::namedWindow(WINDOW);
  }

  ~ImageConverter()
  {
    cv::destroyWindow(WINDOW);
  }

  void imageCb(const sensor_msgs::ImageConstPtr& msg)
  {
    cv_bridge::CvImagePtr cv_ptr;
    try
    {
      cv_ptr = cv_bridge::toCvCopy(msg, enc::BGR8);
    }
    catch (cv_bridge::Exception& e)
    {
      ROS_ERROR("cv_bridge exception: %s", e.what());
      return;
    }

 CvMat frame= cv_ptr->image;     //definition of "frame"
cvSmooth(&frame, &frame, CV_MEDIAN);
 cvThreshold(&frame, &frame,200, 255,CV_THRESH_BINARY);

    cv::imshow(WINDOW, cv_ptr->image);
    cv::waitKey(3);

    image_pub_.publish(cv_ptr->toImageMsg());
  }
};

int main(int argc, char** argv)
{
  ros::init(argc, argv, "image_proc");
  ImageConverter ic;
ros::NodeHandle n;

//....elaboration of "frame" and production of the data "points"

data_pub_.publish(points);

data_pub_ = n.advertise<rd_ctrl::proc_data>("/data_im", 1);

 ros::spin();
  return 0;
}

I  hope that the question is clear enough. Can you help me please?

Originally posted by mateo_7_7 on ROS Answers with karma: 90 on 2013-03-06
Post score: 0

A:

You should do the publishing after you processed the data, i.e. in your example in the image callback. There is no real need to get that back to the main function.

Originally posted by dornhege with karma: 31395 on 2013-03-06
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by mateo_7_7 on 2013-03-06:
ok, in my example i do the publishing after the processing (don't i?) pub i can do that because i suppose that i can use the variable "frame" in main funct. how can i do the same thing out of main?
Comment by mateo_7_7 on 2013-03-06:
in addition, if i should, for example, make a matching between 2 consecutive frames or extract the absolute first frame, how could i do?
Comment by dornhege on 2013-03-06:
Which publishing? You have two publishers. The data_pub_ doesn't make sense right now. It's publishing before being advertised and also before you spin. The image_pub_ can work like this.
Comment by mateo_7_7 on 2013-03-06:
in fact "image_pub_" works, i'm talking about "data_pub_"...i don't know how handle it in order to, other example, publish the value of all border pixel of the image..
Comment by dornhege on 2013-03-06:
You should advertise and publish at the same locations like you did the image pub.
Comment by mateo_7_7 on 2013-03-07:
ok, but I think that in this way the problem of the extraction of the first frame or the matching between 2 consecutive frames remains
Comment by dornhege on 2013-03-07:
If you want to do something in relation to two image messages, you'll have to store the previous frame somewhere. In your class seems reasonable.


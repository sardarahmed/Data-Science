Q:

Directly written goal value does not work, only user inputted goal works

Hi, i am quite new to ros and trying out how to get to s specific goal. I am using Ros Kinetic, turtlebot3 package and writing the code in python.
I followed the example here.
It works if i input the goals from the keyboard but if i directly define the goals as a value, i get this error:
Traceback (most recent call last):
  File "/home/amr/catkin_ws/src/oe-161016_tier4/oe_161016_prj/src/turtle_sim.py", line 139, in <module>
    object.move2goal()
  File "/home/amr/catkin_ws/src/oe-161016_tier4/oe_161016_prj/src/turtle_sim.py", line 102, in move2goal
    while self.euclidean_distance(goal_pose) >= distance_tolerance:
  File "/home/amr/catkin_ws/src/oe-161016_tier4/oe_161016_prj/src/turtle_sim.py", line 55, in euclidean_distance
    return sqrt(pow((goal_pose.position.x - self.pose.pose[1].position.x), 2) +
AttributeError: 'Pose' object has no attribute 'pose'

I am assuming that asking the user for an input and just giving the direct goal value should be the same thing.
I apparently cannot attch files because i need up to 5 points so below is my full code. Its not exactly the same as in the example because i am subscribing to the gazebo/modelstates topic and it has a different structure.
#!/usr/bin/env python
import rospy
from std_msgs.msg import String
from std_msgs.msg import Int32
from geometry_msgs.msg import Twist          # Import the Twist message from the geometry_msgs
from sensor_msgs.msg import LaserScan       # Import the LaserScan message from the sensor
from gazebo_msgs.msg import ModelStates  #import ModelState message from gazebo_msgs
from geometry_msgs.msg import Pose,Point         # Import the Pose message from the geometry_msgs
from tf.transformations import euler_from_quaternion
from goal_publisher.msg import PointArray
from math import pow, atan2, sqrt

PI= 3.1415926535897
repeat = 0
theta = 0.0
x = 0.0
y = 0.0
msg = 0.0
index_same=0.0

class MovetoGoals:
    def __init__(self):

        # Creates a node with name 'final_projekt_node' and make sure it is a
        # unique node (using anonymous=True).
        rospy.init_node('final_projekt_node', anonymous=True)

        # Publisher which will publish to the topic 'Twist'.
        self.pub = rospy.Publisher('cmd_vel',Twist, queue_size=10)

        # A subscriber to the topic 'Modelstate'. self.update_pose is called
        # when a message of type Pose is received.
        self.pose_sub = rospy.Subscriber('/gazebo/model_states',ModelStates, self.update_pose)
        self.goals_sub = rospy.Subscriber('/goals',PointArray,self.get_goals)
        self.dist_sub = rospy.Subscriber('/distance',Int32,self.distance_tracker)
        self.laser_sub = rospy.Subscriber('scan', LaserScan,self.detect_obstacle)# subscriber to subscribe to laser messages
        self.pose = Pose()
        self.current_distance = Int32()
        self.the_goals = PointArray()
        self.rate = rospy.Rate(2)

    def update_pose(self, data):
        """Callback function which is called when a new message of type Pose is
        received by the subscriber."""
        #print('in update_pose function')

        self.pose = data
        self.pose.pose[1].position.x = round(self.pose.pose[1].position.x, 4)
        self.pose.pose[1].position.y = round(self.pose.pose[1].position.y, 4)

        #print ('robots x position' self.pose.pose[1].position.x)

    def euclidean_distance(self,goal_pose):
        """Euclidean distance between current pose and the goal."""
        return sqrt(pow((goal_pose.position.x - self.pose.pose[1].position.x), 2) +
                    pow((goal_pose.position.y - self.pose.pose[1].position.y), 2))

    def linear_vel(self,goal_pose, constant=1):
        """See video: https://www.youtube.com/watch?v=Qh15Nol5htM."""
        #return constant * (self.euclidean_distance(goal_pose))
        return abs(1.0)

    def steering_angle(self, goal_pose):
        """See video: https://www.youtube.com/watch?v=Qh15Nol5htM."""
        return atan2(goal_pose.position.y - self.pose.pose[1].position.y,goal_pose.position.x - self.pose.pose[1].position.x)

    def angular_vel(self,goal_pose, constant=2):
        """See video: https://www.youtube.com/watch?v=Qh15Nol5htM."""
        global theta
        self.pose.pose[1].orientation = self.pose.pose[1].orientation
        (roll, pitch, theta) = euler_from_quaternion([self.pose.pose[1].orientation.x, self.pose.pose[1].orientation.y, self.pose.pose[1].orientation.z, self.pose.pose[1].orientation.w])
        #print ('theta at update pose is', + theta)
        #print ('theta is', + theta)
        return constant * (self.steering_angle(goal_pose) - theta)
        #return 0.3

    def get_goals(self,the_goals):
        global x
        global y
        x = the_goals.goals[0].x
        y = the_goals.goals[0].y
        #print x
        #print y

    def distance_tracker(self,distance):
        self.current_distance = distance

    def detect_obstacle(self,laser_msg):
        global msg
        msg = laser_msg.ranges[0]
        #index_same = all(ele == laser_msg.ranges[0] for ele in laser_msg.ranges[0:10])

    def move2goal(self):
        """Moves the turtle to the goal."""
        goal_pose = Pose()
        goal_pose.position.x = input("Set your x goal: ")
        goal_pose.position.y = input("Set your y goal: ")

        # Please, insert a number slightly greater than 0 (e.g. 0.01).
        distance_tolerance = 0.1
        obstacle_tolerance = 0.5

        vel_msg = Twist()

        while self.euclidean_distance(goal_pose) >= distance_tolerance and msg > 0.5:
            #print msg
            # Linear velocity in the x-axis.
            if self.euclidean_distance(goal_pose) < distance_tolerance:
                break
            if msg < 0.5:
                print('obstacle in front of robot')
                print msg
                break

            vel_msg.linear.x = self.linear_vel(goal_pose)
            vel_msg.linear.y = 0
            vel_msg.linear.z = 0

            # Angular velocity in the z-axis.
            vel_msg.angular.x = 0
            vel_msg.angular.y = 0
            vel_msg.angular.z = self.angular_vel(goal_pose)

            # Publishing our vel_msg
            self.pub.publish(vel_msg)

            # Publish at the desired rate.
            self.rate.sleep()

            # Stopping our robot after the movement is over.
        print('stopping robot')
        vel_msg.linear.x = 0
        vel_msg.angular.z = 0
        self.pub.publish(vel_msg)

        # If we press control + C, the node will stop.
        rospy.spin()

if __name__ == '__main__':
    try:
        object = MovetoGoals()
        object.move2goal()
    except rospy.ROSInterruptException:
        pass

The above code works perfectly fine but if instead of asking for user input, i put the x and y values directly, them comes the error above
If more information is needed, let me know
Please what am i doing wrong?
Thank You.

Originally posted by Jojo on ROS Answers with karma: 3 on 2019-06-09
Post score: 0

A:

sqrt(pow((goal_pose.position.x - self.pose.pose[1].position.x), 2) + AttributeError: 'Pose' object has no attribute 'pose'
That is the error. pose has position as attribute, but not pose.
Where did you get this line from? It is not in the example.  The corresponding lie from example is
return sqrt(pow((goal_pose.x - self.pose.x), 2) +
                    pow((goal_pose.y - self.pose.y), 2))

where they do not make reference to a second level of pose.
Looking at definition of pose messages on http://docs.ros.org/api/geometry_msgs/html/msg/Pose.html you'll see only position and orientation in a pose.
A representation of pose in free space, composed of position and orientation. 
Point position
Quaternion orientation

Originally posted by billy with karma: 1850 on 2019-06-09
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Jojo on 2019-06-10:
Thank you for your reply. I have updated my question.
Yes that line is not the same because  i am subscribing to a different topic.
And this topic(gazebo/modelstates) has a different structure. I unfortunately cannot attach a snapshot of what is being published to this topic but it has at least two positions and orientations, depending on the robot and other objects in the model


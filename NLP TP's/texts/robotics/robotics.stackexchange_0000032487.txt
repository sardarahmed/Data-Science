Q:

ROS Answers SE migration: std::ofstream

Hello everybody,
I have a question regarding ROS launch files and writing a file using the standard library ofstream.
I wrote a program that uses a camera. I want to store the runtime of some operations for further analysis and I put this data in a matrix made of standard vectors. Except for the writing of the files, everything works perfectly.
When I load the parameters using "rosparam load" and then start my software using "rosrun", everything works fine.
If I start all the programs using a launch file, the file won't be neither created nor written to if it already exists. There is no problem with the file opening. And everything was working on Cturtle.
What might be the problem?
Thank you in advance
Francesco
Code:
#include <std_msgs/Time.h>  // ros::Time for the calculation of the ball detection runtime
#include <geometry_msgs/PointStamped.h> // message type used for the communication with the OROCOS component
#include <std_msgs/Float32.h> // message type used for publishing the runtime
#include <ros/ros.h> // ros headers
#include <sensor_msgs/image_encodings.h> // message type used for the CvBridge
#include <image_transport/image_transport.h> // subscribe to and publish images
#include <cv_bridge/cv_bridge.h> // convert from ROS image to opencv image
#include <opencv2/imgproc/imgproc.hpp> // opencv headers
#include <opencv2/highgui/highgui.hpp> // opencv headers
// headers for storing the operation runtimes in a file
#include <vector>
#include <iostream>
#include <fstream>
#include <CMgreenBallDetector.hpp> // Ball detector header

namespace enc = sensor_msgs::image_encodings;

CMgreenBallDetector::CMgreenBallDetector (ros::NodeHandle &n):
                n_(n),
                it_(n),
                it2_(n),
                it3_(n)
{
    // Set the variables to publish or not publish certain topics (0: not publish, another int: publish)
    this->n_.getParam ("/CMgreenBallDetector/detectedBall", pub[0]);
    this->n_.getParam ("/CMgreenBallDetector/algorithmRuntime", pub[1]);
    this->n_.getParam ("/CMgreenBallDetector/thresholded", pub[2]);
    this->n_.getParam ("/CMgreenBallDetector/dilated", pub[3]);

    if (pub[0] != 0)
    {
        // advertise a topic for the detected ball image
        image_pub_ = it_.advertise ("CMgreen_ball_detected", 1);
    }

    if (pub[2] != 0)
    {
        // advertise a topic for the thresholded image
        image_pub2_ = it2_.advertise ("thresholded", 1);
    }

    if (pub[3] != 0)
    {
        // advertise a topic for the dilated image
        image_pub3_ = it3_.advertise ("dilated", 1);
    }

    // subscribe to the color image topic delivered by the camera in order to detect the ball in it
    image_sub_ = it_.subscribe ("/camera/image_color", 1, &CMgreenBallDetector::detectionCallback, this);

    // advertise a topic for the data of the detected ball, i.e. ball center coordinates, ball radius and timestamp
    pub_ball = n.advertise<geometry_msgs::PointStamped> ("CMgreen_ball_data", 1);

    if (pub[1] != 0)
    {
        // advertise a topic for the runtime
        pub_runtime = n.advertise<std_msgs::Float32> ("CMgbd_runtime", 1);
    }

    // Read the parameters from the parameter server
    this->n_.getParam ("/CMgreenBallDetector/h_min", h_min);
    this->n_.getParam ("/CMgreenBallDetector/h_max", h_max);
    this->n_.getParam ("/CMgreenBallDetector/s_min", s_min);
    this->n_.getParam ("/CMgreenBallDetector/s_max", s_max);
    this->n_.getParam ("/CMgreenBallDetector/v_min", v_min);
    this->n_.getParam ("/CMgreenBallDetector/v_max", v_max);

    // Define the ranges for the color filtering in the HSV color space
    // green ball
    hsv_min = cv::Scalar_<double>(h_min, s_min, v_min, 0);
    hsv_max = cv::Scalar_<double>(h_max, s_max, v_max, 0);

    // Get the camera resolution parameters
    this->n_.getParam ("/CMgreenBallDetector/width", width);
    this->n_.getParam ("/CMgreenBallDetector/height", height);

    // Set the size of the image
    size = cv::Size_<int> (width, height);

    hsv_img.create (size, CV_8UC3);
    thresholded.create (size, CV_8UC1);
    eroded.create (size, CV_8UC1);
    dilated.create (size, CV_8UC1);

    // initialize the count
    count = 0;
}

// function called every time an image from the subscribed topic arrives
void CMgreenBallDetector::detectionCallback (const sensor_msgs::ImageConstPtr& msg)
{
    // grow the count
    count++;

    if (pub[1] != 0)
    {
        launch = ros::Time::now(); // get the time
    }

    //      img = NULL; // initialize the pointer to the image that will be read

    start = ros::Time::now (); // get the time
    // Convert image from ROS to opencv type
    cv_bridge::CvImagePtr img_ptr;
    try
    {
        img_ptr = cv_bridge::toCvCopy(msg, enc::BGR8);
    }
    catch (cv_bridge::Exception& e)
    {
        ROS_ERROR("cv_bridge exception: %s", e.what());
        return;
    }
    end = ros::Time::now (); // get the time
    // put the runtime in a vector
    tempVector.push_back ((double)(end.toNSec () - start.toNSec ()));

    start = ros::Time::now (); // get the time
    // convert the image from BGR to HSV color space
    cv::cvtColor (img_ptr->image, hsv_img, CV_BGR2HSV);
    end = ros::Time::now (); // get the time
    // put the runtime in a vector
    tempVector.push_back ((double)(end.toNSec () - start.toNSec ()));

    start = ros::Time::now (); // get the time
    // thresholding of the image. Check if the image color values lie between the interval [hsv_min, hsv_max]. If yes, put a white pixel
    // at the corresponding point in the thresholded image. If not, put a black pixel in there.
    cv::inRange (hsv_img, hsv_min, hsv_max, thresholded);
    end = ros::Time::now (); // get the time
    // put the runtime in a vector
    tempVector.push_back ((double)(end.toNSec () - start.toNSec ()));

    start = ros::Time::now (); // get the time
    // Erosion of the thresholded image, to remove the noise
    cv::erode (thresholded, eroded, cv::Mat (), cv::Point (-1, -1), 1, cv::BORDER_CONSTANT, cv::morphologyDefaultBorderValue());
    // Dilation of the image, to get back to the original size
    cv::dilate (eroded, dilated, cv::Mat (), cv::Point (-1, -1), 1, cv::BORDER_CONSTANT, cv::morphologyDefaultBorderValue());
    end = ros::Time::now (); // get the time
    // put the runtime in a vector
    tempVector.push_back ((double)(end.toNSec () - start.toNSec ()));

    start = ros::Time::now (); // get the time
    // calculate the white area of the thresholded image
    sum = 0.0; // initialize the area
    // Initialize variables for the calculation of the moments
    sum_i = 0.0;
    sum_j = 0.0;
    for (int i = 0; i < dilated.cols; i++)
    {
        for (int j = 0; j < dilated.rows; j++)
        {
            tempPixelValue = dilated.data + dilated.step[0] * j + dilated.step[1] * i;
            if (*tempPixelValue == (uchar)255) {
                sum = sum + (double)(*tempPixelValue);
                sum_i = sum_i + (double)i;
                sum_j = sum_j + (double)j;
            }
        }
    }

    x_c = (double)255 * sum_i / sum;
    y_c = (double)255 * sum_j / sum;
    end = ros::Time::now (); // get the time
    // put the runtime in a vector
    tempVector.push_back ((double)(end.toNSec () - start.toNSec ()));

    done = ros::Time::now(); // get the time
    runtime = done.toNSec() - launch.toNSec(); // calculate the ball detection runtime

    start = ros::Time::now (); // get the time
    if (pub[1] != 0)
    {
        // publish the runtime
        msg_runtime.data = runtime;
        pub_runtime.publish (msg_runtime);

        // give out some information about the detected ball
        ROS_INFO ("(%lf) Ball found in %lf s: x = %lf, y = %lf\n\r", (double)msg->header.stamp.toNSec (), runtime, x_c, y_c);
    }
    end = ros::Time::now (); // get the time
    // put the runtime in a vector
    tempVector.push_back ((double)(end.toNSec () - start.toNSec ()));

    // if the white pixel area is big enough (so if the ball is assumed to be in the image)
    if (sum > (double)(500.0 * 255.0))
    {
        numOps = 10;

        start = ros::Time::now (); // get the time
        // put the needed data into the message
        msg_ball.point.x = x_c;
        msg_ball.point.y = y_c;
        msg_ball.point.z = 0.0;
        msg_ball.header.stamp = msg->header.stamp;
        pub_ball.publish (msg_ball); // publish the message
        end = ros::Time::now (); // get the time
        // put the runtime in a vector
        tempVector.push_back ((double)(end.toNSec () - start.toNSec ()));

        start = ros::Time::now (); // get the time
        if (pub[0] != 0)
        {
            // Draw the ball center on the image
            cv::circle (img_ptr->image, cv::Point (x_c, y_c), 3, cv::Scalar (0, 0, 255), -1, 8, 0);

            // publish the image with the detected ball
            image_pub_.publish(img_ptr->toImageMsg());
        }
        end = ros::Time::now (); // get the time
        // put the runtime in a vector
        tempVector.push_back ((double)(end.toNSec () - start.toNSec ()));
    }
    else // else
    {
        numOps = 9;

        start = ros::Time::now (); // get the time
        if (pub[0] != 0) {
            // publish the color image
            image_pub_.publish(img_ptr->toImageMsg());
        }
        end = ros::Time::now (); // get the time
        // put the runtime in a vector
        tempVector.push_back ((double)(end.toNSec () - start.toNSec ()));
    }

    start = ros::Time::now (); // get the time
    if (pub[2] != 0)
    {
        // publish the thresholded image
        thresholdedROS.header = img_ptr->header;
        thresholdedROS.encoding = "mono8";
        thresholdedROS.image = thresholded;
        image_pub2_.publish (thresholdedROS.toImageMsg ());
    }
    end = ros::Time::now (); // get the time
    // put the runtime in a vector
    tempVector.push_back ((double)(end.toNSec () - start.toNSec ()));

    start = ros::Time::now (); //get the time
    if (pub[3] != 0)
    {
        // publish the dilated image
        dilatedROS.header = img_ptr->header;
        dilatedROS.encoding = "mono8";
        dilatedROS.image = dilated;
        image_pub3_.publish (dilatedROS.toImageMsg ());
    }
    end = ros::Time::now (); // get the time
    // put the runtime in a vector
    tempVector.push_back ((double)(end.toNSec () - start.toNSec ()));

    timeOps.push_back (tempVector); // push the operation runtimes of this time step into a vector
    tempVector.clear (); // clear the temporary vector

    // Store the operation runtimes to a file
    if (count == 500)
    {
        std::ofstream runtimeFile;
        runtimeFile.open ("cmg_operations_runtime.txt", std::ios::trunc);

        if (!runtimeFile)
        {
            std::cout << "cmg_operations_runtime.txt could not be opened.";
        }

        for (int i = 0; i < count; i++)
        {
            tempVector = timeOps[i];
            for (int j = 0; j < numOps; j++)
            {
                runtimeFile << tempVector[j] << ";\t";
            }
            runtimeFile << "\n";
            tempVector.clear ();
        }
        runtimeFile.close ();

        std::cout << "Runtime data stored." << std::endl;
    }
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, "CMgreenBallDetector"); // initialize the CMgreenBallDetector node

    ros::NodeHandle n; // declare a node handle

    CMgreenBallDetector CMgbd (n); // start the ball detector node with the node handle n

    ros::spin(); // wait for callbacks until the node is destroyed

    return 0;
}

Originally posted by frferrara on ROS Answers with karma: 13 on 2011-06-22
Post score: 1

A:

You are writing a file to the current working directory. roslaunch changes that. Look in your .ros directory. You should find the file there.

Originally posted by dornhege with karma: 31395 on 2011-06-22
This answer was ACCEPTED on the original site
Post score: 4

Original comments
Comment by frferrara on 2011-06-22:
Thanks a lot! It was there!


Q:

rosbag playing 100hz lidar data

Hi I'd recorded four lidar(Sick LMS511@100hz,0.67deg) with sicktoolbox_wapper2 and rosbag record(lidar1/scan, lidar2/scan, and so on).
Once I tested my code in the lab using rosbag play XXX.bag, I noticed my callback function actually manipulating quadruple data at once!
Callback takes not 10ms for each lidar data but it takes 40ms at first data and about 0ms at others. even the program subscribe 1 of 4 lidar data(lidar1/scan).
Here is my test code to compare recoded timestamp & callback time

#include <ros/ros.h>
#include <sensor_msgs/LaserScan.h>
class laser_rate_test_node{
private:
    ros::NodeHandle nh;
    ros::Subscriber laser_sub;
public:
laser_rate_test_node(ros::NodeHandle _nh):nh(_nh){
    laser_sub = nh.subscribe<sensor_msgs::LaserScan>("lidar1/scan",10, &laser_rate_test_node::laserCallback, this, ros::TransportHints().unreliable());
}
void laserCallback(const sensor_msgs::LaserScanConstPtr& scan){
    ROS_INFO("%lf",scan.get()->header.stamp.toSec());
}
};
int main (int argc, char **argv)
{
    ros::init(argc, argv, "laser_rate_test_node");
    ros::NodeHandle nh;

    laser_rate_test_node laser_rate_test_node(nh);
    ros::spin();
}

and its results with network IO graph using wireshark are below:
using rosbag play XXX.bag. Highlighted text shows called time(left with bracket) and sensor timestamp(right)

using rosbag with -i option

no bag used(using actual sensor), ignore wireshark result... it's same as upper one.

In view of the results, I think this problem is a bug of rosbag play, not my code related with ROSTCP and ROSCPP.
How can I handle this problem? Is there anyone who suffered similar problem?

Originally posted by LeeJaemin on ROS Answers with karma: 26 on 2016-04-22
Post score: 1

A:

It took me a while to figure out what the question is that you're asking, so let me rephrase it: You recorded a rosbag at 100 Hz, and when you replay it, rosbag sends the messages in bursts of 4. You would instead like rosbag to play each single message at once. Correct?
First: I don't think this behavior by rosbag is a problem or a bug. Do you really absolutely need to get the messages as fast as possible? Since everything is timestamped in ROS, I can not come up with a reason why you need that, especially when playing back a rosbag (there is no interaction with the external world in that case, so it doesn't really matter if there is a 30 ms delay in producing the answer).
But if you really must try to change this, read on. Your first wireshark screenshot shows that it is indeed the publisher inside rosbag that buffers the messages, not the subscriber inside your test node. Perhaps it's because tcpNoDelay() is not set? Try enabling it in player.cpp:199. This should reduce the delay, but be less efficient.
P.S.: Some more comments:

rosbag -i doesn't disable the buffer; instead, it makes rosbag speed up replay time as fast as it can, instead of running at the same speed as when the rosbag was recorded.
When playing back a rosbag, you should usually run rosparam set use_sim_time true right after starting the roscore, and call rosbag with the --clock option. For the screenshots you made it was correct not to do that (because it actually produced more useful log output), but in general you should always do it.

Originally posted by Martin Günther with karma: 11816 on 2016-04-22
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by LeeJaemin on 2016-04-22:
Yes it corrects. I can modify program to use ros timestamp. but I want to clarify why it happen although it actually have power to doing more accurately.
I used -i option to test communication performance between rosbag and my node. I think this results shows that the communication is not problem.
Comment by LeeJaemin on 2016-04-22:
and thank you for your kind advices! I used
--clock
option when that screenshot was taken but I didn't realize that
rosparam set use_sim_time true
is needed!
Comment by Martin Günther on 2016-04-22:
Glad I could help! Just to clarify: If you use ROS time (and you should), the results will be as accurate as possible, no matter if the messages are buffered or not.


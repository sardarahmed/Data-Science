Q:

Openni_tracker Illegal Instruction

Hi,
I'm trying to run openni_tracker and when I type "rosrun openni_tracker openni_tracker".
I get the output "Illegal instruction". I do know my kinect is working since I am able to run openni_launch and visualize the point cloud data.
I saw another post that says this is because of sse3
htt p://answers.ros.org/question/11927/illegal-instruction-in-openni_tracker-libxnvfeaturesso
I'm running a new laptop (AMD Turion(tm) II P540 Dual-Core Processor) and when I run "cat /proc/cpuinfo" I get the output of
flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm 3dnowext 3dnow constant_tsc rep_good nopl nonstop_tsc extd_apicid pni monitor cx16 popcnt lahf_lm cmp_legacy svm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw ibs skinit wdt nodeid_msr npt lbrv svm_lock nrip_save

I know it doesnâ€™t say sse3 but I think that might be pni?
Other than that I'm not really sure how to go about troubleshooting this error.
Thanks,

EDIT 1
output from gdb
(gdb) run
Starting program: /opt/ros/fuerte/stacks/openni_tracker/bin/openni_tracker 
[Thread debugging using libthread_db enabled]
[New Thread 0x7ffff131d700 (LWP 4222)]
[New Thread 0x7ffff0b1c700 (LWP 4223)]
[New Thread 0x7ffff031b700 (LWP 4224)]
[New Thread 0x7fffefb1a700 (LWP 4229)]
[New Thread 0x7fffecb5f700 (LWP 4235)]

Program received signal SIGILL, Illegal instruction.
0x00007fffed40abd3 in NAGeneralData::Downscale2x2SSE(unsigned short const*, unsigned short*, short, short, Box2D<int>*) () from /usr/lib/libXnVFeatures.so

EDIT 2
Thanks, when I ran the codes everything compiled and it ran for sse, sse2, and sse3. When I ran sse4.1, I received the output Illegal instruction (core dumped) and I wasn't able to compile sse4.2 (which would make sense because I don't think my cpu
is supposed support that?)

Originally posted by nickd on ROS Answers with karma: 92 on 2012-12-29
Post score: 1

A:

According to http://www.cpu-world.com/CPUs/K10/AMD-Turion%20II%20Dual-Core%20Mobile%20P540%20-%20TMP540SGR23GM.html and Wikipedia, your CPU should support SSE3. I'm not sure why it isn't showing up in cpuinfo. I do see sse4a in that output, and as far as I know, all CPUs that support SSE4a support SSE3.
To verify your machine's instructions, try to compile and execute some of the code snippets in http://svn.pointclouds.org/pcl/trunk/cmake/pcl_find_sse.cmake . If the chunk for checking SSE3 flags compiles (with the -msse3 flag) and runs on that machine, then missing SSE3 instructions are not the problem.
Could you launch the tracker in gdb and see if you can get any indication of the exact error?
Update with some more directions on using the SSE samples:
What you want to do is basically try to run each of the different C++ snippets in the "check_cxx_source_runs" commands for the different SSE levels you want to examine after compiling them with the correct flags. I'll run through the block for SSE3 detection in that CMake file.
if(CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX OR CMAKE_COMPILER_IS_CLANG)
    set(CMAKE_REQUIRED_FLAGS "-msse3")
endif(CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX OR CMAKE_COMPILER_IS_CLANG)

check_cxx_source_runs("
    #include <pmmintrin.h>
    int main ()
    {
        __m128d a, b;
        double vals[2] = {0};
        a = _mm_loadu_pd (vals);
        b = _mm_hadd_pd (a,a);
        _mm_storeu_pd (vals, b);
        return (0);
    }"
    HAVE_SSE3_EXTENSIONS)

You should copy-paste the C++ code there (everything between #include and }) into a file (e.g. /tmp/sse3_test.cpp). You would then compile that with a command such as g++ -msse3 /tmp/sse3_test.cpp -o sse3_test to generate the file to run. The -msse3 flag was picked because it was the flag set in the block just before this check_cxx_source_runs command. If you can then successfully run ./sse3_test , then you should be fairly certain that your CPU supports SSE3. I don't have a computer without SSE3 extensions to test it on, but that should emulate exactly what those checks in that CMake script are doing.
Update
It looks like the answer to the other question linked pointed out that NITE (a binary dependency of the tracker) was using SSSE3, not simply SSE3. As far as I can tell, your CPU doesn't support SSSE3, only SSE3. I don't know a good way of checking, but I can say that, on my Intel machines, ssse3 shows up in the /proc/cpuinfo output.

Originally posted by Eric Perko with karma: 8406 on 2012-12-29
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by nickd on 2012-12-29:
I updated my original question with the output from running tracker in gdb. Now to figure out how to run and compile that link you sent me. I don't use Ubuntu unless I'm using ROS and I'm new to ROS Thanks for helping, I really appreciate it.
Comment by Eric Perko on 2012-12-30:
Welp... looks like that error is certainly in a function that would use SSE (given it's name "Downscale2x2SSE"). Given that your CPU seems that it should support all SSE up to SSE4a, I'm not really sure what the problem is... I hope those tests using the PCL SSE detection code may be revealing.
Comment by nickd on 2012-12-30:
I'm sorry I'm not really sure how to compile and execute that code in the link you sent me. I've been working on it for the past two nights but haven't really been able to figure out how to work with it.
Comment by Eric Perko on 2012-12-30:
I updated my answer with some more information that should help you.
Comment by Eric Perko on 2012-12-31:
I took another look at the question you linked and updated my answer. There is a difference between "SSSE3" and "SSE3".


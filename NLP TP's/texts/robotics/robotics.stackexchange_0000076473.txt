Q:

Multiple files in one add_executable

I refer to this CMakeLists.txt
I am confused with the add_executable there. For example:
add_executable(drone_stateestimation ${STATEESTIMATION_SOURCE_FILES} ${STATEESTIMATION_HEADER_FILES})

The STATEESTIMATION_SOURCE_FILES and STATEESTIMATION_HEADER_FILES refers to multiple files:
set(STATEESTIMATION_SOURCE_FILES       
    src/stateestimation/GLWindow2.cc
    src/stateestimation/GLWindowMenu.cc  
    src/stateestimation/main_stateestimation.cpp
        ....

and
set(STATEESTIMATION_HEADER_FILES    
  src/stateestimation/GLWindow2.h 
  src/stateestimation/GLWindowMenu.h    
  src/stateestimation/MouseKeyHandler.h  
  src/HelperFunctions.h 
  ....

My QUESTIONS:
I don't understand how they work. The case that I know (from my limited experience) so far is just add_executable( node_name file.cpp).

If there are multiple files referring to one node, which code is executed when we run that node?

Why do we add the header files to the add_executable? I never saw this before.

Please help to explain.
-----.
PS: I saw from the catkin wiki page here as well on point 7.4
"This will build a target executable called myProgram which is built from 3 source files: src/main.cpp, src/some_file.cpp and src/another_file.cpp."
But I don't understand. Like when we call that node , which file is executed? are they all executed? which order?

Originally posted by alienmon on ROS Answers with karma: 582 on 2016-09-26
Post score: 0

A:

1 . If there are multiple files referring to one node, which code is executed when we run that node?

The code that is part of the main entry point, which is by default: int main(int argc, char *argv[]).
Note that this is no different from how you'd specify a target in (GNU) Make: it's perfectly valid for binaries to consist of multiple object files.

2 . Why do we add the header files to the add_executable? I never saw this before.

This is often done for CMake generators that generate projects for tools / IDEs that don't show all files by default (in a project explorer view fi), but only those files that are "part of" a target. Qt Creator is one of those, as is Visual Studio.
Note: these questions are not ROS specific: your first question is basic CMake / Make, the second is a 'trick' (and listed as one of the CMake antipatterns (but read the Errata section at the bottom of the page).

Edit:

But I don't understand. Like when we call that node , which file is executed? are they all executed? which order?

Please read the link to the wikipedia article about entry points. The question "which file is executed" doesn't really make sense in the context of compiled languages and object code (as there isn't necessarily a 1-to-1 correspondence).

Originally posted by gvdhoorn with karma: 86574 on 2016-09-26
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by alienmon on 2016-09-26:
@gvdhoorn thanks for the answer. I'm quite new, so I'm also not rlly familiar with (GNU) Make that you mentioned.
Why don't we put the other files that is not main entry point in either add_dependencies or include or include_dir instead?
Comment by gvdhoorn on 2016-09-26:
re: (GNU) Make: that was just an example: any build tool that supports building C(++) binaries will work the same.
re: add_dependencies(..): that is used for completely different things (namely: to express dependencies between CMake targets, not source files).
Comment by gvdhoorn on 2016-09-26:
And include paths are again something different: those contain paths not files, and nothing gets compiled, so that doesn't help when building an executable binary.
Comment by gvdhoorn on 2016-09-26:
But you actually summarised it quite correctly in your own answer:

We specify the other files , because they contain the things (variables/functions) needed in the main function.

That is it exactly.
Comment by alienmon on 2016-09-26:
Thank you so much for the explanation
Comment by alienmon on 2016-09-26:
Hi sorry, I read from the web that you put. I don't really understand this
Certain IDEs such as Qt Creator and Visual Studio will only display files that belong to a target. Thus headers need to be added in the source list or otherwise they canâ€™t be edited.

Comment by alienmon on 2016-09-26:
-What does "display files" mean? Does it mean displaying in the IDE directories?
-"otherwise they can't be edited" -> because they are not displayed in the IDE directories? but aren't we always able to just find the .h file and open and edit it?
Comment by gvdhoorn on 2016-09-26:
It's a UI thing: Qt Creator will only list files in the project explorer if that file "belongs" to (ie: is related to) something. It only shows compilation targets, so the headers are added to the targets in order for them to show up in the IDE.
Comment by gvdhoorn on 2016-09-26:
re: display files: yes, it only shows things in the "IDE directories"
re: can't be edited: yes, you can always browse for the .h and open it, but that would not be by double clicking in the tree showing all source files, but by file -> open ... and the browsing for it.
Comment by alienmon on 2016-09-26:
From reading the paragraph , I got the impression that we put the .h file just for displaying purpose. It can still work fine ( build and compile) even though we do not specify the .h files in add_executable.
Is that true?
Comment by gvdhoorn on 2016-09-26:
Yes. As long as the directory containing the header files is on the include path, the binary will compile fine, even without adding the headers to add_executable(..). It's just for "displaying purpose".


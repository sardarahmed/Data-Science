Q:

Examples of closed-loop body-frame velocity controllers for a mobile base

Are there any examples of closed-loop velocity controllers for mobile robots? I'm referring to a node, or even a robot-specific function, that takes in:

a desired velocity command (e.g. from nav stack or teleop)
an estimate of the robot's current velocity (e.g. via wheel odometry or robot_localization)

and returns a modified body-frame velocity command, which is then sent to the robot's low-level driver to be translated into motor commands. Its purpose would be to compensate for things like static and rolling friction, weird floor types such as thick carpets, inclines/declines, discrepancies between the robot's wheels/motors, etc.
I realize that the nav stack's local planners do some of that. But I'm looking for something that would work independently of the path and motion planning layer and independently of localization w.r.t. a map. For example, it would also correct velocity commands coming from keyboard teleop.
I thought that the turtlebot or kobuki  repos might contain examples but I wasn't able to find anything there. Did the PR2 have such functionality?
PS. To clarify, I'm not looking for a controller that converts body-frame velocity commands to wheel velocity commands. Rather, I'm looking for a controller that regulates the body-frame velocity itself. Kind of like cruise control.

Originally posted by spmaniato on ROS Answers with karma: 1788 on 2016-07-28
Post score: 1

A:

The PR2 has a rather complex drive configuration with 12 drive motors and a similarly complex control algorithm. It would not be an appropriate example.
The differential_drive package is a controller based on nodes and topics for controlling a mobile base. Should be easy to understand and work with, but won't work as well for high-speed navigation.
The diff_drive_controller package has a differential drive controller that is built on top of the ros_control framework. More difficult to understand and set up, but should work well at high speeds that require very fast cycle times from the controller.
Keep in mind that these packages provide the software, but to make them work well for your robot and your operating environment you'll need to spend time tuning the controller gains.

Originally posted by ahendrix with karma: 47576 on 2016-07-28
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by spmaniato on 2016-07-28:
Thanks for the links Austin. It looks like these packages implement velocity PID loops at the wheel velocity/RPM level. I'm looking for something one level up. A controller that takes in body-frame velocity and spits out a "better" body-frame velocity by taking into account how the robot is moving.
Comment by ahendrix on 2016-07-28:
These controllers implicitly close the loop between the odometry and base_link frames. The nav stack closes the loop between map and base_link. I'm not aware of anything in between.
Comment by spmaniato on 2016-07-28:
Yeah, me neither. I guess what I'm looking for is kind of like cruise control for a mobile robot. I'll keep at it (or just implement one from scratch)


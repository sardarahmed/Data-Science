Q:

advertiseService() Call Error: Member Function Callback

Hi there, this is my first time posting here so I appologize if don't layout my question in the best way.
I'm having an issue passing my callback function to the advertiseService() function. The error I get during the catkin_make process can be seen below:
error: no matching function for call to ‘ros::NodeHandle::advertiseService(const char [19], bool (KinovaPracticeServerClass::*)(package1::kinovaPracticeSrv::Request&, package1::kinovaPracticeSrv::Response&), KinovaPracticeServerClass*) const’

My package is supposed to work as follows: in my kinovaPractice.cpp file I have my main function where I initialize and then create the handle for a node. I then create a new object from a custom class named KinovaPracticeServerClass. This class has two functions, the first being the constructor and the second being the bool function which I want to pass as an argument to the advertiseservice() function.
a KinovaPracticeServerClass object is created in the main() function and the node handle from the main() function is passed to the constructor of the KinovaPracticeServerClass object. The constructor then tries to call the advertiseservice() member of the node handle passed to it. The callback is the bool function which is also in the class: KinovaPracticeServerClass. I have followed the convention in roscpp_tutorials/Tutorials/UsingClassMethodsAsCallbacks but still am having issues.
What is interesting is that if I declare the callback above my main function in kinovaPractice.cpp and then advertise the service within the main function, the service works no problem.
I should also note that I am using a custom service I made called kinovaPracticeSrv.srv. The custom class I made is divided between a .h & .cpp file.
I am using ROS Melodic running Ubuntu 18.04 with the 5.4.0-73-generic kernel.
All files are contained within a package called "package1". All my code can be seen below.
kinovaPractice.cpp:
#include<iostream>
#include"ros/ros.h"
#include"kinovaPracticeClass.h"
#include"std_msgs/String.h"
#include<functional>
#include "package1/kinovaPracticeSrv.h"
#include "kinovaPracticeServerClass.h"

//UNCOMMENTING THIS FUNCTION BELOW ALONG WITH THE OTHER LINE IN THE MAIN() WILL ALLOW FOR MY SERVICE TO WORK PROPERLY
/*
bool serverCallback(package1::kinovaPracticeSrv::Request &req,package1::kinovaPracticeSrv::Response &res)
{
  //going to print the joint angles that were received
  std::cout<<"Received the following for joint1: "<<req.joint1<<std::endl;
  std::cout<<"Received the following for joint2: "<<req.joint2<<std::endl;
  std::cout<<"Received the following for joint3: "<<req.joint3<<std::endl;
  std::cout<<"Received the following for joint4: "<<req.joint4<<std::endl;
  std::cout<<"Received the following for joint5: "<<req.joint5<<std::endl;
  std::cout<<"Received the following for joint6: "<<req.joint6<<std::endl;
  return true;
}//End of the server callback
*/

int main(int argc, char **argv)
{

//initilize node and create node handle
ros::init(argc, argv, "kinovaPracticeNode");
ros::NodeHandle nh("~");//This should make this node handle avalible to all other namespaces?
//ros::ServiceServer server=nh.advertiseService("MoveToHomePosition",serverCallback);<--IF THIS LINE IN UNCOMMENTED ALONG WITH THE FUNCTION ABOVE, THE CALLBACK WORKS FINE

//Creating a kinovaPractceServerClass Object which will initilize my custom services in it's constructor
KinovaPracticeServerClass customServerObj(nh);

while(ros::ok()){
ros::spin();
}

return 0;
}//End of the main function

Custom Class Header:
#ifndef kinovaPracticeServerClass_h
#define kinivaPracticeServerClass_h
#include "kinovaPracticeClass.h"
#include "ros/ros.h"
#include "package1/kinovaPracticeSrv.h"

class KinovaPracticeServerClass
{
public:
  KinovaPracticeServerClass(const ros::NodeHandle &node_handle);

  bool serverCallback(package1::kinovaPracticeSrv::Request &req,package1::kinovaPracticeSrv::Response &res);

private:
  ros::ServiceServer server1_;

};//end of kinovaPracticeServerClass

#endif

Custom Class.cpp file
#include "kinovaPracticeServerClass.h"
#include"ros/ros.h"
#include"kinovaPracticeClass.h"

bool KinovaPracticeServerClass::serverCallback(package1::kinovaPracticeSrv::Request &req,package1::kinovaPracticeSrv::Response &res)
{
  //going to print the joint angles that were received
  std::cout<<"Received the following for joint1: "<<req.joint1<<std::endl;
  std::cout<<"Received the following for joint2: "<<req.joint2<<std::endl;
  std::cout<<"Received the following for joint3: "<<req.joint3<<std::endl;
  std::cout<<"Received the following for joint4: "<<req.joint4<<std::endl;
  std::cout<<"Received the following for joint5: "<<req.joint5<<std::endl;
  std::cout<<"Received the following for joint6: "<<req.joint6<<std::endl;
  return true;
}//End of the server callback

  KinovaPracticeServerClass::KinovaPracticeServerClass(const ros::NodeHandle &node_handle)
  {
    server1_=node_handle.advertiseService("MoveToHomePosition", &KinovaPracticeServerClass::serverCallback, this);
    std::cout<<"You have created a kinovaPracticeServerClassObject"<<std::endl;
  }//End of the constructor

Custom service:
float32 joint1
float32 joint2
float32 joint3
float32 joint4
float32 joint5
float32 joint6
---

package.xml file:
<?xml version="1.0"?>
<package>
  <name>package1</name>
  <version>0.0.1</version>
  <description >
  This contains some practice file for adding a custom service to the kinova robot
  </description>
  <author >Chris Morley</author>
    <maintainer email="n@a.com">Chris Morley</maintainer>
  <license>NA</license>
  <buildtool_depend>catkin</buildtool_depend>
  <build_depend>roscpp</build_depend>
  <build_depend>std_msgs</build_depend>
  <build_depend>message_generation</build_depend>
  <run_depend>roscpp</run_depend>
  <run_depend>std_msgs</run_depend>
  <run_depend>message_runtime</run_depend>
  <export>
  </export>
</package>

CMakeLists.txt file:
cmake_minimum_required(VERSION 2.8.3)
project(package1)

find_package(catkin REQUIRED COMPONENTS
  roscpp
  std_msgs
  message_generation
)

include_directories(
  ${catkin_INCLUDE_DIRS}
)

add_service_files(
  FILES
  kinovaPracticeSrv.srv
)

generate_messages(
  DEPENDENCIES
)

catkin_package(
  CATKIN_DEPENDS roscpp std_msgs message_runtime
)
add_library(kinovaPracticeClassLibrary ./src/kinovaPracticeClass.h ./src/kinovaPracticeClass.cpp)
add_library(kinovaPracticeServerClassLibrary ./src/kinovaPracticeServerClass.h ./src/kinovaPracticeServerClass.cpp)

add_executable(kinovaPractice src/kinovaPractice.cpp)
target_link_libraries(kinovaPractice ${catkin_LIBRARIES})
target_link_libraries(kinovaPractice PRIVATE kinovaPracticeClassLibrary)
target_link_libraries(kinovaPractice PRIVATE kinovaPracticeServerClassLibrary)

Originally posted by chrism on ROS Answers with karma: 36 on 2021-05-28
Post score: 1

A:

After some more digging I found the solution from a similair question asked earlier Why does this not compile? It is matching the documentation and other examples identically. Yet it gives me mismatch errors..
The problem was that I was passing a constant node handle into my constructor and then trying to advertise a service which wasn't allow. The solution, mentioned in the link above, was to remove the const from the node handle argument. Another solution I found would be to have a private member of type ros::NodeHandle and then declare it through a memeber initializer.

Originally posted by chrism with karma: 36 on 2021-05-29
This answer was ACCEPTED on the original site
Post score: 1


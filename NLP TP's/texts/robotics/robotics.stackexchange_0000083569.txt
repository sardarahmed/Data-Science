Q:

How do I remotely compile ROS node (inc cuda) using catkin_make for the Jetson TX1?

I have a Jetson TX1 running Ubuntu 16.04. I installed a pre-built version of ROS for ARM and I can catkin_make and run my personal ROS nodes on the device itself. I now want to extend these nodes to use cuda cores AND still use catkin_make AND be able to compile on any machine.
I cannot use the master build and run remote technique suggested my Nvidia (using their version of Eclipse) - as I want to carry on using catkin_make. However, I have managed to get my nodes and some dummy cuda code compiling with catkin_make on my x86 Ubuntu 16.04 desktop. So part way there.... But how do I cross compile just these personal nodes (ie. not recompile the whole of ROS) to run on the Jetson TX1?
Furthermore, how do I go about debugging with this build system?
Perhaps I'm even trying to use the wrong build architecture?
Any suggestions would be greatly appreciated!

Originally posted by OxDave on ROS Answers with karma: 3 on 2017-10-27
Post score: 0

Original comments
Comment by glukon on 2017-10-27:
I'm also interested in this question. Currently I'm running ROS on a Jetson TK1. Take a look at: https://stackoverflow.com/questions/25748039/add-cuda-to-ros-package
Here you see that it's needed to add information about the cuda lib in the CMakeList.txt file.
Comment by OxDave on 2017-10-27:
Thanks for that. Yes - I did most of this to get cuda code to compile with catkin_make on my x86 Ubuntu 16.04 desktop. However, that only solves part of the problem. I want to be able to compile it on my main PC so that it will run on the Jetson TX1 (ARM)....
Comment by glukon on 2017-10-27:
Alright though, hope someone can give us more information about this. Greets
Comment by OxDave on 2017-10-27:
:-) I suppose I could only compile it using catkin_make on the TX1 itself. But that is a bit rubbish, as when other people in our group want to build the source tree it will fail as they are doing it on their x86 PC. I was hoping as well that doing it remotely would allow some form of debugging too.

A:

I'm not sure if this would fit your needs, but you could possibly make your CUDA specific code a custom external library, which you then link to from catkin.  That would make it more straightforward to figure out how to cross compile as you could use nvcc directly and you wouldn't need to search for ROS-specific instructions for cross compiling. Obviously this adds another layer to the process, so it probably depends on whether your code lends itself to being a library.

Originally posted by john.j.oneill with karma: 136 on 2017-10-27
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by OxDave on 2017-10-27:
Mmm. Not the prettiest solution, but that could definitely work. I'll give it a go. Many thanks!
Comment by gvdhoorn on 2017-10-27:
Making your ROS node(s) a thin wrapper around your actual business logic has always been a best practice. What @john.j.oneill suggests would seem to align with that.


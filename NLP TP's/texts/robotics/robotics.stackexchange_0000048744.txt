Q:

how to calculate the odometry for irobot create robot

Hi,
I'm trying to understand how the odometry is calculated in irobot_create_2_1 driver.
I spent lots of time trying to figure out where the minus sign comes from in y=-sin(th)*d, on the 53th line in driver.py.
I've included the code snippet. I also included the odometry calculation part in turtlebot_node.py from turtlebot stack, which does the same thing but easier for me to understand.
Can anyone give me a hint or let me know where I can find good resource on mobile robot odometry/kinematics in order to understand the whole scenario.
Thanks
From driver.py
00046                 d = self.create.d_distance / 1000.
00047                 th = self.create.d_angle*pi/180
00048                 dx = d / elapsed
00049                 dth = th / elapsed
00050 
00051                 if (d != 0):
00052                         x = cos(th)*d
00053                         y = -sin(th)*d
00054                         self.x = self.x + (cos(self.th)*x - sin(self.th)*y)
00055                         self.y = self.y + (sin(self.th)*x + cos(self.th)*y)
00056 
00057                 if (th != 0):
00058                         self.th = self.th + th

From turtlebot_node.py
    # this is really delta_distance, delta_angle
    d  = sensor_state.distance * self.odom_linear_scale_correction #correction factor from calibration
    angle = sensor_state.angle * self.odom_angular_scale_correction #correction factor from calibration

    x = cos(angle) * d
    y = -sin(angle) * d

    last_angle = self._pos2d.theta
    self._pos2d.x += cos(last_angle)*x - sin(last_angle)*y
    self._pos2d.y += sin(last_angle)*x + cos(last_angle)*y
    self._pos2d.theta += angle

I've attached my calculation as below, can someone point out where went wrong?

Originally posted by vincent on ROS Answers with karma: 311 on 2013-02-26
Post score: 2

A:

I don't know if I can answer your specific question, but this is a good source for learning about how to calculate the odometry:
http://rossum.sourceforge.net/papers/DiffSteer/
-Jon
(EDIT):  It appears that the global coordinate frame (self.x, self.y and self.th in driver.py) has +y to the left.  But the coordinate frame for the change in position (x,y, and th in driver.py) has +y to the right.
It seems unlikely to me that that is what the original author intended.  It's probably either a bug that doesn't matter in the end, or maybe an artifact of the odometry that supplies data to driver.py.

Originally posted by Jon Stephan with karma: 837 on 2013-02-26
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by vincent on 2013-02-26:
thank you Jon, i've read through this tutorial but still didn't get the answer for my question.
Comment by Jon Stephan on 2013-02-26:
I think it just comes down to the definition of the axes and the angle.  If I've got it right, I think +x is forward, +y is to the right, and +angle is counter-clockwise.
Comment by vincent on 2013-02-27:
ok i see. Is it left-handed coordinate system?
Comment by vincent on 2013-02-27:
based on my calculation, it came down to this: self._pos2d.x += cos(last_angle)*x + sin(last_angle)*y; self._pos2d.y += - sin(last_angle)*x + cos(last_angle)*y. (the rest is the same with the examples). still different signs... not sure if you got the same result...
Comment by vincent on 2013-02-27:
i've edited my question with my calculation attached. could you please have a look and let me know if anything went wrong? thx.
Comment by Jon Stephan on 2013-02-27:
Wow, I thought I understood this, but I guess not.  It looks to me like the coordinate frame of x and y (the change of x and y) has +y to the right, while self.x and self.y has +y to the left.  I also confirmed on my robot that +y (the global +y) is to the left.
Comment by Jon Stephan on 2013-02-27:
I also confirmed that rotating to the right gives a positive y, and a negative self.y.
Comment by vincent on 2013-02-28:
Great! that explains. Is it like a convention to define these two coordinate frame differently or is it just specific to the create robot?
Comment by Jon Stephan on 2013-02-28:
I don't know, but I doubt that's what the original programmer intended.  I bet it's a bug that doesn't really matter in the end.
Comment by vincent on 2013-02-28:
could you edit your post with the explanation of the two frames, so that it will be easier for others to locate the answer. thx!


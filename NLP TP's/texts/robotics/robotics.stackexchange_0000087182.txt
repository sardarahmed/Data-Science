Q:

General understanding of ros-canopen

Hello,
over the last couple days i tried to understand the concept of ros-canopen.
I do have a drive motor from dunkermotor which conforms to CiA 402. Also i do have a PEAK-USB adapter to connect the motor to my PC.

From my understanding ros_canopen provides a driver for PEAK-USB in the package socketcan_interface. After some preperation i should be able to test my setup with can-utils.

For usage with other ROS nodes i have to use either canopen_chain_node or canopen_motor_node whereby canopen_motor_node implements the CiA 402 profiles. For configuration i have to follow the description on canopen_chain_node/Configuration. I guess i only have to set a single node here since i only want to drive a single motor for testing purposes. The .eds/.dcf files should be provided by the manufacturer of my motor right? If not, can i write it by myself?

With canopen_motor_node i really get lost. What i don't get is what it all has to do with ros_control as stated in canopen_motor_node/Concepts. I am also confused about joints and URDF, do I really need a robot_description for driving a single motor?

So for the .launch file i would do something like this:
    <launch>
      <node pkg="canopen_motor_node" name="canopen_motor_node" type="canopen_motor_node" >
        <rosparam file="$(find pkgname)/params/canopen.yaml" command="load" />
      </node>
    </launch>

And for the .yaml i would do something like this:
    #driver params
    bus:
      device: can0 # socketcan network
    sync:
      interval_ms: 10 # set to 0 to disable sync
      overflow: 0 # overflow sync counter at value or do not set it (0, default)

    #canopen_chain_node params
    nodes:
      - name: node1
        id: 1
        eds_file: "$(find pkgname)/params/my_config.eds" # path to EDS/DCF file

    #canopen_motor_node params
    ...

edit:
For the #canopen_motor_node params i used configs recomended by jdeleon in the comments and close to the defaults described on canopen_motor_node/Configuration.
    defaults: # optional, all defaults can be overwritten per node
      motor_allocator: canopen::Motor402::Allocator # select allocator for motor layer
      motor_layer: #settings passed to motor layer (plugin-specific)
        switching_state: 2 # (Operation_Enable), state for mode switching
      pos_to_device: "rint(rad2deg(pos)*1000)" # rad -> mdeg
      pos_from_device: "deg2rad(obj6064)/1000" # actual position [mdeg] -> rad
      vel_to_device: "rint(rad2deg(vel)*1000)" # rad/s -> mdeg/s
      vel_from_device: "deg2rad(obj606C)/1000" # actual velocity [mdeg/s] -> rad/s
      eff_to_device: "rint(eff)" # just round to integer
      eff_from_device: "0" # unset
      publish: ["6042"]

When i launch this i get the errors:
    [ERROR] [1528373326.152068579]: Could not find parameter robot_description on parameter server
    [ERROR] [1528373326.221375434]: joint node1 was not found in URDF

Although i am not quiet sure why i would need this i wrote an URDF file and puplished it through robot_state_publisher.
I added those lines to the beginning of my launch file.
    <param name="robot_description" textfile="$(find pkgname)/urdf/urdf.xml"/>
    <node pkg="robot_state_publisher" type="robot_state_publisher" name="rob_st_pub" >
    </node>

And for the URDF i wrote the urdf.xml
     <robot name="test_robot">
       <link name="link1" />
       <link name="link2" />

       <joint name="node1" type="continuous">
         <parent link="link1"/>
         <child link="link2"/>
       </joint>
     </robot>

Now i can launch my launch file without errors.
In a terminal i executed candump can0.
And in another terminal i executed rosservice call /driver/init.
I can now see a lot of traffic on my candump terminal.
I am now stuck with further communication with my motor. How do those ros_controller work, do i really need them? I would simply want my motor_node to subscribe to a topic where i can tell it target motor speeds. Is this possible?
I am really looking forward for some help, let me know if you need more information or if I am completely wrong. It's just hard to ask a specific question when you don't really understand the whole concept.

Originally posted by JulianS on ROS Answers with karma: 11 on 2018-05-29
Post score: 1

A:

Hi JulianS,
I'm also trying to understand ros-canopen in canopen_motor_node params I have the next:
defaults: # optional, all defaults can be overwritten per node
  # canopen_chain_node settings ..
  motor_allocator: canopen::Motor402::Allocator # select allocator for motor layer
  #motor_layer: # settings passed to motor layer (plugin-specific)
  switching_state: 5 # (Operation_Enable), state for mode switching
  pos_to_device: "rint(rad2deg(pos)*1000)" # rad -> mdeg
  pos_from_device: "deg2rad(obj6064)/1000" # actual position [mdeg] -> rad
  vel_to_device: "rint(rad2deg(vel)*1000)" # rad/s -> mdeg/s
  vel_from_device: "deg2rad(obj606C)/1000" # actual velocity [mdeg/s] -> rad/s
  eff_to_device: "rint(eff)" # just round to integer
  #eff_from_device: "0" # unset

With that, I can connect correctly to the motors,
Jorge

Originally posted by jdeleon with karma: 133 on 2018-06-04
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by jayess on 2018-06-04:
Please don't use an answer to ask a question. This isn't a forum. Please create a new question and reference this question instead.
Comment by JulianS on 2018-06-04:
I will test this on wednesday. Do you know what the switching_state parameter does?
And what is happening next? Does the canopen_motor_node puplishes topics then based on the objects described in the .eds file?
Comment by jdeleon on 2018-06-05:
The switching state is the operation mode for the motor:
From the wiki
Profiled Position 1
Velocity 2
Profiled Velocity 3
ï»¿Profiled Torque 4
Interpolated Position 7
Cyclic Synchronous Position 8
Cyclic Synchronous Velocity 9
Cyclic Synchronous Torque 10
Comment by jdeleon on 2018-06-05:
About the canopen_motor_node, I can't answer at this moment, because I'm stuck with the controller_manager
Comment by jdeleon on 2018-06-07:
Hi @JulianS,
did you test something? was it successful?
Comment by JulianS on 2018-06-07:
Hi, yes i tested your canopen_motor_node params yesterday and i was able to comunicate with my motor. I will edit my original post with my new knowledge.


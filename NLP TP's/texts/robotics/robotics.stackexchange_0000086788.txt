Q:

smach: How to execute a new state and then continue with the old state

Hi, I'm using SMACH and I have a situation where I'm executing say, state1. But I get a sensor input and I have to execute a new state now, state2. After execution of state2, I want to continue executing state1 where I left it off. Is this scenario possible? If yes, how do I make this happen?

Originally posted by robot_commander on ROS Answers with karma: 25 on 2018-04-27
Post score: 0

A:

Two possibilities:

Use instance variables inside your state1 Class
Pass data between state instances with userdata

or some combination of the 2...
e.g. #1:
import rospy
from smach import State

class State1(State):
    def __init__(self):
        State.__init__(self, outcomes=['still_working', 'done'])
        
        rate = rospy.Rate(200)  # Loop at 200 Hz

        self._in_progress = False
        self._prev_data = None
        # etc. etc.

    def execute(self):
        # entry
        current_data = []
        if self._in_progress:
            current_data = self._prev_data
        
        sensor_input = False
        while not sensor_input and not rospy.is_shutdown():

             # do a bit of work here
             current_data.append(do_just_a_bit_of_work())
          
             if check_if_work_done():
                 self._in_progress = False
                 self._prev_data = None
                 return 'done'

             if check_for_sensor_input():
                 self._in_progress = True
                 self._prev_data = current_data
                 return 'still_working'

             rate.sleep()

For #2, state1 would pass out different userdata values based on whether or not it had completed before being interrupted. You'd probably want a state3 that would determine the next transition after state2 based on the userdata dictionary.

Originally posted by josephcoombe with karma: 697 on 2018-05-18
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by robot_commander on 2018-07-09:
@josephcoombe Thank you for your input!


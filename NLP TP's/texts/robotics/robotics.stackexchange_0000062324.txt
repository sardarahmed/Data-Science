Q:

SIGINT handler not working

Hey
I wrote a node i could easily end with my personalized SIGINT handler.
The handler set all my velocities to zero before shutting down and called out a short message after doing so. Now I've slightly changed  my node so I can receive keyboard commands and now the Handler doesn't react anymore when I call him Ctrl-C
I don't know where the fault is..
 #include "ros/ros.h"
 #include "std_msgs/String.h"

 #include "signal.h" //necessary for the Custom SIGINT handler

 #include "stdio.h" //necessary for the Custom SIGINT handler

 #include "sstream"

 #include "brics_actuator/JointVelocities.h"

  /**
   * A count of how many messages we have sent. This is used to create
   * a unique string for each message.
   */

int count = 0;
brics_actuator::JointVelocities msg;
ros::Publisher chatter_pub;

void mySigintHandler(int sig){  //hier: funktion wird aufgerufen beim beenden der node
    msg.velocities.resize(6);
    msg.velocities[0].value = 0; // A1 ... (rad/s)
    msg.velocities[1].value = 0;
    msg.velocities[2].value = 0;
    msg.velocities[3].value = 0;
    msg.velocities[4].value = 0;
    msg.velocities[5].value = 0; // A6
    std::cout << "all velocities set to zero";
    chatter_pub.publish(msg);
    ros::shutdown();
}

class talker
{
private:
    ros::NodeHandle n;
    ros::Publisher chatter_pub;

public:

    //!Ros node initialization
    talker(ros::NodeHandle n){
//      //n_ =n;
//      chatter_pub = n.advertise<brics_actuator::JointVelocities>("/arm_controller/command_vel", 10);
    }

//! Loop forever while sending drive commands based on keyboard input
  bool driveKeyboard()
  {
    std::cout << "Type a command and then press enter.  "
      "Use '+' to move forward, 'l' to turn left, "
      "'r' to turn right, '.' to exit.\n";

    char cmd[50];
    ros::NodeHandle n;
    signal(SIGINT, mySigintHandler);

    chatter_pub = n.advertise<brics_actuator::JointVelocities>("/arm_controller/command_vel", 10);

    while(n.ok()){

      std::cin.getline(cmd, 50);
      if(cmd[0]!='+' && cmd[0]!='l' && cmd[0]!='r' && cmd[0]!='.')
      {
        std::cout << "unknown command:" << cmd << "\n";
        continue;
      }

      //base_cmd.linear.x = base_cmd.linear.y = base_cmd.angular.z = 0;
      msg.velocities.resize(6);
      msg.velocities[0].value = 0; // A1 ... (rad/s)
      msg.velocities[1].value = 0;
      msg.velocities[2].value = 0;
      msg.velocities[3].value = 0;
      msg.velocities[4].value = 0;
      msg.velocities[5].value = 0; // A6

      //move forward
      if(cmd[0]=='+'){
      msg.velocities[0].value= 0.1; //postitive X-Richtung
      }

      /**
       * so einstellen, dass man mit buchstaben die achse auswÃ¤hlt
       * und dann immer die pfeiltasten hat um entweder positiv
       * (up) oder negativ (down) zu fahren
       */

      //TATI move backwards
      if(cmd[0]=='-'){
      msg.velocities[3].value= -0.1; //negative X-Richtung
    }

      //turn left
      else if(cmd[0]=='l'){
          msg.velocities[4].value= 0.1; //negative Y-Richtung usw usf.!
      }
      //turn right
      else if(cmd[0]=='r'){
          msg.velocities[1].value= 0.1; //positive Y-Richutng
      }
      //quit
      else if(cmd[0]=='.'){
        break;
      }

      //publish the assembled command
      chatter_pub.publish(msg);
    }
    return true;
  }

};//talker

int main(int argc, char **argv)
{

  ros::init(argc, argv, "talker");

  /**
   * NodeHandle is the main access point to communications with the ROS system.
   * The first NodeHandle constructed will fully initialize this node, and the last
   * NodeHandle destructed will close down the node.
   */
  ros::NodeHandle n;

  std::stringstream ss;

  //  TATI aus der tastatur main()
  talker driver(n);
  driver.driveKeyboard();

  ros::Rate loop_rate(10);

  while (ros::ok())
  {

    ros::spinOnce();

    loop_rate.sleep();
    ++count;
  }

  return 0;
}

Originally posted by irgendeinGastname on ROS Answers with karma: 1 on 2014-09-03
Post score: 0

A:

You missed initializing your node with ros::init_options::NoSigintHandler, e. g.
  ros::init(argc, argv, "MyNode", ros::init_options::NoSigintHandler);

The answer in this thread contains a very good example for handling SIGINT in an ROS node:
http://answers.ros.org/question/27655/what-is-the-correct-way-to-do-stuff-before-a-node-is-shutdown/

Originally posted by Wolf with karma: 7555 on 2014-09-03
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by irgendeinGastname on 2014-09-03:
Thank you very much!


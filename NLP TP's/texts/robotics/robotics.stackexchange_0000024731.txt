Q:

Python's all tf frames function in ROS2 only returns some frames

Spining off of 347857#comment that seems ROS1 code, I tried to get all tf frames in Python but the following quick dirty code goes into "No frames" else block, while I verified that tf frames exists by using ROS2 Service in the answer I posted in the same link (See UPDATE section the concrete command FYI). What's missing/wrong?
#!/usr/bin/python3

import time
import yaml

import rclpy
import tf2_ros

class TfFramesFinder(rclpy.node.Node):
    def __init__(self):
        super().__init__("tf2_frames_finder")
        self.get_logger().info("In class")

        self._tf_buffer = tf2_ros.buffer.Buffer()
        self._tf_listener = tf2_ros.transform_listener.TransformListener(self._tf_buffer, self)
        time.sleep(20.0)
        _frames_dict = yaml.safe_load(self._tf_buffer.all_frames_as_yaml())
        if _frames_dict:
            _frames_list = list(_frames_dict)
            if _frames_list:
                self.get_logger().info(_frames_list)
        else:
            self.get_logger().warn("No frames collected")

rclpy.init()
node = TfFramesFinder()
try:
    rclpy.spin(node)
except KeyboardInterrupt as e:
    print("k/b interrupted")

rclpy.shutdown()

UPDATE I noticed I needed to have spin cycle completed at least once (answers.ros.org#386260). With that applied to my code, I do get only fraction of the existing frames, not the whole.
#!/usr/bin/python3

import time
import yaml

import rclpy
import tf2_ros

class TfFramesFinder(rclpy.node.Node):
    def __init__(self):
        super().__init__("tf2_frames_finder")
        self.get_logger().info("In class")

        self._tf_buffer = tf2_ros.buffer.Buffer()
        self._tf_listener = tf2_ros.transform_listener.TransformListener(self._tf_buffer, self)
        time.sleep(5.0)

    def get_all_frames(self):
        _frames_dict = yaml.safe_load(self._tf_buffer.all_frames_as_yaml())
        if _frames_dict:
            self.get_logger().info(yaml.dump(_frames_dict))
        else:
            self.get_logger().warn("No frames collected")

rclpy.init()
node = TfFramesFinder()
try:
    rclpy.spin_once(node)
    node.get_all_frames()
except KeyboardInterrupt as e:
    print("k/b interrupted")
rclpy.shutdown()

With this I got only turtle2 frame.
[INFO] [1683237201.154050606] [tf2_frames_finder]: turtle2:
  broadcaster: default_authority
  buffer_length: 0.0
  most_recent_transform: 1683237200.355238
  oldest_transform: 1683237200.355238
  parent: world
  rate: 10000.0

While there's also turtle1 frame.
# ros2 run tf2_tools view_frames
[INFO] [1683237263.811576147] [view_frames]: Listening to tf data for 5.0 seconds...
[INFO] [1683237268.821867546] [view_frames]: Generating graph in frames.pdf file...
[INFO] [1683237268.825114244] [view_frames]: Result:tf2_msgs.srv.FrameGraph_Response(frame_yaml="turtle1: \n  parent: 'world'\n  broadcaster: 'default_authority'\n  rate: 62.685\n  most_recent_transform: 1683237268.819402\n  oldest_transform: 1683237263.810233\n  buffer_length: 5.009\nturtle2: \n  parent: 'world'\n  broadcaster: 'default_authority'\n  rate: 62.686\n  most_recent_transform: 1683237268.819385\n  oldest_transform: 1683237263.810261\n  buffer_length: 5.009\n")

A:

The tf information is published from one of more nodes across the system. Because you are creating a fresh buffer with a new buffer you need to let it listen long enough that it will have heard from the lowest rate publisher with the highest latency on your system before you can expect to have a full spanning set of the tree. And you need to leave enough time for connections to all those potential publishers to be established. You might get lucky in a single spin but its usually a matter of several seconds for everything to be established.
If you need it want a faster query you can configure and query an already running buffer in another node with established connections and ask it for what it has already seen via the buffer server client interface.
You'll want to add a Buffer Server C++ only to an existing node. And then query it from the Buffer Client c++ or Python in another node.


Q:

Alternative to .launch files

I just read that ROS2 has an alternative to .launch files, where instead of .xml the logic is defined in a python script. What a great idea. I assume that this won't work with ROS1 per-se. But how would I implement the launching of a series of nodes, setting of parameters and so on and so forth, in python? Is there an api that I could use. Are there other ideas?
I am using melodic right but I could upgrade to neotic at any time.

Originally posted by pitosalas on ROS Answers with karma: 628 on 2020-12-28
Post score: 1

A:

But how would I implement the launching of a series of nodes, setting of parameters and so on and so forth, in python? Is there an api that I could use.

yes, there is the API that roslaunch itself uses, which is a Python API. See wiki/roslaunch/API Usage for some example scripts.
I would actually not recommend you use it though. It's a tad finicky, and leads to a lot of manual work which roslaunch takes care of for you.

I just read that ROS2 has an alternative to .launch files, where instead of .xml the logic is defined in a python script. [..] I assume that this won't work with ROS1 per-se

No, launch and launch_ros can't work with ROS 1, although launch is pretty much ROS-agnostic, so you could theoretically perhaps implement a ROS 1 wrapper similar to launch_ros but for ROS 1.
Whether that would make sense, I don't know.
There is however already someone who wrote a Python-based roslaunch wrapper: CodeFinder2/roslaunch2.
From its readme:

roslaunch2 is a (pure Python based) ROS package that facilitates writing versatile, flexible and dynamic launch configurations for the Robot Operating System (ROS 1) using Python, both for simulation and real hardware setups, as contrasted with the existing XML based launch file system of ROS, namely roslaunch. Note that roslaunch2 is not (yet) designed and developed for ROS 2 but for ROS 1 only although it may also inspire the development (of the launch system) of ROS 2. It is compatible with all ROS versions providing roslaunch which is used as its backend. roslaunch2 has been tested and heavily used on ROS Indigo, Jade, Kinetic, and Lunar; it also supports a “dry-mode” to generate launch files without ROS being installed at all. The key features of roslaunch2 are

versatile control structures (conditionals, loops),
extended support for launching and querying information remotely,
an easy-to-use API for also launching from Python based ROS nodes dynamically, as well as
basic load balancing capabilities for simulation setups.

If you really like using Python instead of roslaunch XML, perhaps you could take a look at that.

Originally posted by gvdhoorn with karma: 86574 on 2020-12-28
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by pitosalas on 2020-12-29:
Great, thanks. I am checking it out, it looks excellent! Thanks a lot for the pointer! (And yes, doesn't everyone prefer Python over those crazy xml files (and other rando proprietary formats?))
Comment by gvdhoorn on 2020-12-29:\

doesn't everyone prefer Python over those crazy xml files

no, certainly not.
Those "crazy xml files" form a declarative description of the deployment configuration of your application. Declarative languages are much easier to parse and verify than an arbitrary, turing-complete imperative language such as Python.
So for some (narrow) use-cases, an imperative language might be nice. But for system composition and eventual modelling, declarative languages are actually much better suited.

(and other rando proprietary formats?

You're probably aware, but XML is not a rando proprietary format[s].
Comment by pitosalas on 2020-12-29:
Hehe. yes I know, xml has existed for 100 years. I was referring to .msg, and friends. But even Cmakielist.txt and package.xml, while the overarching syntax (xml and make) are "standard", they both have complex semantics which in my opinion are part of the reason that the ROS learning curve is so so steep.
Comment by gvdhoorn on 2020-12-29:
I'm biased, but .msg is essentially just an IDL which is something many communication frameworks and middleware systems use/have, and CMakeLists.txt is something Kitware created to script their build system.
Would you rather have used Makefiles?

they both have complex semantics which in my opinion are part of the reason that the ROS learning curve is so so steep.

Creating software for a distributed system is simply complex, and there are many aspects to it which work best when using their own domain specific languages.
I don't believe we've really resolved any of that complexity in software engineering still. ROS is no exception. Even "user friendly" systems such as Mathworks Simulink and Labview quickly become very complex when dealing with real applications.
We may improve that situation in the future, but for now it is what it is.
Comment by pitosalas on 2020-12-29:
I agree that some complexity is unavoidable. But I also think that we need to pay attention to the learning curve. "Make the easy things easy and the hard things possible" is not a good slogan. I think in ROS there are many examples of unnecessary complexity or easy things which are unnecessarily hard. But anyway, this is getting way too philosophical and opinion-based for a comment thread. I truly appreciate all the help you've given me over the last few years and respect your far deeper knowledge of ROS than what I have.


Q:

Trying to use Timesynchronizer...getting compile error

Trying to use Timesynchronizer...getting compile error. Do not know what the error is telling me.  Changed pgm to use ConstPtrs still same error:
It seem based on this reference http://stackoverflow.com/questions/2304203/how-to-use-boost-bind-with-a-member-function  Timesycronizer and other boost type templates are not officially supported by ROS within a class member function. Is my understand correct? If this is true what other interface to these functions is supported? Can the tutorial be updated to show how to use these in member functions or state that they are not available.
find_package(catkin REQUIRED COMPONENTS
  roscpp
  tf2_ros
  std_msgs
  geometry_msgs
  sensor_msgs
  )

catkin_package(
  DEPENDS boost
  LIBRARIES
  CATKIN_DEPENDS
  tf2_ros
  std_msgs
  geometry_msgs
  sensor_msgs
  )

Here is my code:
#include <string>
#include <ros/ros.h>
#include <tf2_ros/transform_broadcaster.h>
#include <tf2_ros/static_transform_broadcaster.h>
#include <std_msgs/String.h>
#include <nav_msgs/Odometry.h>
#include <geometry_msgs/TransformStamped.h>
#include <geometry_msgs/Quaternion.h>
#include <control_msgs/JointControllerState.h>
#include <geometry_msgs/Pose.h>
#include <geometry_msgs/PoseWithCovarianceStamped.h>
#include <sensor_msgs/JointState.h>
#include <message_filters/subscriber.h>
#include <message_filters/time_synchronizer.h>

using namespace control_msgs;
using namespace message_filters;

class PublishOdometry
{
public:
  PublishOdometry()
  {

     count=0;
     motor_position_joint1_new =0;
     motor_position_joint1_old =0;
     motor_position_joint2_new =0;
     motor_position_joint2_old =0;
     x = 0;               
     y = 0;
     theta = 0;

     pubOdometry = n.advertise<nav_msgs::Odometry>("odom", 10);

     // Listen and wait for initial pose from nav
     subInitialPose = n.subscribe("/initialpose", 1, 
           &PublishOdometry::handelerInitialPose,this);
  }

void handelerOdometry(const JointControllerStateConstPtr& msg1, const JointControllerStateConstPtr& msg2)
{
     double wheel_track = 0.4;   //distance between two wheels

     motor_position_joint1_new = msg1->process_value;
     motor_position_joint2_new = msg2->process_value;

     ROS_INFO("J1PV=%f  J2PV=%f",motor_position_joint1_new, motor_position_joint2_new);

     if (timeold.toSec()==0)  // skip first set of joint cmd
     {
       timeold = msg1->header.stamp;
       motor_position_joint1_old = motor_position_joint1_new;
       motor_position_joint2_old = motor_position_joint2_new;
       return; 
     }

     float j1 = (motor_position_joint1_new - motor_position_joint1_old); 
     float j2 = (motor_position_joint2_new - motor_position_joint2_old);

     motor_position_joint1_old = motor_position_joint1_new;
     motor_position_joint2_old = motor_position_joint2_new;

     double  dt = (msg1->header.stamp - timeold).toSec();  // elapsed time in seconds
     float   distance =    ( ((j1 + j2)*dt) / 2.0);             // distance in meters
     float   dtheta   =    ( ((j1 - j2)*dt) / wheel_track);     // rotation
   
     double dx = (distance*sin(dtheta));
     double dy = (distance*cos(dtheta)); 

     theta =  (theta+dtheta); //fmodf((theta+dtheta),(2*M_PI));                   
     x = x + dx;
     y = y + dy;

     ROS_INFO("x=%e  y=%e theta=%f ddtheta=%f ",x,y,theta, dtheta);

     timeold = msg1->header.stamp;    // new old time

     geometry_msgs::Quaternion  quaternion;
     quaternion.x = 0.0;
     quaternion.y = 0.0; 
     quaternion.z = sin(theta/2);          // set yaw
     quaternion.w = cos(theta/2);

     geometry_msgs::TransformStamped odom_trans;
     odom_trans.header.frame_id = "odom";
     odom_trans.child_frame_id = "base_link";
     odom_trans.header.stamp =  timeold;
     odom_trans.transform.translation.x = x;
     odom_trans.transform.translation.y = y;
     odom_trans.transform.translation.z = 0.0; 
     odom_trans.transform.rotation = quaternion;

     odom_broadcaster.sendTransform(odom_trans);
 
     nav_msgs::Odometry odometry;
     odometry.header.frame_id = "odom";
     odometry.child_frame_id  = "base_link";
     odometry.header.stamp    = timeold;

     odometry.pose.pose.position.x  = distance;
     odometry.pose.pose.position.y  = y;
     odometry.pose.pose.position.z  = 0;
     odometry.pose.pose.orientation = quaternion;
     odometry.twist.twist.linear.x  = x;
     odometry.twist.twist.linear.y  = 0;
     odometry.twist.twist.angular.z = ((theta)*(M_PI/180));  // convert to radians

     pubOdometry.publish(odometry);

     calculateJointState(motor_position_joint1_old,"joint1");
     calculateJointState(motor_position_joint2_old,"joint2");
}

void calculateJointState(const float pv, const std::string name)
{
     sensor_msgs::JointState jointStateMsg;
     jointStateMsg.name.resize(1);
     jointStateMsg.position.resize(1);
     jointStateMsg.velocity.resize(1);
     jointStateMsg.header.frame_id = "base_link";
     jointStateMsg.header.stamp = timeold;
     jointStateMsg.name[0] = name;
     jointStateMsg.position[0] = pv;
     jointStateMsg.velocity[0] = 0.0;
     pubJointState.publish(jointStateMsg);
}

void handelerInitialPose(geometry_msgs::PoseWithCovarianceStampedConstPtr msg)
{
     geometry_msgs::TransformStamped odom_trans;
     odom_trans.header.frame_id = "odom";
     odom_trans.child_frame_id = "base_link";
     odom_trans.header.stamp =  msg->header.stamp;
     odom_trans.transform.translation.x = msg->pose.pose.position.x;
     odom_trans.transform.translation.y = msg->pose.pose.position.y;
     odom_trans.transform.translation.z = msg->pose.pose.position.z;
     odom_trans.transform.rotation = msg->pose.pose.orientation;

     odom_broadcaster.sendTransform(odom_trans);
 
     nav_msgs::Odometry odometry;
     odometry.header.frame_id = "odom";
     odometry.child_frame_id  = "base_link";
     odometry.header.stamp    = msg->header.stamp;
     odometry.pose.pose.position = msg->pose.pose.position;
     odometry.pose.pose.orientation = msg->pose.pose.orientation;

     pubOdometry.publish(odometry);

     // Listen for motor control response
     Subscriber<JointControllerState> j1_sub(n, "/rrbot/joint1_position_controller/state", 1);
     Subscriber<JointControllerState> j2_sub(n, "/rrbot/joint2_position_controller/state", 1);
     TimeSynchronizer<JointControllerState, JointControllerState> sync(j1_sub, j2_sub, 10);
     sync.registerCallback(boost::bind(&PublishOdometry::handelerOdometry, _1, _2));

     ROS_INFO("handelerInitialPose finished processing");
}

private:

   double x,y,count;
   float motor_position_joint1_new;
   float motor_position_joint1_old;
   float motor_position_joint2_new;
   float motor_position_joint2_old;
   float theta;
   ros::Time timeold;
   ros::NodeHandle n;
   ros::Publisher pubOdometry;
   tf2_ros::TransformBroadcaster odom_broadcaster;
   ros::Publisher  pubJointState;
   ros::Subscriber subInitialPose;
   ros::Subscriber j1_sub;
   ros::Subscriber j2_sub;

};  // Enodof Class

int main(int argc, char **argv)
{ 
  ros::init(argc, argv, "robot_odometry");

  PublishOdometry sp;

  // send static latch transformations 

  tf2_ros::StaticTransformBroadcaster static_broadcaster;
  geometry_msgs::TransformStamped msg;

  msg.header.stamp = ros::Time::now();
  msg.transform.rotation.x =  0.0;
  msg.transform.rotation.y =  0.0;
  msg.transform.rotation.z =  0.0;
  msg.transform.rotation.w =  1.0;

  msg.header.frame_id = "camera_link";   
  msg.transform.translation.x = 0;
  msg.transform.translation.y = 0;
  msg.transform.translation.z = 0.2;
  msg.child_frame_id = "hokuyo_frame";
  static_broadcaster.sendTransform(msg);

  msg.header.frame_id = "camera_link";   
  msg.transform.translation.x = 0;
  msg.transform.translation.y = 0;
  msg.transform.translation.z = 0.3;
  msg.child_frame_id = "camera_frame";
  static_broadcaster.sendTransform(msg);

  ros::spin();

  return 0;
}
   

ERROR FOLLOWS:::::
   uilding CXX object gazebo_ros_demos/rrbot_control/CMakeFiles/robot_odometry.dir/src/robot_odometry.cpp.o
[100%] [100%] Built target robot_twist_to_vel
Built target robot_jntcmd_to_jntst
In file included from /usr/include/boost/bind.hpp:22:0,
                 from /opt/ros/hydro/include/ros/publisher.h:35,
                 from /opt/ros/hydro/include/ros/node_handle.h:32,
                 from /opt/ros/hydro/include/ros/ros.h:45,
                 from /home/viki/catkin_ws/src/gazebo_ros_demos/rrbot_control/src/robot_odometry.cpp:2:
/usr/include/boost/bind/bind.hpp: In instantiation of ‘struct boost::_bi::result_traits<boost::_bi::unspecified, void (PublishOdometry::*)(const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&, const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&)>’:
/usr/include/boost/bind/bind_template.hpp:15:48:   required from ‘class boost::_bi::bind_t<boost::_bi::unspecified, void (PublishOdometry::*)(const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&, const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&), boost::_bi::list2<boost::arg<1>, boost::arg<2> > >’
/home/viki/catkin_ws/src/gazebo_ros_demos/rrbot_control/src/robot_odometry.cpp:162:82:   required from here
/usr/include/boost/bind/bind.hpp:69:37: error: ‘void (PublishOdometry::*)(const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&, const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&)’ is not a class, struct, or union type
In file included from /usr/include/boost/function/detail/maybe_include.hpp:58:0,
                 from /usr/include/boost/function/detail/function_iterate.hpp:14,
                 from /usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp:92,
                 from /usr/include/boost/function.hpp:64,
                 from /opt/ros/hydro/include/ros/forwards.h:39,
                 from /opt/ros/hydro/include/ros/common.h:37,
                 from /opt/ros/hydro/include/ros/ros.h:43,
                 from /home/viki/catkin_ws/src/gazebo_ros_demos/rrbot_control/src/robot_odometry.cpp:2:
/usr/include/boost/function/function_template.hpp: In instantiation of ‘static void boost::detail::function::void_function_obj_invoker9<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7, T8>::invoke(boost::detail::function::function_buffer&, T0, T1, T2, T3, T4, T5, T6, T7, T8) [with FunctionObj = boost::_bi::bind_t<boost::_bi::unspecified, boost::_bi::bind_t<boost::_bi::unspecified, void (PublishOdometry::*)(const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&, const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&), boost::_bi::list2<boost::arg<1>, boost::arg<2> > >, boost::_bi::list9<boost::arg<1>, boost::arg<2>, boost::arg<3>, boost::arg<4>, boost::arg<5>, boost::arg<6>, boost::arg<7>, boost::arg<8>, boost::arg<9> > >; R = void; T0 = const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&; T1 = const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&; T2 = const boost::shared_ptr<const message_filters::NullType>&; T3 = const boost::shared_ptr<const message_filters::NullType>&; T4 = const boost::shared_ptr<const message_filters::NullType>&; T5 = const boost::shared_ptr<const message_filters::NullType>&; T6 = const boost::shared_ptr<const message_filters::NullType>&; T7 = const boost::shared_ptr<const message_filters::NullType>&; T8 = const boost::shared_ptr<const message_filters::NullType>&]’:
/usr/include/boost/function/function_template.hpp:907:60:   required from ‘void boost::function9<R, T1, T2, T3, T4, T5, T6, T7, T8, T9>::assign_to(Functor) [with Functor = boost::_bi::bind_t<boost::_bi::unspecified, boost::_bi::bind_t<boost::_bi::unspecified, void (PublishOdometry::*)(const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&, const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&), boost::_bi::list2<boost::arg<1>, boost::arg<2> > >, boost::_bi::list9<boost::arg<1>, boost::arg<2>, boost::arg<3>, boost::arg<4>, boost::arg<5>, boost::arg<6>, boost::arg<7>, boost::arg<8>, boost::arg<9> > >; R = void; T0 = const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&; T1 = const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&; T2 = const boost::shared_ptr<const message_filters::NullType>&; T3 = const boost::shared_ptr<const message_filters::NullType>&; T4 = const boost::shared_ptr<const message_filters::NullType>&; T5 = const boost::shared_ptr<const message_filters::NullType>&; T6 = const boost::shared_ptr<const message_filters::NullType>&; T7 = const boost::shared_ptr<const message_filters::NullType>&; T8 = const boost::shared_ptr<const message_filters::NullType>&]’
/usr/include/boost/function/function_template.hpp:722:7:   required from ‘boost::function9<R, T1, T2, T3, T4, T5, T6, T7, T8, T9>::function9(Functor, typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type) [with Functor = boost::_bi::bind_t<boost::_bi::unspecified, boost::_bi::bind_t<boost::_bi::unspecified, void (PublishOdometry::*)(const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&, const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&), boost::_bi::list2<boost::arg<1>, boost::arg<2> > >, boost::_bi::list9<boost::arg<1>, boost::arg<2>, boost::arg<3>, boost::arg<4>, boost::arg<5>, boost::arg<6>, boost::arg<7>, boost::arg<8>, boost::arg<9> > >; R = void; T0 = const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&; T1 = const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&; T2 = const boost::shared_ptr<const message_filters::NullType>&; T3 = const boost::shared_ptr<const message_filters::NullType>&; T4 = const boost::shared_ptr<const message_filters::NullType>&; T5 = const boost::shared_ptr<const message_filters::NullType>&; T6 = const boost::shared_ptr<const message_filters::NullType>&; T7 = const boost::shared_ptr<const message_filters::NullType>&; T8 = const boost::shared_ptr<const message_filters::NullType>&; typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type = int]’
/usr/include/boost/function/function_template.hpp:1042:16:   required from ‘boost::function<R(T0, T1, T2, T3, T4, T5, T6, T7, T8)>::function(Functor, typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type) [with Functor = boost::_bi::bind_t<boost::_bi::unspecified, boost::_bi::bind_t<boost::_bi::unspecified, void (PublishOdometry::*)(const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&, const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&), boost::_bi::list2<boost::arg<1>, boost::arg<2> > >, boost::_bi::list9<boost::arg<1>, boost::arg<2>, boost::arg<3>, boost::arg<4>, boost::arg<5>, boost::arg<6>, boost::arg<7>, boost::arg<8>, boost::arg<9> > >; R = void; T0 = const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&; T1 = const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&; T2 = const boost::shared_ptr<const message_filters::NullType>&; T3 = const boost::shared_ptr<const message_filters::NullType>&; T4 = const boost::shared_ptr<const message_filters::NullType>&; T5 = const boost::shared_ptr<const message_filters::NullType>&; T6 = const boost::shared_ptr<const message_filters::NullType>&; T7 = const boost::shared_ptr<const message_filters::NullType>&; T8 = const boost::shared_ptr<const message_filters::NullType>&; typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type = int]’
/opt/ros/hydro/include/message_filters/signal9.h:281:98:   required from ‘message_filters::Connection message_filters::Signal9<M0, M1, M2, M3, M4, M5, M6, M7, M8>::addCallback(C&) [with C = const boost::_bi::bind_t<boost::_bi::unspecified, void (PublishOdometry::*)(const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&, const boost::shared_ptr<const control_msgs::JointControllerState_<std::allocator<void> > >&), boost::_bi::list2<boost::arg<1>, boost::arg<2> > >; M0 = control_msgs::JointControllerState_<std::allocator<void> >; M1 = control_msgs::JointControllerState_<std::allocator<void> >; M2 = message_filters::NullType; M3 = message_filters

Originally posted by rnunziata on ROS Answers with karma: 713 on 2013-09-25
Post score: 2

Original comments
Comment by georgebrindeiro on 2013-09-26:
I think your problem might be related to how boost::bind works with member functions:
http://stackoverflow.com/questions/2304203/how-to-use-boost-bind-with-a-member-function
Comment by rnunziata on 2013-09-26:
It seem based on this reference  Timesycronizer and other boost type templates are not officially supported by ROS within a class member function. Is my understand correct?  If this is true what other interface to these functions is supported.
Comment by rnunziata on 2013-09-26:
Yes...I tried adding it to several places....a working example would be great
Comment by Boris on 2013-09-26:
@georgebrindeiro is right. this is missing in the bind(). Every method of a class actually has extra argument which is the pointer to the instance of that class. When the method is called within another method of a class, this is passed implicitly. ROS require callback functions to have certain number of arguments, but it has no idea about the host class. So, when the callback is called the only parameters to be passed there are the messages and this is not provided. However your function can not work without this, because it will have no access to any of the class members. So boost::bind simply allows you to pass it as additional argument. Since you didn't do it the compiler complained.
Comment by Boris on 2013-09-26:
Replacing the line for sync.registerCallback() with the sync.registerCallback(boost::bind(&PublishOdometry::handelerOdometry, this, _1, _2)); should be sufficient.
Comment by rnunziata on 2013-09-27:
This solution worked and the code now compiles...thank you. How can this solution get into the tutorial so others like myself who are not steeped in c++ will not repeat this. Also can you make this an Answer.

A:

Have you tried adding this to the boost::bind function call? That's what they usually require for binding member functions. That might be the only thing missing.
Citing Boris' comment, this is how you would do it:
sync.registerCallback(boost::bind(&PublishOdometry::handelerOdometry, this, _1, _2));

Originally posted by georgebrindeiro with karma: 1264 on 2013-09-26
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by soroosh129 on 2019-07-05:
Wow thank you! Saved my day!


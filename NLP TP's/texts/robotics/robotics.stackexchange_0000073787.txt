Q:

rosbridge_suite: InvalidPackageException: Unable to load the manifest for package rosgraph_msgs

Hi,
I'm using the rosbridge internal library to get load the message class for a given message type:
from rosbridge_library import ros_loader
...
self.msg_class = ros_loader.get_message_class(self.msg_type)

where self.msg_type is, for example, "rosgraph_msgs/Log".
This is generating the following error:
  File "/opt/ros/indigo/lib/python2.7/dist-packages/rosbridge_library/internal/ros_loader.py", line 88, in get_message_class
    return _get_msg_class(typestring)
  File "/opt/ros/indigo/lib/python2.7/dist-packages/rosbridge_library/internal/ros_loader.py", line 128, in _get_msg_class
    return _get_class(typestring, "msg", _loaded_msgs, _msgs_lock)
  File "/opt/ros/indigo/lib/python2.7/dist-packages/rosbridge_library/internal/ros_loader.py", line 163, in _get_class
    cls = _load_class(modname, subname, classname)
  File "/opt/ros/indigo/lib/python2.7/dist-packages/rosbridge_library/internal/ros_loader.py", line 187, in _load_class
    raise InvalidPackageException(modname, exc)
InvalidPackageException: Unable to load the manifest for package rosgraph_msgs. Caused by: 'NoneType' object has no attribute 'strip'
<Greenlet at 0x7f1c3cc52230: <bound method RosGraphApi.launch_graph of <luxagent.ros_communication.ros_graph_api.RosGraphApi object at 0x7f1c3cc26090>>> failed with InvalidPackageException

This error is occurring on all message types, not just rosgraph_msgs/Log.
Any suggestions would be appreciated.
Thanks!
Simon

Originally posted by SimonB on ROS Answers with karma: 88 on 2016-05-06
Post score: 0

Original comments
Comment by SimonB on 2016-05-06:
I'm running on Indigo.

A:

This turned out not to be a problem with rosbridge_library at all, but a collateral effect of using gevent in my application. It's highly unlikely that anyone else will come across this, but just in case:
I had to bury down into the depths of roslib to find out where the root exception was occurring. It was in rospkg/os_detect.py:
def _read_stdout(cmd):
    try:
        pop = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (std_out, std_err) = pop.communicate()
        # Python 2.6 compatibility
        if isinstance(std_out, str):
            return std_out.strip()
        return std_out.decode(encoding='UTF-8').strip()
    except:
        return None

The line pop.communicate() was giving an error 'module' object has no attribute 'poll'.
This led me here: https://groups.google.com/forum/embed/#!topic/gevent/IzWhGQHq7n0
gevent is a coroutine based sort-of-multitasking library. It monkey patches various system libraries (I should have known better!) and removes the poll() functionality from subprocesses.
The solution is to import gevent like so:
from gevent import monkey; monkey.patch_all(aggressive=False)

instead of:
from gevent import monkey; monkey.patch_all()

My apologies to Jihooni for taking up his time! Thanks again.

Originally posted by SimonB with karma: 88 on 2016-05-10
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by gvdhoorn on 2016-05-10:
+1 for reporting back on the real cause (and a possible work-around).


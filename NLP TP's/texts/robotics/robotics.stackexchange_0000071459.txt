Q:

Clearing of obstacle layer in the layered_costmap

Hi all,
I have a layered_costmap with static_layer, obstacle_layer (for Lidar and Kinect) and inflation_layer and there are situations when I need to clear out the obstacle_layers manually in the code. I am working on full coverage and I want to clear out the obstacle layer when the robot reaches the goal and starts going to the next goal so that it can cover more area. What is the best way to clear out the entire obstacle layer and remove all obstacles (which are not in the static_map) manually in the code (maybe in move_base.cpp) ? I don't want to make any changes to the static_layer, just want to clear the obstacle_layer.
Update 1 :
I tried using /move_base/clearCostmapsService for which I added a piece of code in move_base.cpp itself (for now) so that I can test it by giving goals from RVIZ.  I added the code in the executeCb function of move_base.cpp which gets called when a goal is received. Here is the code snippet :
void MoveBase::executeCb(const move_base_msgs::MoveBaseGoalConstPtr& move_base_goal)
      {
        if(!isQuaternionValid(move_base_goal->target_pose.pose.orientation)){
          as_->setAborted(move_base_msgs::MoveBaseResult(), "Aborting on goal because it was sent with an invalid quaternion");
          return;
        }

       ///// Added on 01/13/2016
       boost::unique_lock<boost::mutex> lock1(planner_mutex_);
       runPlanner_ = false;

      std_srvs::Empty srv;
      if(clear_costmaps_client.call(srv))
           ROS_INFO("I got the goal and the costmap layers are reset!!!!!");  // It prints this and continues but the costmap is not reset properly, it takes some time after this for the costmap to properly reset

      lock1.unlock();
      /////

        geometry_msgs::PoseStamped goal = goalToGlobalFrame(move_base_goal->target_pose);

        //we have a goal so start the planner
        boost::unique_lock<boost::mutex> lock(planner_mutex_);
        planner_goal_ = goal;
        runPlanner_ = true;
        planner_cond_.notify_one();
        lock.unlock();

    current_goal_pub_.publish(goal);
    std::vector<geometry_msgs::PoseStamped> global_plan;

Using the clearCostmapsService, the map is successfully cleared but the problem is that path planning is done before the map can filled with the static_layer (at this time, the map is basically empty and contains no obstacles) so the path is planned through the obstacles in the static_layer which I don't want. I want the costmap should be cleared and then filled again with static_layer and sensor_data and then path planning should be done. Does anyone have any idea what can be the issue in calling clearCostmapService shown in the code snippet above?
Thanks in advance.
Naman

Originally posted by Naman on ROS Answers with karma: 1464 on 2016-01-19
Post score: 2

Original comments
Comment by SH_Developer on 2017-02-24:
Did you find a solution?

A:

What about using the move_base/clear_costmaps service of move_base?
You could have a service client in your code and wouldn't need to touch move_base itself.
It clears the full obstacle_layer, which then gets filled again by the static_layer as well as any new sensor data.

Originally posted by mgruhler with karma: 12390 on 2016-01-20
This answer was ACCEPTED on the original site
Post score: 6

Original comments
Comment by Naman on 2016-01-20:
Thanks @mig! I tried what you said and have updated the original question. Please have a look.. TIA!
Comment by jorge on 2016-01-21:
I think the problem is that you must call the clear_costmaps from another node, for example from the node you send the move_base goal. Like this, move_base will have time to iterate before replanning and so add back static map obstacles into the global costmap.
Comment by mgruhler on 2016-01-22:
@jorge, this might actually be the problem. Good idea. I don't know how move_base actually behaves if it is called internally...
Comment by Stephen_Z on 2017-02-22:
I am also writing a full coverage planner. The move_base clear_costmaps service works well from the terminal. However, the method shown above halts my global plugin code at "clear_costmaps_client.call(srv)" . it doesn't crash, just doesn't continue. Any ideas? i have Ubuntu 16.04 and Kinetic. Thanks
Comment by mgruhler on 2017-02-23:
@Stephen_Z please post a new question with some more details: Ideally, the source code, otherwise some more relevant input, a more descriptive error description, ...


Q:

How to emulate a MoveJ, or MoveL movement using ROS?

Hi all,
I am currently using a UR5 in simulation and would like to know if there is a way to emulate the way that the UR5 moves from one joint target to another joint target. The movement/trajectory I want to emulate is the same as the one that is  provided by a MoveJ command. Basically, I believe it is simply a linear interpolation from one joint target to another for each joint with parabolic blends at the beginning and at the end of the motion (for smooth acceleration/deceleration). I don't need collision detection.
I could use roscontrol and simply send the joint target, but I believe it isn't going to result in the same motion/trajectory as a MoveJ command would. I believe its only some type of PID controller that increases the output based on the distance to target, which is not what I want.
It tried using the planner from MoveIt, but it results in a crazy trajectory that's generated between the initial robot configuration to the end configuration, sometimes spinning three times around its base. I also find MoveIt extremely tedious to use and not intuitive, but that might just be because I haven't use it enough yet. So far I am not a fan of it.
Does somebody know a simple way to achieve what I am trying to do? Are there any existing packages that I could leverage to do this task?
Thanks!

Originally posted by Pinknoise2077 on ROS Answers with karma: 69 on 2020-05-08
Post score: 0

Original comments
Comment by gvdhoorn on 2020-05-08:
Observation: "the ROS stack" is a bit meaningless. You mention a few packages, but they are not really part of any particular stack.
Comment by Pinknoise2077 on 2020-05-08:
Removed the term stack. I don't mind changing the title of the question if you have a recommendation.

A:

I could use roscontrol and simply send the joint target, but I believe it isn't going to result in the same motion/trajectory as a MoveJ command would. I believe its only some type of PID controller that increases the output based on the distance to target, which is not what I want.

ros_control contains many controllers, you seem to describe (one variant of) the position_controllers?
For trajectory based control, even if the trajectory contains only two points (ie: departure and destination), you could use the joint_trajectory_controller.

It tried using the planner from MoveIt, but it results in a crazy trajectory

that's typically caused by misconfiguration (ie: too few constraints). Without proper constraints, any trajectory is a valid one, as long as it doesn't collide with anything, so there is no difference between "spinning three times around its base" and "a simple linear interpolation".

The movement/trajectory I want to emulate is the same as the one that is provided by a MoveJ command

Well it 's going to be using MoveIt again, but if you can stomach that you could perhaps take a look at wiki/pilz_industrial_motion.

If you'd be using real hardware (or ursim), I'd almost suggest you could just as well write a simple Python script sending URScript statements to tcp://:30002. Could you perhaps give some more information on what sort of functionality you are looking to achieve which made you start / work with ROS?
Also, with real hardware, and when using ur_robot_driver, you'd need to use the ScaledJointTrajectoryController or you'd lose many of the advantages which ur_robot_driver offers.
If all of this is still too tedious, I would probably recommend using something like SintefManufacturing/python-urx or a similar library, but that does not come with any ROS integration (or at least: I don't know of any).

Originally posted by gvdhoorn with karma: 86574 on 2020-05-08
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Pinknoise2077 on 2020-05-08:
Thanks for the answer. The project I am currently working on does the following: generate 6D pose, calculate IK, repeat. Then, I want to see if I can move from one joint target to another without collision using a simple MoveJ.
I believe the best solution is the one you've proposed, which is to use ursim. https://www.universal-robots.com/download/ I was wondering if there were any easier way, but it seems that this is the easiest approach AFAIK.
Comment by gvdhoorn on 2020-05-08:
ursim would not tell you whether you are in collision. It does not do anything but simulate the robot itself (or actually: the controller).
I'm not sure it would be the easiest / best approach.
Unless you're only really interested in self-collisions of course.

Edit: using MoveIt may actually be the faster approach here. A combination of something like RobotState::setFromIK(..) and linear interpolating (perhaps even using computeCartesianPath(..)) and then checking for self-collision using the PlanningScene could work.
There's no need to actually execute any of the motions you describe IIUC. So using ursim sounds like it would waste a lot of time.
Comment by Pinknoise2077 on 2020-05-11:
I've looked deeper into the ursim software, and if I could add tools and objects within the virtual scene, than it would have been exactly what I am looking for. I am simply interested in knowing how the robot moves from one joint configuration to another, using a moveJ command, and visually assess if its going to self-collide (with its tool added to the end-effector) or collide with objects within the workspace of the robot. Then, I need to execute this on the real UR robot using a MoveJ command.

and linear interpolating (perhaps even using computeCartesianPath(..)

I don't think this would work because the linear interpolation has to be in joint space IIUC.
Comment by Pinknoise2077 on 2020-05-11:
By going through all your recommendations again, I think that using the joint_trajectory_controller is what I am looking for. I need to understand how to use it now. Would you have any links to share that I can look at that explains how to use it (e.g. tutorials, examples, etc)?
edit:
So far I've found those resources to be very useful, presented in order of usefulness:
I'll add more if I find more useful info.
The construct tutorial
Tiago robot tutorial
PR2 tutorial
Comment by fvd on 2020-05-13:
You should open a new question for this, but I think the MoveIt tutorials and the concepts page will help.
I'll repeat the recommendation for https://github.com/PilzDE/pilz_industrial_motion , which generates trajectories like MoveL and MoveJ would.
Comment by Pinknoise2077 on 2020-05-14:
I've finished implementing the solution using joint_trajectory_controller. It was a little bit easier than I thought. Thanks for the recommendation.


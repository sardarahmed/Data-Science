Q:

Compile Error for the ros.pde sketch

I am trying to put the ros.pde sketch onto the ArbotiX board that I am using for the turtlebot arm, and I get the following compile errors when I try to upload or verify the sketch:
ros.cpp:46:47: error: no matching function for call to ‘BioloidController::BioloidController()’
/home/marc/sketchbook/libraries/Bioloid/BioloidController.h:48:5: note: candidates are: BioloidController::BioloidController(long int)
/home/marc/sketchbook/libraries/Bioloid/BioloidController.h:45:1: note:                 BioloidController::BioloidController(const BioloidController&)
ros.cpp: In function ‘void loop()’:
ros.cpp:352:32: error: ‘class BioloidController’ has no member named ‘setup’
ros.cpp:386:40: error: ‘class BioloidController’ has no member named ‘setup’
ros.cpp:388:42: error: ‘class BioloidController’ has no member named ‘setId’
ros.cpp:404:77: error: ‘class BioloidController’ has no member named ‘getId’

I have the updated version of the BioloidController library and the newest version of the ros.pde sketch, although I will copy them here for completeness's sake:
ros.pde:
    /* 
  ArbotiX Firmware for ROS driver
  Copyright (c) 2008-2011 Vanadium Labs LLC.  All right reserved.
 
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
      * Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
      * Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
      * Neither the name of Vanadium Labs LLC nor the names of its 
        contributors may be used to endorse or promote products derived 
        from this software without specific prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL VANADIUM LABS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/ 

/* Build Configuration */
#define USE_BASE            // Enable support for a mobile base
#define USE_BIG_MOTORS      // Enable Pololu 30A support
#define USE_HW_SERVOS       // Enable only 2/8 servos, but using hardware control

#define CONTROLLER_COUNT    5
/* Hardware Constructs */
#include <ax12.h>
#include <BioloidController.h>
BioloidController controllers[CONTROLLER_COUNT];

#include "ros.h"

#ifdef USE_HW_SERVOS
  #include <HServo.h>
  HServo servos[2];
  int servo_vals[2];            // in millis
#else 
  #include <Servo.h>
  Servo servos[10];
  int servo_vals[10];           // in millis
#endif

#ifdef USE_BASE
  #ifdef USE_BIG_MOTORS
    #include <BigMotors.h>
    BigMotors drive = BigMotors();
  #else
    #include <Motors2.h>
    Motors2 drive = Motors2();
  #endif
  #include <EncodersAB.h>
  #include "diff_controller.h"
#endif

/* Register Storage */
unsigned char baud = 7;         // ?
unsigned char ret_level = 1;    // ?
unsigned char alarm_led = 0;    // ?

/* Pose & Sequence Structures */
typedef struct{
  unsigned char pose;           // index of pose to transition to 
  int time;                     // time for transition
} sp_trans_t;
int poses[30][AX12_MAX_SERVOS]; // poses [index][servo_id-1]
sp_trans_t sequence[50];        // sequence
int seqPos;                     // step in current sequence

/* 
 * Setup Functions
 */
#if defined(AX_RX_SWITCHED)
void scan(){
  // do a search for devices on the RX bus, default to AX if not found
  int i;
  for(i=0;i<AX12_MAX_SERVOS;i++){
    dynamixel_bus_config[i] = 1;
    if(ax12GetRegister(i+1, AX_ID, 1) != (i+1)){
      dynamixel_bus_config[i] = 0;
    }
  }
}
#endif
void setup(){
  Serial.begin(115200);
  ax12Init(1000000);

#ifdef USE_BASE  
  Encoders.Begin();
  setupPID();
#endif

// note: ARBOTIX_PLUS and SERVO_STIK are defined in our Bioloid library.
#if defined(AX_RX_SWITCHED)
  delay(1000);
  scan();
#endif

  pinMode(0,OUTPUT);     // status LED
}

/*
 * Handle Write Requests to ArbotiX Registers 
 */
unsigned char handleWrite(){
  int addr  = params[0];  // address to write
  int bytes = length-3;   // # of bytes left to write
  int k = 1;              // index in parameters of value to write
  while(bytes > 0){
    if(addr < REG_BAUD_RATE){
      return INSTRUCTION_ERROR;
    }else if(addr == REG_BAUD_RATE){
      UBRR1L = params[k];      
    }else if(addr < REG_RESCAN){
      // write digital 
      int pin = addr - REG_DIGITAL;
    #ifdef SERVO_STIK
      pin = 31-pin;
    #endif
      if(params[k] & 0x02)    // high
        digitalWrite(pin, HIGH);
      else
        digitalWrite(pin, LOW);
      if(params[k] & 0x01)    // output
        pinMode(pin, OUTPUT);
      else
        pinMode(pin, INPUT);
    }else if(addr == REG_RESCAN){
#if defined(AX_RX_SWITCHED)
      scan();
#endif
    }else if(addr == REG_RETURN_LEVEL){
      ret_level = params[k];
    }else if(addr == REG_ALARM_LED){
      // TODO: 
    }else if(addr < REG_SERVO_BASE){
      return INSTRUCTION_ERROR; // error - analog are read only
    }else if(addr < REG_MOVING){
      // write servo
      int s = addr - REG_SERVO_BASE;
 #ifdef USE_HW_SERVO
      if( s >= 4 ){
 #else
      if( s >= 20){
 #endif 
        return INSTRUCTION_ERROR;
      }else{
        if( s%2 == 0 ){ // low byte
          s = s/2;
          servo_vals[s] = params[k];
        }else{          // high byte
          s = s/2;
          servo_vals[s] += (params[k]<<8);
          if(servo_vals[s] > 500 && servo_vals[s] < 2500){
            servos[s].writeMicroseconds(servo_vals[s]);
            if(!servos[s].attached())            
              servos[s].attach(s);
          }else if(servo_vals[s] == 0){
            servos[s].detach();
          }
        }
      }
    }else{
      // write higher ID digitals
      int pin = addr - REG_DIGITAL2;
      if(pin < 8){
        pin = 31 - pin;
        if(params[k] & 0x02)    // high
          digitalWrite(pin, HIGH);
        else
          digitalWrite(pin, LOW);
        if(params[k] & 0x01)    // output
          pinMode(pin, OUTPUT);
        else
          pinMode(pin, INPUT);
      }else{
        return INSTRUCTION_ERROR;
      }
    }
    addr++;k++;bytes--;
  }
  return 0;
}

int handleRead(){
  int checksum = 0;
  int addr = params[0];
  int bytes = params[1];
  unsigned char v;
  while(bytes > 0){
    if(addr == REG_MODEL_NUMBER_L){ 
      v = 44;
    }else if(addr == REG_MODEL_NUMBER_H){
      v = 1;  // 300 
    }else if(addr == REG_VERSION){
      v = 0;
    }else if(addr == REG_ID){
      v = 253;
    }else if(addr == REG_BAUD_RATE){
      v = 34; // 56700
    }else if(addr < REG_RETURN_LEVEL){
      // send digital read
      if(addr == REG_DIGITAL){
        // 0->7
    #ifdef SERVO_STIK
        v = PINA;
    #else
        v = PINB;
    #endif
      }else if(addr == REG_DIGITAL+1){
        // 8-15
    #ifdef SERVO_STIK
        v = (PINB>>1);
    #else
        v = PINA;  // was previously PIND
    #endif        
      }else{
        // 16-23
        v = PIND;
      }
    }else if(addr == REG_RETURN_LEVEL){
      v = ret_level;
    }else if(addr == REG_ALARM_LED){
      // TODO
    }else if(addr < REG_SERVO_BASE){
      // send analog reading
      v = analogRead(addr-REG_ANA_BASE)>>2;
    }else if(addr < REG_MOVING){
      // send servo position
      v = 0;      
    }else{
      v = 0;        
    }
    checksum += v;
    Serial.print(v, BYTE);
    addr++;bytes--;
  }
  return checksum;
}

int doPlaySeq(){
  seqPos = 0; int i;
  while(sequence[seqPos].pose != 0xff){
    int p = sequence[seqPos].pose;
    // are we HALT?
    if(Serial.read() == 'H') return 1;
    // load pose
    for(i=0; i<controllers[0].poseSize; i++)
      controllers[0].setNextPose(i+1,poses[p][i]); 
    controllers[0].interpolateSetup(sequence[seqPos].time);
    while(controllers[0].interpolating)
      controllers[0].interpolateStep();
    // next transition
    seqPos++;
  }
  return 0;
}

/*
 * Send status packet
 */
void statusPacket(int id, int err){
  Serial.print(0xff,BYTE);
  Serial.print(0xff,BYTE);
  Serial.print(id,BYTE);
  Serial.print(2,BYTE);
  Serial.print(err,BYTE);
  Serial.print(255-((id+2+err)%256),BYTE);
}

/* 
 * decode packets: ff ff id length ins params checksum
 *   same as ax-12 table, except, we define new instructions for Arbotix 
 */
void loop(){
  int i;
    
  // process messages
  while(Serial.available() > 0){
    // We need to 0xFF at start of packet
    if(mode == 0){         // start of new packet
      if(Serial.read() == 0xff){
        mode = 2;
        digitalWrite(0,HIGH-digitalRead(0));
      }
    //}else if(mode == 1){   // another start byte
    //    if(Serial.read() == 0xff)
    //        mode = 2;
    //    else
    //        mode = 0;
    }else if(mode == 2){   // next byte is index of servo
      id = Serial.read();    
      if(id != 0xff)
        mode = 3;
    }else if(mode == 3){   // next byte is length
      length = Serial.read();
      checksum = id + length;
      mode = 4;
    }else if(mode == 4){   // next byte is instruction
      ins = Serial.read();
      checksum += ins;
      index = 0;
      mode = 5;
    }else if(mode == 5){   // read data in 
      params[index] = Serial.read();
      checksum += (int) params[index];
      index++;
      if(index + 1 == length){  // we've read params & checksum
        mode = 0;
        if((checksum%256) != 255){ 
          // return an error packet: FF FF id Len Err=bad checksum, params=None check
          statusPacket(id,CHECKSUM_ERROR);
        }else if(id == 253){  // ID = 253, ArbotiX instruction
          switch(ins){     
            case AX_WRITE_DATA:
              // send return packet
              statusPacket(id,handleWrite());
              break;
             
            case AX_READ_DATA:
              checksum = id + params[1] + 2;                            
              Serial.print(0xff,BYTE);
              Serial.print(0xff,BYTE);
              Serial.print(id,BYTE);
              Serial.print(2+params[1],BYTE);
              Serial.print(0,BYTE);
              // send actual data
              checksum += handleRead();
              Serial.print(255-((checksum)%256),BYTE);
              break;
             
            case ARB_SIZE_POSE:                   // Pose Size = 7, followed by single param: size of pose
              statusPacket(id,0);
              if(controllers[0].poseSize == 0)
                controllers[0].setup(18);
              controllers[0].poseSize = params[0];
              controllers[0].readPose();    
              break;
             
            case ARB_LOAD_POSE:                   // Load Pose = 8, followed by index, then pose positions (# of param = 2*pose_size)
              statusPacket(id,0);
              for(i=0; i<controllers[0].poseSize; i++)
                poses[params[0]][i] = params[(2*i)+1]+(params[(2*i)+2]<<8); 
              break;
             
            case ARB_LOAD_SEQ:                    // Load Seq = 9, followed by index/times (# of parameters = 3*seq_size) 
              statusPacket(id,0);
              for(i=0;i<(length-2)/3;i++){
                sequence[i].pose = params[(i*3)];
                sequence[i].time = params[(i*3)+1] + (params[(i*3)+2]<<8);
              }
              break;
             
            case ARB_PLAY_SEQ:                   // Play Seq = A, no params   
              statusPacket(id,0);
              doPlaySeq();
              break;
             
            case ARB_LOOP_SEQ:                   // Play Seq until we recieve a 'H'alt
              statusPacket(id,0);
              while(doPlaySeq() > 0);
              break;

            // ARB_TEST is deprecated and removed

            case ARB_CONTROL_SETUP:              // Setup a controller
              statusPacket(id,0);
              if(params[0] < CONTROLLER_COUNT){
                controllers[params[0]].setup(length-3);
                for(int i=0; i<length-3; i++){
                  controllers[params[0]].setId(i, params[i+1]);
                }
#ifdef USE_BASE
              }else if(params[0] == 10){
                Kp = params[1];
                Kd = params[2];
                Ki = params[3];
                Ko = params[4];
#endif
              }
              break;

            case ARB_CONTROL_WRITE:              // Write values to a controller
              statusPacket(id,0);
              if(params[0] < CONTROLLER_COUNT){
                for(int i=0; i<length-4; i+=2){
                  controllers[params[0]].setNextPose(controllers[params[0]].getId(i/2), params[i+1]+(params[i+2]<<8));
                }
                controllers[params[0]].readPose();
                controllers[params[0]].interpolateSetup(params[length-3]*33);
#ifdef USE_BASE
              }else if(params[0] == 10){
                left_speed = params[1];
                left_speed += (params[2]<<8);
                right_speed = params[3];
                right_speed += (params[4]<<8); 
                if((left_speed == 0) && (right_speed == 0)){
                  drive.set(0,0);
                  ClearPID();
                }else{
                  if((left.Velocity == 0) && (right.Velocity == 0)){
                    PIDmode = 1; moving = 1;
                    left.PrevEnc = Encoders.left;
                    right.PrevEnc = Encoders.right;
                  }
                }   
                left.Velocity = left_speed;
                right.Velocity = right_speed; 
#endif
              }
              break;

            case ARB_CONTROL_STAT:               // Read status of a controller
              if(params[0] < CONTROLLER_COUNT){             
                Serial.print(0xff,BYTE);
                Serial.print(0xff,BYTE);
                Serial.print(id,BYTE);
                Serial.print(3,BYTE);
                Serial.print(0,BYTE);
                checksum = controllers[params[0]].interpolating;
                Serial.print(checksum,BYTE);
                checksum += id + 3;
                Serial.print(255-((checksum)%256),BYTE);
#ifdef USE_BASE
              }else if(params[0] == 10){
                checksum = id + 2 + 8;                            
                Serial.print(0xff,BYTE);
                Serial.print(0xff,BYTE);
                Serial.print(id,BYTE);
                Serial.print(2+8,BYTE);
                Serial.print(0,BYTE);   // error level
                int v = ((unsigned long)Encoders.left>>0)%256;
                Serial.print(v, BYTE);                
                checksum += v;
                v = ((unsigned long)Encoders.left>>8)%256;
                Serial.print(v, BYTE);                
                checksum += v;
                v = ((unsigned long)Encoders.left>>16)%256;
                Serial.print(v, BYTE);                
                checksum += v;
                v = ((unsigned long)Encoders.left>>24)%256;
                Serial.print(v, BYTE);                
                checksum += v;
                v = ((unsigned long)Encoders.right>>0)%256;
                Serial.print(v, BYTE);                
                checksum += v;
                v = ((unsigned long)Encoders.right>>8)%256;
                Serial.print(v, BYTE);                
                checksum += v;
                v = ((unsigned long)Encoders.right>>16)%256;
                Serial.print(v, BYTE);                
                checksum += v;
                v = ((unsigned long)Encoders.right>>24)%256;
                Serial.print(v, BYTE);                
                checksum += v;
                Serial.print(255-((checksum)%256),BYTE);
#endif
              }
              break;

          }
        }else if(id == 0xFE){
          // sync read or write
          if(ins == ARB_SYNC_READ){
            int start = params[0];    // address to read in control table
            int bytes = params[1];    // # of bytes to read from each servo
            int k = 2;
            checksum = id + (bytes*(length-4)) + 2;                            
            Serial.print(0xff,BYTE);
            Serial.print(0xff,BYTE);
            Serial.print(id,BYTE);
            Serial.print(2+(bytes*(length-4)),BYTE);
            Serial.print(0,BYTE);     // error code
            // send actual data
            for(k=2; k<length-2; k++){
              if( ax12GetRegister(params[k], start, bytes) >= 0){
                for(i=0;i<bytes;i++){
                  checksum += ax_rx_buffer[5+i];
                  Serial.print(ax_rx_buffer[5+i],BYTE);
                }
              }else{
                for(i=0;i<bytes;i++){
                  checksum += 255;
                  Serial.print(255,BYTE);
                }
              }
            }
            Serial.print(255-((checksum)%256),BYTE);
          }else{    
            // TODO: sync write pass thru
            int k;
            setTXall();
            ax12write(0xff);
            ax12write(0xff);
            ax12write(id);
            ax12write(length);
            ax12write(ins);
            for(k=0; k<length; k++)
                ax12write(params[k]);
            // no return
          }       
        }else{ // ID != 253, pass thru 
          switch(ins){
            // TODO: streamline this
            case AX_READ_DATA:
              ax12GetRegister(id, params[0], params[1]);
              // return a packet: FF FF id Len Err params check
              if(ax_rx_buffer[3] > 0){
                for(i=0;i<ax_rx_buffer[3]+4;i++)
                  Serial.print(ax_rx_buffer[i],BYTE);
              }
              ax_rx_buffer[3] = 0;
              break;
             
            case AX_WRITE_DATA:
              if(length == 4){
                ax12SetRegister(id, params[0], params[1]);
              }else{
                int x = params[1] + (params[2]<<8);
                ax12SetRegister2(id, params[0], x);
              }
              statusPacket(id,0);
              break;
             
          }
        }
      }
    } // end mode == 5
  } // end while(available)
  // update joints
  for(int i=0; i<5; i++)
    controllers[i].interpolateStep();
 
#ifdef USE_BASE
  // update pid
  updatePID();
#endif

}

BioloidController.h:
/*
  BioloidController.h - arbotiX Library for Bioloid Pose Engine
  Copyright (c) 2008,2009 Michael E. Ferguson.  All right reserved.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#ifndef BioloidController_h
#define BioloidController_h

/* poses:
 *  PROGMEM prog_uint16_t name[ ] = {4,512,512,482,542}; // first number is # of servos
 * sequences:
 *  PROGMEM transition_t name[] = {{NULL,count},{pose_name,1000},...} 
 */

#include "ax12.h"

/* pose engine runs at 30Hz (33ms between frames) 
   recommended values for interpolateSetup are of the form X*BIOLOID_FRAME_LENGTH - 1 */
#define BIOLOID_FRAME_LENGTH      33
/* we need some extra resolution, use 13 bits, rather than 10, during interpolation */
#define BIOLOID_SHIFT             3

/** a structure to hold transitions **/
typedef struct{
    unsigned int * pose;    // addr of pose to transition to 
    int time;               // time for transition

} transition_t; 

/** Bioloid Controller Class for mega324p/644p clients. **/
class BioloidController
{
  public:
    /* YOU SHOULD NOT USE Serial1 */
    BioloidController(long baud);               // baud usually 1000000

    /* Pose Manipulation */
    void loadPose( const unsigned int * addr ); // load a named pose from FLASH  
    void readPose();                            // read a pose in from the servos  
    void writePose();                           // write a pose out to the servos
    int getCurPose(int id);                     // get a servo value in the current pose
    int getNextPose(int id);                    // get a servo value in the next pose
    void setNextPose(int id, int pos);          // set a servo value in the next pose
    
    /* Pose Engine */
    void interpolateSetup(int time);            // calculate speeds for smooth transition
    void interpolateStep();                     // move forward one step in current interpolation  
    unsigned char interpolating;                // are we in an interpolation? 0=No, 1=Yes
    unsigned char runningSeq;                   // are we running a sequence? 0=No, 1=Yes 
    int poseSize;                               // how many servos are in this pose, used by Sync()

    /* to interpolate:
     *  bioloid.loadPose(myPose);
     *  bioloid.interpolateSetup(67);
     *  while(bioloid.interpolating > 0){
     *      bioloid.interpolateStep();
     *      delay(1);
     *  }
     */

    /* Sequence Engine */
    void playSeq( const transition_t * addr );  // load a sequence and play it from FLASH
    void play();                                // keep moving forward in time
    unsigned char playing;                      // are we playing a sequence? 0=No, 1=Yes

    /* to run the sequence engine:
     *  bioloid.playSeq(walk);
     *  while(bioloid.playing){
     *      bioloid.play();
     *  }
     */
    
  private:  
    unsigned int pose[AX12_MAX_SERVOS];         // the current pose, updated by Step(), set out by Sync()
    unsigned int nextpose[AX12_MAX_SERVOS];     // the destination pose, where we put on load
    int speed[AX12_MAX_SERVOS];                 // speeds for interpolation 

    unsigned long lastframe;                    // time last frame was sent out  
    
    transition_t * sequence;                    // sequence we are running
    int transitions;                            // how many transitions we have left to load
   
};
#endif

Edit:  When updating the libraries that Ferg posted, I now get the following compile error, which is an exact duplicate of an error that I was getting with a different sketch (pypose) earlier:
In file included from /usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h:44:0,
                 from /usr/lib/gcc/avr/4.5.3/../../../avr/include/avr/delay.h:37,
                 from /home/marc/sketchbook/hardware/arbotix/cores/arbotix/wiring_private.h:30,
                 from /home/marc/sketchbook/libraries/BigMotors/BigMotors.cpp:21:
/usr/lib/gcc/avr/4.5.3/../../../avr/include/math.h:426:15: error: expected unqualified-id before ‘double’
/usr/lib/gcc/avr/4.5.3/../../../avr/include/math.h:426:15: error: expected ‘)’ before ‘double’
/usr/lib/gcc/avr/4.5.3/../../../avr/include/math.h:426:15: error: expected ‘)’ before ‘double’

Originally posted by Aroarus on ROS Answers with karma: 122 on 2011-11-16
Post score: 0

A:

The ros.pde sketch currently requires the BioloidController library from trunk, it looks like yours is from one of our downloads.

Originally posted by fergs with karma: 13902 on 2011-11-16
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Aroarus on 2011-11-18:
That worked perfectly!  Thank you so much!
Comment by fergs on 2011-11-18:
So, I have a much older version of avr libc (4.3.4) and am unable to reproduce this error -- however, it appears to be a fixable one: http://code.google.com/p/arduino-tiny/issues/detail?id=29
Comment by Aroarus on 2011-11-18:
I just tried upgrading to 0023, but that did not fix the problem.  It appears to be an error in some of the files in my /usr/lib/avr/include/ files, according to the error.  In addition do you know why it is choosing to write the path in such a weird way?  With the .. inside the path?
Comment by Aroarus on 2011-11-18:
0022ubuntu0.1
Comment by fergs on 2011-11-16:
What version of Arduino are you using?
Comment by Aroarus on 2011-11-16:
Thank you so much for your quick response! That fixed one error, but caused another, which I had seen earlier.  Do you have any idea what might be causing it?  Its at the end of the post.
Comment by fergs on 2011-11-16:
I was saying you need to do an svn checkout of trunk. However, I just posted a set of libraries specifically for ROS users: http://code.google.com/p/arbotix/downloads/detail?name=libraries-ros.zip&can=2&q= Docs are being updated now.
Comment by Aroarus on 2011-11-16:
Are you talking about the updated libraries for the Arbotix2?  Because I only have the original ArbotiX
Comment by Aroarus on 2011-11-16:
So what does that mean?  How do I fix it?  Where do I get the right library from?  This was the one I was linked to from the turtlebot arm tutorial.


Q:

Long compile time for ROS2 interface package

I'm prompted to ask this because I just tried changing a single name in a single service of a *_msgs package and it took colcon over 2 minutes to recompile. I don't have a amazingly fast laptop and it is a relatively large package (~50 interfaces) but this seems like an awfully long time to have to wait for any source change at all.
My understanding of the details of the interface generation process is fairly limited. Would anyone be able to shed some light on what's going on under the hood and where all this time is getting eaten up?

Originally posted by jdlangs on ROS Answers with karma: 971 on 2019-06-19
Post score: 0

A:

This document covers this process:
http://docs.ros2.org/dashing/developer_overview.html#type-specific-interfaces
It is slightly out of date, but the gist of what is happening is still the same.
Basically it takes so long because it has to do a lot of work.
It has to generate code for C++, C, and Python for each type, then generate and compile rmw implementation specific code for each type (e.g. code generated by the DDS implementation), and then it has to generate and compile code to handle the interaction between the ROS types and the rmw implementation.
Also, this process is highly decoupled (each stage is an extension), which makes it very flexible for both code generators (i.e. if you wanted to add a new language like Java or something) and for the rmw implementation (i.e. if you wanted to add a new rmw implementation that has its own code generation). Unfortunately that means it hasn't scaled well, and results in starting Python many, many times (each time you start the interpreter it takes like 200ms on most machines), and that adds considerably to the overhead. We've talked about a solution to this in the past, but never had time to implement it.
One good trade off, though, is that applications compile faster (another good reason to separate your msg/srv files into a separate package) and things like code completion in your editor run faster because there's less complex templates behind message types and calls like create_publisher or create_subscription.

Originally posted by William with karma: 17335 on 2019-06-19
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by jdlangs on 2019-06-21:
Thanks for the detailed response! I'm guessing there may be potential for some easy caching-like optimizations since it seems like every interface was regenerated even though I only changed one. Worth opening an issue?


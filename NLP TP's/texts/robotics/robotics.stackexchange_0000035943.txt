Q:

cannot detect file - file path problem?

Hi,
Sorry if this is a dumb question but I am trying to use openCV with ROS to load an .avi file unsuccessfully.
To test out video loading, I used a very simple sample code online http://nashruddin.com/How_to_Play_AVI_Files_with_OpenCV
and just modify line 22 to change the argument from argv[1] to "myvideo.avi" which is in the same folder as the source. I compile using g++ and it works as expected.
When I put that same source file into a ROS package my_ros_package/src and compile in ROS, the executable goes into my_ros_package/bin. So I tried putting myvideo.avi into both /bin and /src. Although the program compile fine using rosmake or make, when I load the executable, the code would return at line 25, implying that the .avi file could not be found.
I also tried various ways such as using rosrun or ./bin/my_executatble in my_ros_package or ./my_executable in my_ros_package/bin, all gave the same error.
Interestingly, if I only load an image instead of an .avi from the same code (using cvLoadImage("myimage.png"), the image can be diplayed when it is in the /bin folder and using ./my_executable in my_ros_package/bin.
I thought this could be a codec problem, I fixed it as suggested in the same link with the sample code, however, that did not work. Also, please note that the .avi could be played by using g++ for compiling and having the .avi file in the same folder with the source.
I am guessing the problem lies in the way ROS is setting its PATH. Could any one help out with this please?
Below is my source code
the video file & source file is in the same ros_package/src/ folder
This is the code that does not work as I compile from rosmake. The output returns
"Cannot capture from AVI"
   #include <stdio.h>
    #include <iostream>
    #include "cv.h"
    #include "highgui.h"
    #include "ros/ros.h"
    #include "ros/package.h"

using namespace std;
using namespace ros::package;
 
int main( int argc, char** argv )
{
    IplImage  *frame;
    int key = 0;
   
    std::string DIR = getPath("iCharibot_face");
    std::string PATH = DIR + "/src/Talking4.avi";
    cout << "PATH " << PATH << endl;

    /* load the AVI file */
    CvCapture *capture = cvCaptureFromAVI(PATH.c_str());
    if(!capture){
         printf("Cannot capture from AVI.\n");
    }
   
    /* get fps, needed to set the delay */
    int fps = ( int )cvGetCaptureProperty( capture, CV_CAP_PROP_FPS );
   //int fps = 30;
    /* display video */
    cvNamedWindow( "video", 0 );
   
    while( key != 'q' ) {
        /* get a frame */
        frame = cvQueryFrame( capture );
        /* always check */
        if( !frame ) break;
        /* display frame */
        cvShowImage( "video", frame );
       
        /* quit if user press 'q' */
        key = cvWaitKey( 1000 / fps );
    }
   
    /* free memory */
    cvReleaseCapture( &capture );
    cvDestroyWindow( "video" );
 
    return 0;
}

The same code works fine even if I do not use the PATH when I use g++ to compile (I have to remove all the ros include to compile in g++). The Talking4.avi video is animated.
#include <stdio.h>
#include <iostream>
#include "cv.h"
#include "highgui.h"

using namespace std;
 
int main( int argc, char** argv )
{
    IplImage  *frame;
    int key = 0;

    /* load the AVI file */
    CvCapture *capture = cvCaptureFromAVI("Talking4.avi");
    if(!capture){
         printf("Cannot capture from AVI. SAD\n");
    }
   
    /* get fps, needed to set the delay */
    int fps = ( int )cvGetCaptureProperty( capture, CV_CAP_PROP_FPS );
   //int fps = 30;
    /* display video */
    cvNamedWindow( "video", 0 );
   
    while( key != 'q' ) {
        /* get a frame */
        frame = cvQueryFrame( capture );
        /* always check */
        if( !frame ) break;
        /* display frame */
        cvShowImage( "video", frame );
       
        /* quit if user press 'q' */
        key = cvWaitKey( 1000 / fps );
    }
   
    /* free memory */
    cvReleaseCapture( &capture );
    cvDestroyWindow( "video" );
 
    return 0;
}

And if I modify the code to display just a static image, it will work as well using rosmake
and PATH
   #include <stdio.h>
    #include <iostream>
    #include "cv.h"
    #include "highgui.h"
    #include "ros/ros.h"
    #include "ros/package.h"

using namespace std;
using namespace ros::package;

int main( int argc, char** argv )
{
    IplImage  *frame;
    int key = 0;

    std::string DIR = getPath("iCharibot_face");
    std::string PATH = DIR + "/src/Talking4.png";
    cout << "PATH " << PATH << endl;

    /* load a static image instead of AVI file */
    
   int fps = 30;
    /* display video */
    cvNamedWindow( "video", 0 );

    while( key != 'q' ) {
        /* get a frame */
        frame = cvLoadImage(PATH.c_str());
        /* always check */
        if( !frame ) break;
        /* display frame */
        cvShowImage( "video", frame );

        /* quit if user press 'q' */
        key = cvWaitKey( 1000 / fps );
    }

    /* free memory */
    cvReleaseCapture( &capture );
    cvDestroyWindow( "video" );

    return 0;
}

Originally posted by Tuan on ROS Answers with karma: 111 on 2011-11-23
Post score: 1

A:

You can get the base_directory from roslib. In Python it is something like:
DIR = roslib.packages.get_pkg_dir("your_package_name", required=True)

So you can retrieve your file by using DIR + "/folder_where_file_is/" + "filename.avi" (You can use a similar code in C++ as the string class overrides the + operator).
Bear in mind that when you do "rosrun pkg executable" then the current directory is the process cwd, so if you run it from your home that is where the file will be searched for. Alternatively you can use absolute paths, like "/home/yourname/path_to_file/file.avi".
Bear in mind that the above solutions are in decreasing order of portability and in increasing order of troublemakingability (I guess you won't find this word in the Oxford dictionary).

Originally posted by Lorenzo Riano with karma: 1342 on 2011-11-24
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by Lorenzo Riano on 2011-11-27:
I don't have experience using opencv + ROS, but I see that you haven't initialized the node. Also a ROS node is threaded, so it needs ros::spin or in your case ros::spin_once. What about the bridge libraries to use opencv from within ROS?
Comment by Tuan on 2011-11-27:
Thanks Riano. I got it working for a static image but the same problem still persists for the AVI file. I have included the source code for your reference. Source 1: does not work. Source 2 works with g++ & source 2 works with a static image.


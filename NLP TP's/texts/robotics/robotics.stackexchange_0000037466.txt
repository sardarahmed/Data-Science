Q:

rosmake don't create .so file for gazebo plugins

Hello!
I made some gazebo plugins (a diffdrive and a range sensor) and it works fine. The problem that i have is if I do just a rosmake of my packages it compiles but don't generate the ".so" library plugin. I have to do separately a "cmake ." and later a "make" in order to obtain the ".so" file. Anyone knows why is it happening? or is it the normal procedure?
Thanks
CMakeList.txt
cmake_minimum_required(VERSION 2.4.6)
include($ENV{ROS_ROOT}/core/rosbuild/rosbuild.cmake)

rosbuild_init()

#set the default path for built executables to the "bin" directory
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)
#set the default path for built libraries to the "lib" directory
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)

rosbuild_add_library(gazebo_ros_ir src/gazebo_ros_ir.cpp)
rosbuild_link_boost(gazebo_ros_ir thread)

Makefile
# CMAKE generated file: DO NOT EDIT!
# Generated by "Unix Makefiles" Generator, CMake Version 2.8

# Default target executed when no arguments are given to make.
default_target: all
.PHONY : default_target

#=============================================================================
# Special targets provided by cmake.

# Disable implicit rules so canoncical targets will work.
.SUFFIXES:

# Remove some rules from gmake that .SUFFIXES does not remove.
SUFFIXES =

.SUFFIXES: .hpux_make_needs_suffix_list

# Suppress display of executed commands.
$(VERBOSE).SILENT:

# A target that is always out of date.
cmake_force:
.PHONY : cmake_force

#=============================================================================
# Set environment variables for the build.

# The shell in which to execute make rules.
SHELL = /bin/sh

# The CMake executable.
CMAKE_COMMAND = /usr/bin/cmake

# The command to remove a file.
RM = /usr/bin/cmake -E remove -f

# The program to use to edit the cache.
CMAKE_EDIT_COMMAND = /usr/bin/ccmake

# The top-level source directory on which CMake was run.
CMAKE_SOURCE_DIR = /home/workspace/stacks/plugins/range_gazebo_plugin

# The top-level build directory on which CMake was run.
CMAKE_BINARY_DIR = /home/workspace/stacks/plugins/range_gazebo_plugin

#=============================================================================
# Targets provided globally by CMake.

# Special rule for the target edit_cache
edit_cache:
    @$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Running CMake cache editor..."
    /usr/bin/ccmake -H$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR)
.PHONY : edit_cache

# Special rule for the target edit_cache
edit_cache/fast: edit_cache
.PHONY : edit_cache/fast

Originally posted by jrcapriles on ROS Answers with karma: 370 on 2012-01-31
Post score: 0

Original comments
Comment by jrcapriles on 2012-01-31:
I already found the answer! Thanks to you Lorenz!! the package is in a repository and the Makefile wasn't commited!! now the rosmake works and create the .so the make file say: include $(shell rospack find mk)/cmake.mk
Comment by jrcapriles on 2012-01-31:
Thanks for your answer, I already added the make information. I normally don't use "cmake .", with "rosmake" all work fine. but in this case the lib file didn't compile so I try to forced it and it works...
Comment by Lorenz on 2012-01-31:
Can you edit your question and put the contents of your Makefile and CMakeLists.txt? Btw. it is normally a bad idea to call 'cmake .' because it messes up your source tree. Normally you do out-of-source builds, i.e. mkdir build; cd build; cmake ..

A:

One problem is that your original ros Makefile has been overwritten by your cmake . call. Replace it by
include $(shell rospack find mk)/cmake.mk

Originally posted by Lorenz with karma: 22731 on 2012-01-31
This answer was ACCEPTED on the original site
Post score: 2


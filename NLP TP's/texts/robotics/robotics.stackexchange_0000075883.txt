Q:

PointXYZRGB to CIELab conversion

I get this error:
/home/dinesh/catkin_ws_pcl/src/my_pcl_tutorial/src/godgift.cpp:48:41: error: no matching function for call to ‘pcl::NormalEstimation<pcl::PointXYZRGB, pcl::Normal>::setInputCloud(pcl::PointCloud<pcl::PointXYZRGB>&)’
    normalEstimation.setInputCloud(output);

when i try to run below code:
void
cloud_cb (const sensor_msgs::PointCloud2ConstPtr& input)
{

    pcl::PointCloud<pcl::PointXYZRGB> output;
    pcl::fromROSMsg(*input,output);
    pcl::PointCloud<pcl::Normal>::Ptr normals;
     pcl::PointCloud<pcl::SHOT1344>::Ptr descriptors;
pcl::PointXYZRGB p[400][400];

for(int i=0;i<400;i++)
{
  for(int j=0;j<400;j++)
    {
      p[i][j] = output.at(i,j);

  }
 }

pcl::NormalEstimation<pcl::PointXYZRGB, pcl::Normal> normalEstimation;

normalEstimation.setInputCloud(output);
        normalEstimation.setRadiusSearch(0.03);
      pcl::search::KdTree<pcl::PointXYZRGB>::Ptr kdtree;
     normalEstimation.setSearchMethod(kdtree);
            normalEstimation.compute(*normals);
     pcl::SHOTColorEstimation<pcl::PointXYZRGB, pcl::Normal, pcl::SHOT1344> shot;
        shot.setInputCloud(output);
        shot.setInputNormals(normals);
 shot.setRadiusSearch(0.02);

        shot.compute(*descriptors);
  std::cout<<"rgb"<<"\t"<<p[200][200].x<<"\t"<<p[200][200].r<<std::endl;
}

which i got from pcl forum but, i dont understand how do i use this. I want to somehow access lab values of color instead of rgb. Im using ros indigo, this are for the computer vision purpose.
I also tried this methode but the values only comes zero.
    pcl::PointCloud<pcl::PointXYZRGB> output;
    pcl::fromROSMsg(*input,output);
    pcl::PointCloud<pcl::PointXYZLAB> cloud;
    pcl::copyPointCloud(output,cloud);

    pcl::PointXYZLAB  p;
 p = output.at(400,300);
 std::cout<<p.L<<"\t"<<p.a<<"\t"<<p.b<<std::endl;

Originally posted by dinesh on ROS Answers with karma: 932 on 2016-08-19
Post score: 0

Original comments
Comment by gvdhoorn on 2016-08-20:
I'm inclined to refer you to the PCL support forum pcl-users.org, as this is a rather PCL-specific question. You probably stand a better chance of getting answers there.
Comment by dinesh on 2016-08-20:
i have posted question their also, to get solution of the problem as fast as it is possible. but no ans till now.

A:

step1: RGB->XYZ
var_R = ( R / 255 )        //R from 0 to 255
var_G = ( G / 255 )        //G from 0 to 255
var_B = ( B / 255 )        //B from 0 to 255

if ( var_R > 0.04045 ) var_R = ( ( var_R + 0.055 ) / 1.055 ) ^ 2.4
else                   var_R = var_R / 12.92
if ( var_G > 0.04045 ) var_G = ( ( var_G + 0.055 ) / 1.055 ) ^ 2.4
else                   var_G = var_G / 12.92
if ( var_B > 0.04045 ) var_B = ( ( var_B + 0.055 ) / 1.055 ) ^ 2.4
else                   var_B = var_B / 12.92
var_R = var_R * 100
var_G = var_G * 100
var_B = var_B * 100
X = var_R * 0.4124 + var_G * 0.3576 + var_B * 0.1805
Y = var_R * 0.2126 + var_G * 0.7152 + var_B * 0.0722
Z = var_R * 0.0193 + var_G * 0.1192 + var_B * 0.9505

step2:XYZ->L*ab
var_X = X / ref_X          //ref_X =  95.047   Observer= 2°, Illuminant= D65
var_Y = Y / ref_Y          //ref_Y = 100.000
var_Z = Z / ref_Z          //ref_Z = 108.883

if ( var_X > 0.008856 ) var_X = var_X ^ ( 1/3 )
else                    var_X = ( 7.787 * var_X ) + ( 16 / 116 )
if ( var_Y > 0.008856 ) var_Y = var_Y ^ ( 1/3 )
else                    var_Y = ( 7.787 * var_Y ) + ( 16 / 116 )
if ( var_Z > 0.008856 ) var_Z = var_Z ^ ( 1/3 )
else                    var_Z = ( 7.787 * var_Z ) + ( 16 / 116 )

CIE-L* = ( 116 * var_Y ) - 16
CIE-a* = 500 * ( var_X - var_Y )
CIE-b* = 200 * ( var_Y - var_Z )

Originally posted by dinesh with karma: 932 on 2016-08-20
This answer was ACCEPTED on the original site
Post score: 0


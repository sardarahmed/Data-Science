Q:

Is AMCL's implementation of the odometry model correct?

Hi there,
after a lengthy internal discussion about a motion model issue my colleague Erik discovered, I decided to take this question here. We have been experimenting with motion models for differential drive and compared to various available implementions, one of them being ROS AMCL.
AMCL implements the motion model in file (https://github.com/ros-planning/navigation/blob/groovy-devel/amcl/src/sensors/amcl_odom.cpp). A comment at line 150 refers to an algorithm (sample_motion_model_odometry) presented in "Thrun,Burgard,Fox: Probabilistic Robotics". The uncertainty parameters are calculated exactly following the reference (lines 180-189). However, the implementation differs in one detail: the algorithm in the book passes the calculated uncertainty to function sample(), which takes the variance as parameter, while the AMCL implementation calls function pf_ran_gaussian(), which expects as parameter the standard deviation (and indeed samples accordingly). (Note that function sample() is not explained directly for algorithm sample_motion_model_odometry, but for sample_motion_model_velocity at page 124, and there is no reason to assume it should be different in these two algorithms.)
The discussion is complicated considerably by the fact that several printings of the book exist which differ significantly in the algorithms for the motion model. Eventually, we'd question the validity of the uncertainty formula given in the book at all. While this is not originally a ROS issue, it is related to the implementation error above (and in particular its correction) and I present it here in the hope to find some verification (or falsification) of our view:
In the second printing (and it seems all later ones), which apparently has been used as the reference for AMCL, the formula for the translation uncertainty is

d_trans_hat = d_trans -
sample(alpha3 * d_trans * d_trans +
alpha4 * (d_rot1 * d_rot1 + d_rot2 * d_rot2))

In the first printing it was

d_trans_hat = d_trans -
sample(alpha3 * d_trans + alpha4 * (|d_rot1| + |d_rot2|)

but the sample() function was described as taking the standard deviation as parameter.
The errata for the first version, available at http://www.probabilistic-robotics.org, says:

Throughout chapters 5 and 7, the book
uses standard deviations as parameters
of the function prob() and the error
variables \varspeilon. The problem
with those expressions is that
standard deviations are not additive.
The correct notation (which will be in
the second printing) involves
variances, which are additive.

In our opinion, this is right, but the change in the formula (from uncertainty being linear to quadratic in motion distance) "compensates" this correction.
Imagine driving a straight line forward for a certain distance a. When sampling the motion (distance only), we end up with a normal distribution
A ~ N(a,m) (mean a, variance m)
When we decide to sample twice during the same motion, we get estimated distances for 2 sections, which we have to sum up for the estimation of the overall distance:
B ~ N(b,n)
C ~ N(c,o)
B+C ~ N(b+c, n+o)
(http://en.wikipedia.org/wiki/Sum_of_normally_distributed_random_variables)
Since the overall motion was the same, distribution A should be the same as B+C, and therefore m=n+o, which implies that the variance should be a linear function of the distance:
n=alpha*b, o=alpha*c, m=alpha*a = alpha*(b+c) = n+o

With the above formula from the second printing, the variance for repeated sampling will be proportional to the sum of the squared sections, while for sampling once it will be proportional to the squared sum of the sections:
n=alpha*b*b, o=alpha*c*c, m=alpha*(b+c)*(b+c) != n+o 

That means the estimation for the same observed motion will differ depending on how often and when exactly the estimation is done.
So to sum it up:
We think the formula from the first printing is indeed right, just that d_trans_hat is the variance and not the standard deviation. The second printing corrected the standard deviation/variance mixup, but at the same time introduced a wrong formula for the previous correct one.

Originally posted by Christof Schroeter on ROS Answers with karma: 209 on 2013-02-06
Post score: 21

Original comments
Comment by Thomas D on 2013-02-06:
Great write up of your question. With your new karma you should be able to edit your question to add in the link tags if you so desire.
Comment by Christof Schroeter on 2013-02-06:
done. thanks for the hint.
Comment by Christof Schroeter on 2013-02-08:
Can anyone comment on the assumption that the final estimated distribution should not depend on the frequency of updating the estimation, and the finding that this conflicts with variance being a linear function of squared distance?

A:

Good find, the AMCL software package doesn't have this right.  I made an issue to track this:
https://github.com/ros-planning/navigation/issues/20
As for the distributions, summing the variance is absolutely required, as seen here: http://apcentral.collegeboard.com/apc/members/courses/teachers_corner/50250.html
The rest of the algorithm is explained in the 3rd edition in section 5.4.3.  d_trans must be in units of meters since it is the translation component of the odometry update.  The lines you quote are the ones described as "To model the motion error, we assume that the "true" values of the rotation and translation are obtained from the measured ones by subtracting independent noise (SAMPLE) with zero mean and variance b^2).  So the formula from edition 1 cannot be correct since d_trans and d_trans_hat are in meters, not meters^2 (see equation 5.38 and 5.40).
Finally, it may help to remember that this is sampling the noise for a particle filter where the overall distribution is tracked by the particles, not a closed-form estimate.  Each particle in the filter experiences these updates, so the 'A' compoment of AMCL allows an adaptive (KLD sampling) approach that increases and decreases the number of particles in order to keep the particles from diverging and to ensure there are enough to track the important high-probability areas of distribution.

Edit to show units of alpha, along with the units of the other values:

Originally posted by Chad Rockey with karma: 4541 on 2013-02-07
This answer was ACCEPTED on the original site
Post score: 7

Original comments
Comment by Christof Schroeter on 2013-02-08:
Thank you, an interesting read about the variance summation, but please note that I did not at all question this property, but assumed it as the foundation of my argument.
Regarding the derivation of the variance formula from the variables' units I am sorry it is not entirely convincing:
Comment by Christof Schroeter on 2013-02-08:
you assume that the variance must be proportional to the square of the distance because its unit is in m^2. But then how do you explain summing distance and rotation within this formula, and calculating rotation variance from distance and vice versa?
Comment by Christof Schroeter on 2013-02-08:
Obviously, the alphas must have units themselves in these formulas, and that means you cannot equal the unit of one parameter with the unit of the result, which invalidates your argument in my opinion.
Comment by Christof Schroeter on 2013-02-08:
The eventual question remains whether the variance is proportional to the distance or the squared distance. In my original question I gave an argument why it should be the former.
Comment by Chad Rockey on 2013-02-08:
I've posted a quick notebook page of the units in the equations.  The only question left then is the sample space.  Sample takes a random value from the distribution specified by that variance.
Comment by Christof Schroeter on 2013-02-08:
I don't agree that your formula and units assignment is the only possible way. The units are right, but you can as well assign units to the alphas so that the units are right without squaring d_trans/d_rot. This is not a proof for one or the other formula.
Comment by hersh on 2013-02-11:
The book does not seem to give a reason for why the noise is modeled as a sum of weighted squares, but the definition of variance is the squared deviation of the variable from its expected value.


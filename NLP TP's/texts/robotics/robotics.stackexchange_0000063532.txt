Q:

how to receive non-const shared_ptr without copies when publishing between nodelets?

I have several nodelets sharing a C++ class adapted to ROS message_traits. I'm publishing a non-const shared_ptr to other nodelets. The nodelets expecting a ConstPtr on the callback receive the same data (the .get() method of the shared_ptr returns the same number from sender to receivers). However, on another I'm receiving a non-const shared_ptr as well and in this case a copy of the object is made (I can confirm this several ways, .get() also returns a different number).
I understand that problems could arise if an object is modified on the receiver and the sender does not expect this, but I hoped this would be a decision left to the user and not enforced by performing a copy in this case. Since I publish a non-const object, I expect to be able to receive a non-const object without any intermediate copies. My code ensures that modifying things on the sender will not break things on receiver in this case.
Is it possible to avoid the copy?
UPDATE:
I've looked a bit more into the issue and I'm starting to believe there is a bug.
The matter occurs when publishing a non-const shared_ptr and I have one non-const subscriber AND another subscriber  (be it const or non-const). If I have a single non-const, two non-const or one const subscriber, it works. However, having one non-const with any others trigger the problem.
Note that it appears the non-const subscribers receive the copy and this only happens after a second sending of the message.
It all leads me to believe that, whenever a non-const subscriber's callback is called, for some reason, an internal const version of the message is stored somewhere in the ROS pipeline. Afterwards, any other invoked non-const callback sees that since it has an internal const ptr stored, it needs to perform a copy to offer the non-const version. However, it appears as a contradiction since I can at least once receive the non-const version so it appears the behavior is unintended.

Originally posted by Matias on ROS Answers with karma: 122 on 2014-10-23
Post score: 1

A:

This is not a bug but the only reasonable behavior of the API. If your non-const subscriber would receive a reference (no copy) of the original message it can modify the message instance which would effect all other subscribers. Even worst since the order of the subscriber callbacks is not deterministic the overall system behavior would be non-deterministic.
From the perspective of another const subscriber the message instance can change will it is being processed in the callback.
So if you do want to use zero copy your subscriber must specify const in the callback signature.

Originally posted by Dirk Thomas with karma: 16276 on 2014-10-24
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by Dirk Thomas on 2014-10-24:
Please read https://github.com/ros/roscpp_core/issues/31 for a more detailed explanation.
Comment by Matias on 2014-10-24:
Ok! Sorry again for the mixup!
What do you think would be then the way to share non-const data between nodelets? Being threads I could share global data, but I was hoping to use some ROS standard way. I was hoping that sharing shared_ptr as messages would be the correct way.
Comment by Dirk Thomas on 2014-10-24:
ROS does not provide you with an atomic way to share pointers in a bidirectional way. You should consider using two topics: once from A to B and the other from B to A and use const in the subscriber signature to avoid copies.
Comment by Matias on 2014-10-24:
And if I want the receiver to be able to modify the sender's instance? (ie. to receive a non-const ptr)? Can I avoid the copy somehow?
Comment by Dirk Thomas on 2014-10-24:
No, that is not possible for the state reasons.


Q:

Issues related to navfn and global_planner plugin

Hi,
I am using ROS fuerte. I have gone through the navfn .
I want a ROS plugin for my own global planner I have Visited this page.
I have following doubts:

I want to my own global path planner to make two/three of different plans. All these plans will require to remove the inbuilt Dijkstra's  algorithm, implemented inside navfn.cpp and used inside navfn_ros.cpp. Will a single plugin serve my purpose or I have to make different plugins and make them switchable to decide the proper plan?

Why two makePlan() methods are used (see here)?

In the link (http://www.iroboapp.org/index.php?title=Adding_Genetic_Algorithm_Global_Path_Planner_As_Plugin_in_ROS); they have not told anything about modification about navfn.cpp. .

Finally, where the should I place the code specific to this plugin? Should I create a separate library containing all the files similar to navfn?

Updated based on Comment
As mentioned in the link, pluginlib is a C++ library for loading and unloading plugins from within a ROS package. Plugins are dynamically loadable classes that are loaded from a runtime library. So, in the
tutorial, a static makePlan() method is used. I observe that the Dijkstra's algorithm has to be modified and it is defined as calcNavFnDijkstra(true). Again, calcNavFnDijkstra(true) is defined inside navfn.cpp.  So, I want to know, if I write my own navfn.cpp which is the only source file in my plugin, can the other part of navfn_ros.cpp (defined inside navfn package) can relate to the new navfn.cpp dynamically?
I hope somebody has enough insight into the code to help me with these doubts.
Thanks in advance

Originally posted by RB on ROS Answers with karma: 229 on 2015-01-25
Post score: 0

A:

I want to my own global path planner to make two/three of different plans. All these plans will require to remove the inbuilt Dijkstra's algorithm, implemented inside navfn.cpp and used inside navfn_ros.cpp. Will a single plugin serve my purpose or I have to make different plugins and make them switchable to decide the proper plan?

The global planner interface is defined so that you only return one plan. In order to use the navigation frame work as is, a global planner can only return one plan. That said, you could make several plans and then only return the best one.

Why two makePlan() methods are used (see here)?

The one with the tolerance parameter allows for a plan that does not find the exact goal position, but instead has some tolerance.

In the link ( http://www.iroboapp.org/index.php?tit... ); they have not told anything about modification about navfn.cpp. .

I'm not familiar with that tutorial.

Finally, where the should I place the code specific to this plugin? Should I create a separate library containing all the files similar to navfn?

Yes.

Originally posted by David Lu with karma: 10932 on 2015-01-26
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by RB on 2015-01-26:
Thank you @David
Comment by David Lu on 2015-01-26:
If this is satisfactory, please click the check mark to mark the question as answered.
Comment by RB on 2015-01-27:
I have a doubt related to your last answer. In tutorial, only global_planner.cpp is used specific to plugin. global_planner.cpp is similar to navfn_ros.cpp. calcNavFnDijkstra(true) is used inside makePlan() method and computePotential() uses calcNavFnDijkstra(). calcNavFnDijkstra(true) is 2b changed
Comment by David Lu on 2015-01-27:
I'm really not sure what you're asking. If you're writing a new planner, you should make a new package. If you're modifying files from navfn, you should copy them over. If you're not modifying files from navfn, you should dynamically link to them.
Comment by RB on 2015-01-27:
Sorry for not explaining my doubt @David. I have updated the question to incorporate the doubt.


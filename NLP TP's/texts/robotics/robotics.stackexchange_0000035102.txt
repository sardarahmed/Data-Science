Q:

Diagnostic Updater Constructor and Nodelets

I'm having a really difficult time using Diagnostic Updater.  In general, the DiagnosedPublisher constructor is very strict and requires:
DiagnosedPublisher (const ros::Publisher &pub, diagnostic_updater::Updater &diag, const diagnostic_updater::FrequencyStatusParam &freq, const diagnostic_updater::TimeStampStatusParam &stamp)
which FrequenceyStatusParam requires: FrequencyStatusParam (double *min_freq, double *max_freq, double tolerance=0.1, int window_size=5)
and TimeStampStatusParam optionally requires: TimeStampStatusParam (const double min_acceptable=-1, const double max_acceptable=5)
And even worse, the diagnostic_updater::Updater seems to make its own Nodehandle, so you'll have to call init before declaring it.
It seems to be impossible to have one of these as a global variable outside of a class (example, in a C++ file with just a main and a few functions wrapping a non-ROS library).  The only reasonable approach here seems to be keeping the diagnostics declarations within main and running with a while(ros::ok()){ros::spinOnce();} loop.
It also seems extremely difficult to initialize a DiagnosedPublisher member inside of a nodelet in an initialization list.  This needs access to the nodehandle, but you cannot call getMTNodeHandle() or getMTPrivateNodeHandle() until the onInit() function in the nodelet.
Does anyone have a experience running diagnostics in these situations (or even better an example script and nodelet that use diagnostics)?
It's also possible that there are less-strict alternatives that I did not see looking through the API.
Thanks for your help.

Originally posted by Chad Rockey on ROS Answers with karma: 4541 on 2011-10-20
Post score: 2

A:

Did you try allocating it as a new class member pointer inside your onInit()?

Originally posted by joq with karma: 25443 on 2011-10-20
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by Chad Rockey on 2011-10-25:
Thanks Jack!  The eventual, super easy solution was to use a boost shared pointer, and reset or make shared in the onInit.  This is what I get for learning Java first years ago.  ;)


Q:

IMU_GPS robot_localization and navsat_transform_node

Hi everyone, I have some car GPS data (about 1Hz) in my hand, and there is an electronic device built-in IMU in the car to collect IMU data (about 1KHz). The direction of the IMU on the car is the Z axis forward, the X axis right, and the Y axis point to the ground.However, because GPS will drift (some have left the road), it can not be used as accurate data for positioning algorithms.So I decided to use the robot_localization package to put the two kinds of data together, generating new, more accurate GPS data for future use.And I have referred to this post's answer (https://answers.ros.org/question/200071/how-to-fuse-imu-gps-using-robot_localization/). But my current program can not get the output (even if it is not accurate), I hope you can help me analyze the reasons. In addition, I finally hope to get GPS or UTM data. Thank you!
the rqt pic is here:

the launch file is here:
<launch>
  <rosparam command="load" file="$(find robot_localization)/params/ekf_imu_gps.yaml" />
  <node pkg="robot_localization" type="ekf_localization_node" name="ekf_se_map" clear_params="true">
    <remap from="odometry/filtered" to="odometry/filtered_map"/>
  </node>
  <node pkg="robot_localization" type="navsat_transform_node" name="navsat_transform" clear_params="true">
    <remap from="odometry/filtered" to="odometry/filtered_map"/>
  </node>
</launch>

the pramater file is here:
ekf_se_map:
  frequency: 30
  sensor_timeout: 0.1
  two_d_mode: true
  transform_time_offset: 0.0
  transform_timeout: 0.0
  print_diagnostics: true
  debug: false

  map_frame: map
  odom_frame: odom
  base_link_frame: base_link
  world_frame: odom

  # odom0: odometry/gps
  odom0: odometry/gps
  odom0_config: [true, true, false,
                 false, false, false,
                 false, false, false,
                 false, false, false,
                 false, false, false]
  odom0_queue_size: 10
  odom0_nodelay: true
  odom0_differential: false
  odom0_relative: false

  imu0: imu/data
  imu0_config: [false, false, false,
                false, false, false,
                false, false, false,
                true,  true,  true,
                true,  true,  true]
  imu0_nodelay: false
  imu0_differential: false
  imu0_relative: false
  imu0_queue_size: 10
  imu0_remove_gravitational_acceleration: true

  use_control: false

  process_noise_covariance:
  [1e-9, 0, 0, 0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    1e-9, 0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    1e-9, 0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    1e-9,  0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    1e-9,  0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    1e-9, 0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    1e-9,  0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    1e-9,  0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    1e-9,  0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    1e-9,   0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     1e-9,   0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     1e-9,   0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     1e-9,  0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    1e-9,  0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    1e-9]

  initial_estimate_covariance: [1e-9, 0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    1e-9, 0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    1e-9, 0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    1e-9,  0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    1e-9,  0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    1e-9, 0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    1e-9,  0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    1e-9,  0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    1e-9,  0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    1e-9,   0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     1e-9,   0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     1e-9,   0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     1e-9,  0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    1e-9,  0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    1e-9]

navsat_transform:
  frequency: 30
  delay: 0
  magnetic_declination_radians: 0.05288347 # For lat/long 55.944831, -3.186998
  yaw_offset: 1.570796327  # IMU reads 0 facing magnetic north, not east
  zero_altitude: true
  broadcast_utm_transform: true
  publish_filtered_gps: true
  use_odometry_yaw: false
  wait_for_datum: false

next is the scirpt I use to make bag file from the csv data:
# -*- coding: utf-8 -*-
import rospy
import rosbag
import numpy as np
from sensor_msgs.msg import Imu
from sensor_msgs.msg import NavSatFix
def make_imu_data(a,b,t,n):
    a=np.array(a)
    b=np.array(b)
    message1=Imu()
    message1.header.seq=n
    message1.header.stamp.secs=float(t.split(".")[0])
    message1.header.stamp.nsecs=float(t.split(".")[1])*1e3
    message1.header.frame_id='odom'
    message1.orientation.x=0
    message1.orientation.y=0
    message1.orientation.z=0
    message1.orientation.w=0
    message1.orientation_covariance=np.array([-1,-1,-1,-1,-1,-1,-1,-1,-1])
    message1.linear_acceleration.x=float(a[0])
    message1.linear_acceleration.y=float(a[1])
    message1.linear_acceleration.z=float(a[2])
    message1.linear_acceleration_covariance=np.array([0,0,0,0,0,0,0,0,0])
    message1.angular_velocity.x=float(b[0])
    message1.angular_velocity.y=float(b[1])
    message1.angular_velocity.z=float(b[2])
    message1.angular_velocity_covariance=np.array([0,0,0,0,0,0,0,0,0])
    return message1

def make_gps_data(latitude,longitude,t,i):
    message2=NavSatFix()
    message2.header.seq=i
    message2.header.stamp.secs=float(t.split(".")[0])
    message2.header.stamp.nsecs=float(t.split(".")[1])*1e3
    message2.header.frame_id='/gps'
    message2.status.status=1
    message2.status.service=1
    message2.longitude=float(longitude)
    message2.latitude=float(latitude)
    message2.altitude=np.NAN
    message2.position_covariance=np.array([0.64, 0.0, 0.0, 0.0, 0.64, 0.0, 0.0, 0.0, 2.56])
    message2.position_covariance_type=0
    return message2

imufile='/home/Desktop/imu.txt'
gpsfile='/home/Desktop/gps.txt'
with open(gpsfile) as dataset:
    row_numer=1
    with rosbag.Bag('test.bag', 'w') as bag:
        for line in dataset.readlines():
            gps_data=line.split()
            # print imu_data,row_numer
            row_numer=row_numer+1
            msg=make_gps_data(gps_data[2],gps_data[1],gps_data[0],row_numer)
            # print msg.header.stamp
            bag.write('/gps/fix',msg,msg.header.stamp)

with open(imufile) as dataset:
    row_numer=1
    with rosbag.Bag('test.bag', 'a') as bag:
        for line in dataset.readlines():
            imu_data=line.split()
            # print imu_data,row_numer
            row_numer=row_numer+1
            msg=make_imu_data(imu_data[1:4],imu_data[4:7],imu_data[0],row_numer)
            # print msg.angular_velocity
            bag.write('/imu/data',msg,msg.header.stamp)

the imu data is here:
---
header: 
  seq: 9199
  stamp: 
    secs: 9
    nsecs: 194340000
  frame_id: "odom"
orientation: 
  x: 0.0
  y: 0.0
  z: 0.0
  w: 0.0
orientation_covariance: [-1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0]
angular_velocity: 
  x: -3.067016
  y: -4.959106
  z: -1.815796
angular_velocity_covariance: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
linear_acceleration: 
  x: 0.032837
  y: -1.048462
  z: -0.060669
linear_acceleration_covariance: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
---

the GPS data is here:
---
header: 
  seq: 23
  stamp: 
    secs: 21
    nsecs:     93000
  frame_id: "/gps"
status: 
  status: 1
  service: 1
latitude: 47.347427
longitude: 8.721068
altitude: nan
position_covariance: [0.64, 0.0, 0.0, 0.0, 0.64, 0.0, 0.0, 0.0, 2.56]
position_covariance_type: 0
---

I really hope Tom Moore can help me,thank you very much.
All the files I metioned above can be downlaoded from here:google drive

Originally posted by omoyouo on ROS Answers with karma: 1 on 2018-03-04
Post score: 0

Original comments
Comment by omoyouo on 2018-03-09:
the new bag file is here:NEW_bagfile

A:

I haven't looked at the bag data, but just a few things I note looking at your data and configuration.

Linear acceleration: I'd set them all to false for your IMU. The filter does not have active bias correction, so unless you have a velocity reference (e.g., wheel encoder or visual odometry), the integration of acceleration data will cause your state estimate to start running away rapidly. It'll snap back whenever it gets a GPS measurement, but the state estimate will get progressively worse.

Change your IMU message frame_id to imu_link. Also, what units are your IMU velocities and the static_transform_publisher in? ROS uses radians, and those look suspiciously like degrees.

If your IMU is mounted as you say, then I'd expect this. Keep in mind that tf and tf2 assume that the order is X Y Z yaw pitch roll, though I believe they are applied extrinsically with roll, then pitch, then yaw. Experiment with values here and look at the frame in rviz to confirm.
<node pkg="tf2_ros" type="static_transform_publisher" name="transform" args="0 0 0 -1.5707963268 0 -1.5707963268  base_link imu_link" />

Get rid of the leading slash in your GPS message.

Did you define a base_link->gps transform? You're going to need one, if you gave your GPS message a frame_id. There is a bug at the time of this writing, though, so I suggest making the transform the identity (all zeros) for now. Also, get rid of the leading slash in your GPS frame ('/gps').

Originally posted by Tom Moore with karma: 13689 on 2018-03-19
This answer was ACCEPTED on the original site
Post score: 1


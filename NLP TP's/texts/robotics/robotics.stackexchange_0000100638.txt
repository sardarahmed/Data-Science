Q:

Using robot_localization package does not filter odometry noise

Hello.
I'm trying to implement fusion of visual odometry (stereocamera) and IMU using the robot_localization package (EKF) for my autonomous robot vehicle. I've customized the ekf_template.yaml file with respect to my configuration, especially the input topics and matrices.
To verify, that the robot_localization package does its job well, I've added a random noise to the y pose coordinate of the visual odometry messages. However, the result is not satisfactory. In fact, the fused pose (published on the /odometry/filtered topic) does not improve the noisy odometry information at all!
I've also tried to change values in the process_noise_covariance parameter of the .yaml file, but couldn't get better results either. Unfortunately, I couldn't find a tutorial showing configuration of this matrix.
Here is my ekf_template.yaml:
frequency: 10
silent_tf_failure: false
sensor_timeout: 0.1
two_d_mode: true
transform_time_offset: 0.0
transform_timeout: 0.0
print_diagnostics: true
debug: false
publish_tf: true
publish_acceleration: false

odom_frame: odom
base_link_frame: imu
world_frame: odom

odom0: noisy_odom
odom0_config: [true,  true,  false,
           false, false, true,
           false, false, false,
           false, false, false,
           false, false, false]
odom0_queue_size: 2
odom0_nodelay: false
odom0_differential: false
odom0_relative: false
odom0_pose_rejection_threshold: 5
odom0_twist_rejection_threshold: 1

imu0: imu/data
imu0_config: [false, false, false,
          false,  false,  true,
          false, false, false,
          false,  false,  true,
          true,  false,  false]
imu0_nodelay: false
imu0_differential: false
imu0_relative: true
imu0_queue_size: 5
imu0_pose_rejection_threshold: 0.8
imu0_twist_rejection_threshold: 0.8
imu0_linear_acceleration_rejection_threshold: 0.8
imu0_remove_gravitational_acceleration: true

use_control: false
stamped_control: false
control_timeout: 0.2
control_config: [false, false, false, false, false, false]

process_noise_covariance: [0.05, 0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                       0,    0.05, 0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                       0,    0,    0.06, 0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                       0,    0,    0,    0.03, 0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                       0,    0,    0,    0,    0.03, 0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                       0,    0,    0,    0,    0,    0.06, 0,     0,     0,    0,    0,    0,    0,    0,    0,
                       0,    0,    0,    0,    0,    0,    0.025, 0,     0,    0,    0,    0,    0,    0,    0,
                       0,    0,    0,    0,    0,    0,    0,     0.025, 0,    0,    0,    0,    0,    0,    0,
                       0,    0,    0,    0,    0,    0,    0,     0,     0.04, 0,    0,    0,    0,    0,    0,
                       0,    0,    0,    0,    0,    0,    0,     0,     0,    0.01, 0,    0,    0,    0,    0,
                       0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0.01, 0,    0,    0,    0,
                       0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0.02, 0,    0,    0,
                       0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0.01, 0,    0,
                       0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0.01, 0,
                       0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0.015]

initial_estimate_covariance: [1e-9, 0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                          0,    1e-9, 0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                          0,    0,    1e-9, 0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                          0,    0,    0,    1e-9, 0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                          0,    0,    0,    0,    1e-9, 0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                          0,    0,    0,    0,    0,    1e-9, 0,    0,    0,    0,     0,     0,     0,    0,    0,
                          0,    0,    0,    0,    0,    0,    1e-9, 0,    0,    0,     0,     0,     0,    0,    0,
                          0,    0,    0,    0,    0,    0,    0,    1e-9, 0,    0,     0,     0,     0,    0,    0,
                          0,    0,    0,    0,    0,    0,    0,    0,    1e-9, 0,     0,     0,     0,    0,    0,
                          0,    0,    0,    0,    0,    0,    0,    0,    0,    1e-9,  0,     0,     0,    0,    0,
                          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     1e-9,  0,     0,    0,    0,
                          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     1e-9,  0,    0,    0,
                          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     1e-9, 0,    0,
                          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    1e-9, 0,
                          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    1e-9]

A message sample from odometry:
header: 
  seq: 219
  stamp: 
    secs: 1602168731
    nsecs:  67815813
  frame_id: "odom"
child_frame_id: "base_link"
pose: 
  pose: 
    position: 
      x: 0.000417153039189
      y: -0.00140407813807
      z: -0.000755594158258
    orientation: 
      x: -0.00101575056942
      y: -0.000639465454431
      z: 0.000149149720833
      w: 0.999999268544
  covariance: [4.407756932778284e-06, 6.622276487178169e-07, -1.165842377304216e-06, -1.4342425913582701e-07, -3.320713801713282e-07, 8.988900646045295e-08, 6.622282171520055e-07, 2.9475347673724173e-06, -5.474263957694347e-07, -1.3079514360470057e-07, -1.6424715454377292e-07, -4.2863163685069594e-07, -1.1658424909910536e-06, -5.47426282082597e-07, 1.3725962162425276e-06, 1.1595525961638486e-07, 3.653719886642648e-07, 5.840940886514545e-08, -1.4342430176839116e-07, -1.3079514360470057e-07, 1.1595529514352165e-07, 2.0272929646125704e-07, 5.668728420005209e-08, 4.390295771372621e-08, -3.320714654364565e-07, -1.6424715454377292e-07, 3.653719886642648e-07, 5.668727709462473e-08, 1.4853210927867622e-07, 2.3355827494242476e-08, 8.988885724647844e-08, -4.2863172211582423e-07, 5.840946926127799e-08, 4.390295771372621e-08, 2.335584170509719e-08, 9.884961826855942e-08]
twist: 
  twist: 
    linear: 
      x: 0.0
      y: 0.0
      z: 0.0
    angular: 
      x: 0.0
      y: 0.0
      z: 0.0
  covariance: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
---

A message sample from /noisy_odom:
header: 
  seq: 1273
  stamp: 
    secs: 1602168731
    nsecs: 101187813
  frame_id: "odom"
child_frame_id: "base_link"
pose: 
  pose: 
    position: 
      x: 0.000364238785219
      y: 0.0274764896951
      z: -0.000780172737499
    orientation: 
      x: -0.000771550235511
      y: -0.00051748278757
      z: 2.71116229165e-05
      w: 0.999999568093
  covariance: [4.446595085028093e-06, 6.682002435809409e-07, -1.176394903268374e-06, -1.4465334174929012e-07, -3.3499100027256645e-07, 9.068993023220173e-08, 6.682009825453861e-07, 2.9739057936239988e-06, -5.523118602468458e-07, -1.3199070281189051e-07, -1.657172106206417e-07, -4.324474787154031e-07, -1.176395699076238e-06, -5.523119739336835e-07, 1.384984670949052e-06, 1.169998427030805e-07, 3.6865094443783164e-07, 5.891514121003638e-08, -1.4465354070125613e-07, -1.3199075965530938e-07, 1.1699993507363615e-07, 2.0452264948289667e-07, 5.718816709077146e-08, 4.428655131505366e-08, -3.3499117080282304e-07, -1.657172106206417e-07, 3.6865085917270335e-07, 5.7188142221775706e-08, 1.4985002394496405e-07, 2.356335038200541e-08, 9.068969575309893e-08, -4.3244759240224084e-07, 5.891520160616892e-08, 4.42865442096263e-08, 2.3563362816503286e-08, 9.97231239807661e-08]
twist: 
  twist: 
    linear: 
      x: 0.0
      y: 0.0
      z: 0.0
    angular: 
      x: 0.0
      y: 0.0
      z: 0.0
  covariance: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
---

A message sample from /imu/data:
header: 
  seq: 3005
  stamp: 
    secs: 1602168731
    nsecs: 107441902
  frame_id: "imu"
orientation: 
  x: 0.00127810183888
  y: 0.00827816998698
  z: -0.0321188167373
  w: 0.999448958161
orientation_covariance: [0.01745, 0.0, 0.0, 0.0, 0.01745, 0.0, 0.0, 0.0, 0.15708]
angular_velocity: 
  x: 0.00332654227867
  y: 0.00689090706163
  z: -0.00970761734675
angular_velocity_covariance: [0.0004, 0.0, 0.0, 0.0, 0.0004, 0.0, 0.0, 0.0, 0.0004]
linear_acceleration: 
  x: 0.00023427605629
  y: 0.000261500477791
  z: 0.0244922190905
linear_acceleration_covariance: [0.0004, 0.0, 0.0, 0.0, 0.0004, 0.0, 0.0, 0.0, 0.0004]
---

I use static transformation from imu to base_link in the ekf_template.launch file:
<launch>
  <node pkg="robot_localization" type="ekf_localization_node" name="ekf_se" clear_params="true">
    <rosparam command="load" file="$(find robot_localization)/params/ekf_template.yaml" />

    <!--  Placeholder for output topic remapping
    <remap from="odometry/filtered" to=""/>
    <remap from="accel/filtered" to=""/>
    -->

  </node>

  <node pkg="tf" type="static_transform_publisher" name="imu_to_base_link" args="0 0 0 0 0 0 base_link imu 100" />

</launch>

Transformation for the camera isn't needed, as it's location is identical with the base_linkframe.
Is there a chance that I'd be able to tune the process_noise_covariance matrix in order to get better results? Or is there anything else in the configuration that should be done other way?
I'd be thankful for any help!
P.S.: I use ROS Noetic distro.

Originally posted by bugino on ROS Answers with karma: 11 on 2021-11-22
Post score: 1

Original comments
Comment by osilva on 2021-11-26:
Hi @bugino, I recently answered a similar question in general terms: https://answers.ros.org/question/391483/process_noise_covariance-and-initial_estimate_covariance-in-ekf-global-and-ekf-local/
You are following the right steps. Adjustment of these parameters is a bit of more art than science. However there are systematic ways to adjust them, please refer to the papers in the answer to get some ideas.

A:

An EKF isn't going to necessarily clean up noise in your data. Every time the EKF processes a measurement, it's just doing fancy (optimal) weighted averaging between its current state and the measurement you gave it. How much weight is given to each is determined by their relative covariance values.
So it goes something like this:

Your EKF gets a new measurement. It carries out a prediction from its last updated time to the time of the measurement. As part of that prediction, it adds the process_noise_covariance (scaled by the time delta) to the current state covariance.
It then computes the weights (Kalman Gain) using the relative covariance of the state and the measurement you just gave it, and then combines the weighted current state and the weighted measurement into a new state.

So the two quantities that matter w.r.t. how much a given measurement is "trusted" are the process_noise_covariance and the covariance in the message itself.
Let's look at just the X variance in your messages. In the raw odometry message, you have an X variance of 4.407756932778284e-06, which is a standard deviation of 0.0021. Your X variance in your process_noise_covariance is set to 0.05, which is a standard deviation of 0.2236. Let's say your odometry is published at 10 Hz. That means you'd likely be looking at a state with an X standard deviation of at least 0.02236, which is an order of magnitude larger than your measurement covariance. So when the new state is computed, you're telling the filter to trust the odometry measurement at least 10x more than its predicted state.
Secondly, you said you added noise to the measurement. The variance from your noisy measurement is 4.446595085028093e-06, which is pretty much identical to the original odometry message. If you are adding noise to the values, then that error needs to be represented in the covariance. Otherwise, your measurement is lying.
Finally, your odometry data has tiny covariance values for pose data. But if your robot is driving around for a long time, the pose covariance from odometry should grow without bound. If it was providing the velocity (twist) data, then those covariance values might be more or less static, but what you're telling the filter is that no matter how far the robot travels, the X standard deviation on the odometry pose is only 0.0021.
EDIT in response to comment.

Although, I am still quite ambiguous about which input data is used for a prediction step and which one for a correction

At least in r_l, no specific sensor is used for prediction or correction. Every sensor measurement causes both steps to happen. Let's pretend we have an EKF with a state vector that is just [X, Y, Z, X velocity, Y velocity, Z velocity].

Initialize filter to some value at time t0. We'll use [0, 0, 0, 0, 0, 0].
Receive measurement from sensor A at time t1. Sensor A is configured to just give us X velocity. The measurement has a value of X velocity = 2.
Carry out a prediction from time t0 to t1 using our motion model. Predicted state will still be [0, 0, 0, 0, 0, 0] because the robot had 0 velocity in the previous step.
Carry out a correction. Let's say we end up with a state of [0, 0, 0, 1.8, 0, 0].
Now we get a measurement from sensor B at time t2. Sensor B is configured to just give us Z position. The measurement has a value of Z = -1.
Carry out a prediction from time t1 to t2. Predicted state is, say, [0.6, 0, 0, 1.8, 0, 0]. Note the non-zero X position value that happened as a result of our kinematic model and the X velocity.
Carry out a correction. We'll say our new state is [0.6, 0, -0.7, 1.8, 0, 0].

I am glossing over a lot of things here, but the point to take away is that measurements arrive in a sequence, and for each measurement, we predict to the time of that measurement, then use that measurement to correct the prediction.

Originally posted by Tom Moore with karma: 13689 on 2021-12-22
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by martinlucan on 2022-01-25:
Thank you @Tom Moore for the explanation. Although, I am still quite ambiguous about which input data is used for a prediction step and which one for a correction. Let's assume, we use the same sensor setup as stated in a question - visual odometry from the stereo camera and IMU data. Does the choice of input to particular EKF steps depend on the type of information (position, velocities, accel) or the data uncertainty? E.g. more uncertain data are used for a prediction, while more precise data for correction step? May the user somehow assign the odometry source to EKF steps?


Q:

Filling sensor_msgs/Image with uint8_t buffer array

So I'm working on making a camera driver, and the data struct contains the frame data such as the height and width, and uint8_t leftData  and uint8_t rightData pointers. Ive been trying to see which way would be the best way to just fill simple fill in the sensor_msgs/Image message i create, but i cannot seem to find how to do it.
Here is what i have tried so far:
    leftImage.height                = pFrameData->height;
    leftImage.width                 = pFrameData->width;
    leftImage.encoding              = sensor_msgs::image_encodings::MONO8;
    leftImage.step                  = 64;
    leftImage.data                  = pFrameData->leftData;

But with that i get a error saying "no viable overloaded '=' "
Then after searching around i found people linking to the sensor_msgs::fillImage() header, and tried to use the memcpy method, but that did not work either (i got a seg fault)
Then i tried using the cv::Mat constructor to see if i could at LEAST somehow get a image to publish, by passing the size, type, and data pointer (pFrameData->leftData).
No luck with any of them. Im really new to opencv, cv_bridge, and camera related things in general. Would someone be able to guide me in the right direction?
Here is a example buffer for the left camera if i just print to the screen: 0x7ff7549ea800
EDIT 1:
Here is my frame callback function (after trying ahendrix's solution, which gave a malloc error which i put in comments below):
void frameCallback(const PFrame pFrameData)
{
    leftImage.header.stamp            = ros::Time::now();
    leftImage.header.frame_id       = "camera";
    leftImage.height                      = pFrameData->height;
    leftImage.width                       = pFrameData->width;
    leftImage.encoding                  = sensor_msgs::image_encodings::MONO8;
    leftImage.step                         = 64;

    const int image_size = pFrameData->height * pFrameData->width;
    leftImage.data.reserve(image_size);

    for( int i=0; i < image_size; i++ )
    {
            leftImage.data.push_back(pFrameData->leftData[i]); 
    }
 }

Originally posted by l0g1x on ROS Answers with karma: 1526 on 2014-10-29
Post score: 0

A:

So after @ahendrix helped explaining a few things, i ended up using the sensor_msgs::fillImage() function to store my left/right camera buffer data into a sensor_msgs::Image.
Here is my code:
    ros::Time       timeNow         = ros::Time::now();
    std::string     frame           = "camera";

    leftImage.header.stamp          = timeNow;
    leftImage.header.frame_id       = frame;

    rightImage.header.stamp         = timeNow;
    rightImage.header.frame_id      = frame;

    // Fill the left image message
    sensor_msgs::fillImage( leftImage,
                            sensor_msgs::image_encodings::MONO8,
                            240, // height
                            320, // width
                            320, // stepSize
                            pFrameData->leftData);

    // Fill the right image message
    sensor_msgs::fillImage( rightImage,
                            sensor_msgs::image_encodings::MONO8,
                            240, // height
                            320, // width
                            320, // stepSize
                            pFrameData->rightData);

    leftImagePub.publish(leftImage);
    rightImagePub.publish(rightImage);

    sensor_msgs::clearImage(leftImage);
    sensor_msgs::clearImage(rightImage);

If you look in the sensor_msgs::fillImage() the step size (in my case) was the width of the image; the total amount of columns your image has.
inside the fillImage() you will see that a size_t st0 is created by multiplying the step size (which we said is the width) * rows (height of the image), which will create a size and then allocate the total amount of pixels your image has.

Originally posted by l0g1x with karma: 1526 on 2014-10-29
This answer was ACCEPTED on the original site
Post score: 1


Q:

link to opencv2 in kinetic

Hello! I am using ROS Kinetic on Ubuntu 16.04 Xenial 64bit. I have installed both opencv2 (by libopencv-dev) and opencv3 (by ros-kinetic-opencv3). A project of mine depends on cv_bridge, the problem is: by compilation opencv3 is always linked instead of opencv2 that is acutally needed, although in CMakeLists.txt I have explicitly indicated to use opencv2:
find_package(OpenCV 2.4.9.1 EXACT REQUIRED)
I also tried:
find_package(OpenCV 2 REQUIRED)
but it failed too. If I remove the dependency of cv_bridge in CMakeLists.txt, opencv2 is correctly linked, but the compilation complains the lack of cv_bridge library. Any suggestion or experience on this issue? Thanks in advance!
PS: when I output the path where the opencv2 header files are found to be stored in CMakeLists.txt:
message( STATUS "OpenCV Include Dir: " ${OpenCV_INCLUDE_DIRS} )
it gives me a weird result:
/usr/include/opencv/usr/include
although it does not break the compilation when the dependency on cv_bridge is removed.

Originally posted by mikegao88 on ROS Answers with karma: 31 on 2017-05-17
Post score: 2

Original comments
Comment by lakehanne on 2017-05-18:
Please mark the answer as correct if it answer your question.
Comment by mikegao88 on 2017-05-19:
Unfortunately, it does not. Actually, the workaround is to clone cv_bridge source, and switch it to indigo branch to force it to link against opencv2, then compile it, and everything is ok again.
Comment by zaddan on 2017-10-23:
I installed cv_brdige from source and switched to indigo branch as suggested, but it seems like I am still using ros-kinetic-opencv3 because when I run my program, I get an error with the following line:
"file /tmp/binarydeb/ros-kinetic-opencv3-3.2.0/modules/core/src/matrix.cpp terminate". Any idea?

A:

Adapted from this wiki:
If you have OpenCV2 and OpenCV3 installed, find_package(OpenCV) in CMake will first find OpenCV3.
If you want to explicitly link to OpenCV2, use find_package(OpenCV 2).
If you have OpenCV2 and OpenCV3 installed, OpenCV3 is not on your path: libraries and headers are renamed to only be visible through CMake. Python is the only exception but you can use the guide below to get your code to work with both.
Just like with any library, you have to be careful that your binary does not link/includes directly or indirectly (through a dependency) to both OpenCV2 and OpenCV3.
Python:
    import cv2
    from distutils.version import LooseVersion
    if LooseVersion(cv2.__version__).version[0] == 2:
    # Whatever OpenCV2 code
    else:
     # Whatever OpenCV3 code

C++:
   #include "opencv2/core/version.hpp"
   #if CV_MAJOR_VERSION == 2
   // do opencv 2 code
   #elif CV_MAJOR_VERSION == 3
  // do opencv 3 code
  #endif

CMake:
if(OpenCV_VERSION VERSION_LESS "3.0")
# use 2.4 modules
else()
# use 3.x modules
endif()

Package.xml:
Instead of depending on opencv3, you should depend on cv_bridge or image_geometry. Depending on one of those two keys transitively makes you depend on libopencv-dev on Jade and below, or opencv3 on Kinetic and above.
image_pipeline will only pull in sensor_msgs as an extra dependency while cv_bridge will also pull in boost, python and rosconsole so it depends on whether you go for something small or something you need.
Building the OpenCV package
See this wiki.

Originally posted by lakehanne with karma: 152 on 2017-05-17
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by joq on 2018-01-02:
An informative answer, but the question was: how to use OpenCV2 on Kinetic? Depending on cv_bridge forces the program to use OpenCV3, so it seems that dependency must be removed for the OpenCV2 code to compile, link and run.


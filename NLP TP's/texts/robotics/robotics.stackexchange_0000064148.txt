Q:

rosjava network configuration

Hi I am using rosjava to pub/sub topics between different computers however I can list the topic but can not echo the message. I referred to this post but the link to the solution is not available now. Does any one know how to solve it.
By the way I test the network using turtlesim it works ok but just can not work in rosjava. Under java, the rostopic list -a command gives the following output:
http://127.0.0.1:43190/     rosjava_tutorial_pubsub/talker
Here is the java code I use, the main java file is used to run the node alone, and need the class name of the node that I want to execute, which is the talker class. The talker and the master run on one computer, I just use rostopic to check the talker on another computer.
main
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import org.ros.address.InetAddressFactory;
import org.ros.exception.RosRuntimeException;
import org.ros.internal.loader.CommandLineLoader;
import org.ros.node.DefaultNodeMainExecutor;
import org.ros.node.NodeConfiguration;
import org.ros.node.NodeMain;
import org.ros.node.NodeMainExecutor;

import java.net.URI;

import static java.lang.System.exit;

public class tstAlone {
    public static void printUsage() {
        //the jar file is the one with the main class and also the node classes that need to be executed, the
        //arg behind jar is the name of the node or nodemain class
        System.err.println("Usage: java -jar my_package.jar com.example.MyNodeMain [args]");
    }

    public static void main(String[] argv) throws Exception {
        if (argv.length == 0) {
            printUsage();
            exit(1);
        }
        CommandLineLoader loader = new CommandLineLoader(Lists.newArrayList(argv));
        String nodeClassName = loader.getNodeClassName();
        System.out.println("Loading node class: " + loader.getNodeClassName());
        NodeConfiguration nodeConfiguration = loader.build();

        NodeMain nodeMain = null;
        try {
            nodeMain = loader.loadClass(nodeClassName);
        } catch (ClassNotFoundException e) {
            throw new RosRuntimeException("Unable to locate node: " + nodeClassName, e);
        } catch (InstantiationException e) {
            throw new RosRuntimeException("Unable to instantiate node: " + nodeClassName, e);
        } catch (IllegalAccessException e) {
            throw new RosRuntimeException("Unable to instantiate node: " + nodeClassName, e);
        }
        Preconditions.checkState(nodeMain != null);
        String host = InetAddressFactory.newNonLoopback().getHostAddress()
                .toString();
        final NodeMainExecutor nodeMainExecutor = DefaultNodeMainExecutor.newDefault();
        nodeConfiguration.newPublic(host,URI.create("http://IPofMaster:11311/"));
        nodeMainExecutor.execute(nodeMain, nodeConfiguration);
    }

}

the talker
import org.ros.concurrent.CancellableLoop;
import org.ros.namespace.GraphName;
import org.ros.node.AbstractNodeMain;
import org.ros.node.ConnectedNode;
import org.ros.node.NodeMain;
import org.ros.node.topic.Publisher;

    public class TalkerOri extends AbstractNodeMain {

        @Override
        public GraphName getDefaultNodeName() {
            return GraphName.of("rosjava_tutorial_pubsub/talker");
        }

        @Override
        public void onStart(final ConnectedNode connectedNode) {
            System.out.println(connectedNode.getUri().toString());

            final Publisher<std_msgs.String> publisher =
                    connectedNode.newPublisher("chatter", std_msgs.String._TYPE);

            std_msgs.String str = publisher.newMessage();
            str.setData("H++++++++++++++++++++++++++++++ello world! ");
            publisher.publish(str);

            // This CancellableLoop will be canceled automatically when the node shuts
            // down.
            connectedNode.executeCancellableLoop(new CancellableLoop() {
                private int sequenceNumber;

                @Override
                protected void setup() {
                    sequenceNumber = 0;
                }

                @Override
                protected void loop() throws InterruptedException {
                    std_msgs.String str = publisher.newMessage();
                    str.setData("**************Hello world! " + sequenceNumber);
                    publisher.publish(str);
                    sequenceNumber++;
                    Thread.sleep(1000);
                }
            });
        }
    }

Solution code:
public class newMain {

    public static void main(String[] args) throws InterruptedException {

        String host = InetAddressFactory.newNonLoopback().getHostAddress()
                .toString();

        NodeConfiguration configuration = NodeConfiguration.newPublic(host,
                URI.create("http://localhost:11311"));
            TalkerOri talker = new TalkerOri();
        final NodeMainExecutor runner = DefaultNodeMainExecutor.newDefault();
        configuration.setNodeName("myNodeName1");
        runner.execute(talker, configuration);
    }
}

Originally posted by hjh on ROS Answers with karma: 58 on 2014-11-20
Post score: 0

A:

I'm not to sure if this is directly related to your issue, and how exactly your nodes are implemented, but when I launch my own Rosjava nodes in a distributed setup, each node needs a NodeConfiguration where I have to give the IP of the system the node is running on. If I set it wrong, the node comes up and registers, but I can't send and recieve messages.
Here is my method, with which I launch my node:
public void run() {
        if (this.isRunning == false) {
            NodeConfiguration configuration = null;
            try {
                if (RosValues.ros_master_uri.compareTo("") == 0) {
                    // IF ROSCORE IS RUNNING ON SAME MACHINE AS THIS NODE, E.G.
                    // ALL IN JAVA, USE THE FOLLOWING
                    configuration = NodeConfiguration.newPublic("127.0.0.1");
                } else {
                    // IF ROSCORE IS RUNNING ON ANOTHER MACHINE AS THIS NODE,
                    // E.G. ON ANOTHER LINUX, USE THE FOLLOWING
                    configuration = NodeConfiguration.newPublic(
                            RosValues.this_host, new URI(
                                    RosValues.ros_master_uri));
                }
                this.nodeExecutor.execute(this, configuration);
                this.isRunning = true;
                System.out.println("(II) ROS node " + this.nodeName
                        + " is running and registered on "
                        + configuration.getMasterUri());
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

RosValues.this_host is a string with my IP address, and the NodeExecutor gets initilized like this:
private NodeMainExecutor nodeExecutor = DefaultNodeMainExecutor.newDefault();

Originally posted by Rabe with karma: 683 on 2014-11-21
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by hjh on 2014-11-21:
thank you very much for your reply. In the main java file I do assign the host IP of the talker to the node that is :
nodeConfiguration.newPublic(host,URI.create("http://IPofMaster:11311/"));
the host variable is the host IP, but still the same as before.
Comment by hjh on 2014-11-21:
I finally got it run. If I use the running code in the solution part of my question it goes all well. But I am not sure what is the problem. Thank you!!


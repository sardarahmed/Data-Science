Q:

Moveit control gripper instead of panda_link8 EFF

I'm currently trying to execute a grasp pose, which I computed using a CNN, on the Panda Emika Franka Robot using Moveit. Unfortunately, the panda_moveit_config and franka_ros packages didn't specify the panda_hand link as a move_group end effector in their urdf's/srdf's. I, therefore, have to control the robot using the panda_link8 joint instead. Based on the following topics how-to-plan-moves-with-gripper-attached-to-arm and openclose-end-effector-with-moveit-rviz. I found two ways of solving my problem.

Transform the grasp pose (using the tf2 package) in such a way that the gripper centre aligns with the computed grasp pose.
Modify the urdfs/srdfprovided by panda_moveit_config and franka_ros to include an extra (virtual) link that ends in the middle of the gripper, making controlling the arm plus gripper easier. Virtual in the sense that it has no mass,  inertia, visual geometry and collision geometry.

UPDATE: I am currently using method 2.
Method 1: Use the tf2 package
Using the tf2 package, I try to correct for the fact that I am planning using the panda_link8 frame as the end effector. I do this by calculating the transformation between the panda_link8 frame and the gripper_center frame (trans_grip_center_p8). I then transform the grasping pose which was computed initially in the kinect2_rgb_optical_Frame to the panda_link8 frame. After the pose is expressed in the panda_link8 frame I transform both the pose and the trans_grip_center_p8 transformation message into a 4x4 homogeneous transformation matrix. I following take the inverse of the trans_grip_center_p8transformation matrix and multiply this with the pose. Lastly, I transform this new pose to the panda_link0 frame, which is used as the reference frame in my move_group. Unfortunately, I did something wrong in my reasoning since using the new corrected pose (depicted in purple) the end effector still does not end up in the right pose (Depicted in blue).
What I tried:

Not taking the inverse.
Using the self.tf2_buffer.transform directly. And afterward setting the pose.header.frame_id to the old frame (Before the transform).

Wrong pose
](/upfiles/15708151267919294.png)
Code
Main code
## Get transform between panda_link8 and gripper centre ##
    try:
        trans_grip_center_p8 = self.tf2_buffer.lookup_transform("panda_link8", "gripper_center", rospy.Time(0))
    except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
        return False

    ## Get pose expressed in the panda_link8 frame ##
    try:
        pose_msg = self.tf2_buffer.transform(self.pose_msg, "panda_link8", rospy.Duration(1))
    except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
        return False

    ## Transform grasp pose such that it aligns with the gripper_center frame ##
    # This is needed since the move_group uses the panda_link8 frame as its
    # end-effector.

    ## Transform transformation to 4x4 homogeneous matrix ##
    H_trans = conversions.transform_stamped_2_matrix(trans_grip_center_p8)
    H_trans = tf_conversions.transformations.inverse_matrix(H_trans) # Use inverse to correct for planning in the wrong EEF
    H_pose = conversions.pose_msg_stamped_2_matrix(pose_msg)

    ## New Pose ##
    pose_new = np.dot(H_trans, H_pose)
    trans = tf_conversions.transformations.translation_from_matrix(pose_new)
    rot = tf_conversions.transformations.quaternion_from_matrix(pose_new)
    pose_msg.pose.position.x = trans[0]
    pose_msg.pose.position.y = trans[1]
    pose_msg.pose.position.z = trans[2]
    pose_msg.pose.orientation.x = rot[0]
    pose_msg.pose.orientation.y = rot[1]
    pose_msg.pose.orientation.z = rot[2]
    pose_msg.pose.orientation.w = rot[3]
    # pose_msg = tf2_geometry_msgs.do_transform_pose(pose_msg, trans_grip_center_p8)

    ## Get pose expressed in the panda_link0 frame ##
    # Needed since the panda_link0 is the reference frame
    # of the move group.
    try:
        pose_msg = self.tf2_buffer.transform(pose_msg, "panda_link0", rospy.Duration(1))
    except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
        return False

    ## Display pose in panda_link0 frame ##
    position = pose_msg.pose.position
    orientation = pose_msg.pose.orientation
    pose_array = [position.x, position.y, position.z, orientation.x, orientation.y, orientation.z, orientation.w]
    rospy.logdebug("Grasp pose result in panda_link0: x={0}, y={1}, z={2}, q1={3}, q2={4}, q3={5} and q4={6}".format(*pose_array))

    ## Publish transformed pose ##
    self.pose_pub.publish(pose_msg)

    ## Call grasp plan to pose service ##
    result = self.plan_to_pose_srv(pose_msg.pose)

    ## Test if successful ##
    if result.success:
        return True
    else:
        return False

Used functions
def transform_stamped_2_matrix(transform_stamped):
    """Generate 4x4 homogeneous transformation matrix from a transform_stamped msg.

    Parameters
    ----------
    transform_stamped : geometry_msgs.msg.TransformStamped
        Stamped transform.

    Returns
    -------
    np.array()
        Homogeneous 4x4 transformation matrix.
    """

    ## Unpack transform stamped object ##
    trans_obj = transform_stamped.transform.translation
    rot_obj = transform_stamped.transform.rotation
    trans = tf_conversions.transformations.translation_matrix(
        [trans_obj.x, trans_obj.y, trans_obj.z])
    rot = tf_conversions.transformations.quaternion_matrix(
        [rot_obj.x, rot_obj.y, rot_obj.z, rot_obj.w])

    ## Generate homogeneous transformation matrix ##
    H = np.dot(trans, rot)

    ## Return homogeneous transformation matrix ##
    return H

def pose_msg_stamped_2_matrix(pose_msg):
    """Generate 4x4 homogeneous transformation matrix from a pose_stamped msg.

    Parameters
    ----------
    pose_msg : geometry_msgs.msgs.PoseStamped
        Stamped pose message.

    Returns
    -------
    np.array
        Homogeneous 4x4 transformation matrix.
    """

    ## Unpack transform stamped object ##
    position_obj = pose_msg.pose.position
    rot_obj = pose_msg.pose.orientation
    trans = tf_conversions.transformations.translation_matrix(
        [position_obj.x, position_obj.y, position_obj.z])
    rot = tf_conversions.transformations.quaternion_matrix(
        [rot_obj.x, rot_obj.y, rot_obj.z, rot_obj.w])

    ## Generate homogeneous transformation matrix ##
    H = np.dot(trans, rot)

    ## Return homogeneous transformation matrix ##
    return H

Method 2: Modify the urdf/srdf in the franka_ros and panda_moveit_config packages
Add a extra panda_gripper_center (virtual) link to the urdfs/srdfprovided by panda_moveit_config and franka_ros. Following, in my control script I set the movegroup end effector to this new (virtual) link.
Additional info
Launch File
To start the robot I use the demo.launch file provided by the panda_moveit_config.

Originally posted by rickstaa on ROS Answers with karma: 111 on 2019-10-08
Post score: 1

Original comments
Comment by gvdhoorn on 2019-10-08:\

quat_pose = Quaternion(pose_msg.pose.orientation.w, pose_msg.pose.orientation.x, pose_msg.pose.orientation.y, pose_msg.pose.orientation.z)

What sort of Quaternion is that? Eigen?

Unfortunately, the panda_moveit_config and franka_ros packages didn't specify the panda_hand link as a move_group end effector in their urdf's/srdf's. I, therefore, have to

why do you "have to"? I'm not saying it's going to necessarily solve everything for you, but this is open-source. Clone the sources and add the end-effector to the moveit configuration.
And can't you use doTransform(..) instead of manually transforming the Pose object? See #q261419 fi and the linked tutorial.
Comment by rickstaa on 2019-10-08:\

What sort of Quaternion is that? Eigen?

Ah ofcourse, sorry. It is the Quaternion class of the pyquaternion package. I also tried it with the tf_conversions package:
quat_old = [pose_msg.pose.orientation.x, pose_msg.pose.orientation.y, pose_msg.pose.orientation.z, pose_msg.pose.orientation.w]
quat_diff = [trans_p8_grip_center.transform.rotation.x, trans_p8_grip_center.transform.rotation.y, trans_p8_grip_center.transform.rotation.z, trans_p8_grip_center.transform.rotation.w]
quat = tf_conversions.transformations.quaternion_multiply(quat_diff, quat_old)

but as expected this gives me the same result.
Comment by rickstaa on 2019-10-08:\

why do you "have to"?

Your right, sorry for that, I could have said that differently. I tried changing the urdfs and srdfs, but I resorted to the second method since I ran into some problems. I will first reference the sources you send me thanks a lot!
Comment by gvdhoorn on 2019-10-08:
With all your edits I'm no longer sure you weren't already using tf2_geometry_msgs.do_transform_pose(..). If so: sorry for the noise.
Comment by rickstaa on 2019-10-08:
@gvdhoorn No, thank you for your reply! I was updating the original code using the suggestions you made as the manual transform could indeed be replaced by `tf2_geometry_msgs.do_transform_pose(). But had to leave in the middle of it. Sorry for the confusion. The new code already gives the right EFF pose in some cases (See updated answer). I, therefore, think to start there was an error in the way I handled the quaternions.
Comment by rickstaa on 2019-10-11:
@gvdhoorn I managed to fix my problem by adding an extra virtual joint to the urdf and srds in the panda_moveit_config and franka_ros. I am, however curious what goes wrong with my reasoning while using the tf2 library to correct for the fact that I am not planning in the panda_gripper_center frame but the panda_link8 frame. I updated my question to depict my reasoning. Let me know if you see some immediate flaws in my reasoning. Otherwise, I will open a new ticket in the future if needed.

A:

In the end, I fixed my issue by using method 2. After changing the urdf and srdf files of panda_moveit_config and franka_ros packages as was suggested by @gvdhoorn, I was able to plan for the gripper_center. The changes I made can be found on the following branches:

rickstaa/franka_ros/tree/melodic-devel-panda_autograsp
rickstaa/panda_moveit_config/tree/melodic-devel-panda_autograsp

With these changes one can now control the gripper relative to the end effector by setting the move_group end effector link to panda_gripper_center.
move_group = self.robot.get_group("panda_arm")
move_group.set_end_effector_link("panda_gripper_center")

Originally posted by rickstaa with karma: 111 on 2019-10-11
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by aPonza on 2020-02-07:
I had this problem in 2018 and solved it via what you call method 1. However, I'm now trying to use the second way for an unrelated thing and looking through the changes in both files I can see you didn't really add hand as an end effector, because that was already the case. You added gripper_center and gripper_center_xyz as a link in the hand. This is different than using the tf2 frame called panda_K, the center of the internal cartesian impedance, which the franka emika team provides, because it's not set at runtime. Are you still using this method or did you manage to use the runtime change?
Comment by rickstaa on 2020-02-18:
@aPonza Your correct, that is precisely what I did in the end and what I am still using now (see most recent version of my project). I first added an extra panda_gripper_center (virtual) link to the urdfs/srdfprovided by panda_moveit_config and franka_ros. Following, in my control script I set the movegroup end effector to this new (virtual) link. I did not yet try the runtime change you describe above. I updated the original question a little bit to make it more clear.


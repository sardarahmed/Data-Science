Q:

Not getting the correct response from the controller serial communication

I am trying to communicate with a Roboteq FBL2360TE brushless motor controller using serial communication, according with the controller's user manual if I send a ?S 1_ command to request the encoder velocity in RPMs I should get something like S=0, but instead I am getting the same command I sent. This is an example code I am using to test:
#include <stdio.h>
#include <string.h>
#include <sstream>
#include <iostream>

#include <libserial/SerialPort.h>

int main(){
    LibSerial::SerialPort serial_comm_;
    float enc1;
    float enc2;

    serial_comm_.Open("/dev/ttyACM0");
    serial_comm_.SetBaudRate(LibSerial::BaudRate::BAUD_115200);

    serial_comm_.FlushIOBuffers();
    std::stringstream msg_to_send;
    msg_to_send << "?S 1_";
    serial_comm_.Write(msg_to_send.str());

    std::string response = "";
    try
    {
        serial_comm_.ReadLine(response, '\r', 1000);
        std::cout << response << std::endl;
    }
    catch(const LibSerial::ReadTimeout&)
    {
        std::cerr << "The ReadByte() call has timed out." << std::endl;
    }

    serial_comm_.Close();

    return 0;
}

Thanks in advance for the help!

A:

I just realized the controller response is actually ?S 1\rS=0\r so with my code I am only getting the first part of the message, so to fix this I just added another serial ReadLine to get both parts of the message like this:
#include <stdio.h>
#include <string.h>
#include <sstream>
#include <iostream>

#include <libserial/SerialPort.h>

int main(){
    LibSerial::SerialPort serial_comm_;
    float enc1;
    float enc2;

    serial_comm_.Open("/dev/ttyACM0");
    serial_comm_.SetBaudRate(LibSerial::BaudRate::BAUD_115200);

    serial_comm_.FlushIOBuffers();
    std::stringstream msg_to_send;
    msg_to_send << "?S 1_";
    serial_comm_.Write(msg_to_send.str());

    std::string command = "";
    std::string response = "";

    try
    {
        serial_comm_.ReadLine(command, '\r', 1000);
        serial_comm_.ReadLine(response, '\r', 1000);
        
        std::cout << command << std::endl;
        std::cout << response << std::endl;
    }
    catch(const LibSerial::ReadTimeout&)
    {
        std::cerr << "The ReadByte() call has timed out." << std::endl;
    }

    serial_comm_.Close();

    return 0;
}

Maybe there is a more elegant way to solve this issue but this works for me at the moment.


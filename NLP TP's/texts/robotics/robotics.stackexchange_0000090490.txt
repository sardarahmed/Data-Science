Q:

how does ros communication works

When does ros calls serialize::read() write() methods? when message is publishing, does it call serialization::write internally? and If I am subscribing to particular type on receiver side, does it call instantiate() or read() method? Lets assume when I publish rosbag::MessageInstance from publisher, and I am subscribed to MsgType, does it call instantiate()? how does it convert ros:MessageInstance to MsgType ?

Originally posted by debonair on ROS Answers with karma: 17 on 2019-02-12
Post score: 0

Original comments
Comment by gregbowers on 2023-06-27:
In ROS, the ros::serialization::read() method is used for deserialization, converting serialized data into a ROS message object. On the other hand, the ros::serialization::write() method is used for serialization, converting a ROS message object into a byte stream.
When you publish a message, ROS internally calls ros::serialization::write() to serialize the message before sending it over the network.
When you subscribe to a particular message type, ROS internally calls the instantiate() method of the message type to create an instance of that message type. Then, it calls the ros::serialization::read() method to deserialize the received byte stream into the instantiated message object.
If you publish a rosbag::MessageInstance from a publisher and subscribe to MsgType on the receiver side, ROS will internally call instantiate() to create an instance of MsgType. Then it will call ros::serialization::read() to deserialize the rosbag::MessageInstance into the MsgType object.
This allows

A:

ROS messages are transferred over TCP as serialized data.
If you're subscribing to normal message type (for example std_msgs/String or whatever), then ros::serialization::Serializer<std_msgs::String>::read() is called by roscpp to deserialize the message, and the deserialized message is passed to your callback.
If you're publishing to normal message type (for example std_msgs/String or whatever), then ros::serialization::Serializer<std_msgs::String>::write() is called after you call publish(), to serialize the message.
If you're publishing and subscribing std_msgs::String::ConstPtr within the same process (often when using nodelets), the serialization and deserialization steps are skipped for messages passed within the same process. (if there are publishers or subscribers outside the process, serialization still happens).
rosbag is a bit of a special case; instead of handling normal messages, it directly handles the serialized data and message description. When rosbag records, it writes the serialized data (and the message MD5) directly to the bag file, without deserialized it (and without needing to be compiled against every message type). When rosbag plays back a file, it advertises with the same MD5 that was used during recording, and then it reads the serialized data and publishes it directly. Deserialization of these messages happens in the subscriber in the normal way (assuming the MD5 still matches).
The rosbag instantiate() is only used in the rosbag C++ API, if you want to read a specific message type from a bag file in C++.

Originally posted by ahendrix with karma: 47576 on 2019-02-12
This answer was ACCEPTED on the original site
Post score: 1


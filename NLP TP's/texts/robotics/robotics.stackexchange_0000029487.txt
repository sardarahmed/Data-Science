Q:

How can I use the navigation stack on a carlike robot?

AFAIK the navigation stack in its current state does not work for a carlike robot. The last time I checked, base_local_planner required the robot to be able to turn in place.
Would I have to implement an alternative to base_local_planner or is there an easier way to make base_local_planner work for carlike robots?

Originally posted by sebsch on ROS Answers with karma: 790 on 2011-02-14
Post score: 9

A:

That's correct, base local planner can only handle holonomic/differential drive robots and assumes roughly circular shape.
The global path currently can be constructed using the sbpl lattice planner.  This planner follows the BaseGlobalPlanner interface, so it will output a valid global path for use by a local planner.  Be sure to check out the list of motion primitives (section 3.1.2).  We have had luck using the unicycle.m and it has generated k-turns for our diff drive robot when we forgot to tell it to turn in place.  Base Local Planner took one look at those and ignored them.  :)
This code will provide a (probably!) valid plan for Ackermann drive vehicles.  Once you have this working, you will need to write your own local planner to take in the desired x, desired y, and desired heading output by the lattice planner.  This is more complicated, but you could easily take a systems approach and calculate x_err, y_err, and yaw_err and then perform some sort of PID approach to the steering.
That's the takes effort to implement approach, so I'm hoping someone else knows of a package to do precise path following as the potential based approach in the base local planner will fail for avoiding obstacles in Ackermann (it wants to descend the gradient each step no matter what, not always possible for a car).  If you do write your own base planner, be sure to follow the interface given.

Originally posted by Chad Rockey with karma: 4541 on 2011-02-20
This answer was ACCEPTED on the original site
Post score: 13


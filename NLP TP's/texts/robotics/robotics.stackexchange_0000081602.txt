Q:

Moveit gets stuck after planning

Hi everyone,
I currently want to send a joint-space goal to my 6DOF arm. move_point is a pointer to my move_group. The command comes from a GUI I wrote and the callback looks like this:
void goal_joint_callback(mybot::joint_command msg){
     ROS_INFO("debug1");
     std::vector<double> joint_group_positions(6);
     joint_group_positions[0] = msg.joint1;  // radians
     joint_group_positions[1] = msg.joint2;
     joint_group_positions[2] = msg.joint3; 
     joint_group_positions[3] = msg.joint4; 
     joint_group_positions[4] = msg.joint5;
     joint_group_positions[5] = msg.joint6;
     ROS_INFO("debug2");
     move_point->setJointValueTarget(joint_group_positions);
     ROS_INFO("debug3");
     bool success = move_point->plan(*current_plan);
     ROS_INFO("debug4");
     ROS_INFO_NAMED("tutorial", "Visualizing plan 2 (joint space goal) %s", success ? "" : "FAILED");
 } 

The goal gets visualized quite nice in rviz and until then everything looks ok.
In my output terminal I can see "debug 1,2,3" but not "debug 4": I am also unable to send additional goals after the first one. I cant really tell why, because the same lines of code (bool success = move_point->plan(*current_plan);) do work at another place with the cartesian path.
Thank you in advance,
Felix

Originally posted by Felix_N on ROS Answers with karma: 115 on 2017-07-02
Post score: 1

A:

Hey Felix_N,
my first guess is a problem with your control flow.
The plan function calls the ROS action provided by the move_group node and waits for the result.
See here.
If you are already in a callback and don't have an additional ROS spinner, the action client will never receive the message it is waiting for.
Try to create (and start) a ros::AsyncSpinner in your main scope before ros::spin().

Originally posted by v4hn with karma: 2950 on 2017-07-03
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by gvdhoorn on 2017-07-03:
Probably related: #q264748 (see the comments).
Comment by Felix_N on 2017-07-05:
You got it. I have a spinner everywhere else but forgot it at that point. Thanks.
Comment by amcelroy on 2017-07-27:
Thanks, this was my issue as well, started and stopped an async spinner in my callback did the trick
Comment by gvdhoorn on 2017-07-28:
@Felix_N and @amcelroy: please note what @v4hn writes:

create [..] a ros::AsyncSpinner in your main scope

main scope != in your callback.
I would refrain from doing any spinning in callbacks. Only in very specific circumstances should this be done.
Comment by amcelroy on 2017-07-28:
@Felix_N and @gvdhoorn - I do have an asyncspinner in my the main function that registers the callback, but for some reason I still had this exact same problem.
My workflow in main is:

ros::init
allocate asyncspinner
start the spinner
register callback / do stuff
ros::waitForShutdown

Comment by v4hn on 2017-07-29:
Notice that waitForShutdown does not spin, so if your asyncspinner does not spin with more than one thread you will still see the problem.
Comment by amcelroy on 2017-07-29:
Wow, ok, thanks so much. Creating AscynSpinner with 2 threads did the trick and allowed for the removal of the aysncspinner in the callback. Is it possible for myself or someone higher up to make a note of this on the Callbacks wiki? http://wiki.ros.org/roscpp/Overview/Callbacks%20and%20Spinning
Comment by v4hn on 2017-07-29:
Oh, I didn't know such a documentation actually exists :)
I added a short comment to the section. Please have a look.


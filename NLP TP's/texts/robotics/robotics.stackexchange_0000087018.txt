Q:

Proper Shutdown handling of node

I have problems shutting down my nodes correctly. Se the following minimal example:
int  main(int argc, char **argv)
{
    ros::init(argc, argv, "mec_sensor_node");
    ros::NodeHandle _oNH;
    while (ros::ok()) {}
    ROS_WARN("Test");
    return 0;
}

If I kill the node (CTRL+C or rosnode kill) the node quits immediately without giving me the chance to do any cleanup. So my question is, how can I achieve this functionality? Using signals is a problem, because I need a function callback. So I thought killing the node makes ros::ok() to fail, such that the node finishes, but that isn't the case, as can be seen via the ROS_WARN command. Any odeas?
EDIT 1:
    int  main(int argc, char **argv)
    {
        ros::init(argc, argv, "mec_sensor_node");
        ros::NodeHandle _oNH;
        ros::spinOnce();
        ros::Rate _oLoopRate(10);
        while (ros::ok()) 
        {
                _oLoopRate.sleep();
        }
        ROS_WARN("Test");
        return 0;
    }

Originally posted by mherrmann on ROS Answers with karma: 9 on 2018-05-18
Post score: 0

Original comments
Comment by Delb on 2018-05-18:
Why is it an issue to have a function callback ?
Comment by gvdhoorn on 2018-05-18:\

while (ros::ok()) {}

This may be a minimal example, but just to note: without a sleep or ros::Rate in there, this is consuming 100% of your cpu, even when doing nothing.
I also don't see a ros::spinOnce(), so ROS has no way of processing events. That may be the cause of your issues.
Comment by mherrmann on 2018-05-18:
@Delb: Probably it may not be an issue, but I couldn't make it to pass a pointer to a signal_handler function. Could you provide a minimal example?
Comment by mherrmann on 2018-05-18:
@gvdhoorn: I know about the resource problem, just deleted the content to reduce the code, but do you think that this regards my problem directly? However I edited the minimal example, but have the same problem.
Comment by Delb on 2018-05-18:
I would have provided a similar example as @gvdhoorn 's link I think this is what you are looking for, and as he said if ros::ok() returns false the connection to the master are dropped (see #q253661 )
Comment by mherrmann on 2018-05-18:
@gvdhoorn: Now I see, I couldn't use the ros logging system. Printing with cout shows that ros works as intended. Thank you very much for your help.

A:

ros::spinOnce() should be inside your while loop. That function allows ROS time to process incoming events.
Note that logging after ros::ok() returns false is not at all guaranteed to work iirc. A printf(..) might be better.
Btw see #q27655 for what I believe is a duplicate.

Originally posted by gvdhoorn with karma: 86574 on 2018-05-18
This answer was ACCEPTED on the original site
Post score: 2


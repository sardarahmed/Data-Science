Q:

Passing large data messages

Hi,
I would like some suggestions or guidelines for the following design problem. I have a ROS node which maintains a fairly large data structure (a 3D map). I would like to publish it efficiently, so I can create independent packages that visualize or process the data. I can publish ROS messages as shared pointers using the nodelet architecture, but that still leaves the problem of converting the map structure to a ROS message. Translating the map structure to a ROS message is undesirable for two reasons

I need to spend time copying data out of the structure and into the ROS message
The native map is built using some data structures not available to the ROS message, which can only use vectors.

An alternative I can think of is to directly maintain the map data in my program as a ROS message, so no translation would be required. However, again I have the problem that the ROS messages only allow for vectors, so I'd be restricted in how I design the structure.
Is my reasoning correct? Does anyone have a good solution to this problem?

Originally posted by Ivan Dryanovski on ROS Answers with karma: 4954 on 2011-03-08
Post score: 4

A:

We had a similar discussin in-house at our company a while ago.
It is possible to adapt your own c++ types to the pub/sub mechanisms without having to use an ros msg. See here: MessageSerialisationAndAdaptingTypes. I haven't tried this yet, but we've talked about giving it a whirl on the next stage of one of our projects.
There is one further gotcha with regards to sharing large data types. So long as your subscribers don't need to modify the map structure, you can create all your packages as nodelets and pass around your adapted c++ type via pub/sub without doing any copying. However, if your subscribers need to modify the map, then you need to find another solution as subscribers will only ever get a pointer to a const version of the object.
There was a discussion on the mailing list about that, where it was pointed out that this was to help maintain a contract between publisher/subscriber, to make sure that other parts of your program (which, being very modularised, may be very unknown) do not cause problems by modifying your underlying data.
The best way we figured we might avoid copies on a low perf cpu with a map that we wanted modifiable among several modules might be to create them all as libraries, or ros libplugins, tied together by a single manager which stores the map. The manager would then pass a reference to the map to each module at init() time.

Originally posted by Daniel Stonier with karma: 3170 on 2011-03-13
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by tfoote on 2011-04-18:
So if you truely need the optimization of being able to maintain one map and have many accessors it's likely that using an abstraction like message passing is inappropriate for your design.
Comment by tfoote on 2011-04-18:
If it is not subscribed with the custom type it will be serialized and sent as a message.  And you will also need to write a deserializer routine.  An example of doing the PointCloud datatype in pcl_ros http://www.ros.org/wiki/pcl_ros.  Note that after passing the data it cannot be mutated.
Comment by tfoote on 2011-04-18:
I believe this solution would work for you.  All you need to do is be able to define a message into which you could serialize the data, and write the serializer. Then you can publish with the native data type, and if it's local to the node with the same datatype it will be passed by pointer.
Comment by Ivan Dryanovski on 2011-03-14:
snorri, this is probably what I'm looking for - I'll take a look into it. I don't plan on having clients make changes to the map, so that won't be an issue.


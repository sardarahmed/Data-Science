Q:

Launching a Python program without a #! at the top

I am currently porting some of our code/infrastructure to electric from diamondback. When trying to launch my new electric stuff, I get a problem being able to launch one of our third party libraries (dynamixel_controllers) It looks like all the python programs in this package do not have the #!/usr/bin/python at the top of the files, and now they will not launch with the following error message:
If it is a script, you may be missing a '#!' declaration at the top.
I haven't changed anything related to this, and while I can add the #! to the top of each file, I'd rather not as it is an external library, and I don't want to be running our own fork of it. Is there something new to electric that I must do to launch python files?
[Update]
The specific file I'm attempting to run is the joint_trajectory_action_controller.py file from the dynamixel_controllers package. Should this be launched instead by the controller spawner or something? Here's the associated (failing) launch file:
<launch>
    <!-- Load joint names from yaml file -->
    <rosparam file="$(find cyton_arm_driver)/config/joint_controllers.yaml" command="load"/>

    <node name="cyton_joint_action_controller" pkg="dynamixel_controllers" type="joint_trajectory_action_controller.py" required="true">
        <param name="~controller_namespace" type="str" value=""/>
    </node>
</launch>

Originally posted by John Hoare on ROS Answers with karma: 765 on 2011-09-15
Post score: 0

Original comments
Comment by John Hoare on 2011-09-15:
Please see my update, I am trying to run the joint_trajectory_action_controller.py file.
Comment by arebgun on 2011-09-15:
John, what files are you trying to run that don't have #! line? The two nodes that are designed to run as a script have that line (controller_manager.py and controller_spawner.py), all other modules are not supposed to be run standalone.

A:

You are correct, joint_trajectory_action_controller was redesigned in electric version of dynamixel_controllers package. In Diamondback version it was a standalone node that communicated with joint controllers through ROS topics. In Electric version it was rewritten to be more like a standard joint controller to gain direct access to serial port. New version is much smoother than the old one because commands (both velocity and position) for all controlled joints are packed into a single packet that gets sent over the serial bus (before we had to send a separate command for each velocity/position change for each joint).
With that said, the way you start joint_trajectory_action_controller is also different in Electric, now you have to use controller_spawner.py script to start it up. When trajectory controller starts up it expects joint controllers for all joint it will control to be up and running. I haven't yet written proper documentation for it, but there's a couple of examples for 2 different arms that will help you to get started:
Wubble robot's arm: launch file, joint controllers configuration and trajectory controller configuration
Pi robot's arm: launch file, joint controller configuration (also includes trajectory controller configuration at the very bottom)
Basically, when launching joint trajectory controller you need to specify all its dependencies (all joint controllers that it will use to carry out the desired trajectory).
Let me know if you have any problems running this.

Originally posted by arebgun with karma: 2121 on 2011-09-15
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by arebgun on 2011-09-15:
Great! Send some videos, I'd like to see how Cyton arm works :)
Comment by John Hoare on 2011-09-15:
Thanks, following this post and those examples I've successfully ported everything over to the Electric version. Thanks.


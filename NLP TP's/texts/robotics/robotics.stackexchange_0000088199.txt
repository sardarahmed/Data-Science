Q:

issue with odom and tf with gazebo simulation

I'm creatig a four wheel robot. I can simulate it and pilot it with a joystick and everything woks fine until this point.
However, I'm facing issues with gmapping. When I start it, I got the following message:
[ WARN] [1532859238.408531484]: MessageFilter [target=odom ]: Dropped 100.00% of messages so far. Please turn the [ros.gmapping.message_notifier] rosconsole logger to DEBUG for more information.

I do launch gmapping with the following command:
rosrun gmapping slam_gmapping scan:=base_scan

my urdf file is:
<?xml version="1.0"?>
<robot name="gribot" xmlns:xacro="http://www.ros.org/wiki/xacro">

   <xacro:include filename="$(find gribot)/urdf/wheel.urdf.xacro" />

   <!-- Defining the colors used in this robot -->

   <material name="Black">
      <color rgba="0.0 0.0 0.0 1.0"/>
   </material>

   <material name="Red">
      <color rgba="0.8 0.0 0.0 1.0"/>
   </material>

   <material name="White">
      <color rgba="1.0 1.0 1.0 1.0"/>
   </material>

   <material name="Blue">
      <color rgba="0.0 0.0 0.8 1.0"/>
   </material>

   <!-- Property list -->
   <!-- All units in m-kg-s-radians unit system -->
   
   <xacro:property name="M_PI" value="3.1415926535897931" />      
   <xacro:property name="M_PI_2" value="1.570796327" />
   <xacro:property name="DEG_TO_RAD" value="0.017453293" />

   <!-- Main body length height width -->
   
   <xacro:property name="base_height"   value="0.25" /> <!-- in meter -->
   <xacro:property name="base_width"    value="0.6"  /> <!-- in meter -->
   <xacro:property name="base_lenght"   value="0.8"  /> <!-- in meter -->
   <xacro:property name="base_mass"     value="20.0" /> <!-- in kg -->

   <!-- Macro for calculating inertia of cylinder -->
   
   <xacro:macro name="cylinder_inertia" params="m r h">
      <inertia ixx="${ m * ( 3 * r*r + h*h ) / 12}" ixy="0" ixz="0"
               iyy="${ m * ( 3 * r*r + h*h ) / 12}" iyz="0"
               izz="${ m * r / 2}" />
   </xacro:macro>

   <!-- Macro for calculating inertia of a box -->
   
   <xacro:macro name="box_inertia" params="m x y z">
      <inertia ixx="${0.0833333 * m * (y*y + z*z)}" ixy="0.0" ixz="0.0"
               iyy="${0.0833333 * m * (x*x + z*z)}" iyz="0.0"
               izz="${0.0833333 * m * (x*x + y*y)}" />
   </xacro:macro>

   <!-- World link -->
   <!-- world_link is a fictious link(frame) that is on the ground right below base_link origin -->
   <!-- It is necessary as gazebo does not support inertia for the root link -->
   <!-- Do not call it world as it is reserved for robot that must be fixed to the world -->

   <link name="world_link">
   </link>

   <gazebo reference="world_link">
      <turnGravityOff>false</turnGravityOff>
   </gazebo>

   <joint name="glue_robot_to_world" type="fixed">
      <origin xyz="0 0 0.1" rpy="0 0 0" />
      <parent link="world_link" />
      <child link="base_link" />
   </joint>

   <!-- Base link -->
   <!-- Actual body/chassis of the robot -->

   <link name="base_link">
      <inertial>
         <mass value="${base_mass}" />
         <!-- the3x3 rotational inertia matrix -->
         <box_inertia m="${base_mass}" x="${base_lenght}" y="${base_width}" z="${base_height}" />
         <origin xyz="0 0 0" />
      </inertial>
      <visual>
         <origin xyz="0 0 0" rpy="0 0 0" />
         <geometry>
            <box size="${base_lenght} ${base_width} ${base_height}" />
         </geometry>
         <material name="Blue" />
      </visual>
      <collision>
         <origin xyz="0 0 0" rpy="0 0 0" />
         <geometry>
            <box size="${base_lenght} ${base_width} ${base_height}" />
         </geometry>
      </collision>
   </link>

   <gazebo reference="base_link">
      <material>Gazebo/White</material>
      <turnGravityOff>false</turnGravityOff>
   </gazebo>

   <!-- Skid Steering Drive for 4 wheel robot for simulation -->
   
   <gazebo>
      <plugin name="drive_controller" filename="libgazebo_ros_skid_steer_drive.so">
         <updateRate>100</updateRate>
         <robotNameSpace>/</robotNameSpace>
         <leftFrontJoint>front_left_wheel_joint</leftFrontJoint>
         <rightFrontJoint>front_right_wheel_joint</rightFrontJoint>
         <leftRearJoint>back_left_wheel_joint</leftRearJoint>
         <rightRearJoint>back_right_wheel_joint</rightRearJoint>
         <wheelSeparation>0.4</wheelSeparation>
         <wheelDiameter>0.32</wheelDiameter>
         <robotBaseFrame>base_link</robotBaseFrame>
         <torque>10</torque>
         <topicName>cmd_vel</topicName>
         <broadcastTF>false</broadcastTF>
         <commandTopic>cmd_vel</commandTopic>      
         <odometryTopic>odom</odometryTopic>       
         <odometryFrame>odom</odometryFrame>       
         <covariance_x>0.00100</covariance_x>      
         <covariance_y>0.00100</covariance_y>      
         <covariance_yaw>0.010000</covariance_yaw> 
      </plugin>
   </gazebo>

   <!-- Wheel Definition for simulation -->
   
   <wheel fb="front" lr="right" parent="base_link" translateX="0.2" translateY="${base_width/2+0.05}"       translateZ="-0.065" flipY="1"/>
   <wheel fb="front" lr="left"  parent="base_link" translateX="0.2" translateY="${-1*(base_width/2+0.05)}"  translateZ="-0.065" flipY="1"/>
   <wheel fb="back"  lr="right" parent="base_link" translateX="-0.2" translateY="${base_width/2+0.05}"      translateZ="-0.065" flipY="1"/>
   <wheel fb="back"  lr="left"  parent="base_link" translateX="-0.2" translateY="${-1*(base_width/2+0.05)}" translateZ="-0.065" flipY="1"/>

   <!-- Lidar definition for simulation -->

   <link name="sweep_link" >
      <collision>
         <origin xyz="0 0 0" rpy="0 0 0" />
         <geometry>
            <box size="0.1 0.1 0.1" />
         </geometry>
      </collision>
      <visual>
         <origin xyz="0 0 0" rpy="0 0 0" />
         <geometry>
            <cylinder length="0.1" radius="0.05" />
         </geometry>
         <material name="black" />
      </visual>
      <inertial>
         <mass value="1e-5" />
         <origin xyz="0 0 0" rpy="0 0 0" />
         <inertia ixx="1e-6" ixy="0" ixz="0" iyy="1e-6" iyz="0" izz="1e-6" />
      </inertial>
   </link>

   <joint name="lidar_to_base" type="fixed" >
      <origin xyz="0 0 ${base_height/2+0.05}" rpy="0 0 0" />
      <parent link="base_link" />
      <child link="sweep_link" />
   </joint>

   <gazebo reference="sweep_link" >
      <sensor type="ray" name="laser">
         <pose>0 0 0 0 0 0</pose>
         <visualize>false</visualize>   <!-- temporary for testing, but should be put to false -->
         <update_rate>40</update_rate>
         <ray>
            <scan>
               <horizontal>
                  <samples>720</samples>
                  <resolution>1</resolution>
                  <!-- <min_angle>-1.570796</min_angle> -->
                  <!-- <max_angle>1.570796</max_angle> -->
                  <min_angle>-3.141592</min_angle>
                  <max_angle>3.141592</max_angle>
               </horizontal>
            </scan>
            <range>
               <min>0.10</min>
               <max>30.0</max>
               <resolution>0.01</resolution>
            </range>
            <noise>
               <type>gaussian</type>  <!-- Add parameters for Svcansee sweep -->
               <mean>0.0</mean>
               <stddev>0.01</stddev>
            </noise>
         </ray>
         <plugin name="sweep_link" filename="libgazebo_ros_laser.so">
            <topicName>base_scan</topicName>
            <frameName>sweep_link</frameName>
         </plugin>
      </sensor>
   </gazebo>

   <!-- Publishing joint states from Gazebo simulator -->
   <!-- fixed links are not published -->
   
   <gazebo>
      <plugin name="joint_state_publisher" filename="libgazebo_ros_joint_state_publisher.so">
         <jointName>front_left_wheel_joint, front_right_wheel_joint, back_left_wheel_joint, back_right_wheel_joint</jointName>
         <robotNameSpace>/gribot</robotNameSpace>
         <updateRate>100</updateRate>
         <alwaysOn>true</alwaysOn>
      </plugin>
   </gazebo>

</robot>

My launch file is:
<?xml version="1.0"?>

<!-- Launch file for gribot robot -->

<launch>

   <!-- Values passed by command line input -->

   <arg name="paused"       default="false" />
   <arg name="use_sim_time" default="false" />
   <arg name="gui"          default="true" />
   <arg name="headless"     default="false" />
   <arg name="debug"        default="false" />

   <!-- We resume the logic in empty_world.launch -->

   <include file="$(find gazebo_ros)/launch/empty_world.launch">
      <arg name="debug"        value="$(arg debug)" />
      <arg name="gui"          value="$(arg gui)" />
      <arg name="paused"       value="$(arg paused)" />
      <arg name="use_sim_time" value="$(arg use_sim_time)" />
      <arg name="headless"     value="$(arg headless)" />
   </include>

   <!-- Load robot description on Parameter Server -->

   <param name="robot_description" command="$(find xacro)/xacro --inorder $(find gribot)/urdf/gribot.xacro" />
   <param name="use_gui" value="$(arg gui)" />
   
   
   <!-- Load robot params into parameter server -->
   <!-- <rosparam command="load" file="$(find gribot)config/dependent_joints.yaml" /> -->

   <!-- very important for Joystick -->
   <!-- defines which field contain which axe -->

   <param name="axis_linear" value="1" type="int" />
   <param name="axis_angular" value="0" type="int" />

   <!-- Run a python script to send a service call to gazebo_ros to spawn a URDF robot -->

   <node name="urdf_spawner" pkg="gazebo_ros" type="spawn_model" respawn="false" output="screen" args="-urdf -model gribot -param robot_description" /> 

   <!-- Start rviz -->

   <node name="rviz" pkg="rviz" type="rviz" args="-d $(find gribot)/urdf/urdf.rviz" required="true" clear_params="true" />

   <!-- Start robot state publisher: publish the state of the robot -->

   <node name="robot_state_publisher" pkg="robot_state_publisher" type="robot_state_publisher" output="screen">
      <param name="publish_frequency" type="double" value="50.0" />
      <!-- <param name="use_tf_static" value="false" /> -->
   </node>
   
   
   <!-- Start the robot joint state publisher -->
   <!-- <node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher" /> -->

   <!-- Start CANOpen nodes for controlling motors -->

<!--   <node name="driver" pkg="canopen_motor_node" type="canopen_motor_node" output="screen" clear_params="true" launch-prefix=""> -->
<!--      <rosparam command="load" file="$(find gribot)/config/can0.yaml" /> -->
<!--   </node> -->

   <!-- Start the joystick nodes -->

   <node name="joystick" pkg="joy" type="joy_node" output="screen" respawn="true" > 
      <param name="dev" type="string" value="/dev/input/js0" /> 
      <param name="deadzone" value="0.12" /> 
   </node> 

   <!-- Start link between joystick and robot -->

   <node name="teleopjoy" pkg="gribot" type="teleopjoy" respawn="true" >
      <param name="dev" type="string" value="/dev/input/js0" />
      <param name="deadzone" value="0.12" />
   </node>

</launch>

I noticef some strange thinks: when I run
rosrun tf tf_monitor

I got the following result:
RESULTS: for all Frames
Frames:
Frame: back_left_wheel published by unknown_publisher Average Delay: 0.000310674 Max Delay: 0.000626253
Frame: back_right_wheel published by unknown_publisher Average Delay: 0.000311771 Max Delay: 0.000628386
Frame: base_link published by unknown_publisher(static) Average Delay: 0 Max Delay: 0
Frame: front_left_wheel published by unknown_publisher Average Delay: 0.000312559 Max Delay: 0.000630082
Frame: front_right_wheel published by unknown_publisher Average Delay: 0.000312974 Max Delay: 0.000630762
Frame: sweep_link published by unknown_publisher(static) Average Delay: 0 Max Delay: 0

All Broadcasters:
Node: unknown_publisher 43.6916 Hz, Average Delay: 0.000311995 Max Delay: 0.000628871
Node: unknown_publisher(static) 1e+08 Hz, Average Delay: 0 Max Delay: 0

There is also strange think with the tf graphs: the map is linked to odom, ut not to the rest of the frames. The nodes graphs seems to be correct.
I'm sure I missed something somewhere, but I can not find what. Would someone be so kind as to help me ?
Thank you very much.

Originally posted by Guy Corbaz on ROS Answers with karma: 26 on 2018-07-29
Post score: 1

A:

Finally I solved the issue of gmapping:
The parameter
<broadcastTF>true</broadcastTF>

of section
<plugin name="drive_controller" filename="libgazebo_ros_skid_steer_drive.so">

must be true.
For those who are interested, complete robot files are in github.

Originally posted by Guy Corbaz with karma: 26 on 2018-08-01
This answer was ACCEPTED on the original site
Post score: 0


Q:

tf2 buffer length setting problem

I'm using Kinetic on Ubuntu 16.04 and met a problem with extending tf2 buffer (roscpp).
In my header file, I defined like this:
Class A
{
private: 
    std::unique_ptr<tf2_ros::Buffer> buffer_ptr;
    std::unique_ptr<tf2_ros::TransformListener> listener_ptr;
}

Then in the source file, I have initialized them in the constructor:
A::A
{
    buffer_ptr.reset(new tf2_ros::Buffer(ros::Duration(30.0)));
    listener_ptr.reset(new tf2_ros::TransformListener(*tf_buffer_ptr));
}

When I use the rqt tf_tree to view the transformation info, I noticed that the cached buffer length is still around 10 seconds, not extended to 30 seconds as I set here...
I tried to print out the buffer length out at runtime (via GetCacheLength method), and the value is correct.
I searched a lot but found very few info on this, and I checked the tf2_ros buffer related source code didn't get any luck as well..

Originally posted by Dutch on ROS Answers with karma: 25 on 2019-02-14
Post score: 0

Original comments
Comment by gvdhoorn on 2019-02-15:
I'm 99% sure that the "buffer length" shown by tf_tree is the buffer that tf_tree itself uses. It does not reflect the state of the node broadcasting the frame.
So in your case: nothing outside A would know that you're using a 30 sec long buffer.
Comment by Dutch on 2019-02-15:
Ahh, I misunderstood the meaning of the cache length in the tf_tree then. My program is having some network delay issue, so I would like to keep a long buffer to lower the risk of extrapolation exception, however it didn't work out and that's why I thought the parameter wasn't effective. Thank you!
Comment by gvdhoorn on 2019-02-15:
As I wrote: I'm 99% sure (from a cursory look at the code). You may want to verify yourself.

A:

The tf_tree and your class are separate processes and as such have different Buffers with independent timeouts. Thus as @gvdhoorn mentions changing one does not effect the other.
Often if you are having extrapolation errors on a high latency system the most likely issue is not that the buffer is not long enough, but that the data has not arrived. Unless you have network delays longer than 10 seconds. Then increasing your buffer length will help.
But assuming that's not the case you need to make sure that transforms are available when data arrives to be processed. There's a tool called the tf2::MessageFilter that will help with this. A tutorial is here

Originally posted by tfoote with karma: 58457 on 2019-02-15
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Dutch on 2019-02-16:
Got it! Thank you!


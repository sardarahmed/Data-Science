Q:

How can I use /bumper topic data in move_base?

Hi there,
I am new to ROS and ROS navigation stack. Right now I am trying to use /bumper topic data ( msg->left.state and msg->right.state ) on roomba_500_series in move_base. The topic has been already published from /roomba560_node. I would like to know how to use(subscribe) it in move_base. Please let me know if you know any.
(What I would like to do is to use bumper's right state and its left state ( true or false ). For example, if right state is true, I let roomba turn left and go straight.)
*additional comment
I modified kobuki_bumper2pc as bumper2pc as follows.
//bumper2pc.cpp 
#include <ros/ros.h> 
#include <ros/ros.h>
#include <iostream>
#include <pluginlib/class_list_macros.h>
#include <roomba_500_series/Bumper.h>
#include "bumper2pc/bumper2pc.hpp"
#include <geometry_msgs/Twist.h>

namespace bumper2pc{
 bool left_bumper, right_bumper;
 
 //this function is defined in "bumper2pc.hpp"
 void Bumper2PcNodelet::BumperUpdateCB(const roomba_500_series::Bumper::ConstPtr& msg){
  left_bumper = msg->left.state;
  right_bumper = msg->right.state;
 }

 void Bumper2PcNodelet::coreSensorCB(const roomba_500_series::Bumper::ConstPtr& msg){

  left_bumper = msg->left.state;
  right_bumper = msg->right.state;

  ros::NodeHandle n;
  ros::Publisher vel_pub_ = n.advertise<geometry_msgs::Twist>("/cmd_vel", 1)
  geometry_msgs::Twist cmd_vel;

  if (left_bumper == 1){

   bool judge_left = true;
   while(judge_left == true){
    if(judge_left == false){ break; }

    cmd_vel.linear.x = 0.0;
    cmd_vel.angular.z = 0.0;
    vel_pub_.publish(cmd_vel);

    while(left_bumper == 1){
     cmd_vel.linear.x = 0.0;
     cmd_vel.angular.z = -0.78; //turn right while left bumper is true
     vel_pub_.publish(cmd_vel);

     bumper_update_sub_ = n.subscribe("/bumper", 1000, &Bumper2PcNodelet::BumperUpdateCB, this);  //update bumper data

    }

    while(right_bumper == 0 || left_bumper == 0){
     if(judge_left == false){ break; }

     cmd_vel.linear.x = 0.2;
     cmd_vel.angular.z = 0.0; 
     vel_pub_.publish(cmd_vel);  

     bumper_update_sub_ = n.subscribe("/bumper", 1000, &Bumper2PcNodelet::BumperUpdateCB, this);
     if(right_bumper == 1){ judge_left = false; }
     if(left_bumper == 1){ break; }
    }
   }
   return;
  }

  if (right_bumper == 1){
     //same as above ("left" -> "right")
  }

 void Bumper2PcNodelet::onInit(){
  ros::NodeHandle nh = this->getPrivateNodeHandle();
  
  core_sensor_sub_ = nh.subscribe("/bumper", 1000, &Bumper2PcNodelet::coreSensorCB, this);  //core_sensor_sub is defined in "bumper2pc.hpp"
 }
} //namespace bumper2pc

PLUGINLIB_EXPORT_CLASS(bumper2pc::Bumper2PcNodelet, nodelet::Nodelet);

Originally posted by rostaro on ROS Answers with karma: 17 on 2017-11-06
Post score: 1

A:

The easiest option would probably be to translate the bumper data into a PointCloud, which you could then use as an input to your costmap.

Originally posted by David Lu with karma: 10932 on 2017-11-06
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by rostaro on 2017-11-20:
I'm terribly sorry for the delay in my reply.
Thank you for answering my question.
I used kobuki_bumper2pc and rewrited it.
Finally, I could publish cmd_vel from bumper2pc according to bumper's states.
Thank you very much.


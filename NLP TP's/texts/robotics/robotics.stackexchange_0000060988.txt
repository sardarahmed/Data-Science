Q:

NodeHandle and ROS_DEBUG

Dear ROS members.
I had a trouble to use ROS_DEBUG macro after destructing a private node handle in a local scope.
As the following codes, when the "priv_nh1" node handle in the 1st local scope was
destructed, ROS_DEBUG macro will never say anything at all.
it's occurred in ROS::Groovy and ROS::Indigo.
In other words, the 1st and 2nd local scopes are meaning multi-threads or functions.
Is there bettwer way to use private node handles in each scopes?
Thank you.
#include <ros/ros.h>
#include <ros/console.h>
int main( int  argc, char**  argv )
{
  ros::init( argc, argv, "test" );
  ROS_INFO("hello");
  { // <1st local scope>
    ROS_INFO("local scope : enter");
    ros::NodeHandle  priv_nh1("~");
    /* ... do something ... */
    ROS_INFO("local scope : exit");
  } // </1st local scope>
  // I can not get following ROS_DEBUG messages ...
  ROS_INFO("next");
  { // <2nd local scope>
    ROS_INFO("local scope : enter");
    ros::NodeHandle  priv_nh2("~");
    int              value = 0;
    priv_nh2.param( "value", value, 0 );
    ROS_INFO("value %d", value);
    ROS_INFO("local scope : exit");
  } // </2nd local scope>
  ROS_INFO("bye");
  ros::spin();
  return 0;
}

Originally posted by ST-Lab on ROS Answers with karma: 15 on 2014-07-20
Post score: 0

Original comments
Comment by ahendrix on 2014-07-21:
Does ROS_DEBUG work if you use it elsewhere in your program?
Comment by ST-Lab on 2014-07-21:
Thank you, ahendrix.
ROS_DEBUG can work anywhere, if I do not use such a private(disposable) node handle.
When I remove such a private node handle and get parameters by ros::param::get directly, there is no problem occurred.
Comment by ahendrix on 2014-07-21:
I'm seeing this with all of the rosconsle output macros, including ROS_INFO, not just ROS_DEBUG.

A:

The trouble here is that you don't have a persistent NodeHandle throughout the scope of your program.
As explained on the NodeHandle wiki page, once all NodeHandles go out of scope, the internal node is shut down.
Private NodeHandles with limited scope are generally a good idea, but you should also maintain a NodeHandle (public or private) that lasts for the entire duration of your program.

Originally posted by ahendrix with karma: 47576 on 2014-07-21
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by ST-Lab on 2014-07-21:
Dear, ahendrix. Thank you for your advice. I've read the class reference of the node handle, and I also got the same conclution as well as you. The problem is based on the complexity of the global reference counter in the node handle. But I hope that the above made codes clean and safe.


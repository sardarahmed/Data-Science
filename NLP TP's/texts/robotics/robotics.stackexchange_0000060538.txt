Q:

Nodelet code subscriber - Data is not ready to read at the beginning losing first data published

Hi,
My code is already working with nodelets but data is not read always.
ex: I have a bag file that publishes 1156 the same topic but I only can read some of them.
Sometimes it reads only one thousand times and sometimes a thousand and a litle more, but never constant.
Have you any idea about my problem?
(The code below is a simple counter in the function that "reads" the data from the nodelet)
(I had the same problem with nodes, that's the reason I changed to nodelets)
Thank you
Oportoz
CODE (Rnode.cpp):
#include <ros/ros.h>
#include <pluginlib/class_list_macros.h>
#include <nodelet/nodelet.h>
#include <velodyne_msgs/VelodyneScan.h>
#include <velodyne_msgs/VelodynePacket.h>
[...]
#include "velodyne_R/rpcl_classsss.h"

    int main(int argc, char** argv)
{
    ros::init(argc, argv, "sub_pcl");
    ros::NodeHandle node;
    ros::NodeHandle priv_nh("~");
    
    Classico rpcl(node, priv_nh);

    while(ros::ok())
    {
        ros::spin(); // Manter a função a correr??  
    }
    
    std::cout << rpcl.getCount() << std::endl;
    
return 0;
}

CODE (Rnodelet.cpp):
#include <ros/ros.h>
#include <pluginlib/class_list_macros.h>
#include <nodelet/nodelet.h>
#include <velodyne_msgs/VelodyneScan.h>
#include <velodyne_msgs/VelodynePacket.h>
[...]
#include "velodyne_R/rpcl_classsss.h"

namespace velodyne_R
{
        
class velodyne_Rnodelet: public nodelet::Nodelet
  {
  public:
    velodyne_Rnodelet() {}
    ~velodyne_Rnodelet() {}
    
  private:
    virtual void onInit();
    boost::shared_ptr<Classico> rpcl_;
  };

  /** @brief Nodelet initialization. */
  void velodyne_Rnodelet::onInit()
  {
    rpcl_.reset(new Classico(getNodeHandle(), getPrivateNodeHandle()));
  }

} // namespace your_package
// parameters: package, class name, class type, base class type
PLUGINLIB_DECLARE_CLASS(velodyne_R, velodyne_Rnodelet, velodyne_R::velodyne_Rnodelet, nodelet::Nodelet);

CODE (rcpl_classsss.cpp):
#include <ros/ros.h>
#include <pluginlib/class_list_macros.h>
#include <nodelet/nodelet.h>

#include "velodyne_R/rpcl_classsss.h"

    /** @brief Constructor. */
    Classico::Classico(ros::NodeHandle node, ros::NodeHandle private_nh):
        count(0)
    {
    velodyne_scan_ = node.subscribe("velodyne_packets", 1059, &Classico::processScan,
                                    (Classico *) this, ros::TransportHints().tcpNoDelay(true));
    }

    /** @brief Callback for raw scan messages. */
    void Classico::processScan(const velodyne_msgs::VelodyneScan::ConstPtr &scanMsg)
    {
    count++;
    }

CODE (rcpl_classsss.h):
    #include <ros/ros.h>
    #include <pluginlib/class_list_macros.h>
    #include <nodelet/nodelet.h>
    #include <velodyne_msgs/VelodyneScan.h>
    #include <velodyne_msgs/VelodynePacket.h>

[...]

class Classico
{
public:

    Classico(ros::NodeHandle node, ros::NodeHandle private_nh);
    ~Classico() {}
    int getCount(){return count;}

private:
    void processScan(const velodyne_msgs::VelodyneScan::ConstPtr &scanMsg);
    int count;

    ros::Subscriber velodyne_scan_;
};

Originally posted by Oportoz on ROS Answers with karma: 1 on 2014-07-02
Post score: 0

Original comments
Comment by Oportoz on 2014-07-02:
Now I've tested and I know that the lost packets are at the beginning.
And if I had a small queue in node.subscribe it would lose some published topics during the process

A:

I would expect messages to be lost on startup, because not all nodes start at once.
rosbag play has --pause and --delay=SEC options to mitigate this effect, but I doubt you should count on seeing all the messages.

Originally posted by joq with karma: 25443 on 2014-07-02
This answer was ACCEPTED on the original site
Post score: 1


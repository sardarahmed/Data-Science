Q:

rotate a quaternion

I have a quaternion that represents the orientation of the robot gripper. Now, I want to define a set of primitive actions to change this orientation in some directions, so that all possible orientations are reachable (to some accuracy).
My solution is to convert quaternions into Euler angles, then add a certain amount (say 10 degrees) to one of the three angles, and convert back to quaternions. This worked quite well as I thought but had the problem of gimbal lock.
So here is my question. Is there a way to achieve the behaviour obtained here, without converting back and forth between quaternions and Euler angles?
====================================================
EDIT: From some tutorials, I learn that I can apply a rotation quaternion q to a orietation quaternion v to obtain a new orietation quaternion v'=qvq*. So my question is, given v=(w,x,y,z), what are the q's that only change its pitch, roll and yaw respectively?
After some thinking, I get the following:
yaw: (cos(alpha),0,0,sin(alpha))
roll: (cos(alpha),x,y,z) --> normalization
pitch: (cos(alpha),y,-x,0) --> normalization
Am I right?

Originally posted by Nan Jiang on ROS Answers with karma: 131 on 2012-08-03
Post score: 2

A:

Just use TF's functions for creating a quaternion from euler angles and the multiplication operator for combining quaternions. Have a look here, in particular at the method tf::createQuaternionFromRPY.

Originally posted by Lorenz with karma: 22731 on 2012-08-05
This answer was ACCEPTED on the original site
Post score: 6

Original comments
Comment by dinosaur on 2015-07-08:
How do you invoke the quaternion multiplication operator from python?
Comment by Henschel.X on 2016-03-17:
For example, I have a vector X (x,y,z) and its ERY is (0,0,a), and I have another vector Y(x',y',z') and ERY is (0,0,b), if I want to get Y by doing RX+T, can I get the rotation matrix R and transformation matrix T by using TF's function? Or if its not possible, how can I compute this? Thx a lot!


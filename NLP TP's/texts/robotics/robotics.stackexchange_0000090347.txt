Q:

If a plugin is initialized inside a try/catch, it doesn't keep the subscribers running

Hi all,
Let me give first an introduction of my problem. I'm playing around with the "Creating your own plugin" tutorial. Until now I have 2 plugins, each of them has a subscriber callback to different topics. All the plugins are created correctly. The problem starts when I want to load them. The following is the code I'm using for that:
int main(int argc, char** argv)
{
  ros::init(argc, argv, "polygon_loader_node");
  ros::NodeHandle private_nh("~/plugin_test");
  ros::NodeHandle g_nh;
  pluginlib::ClassLoader<polygon_base::RegularPolygon> poly_loader("plugin_test", "polygon_base::RegularPolygon");
  boost::shared_ptr<polygon_base::RegularPolygon> polygon_plugins = poly_loader.createInstance("polygon_plugins::polygonPlugins");
  polygon_plugins->initialize();
  try
  {
    boost::shared_ptr<polygon_base::RegularPolygon> plugin = poly_loader.createInstance(polygon_plugins::Triangle);
    plugin->initialize();
  }
  catch(pluginlib::PluginlibException& ex)
  {
    ROS_ERROR("The plugin failed to load for some reason. Error: %s", ex.what());
  }
 ros::spin();
 return 0;
}

In the code above, both plugins are initialized, however I can only go into the callback of the polygonPlugins one. However if I remove the try/catch, so both plugins are in the same level, then I can go into the Triangle plugin callback as well.
I suspect is something related with the location of the ros::spin(), however I don't know exactly the issue. I appreciate in advance your help.
Cheers.

Originally posted by Edu_ on ROS Answers with karma: 3 on 2019-02-02
Post score: 0

A:

This is pretty typical C++ object lifetime: a C++ variable only lasts for the duration of block where it is created, and it is destroyed at the end of the block.
A block is the scope that starts at { and ends at the matching }
Therefore, since your boost::shared_ptr<polygon_base::RegularPolygon> plugin variable is declared inside the try {}, it is also destructed at the end of that block.
You can fix this by moving the variable declaration outside of the try {} block, like this:
boost::shared_ptr<polygon_base::RegularPolygon> plugin;
try {
    plugin = poly_loader.createInstance(polygon_plugins::Triangle);
    plugin->initialize();
} catch(pluginlib::PluginlibException& ex) {
    ROS_ERROR("The plugin failed to load for some reason. Error: %s", ex.what());
}

Now boost::shared_ptr<polygon_base::RegularPolygon> plugin is declared within main's block (or scope), and lasts until the end of main.

Originally posted by ahendrix with karma: 47576 on 2019-02-02
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Edu_ on 2019-02-02:
Cool, it worked! Thank you very much!
Comment by gvdhoorn on 2019-02-03:
Please mark the question as answered by clicking the checkmark to the left of the answer, if you feel it has been answered.


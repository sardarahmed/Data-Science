Q:

Proper use of ros_control's RealtimeBuffer

I am new to real-time programming, and I am trying to learn how to properly use realtime_tools::RealtimeBuffer in my ros_control controller by looking at source code from related packages. After looking at the source code of RealtimeBuffer, effort_controllers::JointPositionController, and forward_command_controller::ForwardJointGroupCommandController, I am still confused about three things.
First, JointPositionController uses the buffer to share command data between the RT and non-RT threads, but command_struct_, the member variable used to set the buffer, is also accessed by both threads. Is it safe to access command_struct_ in this way? If it is safe, why is this the case?
Second, in ForwardJointGroupCommandController, why is RealtimeBuffer not used at all? My controller has several joints and I was thinking on using RealtimeBuffer to protect a vector. In order to pre-allocate the buffer internally, I was thinking on passing a vector with dummy values to RealtimeBuffer::initRT() in the init() method of the controller (I don't know the size of the vector until this point). Then call initRT() again in starting() with appropriate values.
Third, why doesn't RealtimeBuffer::initRT() check the lock of the mutex? Under the context of the JointPositionController , I can imagine messages published to the command topic even before the controller is started. Would this be safe?
Source code: RealtimeBuffer, JointPositionController, ForwardJointGroupCommandController.

Originally posted by Daniel L on ROS Answers with karma: 43 on 2015-01-19
Post score: 0

A:

For your first question, the RealtimeBuffer is intended for synchronization of data shared by one non-rt and one rt thread, where the non-rt thread writes into the shared data, and the rt thread reads it. When writing, the non-rt thread is subject to waiting for the shared resource to become free, while the rt thread never waits for reading. Internally, RealtimeBuffer keeps two versions of the shared resource, one which can always be read, and another one which can be safely written into.
For your second question, the implementation of both ForwardCommandController and ForwardJointGroupCommandController is missing proper synchronization between the non-rt thread that executes the subscriber callback and the rt thread that runs the controller update method. Good catch!, I just opened a ticket to track this issue. effort_controllers::JointPositionController, on the other hand, handles concurrency correctly.
Finally, for the third question. The RealtimeBuffer::initRT() is likely assuming that it can only be called in circumstances in which there is no active writer to the shared resource. This is of course undocumented, and I'm judging from the implementation. The fact is, RealtimeBuffer is not well suited for usecases in which the rt-thread writes into the shared resource. For such cases, you could try using a regular lock, possibly around a lightweight object like a pointer. realtime_tools::RealtimeBox is a trivial implementation of this (in fact, there is nothing rt-specific in the implementation).
It has been on my mind for ros_control to leverage better synchronization primitives, but so far the resources have not been there to properly take on the task.
i hope to have answered your questions.

Originally posted by Adolfo Rodriguez T with karma: 3907 on 2015-01-22
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Daniel L on 2015-01-24:
Thank you for taking the time to answer. I think I was not clear with my first question. In JointPositionController, command_struct_, which is not the RealtimeBuffer, is used in both threads: ROS message handling (setCommand) and the control loop (starting and update). Is this ok?
Comment by Mathias LÃ¼dtke on 2015-01-28:
I have added the realtime buffers for the forward controllers: https://github.com/ros-controls/ros_controllers/pull/161
It fixes some other problems as well.
You are right, the use of command_struct_ is not thread-safe!
It must not be used in update. The copy could be replaced by a local reference.


Q:

Using ROS for Bipedal Balancing

I'm looking to use ROS for a robot that balances in a bipedal configuration and can maintain its balance with external forces being applied (light pushing). My main concern would be if ROS could handle quickly taking in sensor data and making small adjustments during operation. I'm aware that ROS 2 has better support for real time systems, however my team is more acquainted with ROS 1 and will be using components that don't have explicit support in ROS 2 yet.
The system will be equipped with an arduino as an interface to motor controllers (and potentially the sensors) connected to a Raspberry Pi or Jetson Nano that will be running ROS. An external computer will more than likely be providing the actual balancing algorithm through ROS.
Any help in this topic is greatly appreciated. I can provide more details about the robot and its theoretical software architecture as needed.

Originally posted by andrew_103 on ROS Answers with karma: 23 on 2020-10-03
Post score: 0

A:

https://index.ros.org/doc/ros2/Tutorials/Real-Time-Programming/
might have some info for you.
Every time you read sensor and have to move the data over a some kind of network (serial, ethernet, wifi, usb etc etc), you will experience network effects.
What data speeds will your sensors be generating?
It maybe a better idea to have a dedicated microprocessor doing this, rather than a general purpose computer. The MCU can just worry about collecting sensor data, running the algorithm and making adjustments in low latency in a tight loop.
once you start to transmit and receive data in and out of one MCU to another MCU, or to a computer (PI/Desktop) then it can get a little unpredictable with bandwidth, delay, jitter, latency etc etc ... although they can be optimised and set to realtime scheduling to reduce this....factor in the time it takes to run the balance algorithm in the worse case and get those correction out to motors/actuators....... the robot might have been tipped of balance too far, and unable to correct.
With a MCU your guaranteed that every cpu cycle is dedicated to a single task , or a few tasks, quite the opposite to a full computer , running a multitasking kernel , with many devices etc etc etc. The MCU doesn't have to worry about putting the data 'onto the wire', buffering the data etc etc etc...
Your data rates might be lower, and latencies high enough to tollerate this however. Or you maybe be able to some processing on the MCU's to lower data rates, and use high speed interconnection busses to decrease latency and jitter.

Originally posted by l33 with karma: 18 on 2020-10-05
This answer was ACCEPTED on the original site
Post score: 0


Q:

Installing recursive dependencies with rosdep?

I've got two catkin packages A and B, and a rosdep key for libfoo.  A <depend>s on B.  B <depend>s on libfoo.  libfoo is not installed.   rosdep install A does not attempt to install libfoo.  rosdep install B does.   Why doesn't rosdep recursively find all of A's dependencies and install them?  There's a rosdep argument -n that says to ignore implicit/recursive dependencies, but I'm not using it, so I would expect libfoo to be found.  Help?
Versions: rosdep v0.11.5, ROS Hydro, Ubuntu 12.04.5
Edit:
In this case, I haven't built the workspace yet, because I haven't installed all the system build dependencies.  So, I've cloned a few repos (including A and B) into a workspace src dir and then I do the following:
ROS_PACKAGE_PATH=~/ws/src:$ROS_PACKAGE_PATH rosdep install -i A

So here, B is found in the path and rosdep will not attempt to install B (in Debian form).  This is preferred, as I'm actively developing on B.  It does not however, attempt to resolve and install B's dependency libfoo.
ROS_PACKAGE_PATH=~/ws/src:$ROS_PACKAGE_PATH rosdep install -i B

This does resolve and install B's dependency libfoo.
My problem with "just install all the dependencies for everything in your workspace" is now I have to be very selective about what's in my workspace and how my repos are structured, even though I have the ability to only catkin build a certain package and its dependencies.  This is particularly onerous when I have metapackages with both backend and frontend packages in them, and I only want to build the backend (on robot) and frontend (on console).  It makes a lot of sense to keep the metapackage together so backend and frontend are tightly coupled... but I don't want to install a bunch of X or Qt dependencies on my robot.
I just want rosdep to do what I believe it's says it does...  Without using -n I expect implicit/recursive dependencies to be considered.
In the end, I would love a workflow that looks like this:
source /opt/ros/release/setup.bash
mkdir ~/ws/src
cd ~/ws/src
vcs import < ~/bunch-of-repos.yaml
ROS_PACKAGE_PATH=~/ws/src:$ROS_PACKAGE_PATH rosdep install -i on_robot_metapackage
cd ..
catkin config --init
catkin build on_robot_metapackage

And end up with all the system dependencies installed and workspace-resident catkin package dependencies built for my on-robot needs... and a very similar workflow with on_console_metapackage for my on-console needs.
Edit 2:
For metapackages... maybe something like this to rosdep install their dependencies:
# get direct dependencies
grep "exec_depend" ~/ws/src/A/package.xml | \
sed 's|^[[:blank:]]*<exec_depend>\(.*\)</exec_depend>|\1|' | \
ROS_PACKAGE_PATH=~/ws/src:$ROS_PACKAGE_PATH xargs -n1 rosdep install -i

# get direct dependencies' dependencies
grep "exec_depend" ~/ws/src/A/package.xml | \
sed 's|^[[:blank:]]*<exec_depend>\(.*\)</exec_depend>|\1|' | \
ROS_PACKAGE_PATH=~/ws/src:$ROS_PACKAGE_PATH xargs -n1 rospack depends | \
sort | uniq | \
ROS_PACKAGE_PATH=~/ws/src:$ROS_PACKAGE_PATH xargs -n1 rosdep install -i

That seems overly complicated...

Originally posted by dustingooding on ROS Answers with karma: 139 on 2016-07-27
Post score: 0

A:

rosdep is not a package manager it's an abstraction that resolves keys to pass to the appropriate package manager. In general it will look at your dependencies and ask the package manager to install those specifically. It expects the package manager to resolve recursive dependencies.
I'm guessing you're using an argument like --ignore-packages-from-source in which case it would skip A as requested. Otherwise it would attempt to install A from the debian package.
I could help you more if you'd provide an example of your command line usage and indicate whether A and B are release upstream, modified locally etc?
My general recommendation is to go to the root of your workspace and call rosdep install --from-paths src --ignore-src which will install all system dependencies of packages in your workspace.
Edit:
As I guessed in my answer you're using the -i option. Which means that you're telling it to ignore that package. An easy way to do what you want is to ask for your recursive dependencies using rospack.
rosdep install -i `rospack depends A`

Originally posted by tfoote with karma: 58457 on 2016-07-28
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by dustingooding on 2016-07-28:
I added an answer, because comments are too short for meaningful discussion.
Comment by tfoote on 2016-07-28:
Please edit your question to add more details instead of writing a new answer.
Comment by dustingooding on 2016-07-28:
Done.
It's worth noting rospack depends A doesn't work if A is a metapackage.  [rospack] Error: no such package A
Comment by sam26 on 2017-03-01:
Hey!! I was looking for the -n argument you mentioned. I want to install a package only with its top level dependencies and not all the dependencies recursively. Is there a similar argument for apt-get or any other command (besides rosdep) to achieve this?


Q:

Exporting multiple libraries from the same package

I have a package (simple_message) that builds a library, that is then used by other packages.  I would now like to build two versions of that library (one with some additional functionality).  I am able to build the two versions using some compiler switches and defining them in the CMakeLists.  To allow other packages to use the library I haved added the following to the manifest file:
<export>     <cpp cflags="-I${prefix}/include -DROS=1" lflags="-Wl,-rpath,${prefix}/lib -L${prefix}/lib -lsimple_message"/>   </export>
My problem is how do I add the second library.  I could add it to the manifest as part of the export tags, but how will other packages specify which version of the library they want to use?

Originally posted by sedwards on ROS Answers with karma: 1601 on 2012-11-21
Post score: 1

Original comments
Comment by joq on 2012-11-24:
How do you know which library instance you want to use?
Comment by Martin Peris on 2012-11-25:
Why don't you create a Stack and put each library on a different package inside the same stack?
Comment by sedwards on 2012-11-25:
Martin, the different packages would need to build against a common source.  The differences between the packages would be in a low level, common source file.  Right now, I use compiler flags to alter the source file.

A:

Although the discussion of my original question has changed my approach, here is the answer to my question.  Full disclaimer, I'm not an expert at CMake or even c/l flags, so there may be an even better answer.
The export line in the manifest should be changed to the following:
<export> <cpp cflags="-I${prefix}/include -DROS=1" lflags="-Wl,-rpath,${prefix}/lib -L${prefix}/lib" /> </export>
Any package that requires the library now must explicitly state which library it wants to use in CMakeLists.txt, ex:
rosbuild_add_executable(my_exe  src/my_exe.cpp)
target_link_libraries(my_exe my_lib) OR target_link_libraries(my_exe my_lib_alternate)
This goes against the recommended approach here.

Originally posted by sedwards with karma: 1601 on 2012-11-25
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by Lorenz on 2012-11-25:
I think your solution here is not bad. It doesn't seem too dirty and is probably more robust than compiling and linking the source files in other packages as mentioned in your other question.
Comment by dornhege on 2012-11-25:
I agree. There would be the option to make meta-packages that depend on yours and only export the -lmylib/-lmylib2 flags (empty otherwise). Then you could depend on those package names and users don't need to know the library names. The overhead is the meta/dummy package which isn't that nice.
Comment by joq on 2012-11-26:
I can't spot any difference in the target_link_libraries() alternatives. Is there supposed to be one?
Comment by sedwards on 2012-11-26:
Jack(see dit).  Lorenz, while this approach works, I have 3 potential compiler swtiches (one for byte order, size of ints, and size of floats) which could result in 8 versions of the library.  I'm trying to address platform independence on the client side because the servers side isn't capable.


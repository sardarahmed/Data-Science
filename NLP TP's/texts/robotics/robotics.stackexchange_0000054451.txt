Q:

TimeSync handler never called

The following code handler is never called. This should work yes?
    #include <string>
    #include <ros/ros.h>
    #include <geometry_msgs/PoseStamped.h>
    #include <message_filters/subscriber.h>
    #include <message_filters/time_synchronizer.h>
    #include <message_filters/sync_policies/approximate_time.h>
    
    
    using namespace message_filters;
    
    class SynchronizerTest
    {
    public:
      SynchronizerTest()
      {
        setTest();
      }
    
    
    void handelerSynchronizerTest(const geometry_msgs::PoseStampedConstPtr& msg1, const geometry_msgs::PoseStampedConstPtr& msg2)
    {
        ROS_INFO("HERE1 made it to handeler [%e]", msg1->header.stamp.toSec());
        ROS_INFO("HERE2                     [%e]", msg2->header.stamp.toSec());
    }
    
void setTest()
{
     j1_sub = n.subscribe("/SynchronizerTest1", 10, &SynchronizerTest::handelerSynchronizerTest, this);
     j2_sub = n.subscribe("/SynchronizerTest2", 10, &SynchronizerTest::handelerSynchronizerTest, this);
    // TimeSynchronizer<geometry_msgs::PoseStamped, geometry_msgs::PoseStamped> sync(j1_sub, j2_sub, 10);
    // sync.registerCallback(boost::bind(&SynchronizerTest::handelerSynchronizerTest, this, _1, _2));
     ROS_INFO("Test set");
}

private:

 ros::NodeHandle n;
 Subscriber<geometry_msgs::PoseStamped> j1_sub;
 Subscriber<geometry_msgs::PoseStamped> j2_sub;

};  // Enodof Class
    
    
    
    int main(int argc, char **argv)
    { 
      ros::init(argc, argv, "SynchronizerTest");
      ros::NodeHandle n;
      ros::Rate loop_rate(10);
      int count = 0;
    
      SynchronizerTest sp;
      ros::Publisher pub1 = n.advertise<geometry_msgs::PoseStamped>("SynchronizerTest1", 10);
      ros::Publisher pub2 = n.advertise<geometry_msgs::PoseStamped>("SynchronizerTest2", 10);
      while (ros::ok())
      {
         geometry_msgs::PoseStamped msg;
         msg.header.stamp = ros::Time::now();
         pub1.publish(msg);
         pub2.publish(msg);
         ros::spinOnce();
         loop_rate.sleep();
         ++count;
      }
    
      return 0;
    }

Originally posted by rnunziata on ROS Answers with karma: 713 on 2013-09-28
Post score: 2

Original comments
Comment by Boris on 2013-09-28:
How do you publish to /SynchronizerTest1 and /SynchronizerTest2? Do your messages satisfy the conditions from here: http://wiki.ros.org/message_filters/ApproximateTime ?
Comment by rnunziata on 2013-09-28:
If you can see where this does not meet requirements then please point it out.  Really all I want is a blocking read I can correlate time. I did look over this document and did not see anything that should stop this code from working.
Comment by Boris on 2013-09-28:
Oh, sorry... I confused this questions with another yours. Somehow several of them looks very similar.

A:

The problem is that you have defined subscribers in a local namespace. Thus j1_sub and j2_sub are destroyed immediately after setTest() function returns. So make them members of the class to make it work. Same with the TimeSynchronizer.

EDIT:
Here is one of the possible implementations:
class SynchronizerTest
{
  boost::shared_ptr<Subscriber<geometry_msgs::PoseStamped> > j1_sub;
  boost::shared_ptr<Subscriber<geometry_msgs::PoseStamped> > j2_sub;
  boost::shared_ptr<TimeSynchronizer<geometry_msgs::PoseStamped, geometry_msgs::PoseStamped> > sync;

...

  void setTest()
  {
    j1_sub.reset(new Subscriber<geometry_msgs::PoseStamped>(n, "/SynchronizerTest1", 10));
    j2_sub.reset(new Subscriber<geometry_msgs::PoseStamped>(n, "/SynchronizerTest2", 10));
    sync.reset(new TimeSynchronizer<geometry_msgs::PoseStamped, geometry_msgs::PoseStamped>(*j1_sub, *j2_sub, 10));
    sync->registerCallback(boost::bind(&SynchronizerTest::handelerSynchronizerTest, this, _1, _2));
    ROS_INFO("Test set");
  }

...

}

Originally posted by Boris with karma: 3060 on 2013-09-28
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by rnunziata on 2013-09-29:
I have made the changes you recommend by now I get compilation errors. Can you supply the correct code for this short program please. I do recommend that the documentation be updated with solution for class functions.
Comment by Boris on 2013-09-29:
Well, you did some very strange modifications, but definitely not what was recommended. I will update the answer with a code snippet in a bit.
Comment by rnunziata on 2013-09-29:
Thank you..I look forward to the solution.
Comment by rnunziata on 2013-09-30:
Do you think you will have time this week to post the solution. Thank you.
Comment by Boris on 2013-09-30:
It has been posted couple of days ago. Please see EDIT section in my answer.
Comment by rnunziata on 2013-10-01:
Sorry Boris...did not see Edit. The *n_ was giving me problems but it compiled if I changed it to just n.  Will be testing shortly.
Comment by Boris on 2013-10-01:
My mistake, sorry... That is actually exerpt from a working program, I just have a habit to keep things as shared pointers including ros::NodeHandle and forgot to change it back to your notation.
Comment by rnunziata on 2013-10-01:
Much thanks...that worked..:-)
I would like to see the tutorial updated to reflex member usage as it is not obvious. I feel the two approaches present a inconsistent view of the interface and that it would be better to just have one that worked for both.


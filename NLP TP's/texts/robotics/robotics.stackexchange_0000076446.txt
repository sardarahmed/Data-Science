Q:

How to Detect Subscriber Drops a Message

I made a subscriber which reads LIDAR data from rosbag-play. I use C++(roscpp).
But when I do rosbag-play with normal speed, subscriber's callback function cannot catch up with
LIDAR stream speed, then subscriber's queue become easily full, and many data is dropped and algorithm doesn't work properly.
So I have to control the speed of rosbag-play, and to decide appropriate speed, I need to know whether subscriber is dropping data or not.
How can I detect that ?
(Making queue-size very big is not my choice, because it's just a matter of time until the queue gets full...)
(I googled about this question and expected someone already answered, but I could not find any concrete solutions)
Thank you for your time, in advance.

Best regards,
Nanoha.

Originally posted by Nanoha on ROS Answers with karma: 45 on 2016-09-23
Post score: 3

Original comments
Comment by NEngelhard on 2016-09-24:
Why do you need the rosbag play? Can't you implement a testing interface in which the node pulls the data directly from the bagfile with the C++-Api?

A:

You might try this approach:

Set up a queue inside your node for incoming messages, with some fixed size.

Callback function for your message subscriber (which runs in its own thread) puts incoming messages into the queue, unless full, in which case it drops the message and increments a count of dropped messages.

Main loop follows the logic below.
 while (ros::ok()) {
     nh.spinOnce();

     if  (droppedMessageCount > 0) {
         ROS_ERROR("%d messages were dropped", droppedMessageCount);
     }
     droppedMessageCount = 0;

     if (message queue not empty) {
         take first message from queue and process it
     }
 }

This doesn't use any ROS facilities to find out if messages are dropped, but would allow your node to give an indication in the log.

Originally posted by Mark Rose with karma: 1563 on 2016-09-23
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Nanoha on 2016-09-24:
Thank you for replies. You mean making a class like below, or make global queue?
class LaserSub {
static queue<sensor_msgs> input;
static void callback(&msg) {
// if queue is full print error, if not full just process
};
// main
scan_sub = nh.subscriber("hoge", 1, &LaserSub::callback, this) ;


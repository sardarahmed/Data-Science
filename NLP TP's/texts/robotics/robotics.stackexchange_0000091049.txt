Q:

how does ros2 implement its network design?

In Why ROS 2.0, there is design goal of ros2 network:

we want ROS to behave as well as is possible when network connectivity degrades due to loss and/or delay, from poor-quality WiFi to ground-to-space communication links.

I am curious about how ros achieves this goal? If the network is poor, what will ros2 do, discard messages?

Originally posted by huchaohong on ROS Answers with karma: 47 on 2019-03-22
Post score: 1

A:

I am curious about how ros achieves this goal?

The issue with lossy networks and ROS 1 was that it used TCP almost exclusively, and if you lost data, TCP would try to resend it, which would further stress the network and you could end up saturating the network and not even keeping up at all. Especially since the common use case for this was streaming some sensor data over wifi to a workstation to visualize it in rviz, in which case you don't care if you miss a few messages. ROS 1 does have a UDP transport, but it had several issues, for example being unreliable for large data and not being supported uniformly (python never supported it).
DDS has unreliable and reliable communication and graceful degradation, i.e. a reliable publisher can send data to an unreliable subscriber (but not the other way around). But more importantly, DDS's reliable communication happens over UDP with a custom protocol on top (DDSI-RTPS), which has the advantage over TCP that you can control things like how long it will retry to send data, how long it will wait for a NAK, how it will buffer data before sending (like Nagle's algorithm), etc...
Basically, the idea is that DDS's configuration options allow it to be many things between TCP and simple UDP, including a more flexible version of TCP, which in turn allows you to fine tune your communication settings to better work on lossy networks.
This comes at the cost of complexity and some performance (TCP on the local host is really good), but should allow knowledgeable users to get good results in more situations.

If the network is poor, what will ros2 do, discard messages?

To answer this more directly, I'll cop-out and say "it depends". If you're using unreliable the messages will be discarded. If you're using reliable then just like ROS 1 and TCP it will try to send them until your system resource limits are reached, at which point it will discard them. The only difference, as I mentioned above, is that with DDS you can know when they are discarded and have more control over when they will be discarded and how it will try to resend them.
Hope that answers your questions somewhat.

Originally posted by William with karma: 17335 on 2019-03-22
This answer was ACCEPTED on the original site
Post score: 7

Original comments
Comment by huchaohong on 2019-03-22:
Thanks for you detailed explanation,  i can understand the design more clearly now.
Comment by lucasw on 2019-03-24:
Is there anything in the works that could make future ROS2 versions achieve that really good ROS1 TCP performance level for inter-process localhost communications?
Comment by Geoff on 2019-03-25:
You can use the intraprocess transport, which is zero-copy for nodes in the same process, or you could direct your DDS implementation to use TCP if it has support for it (Connext DDS does, for example). Depending on the implementation you may still have marshalling (again, Connext does), but it should use the loopback interface. If you must have no marshalling and local-only maximum performance, then intraprocess is the way to go.
Comment by lucasw on 2019-03-26:
It would be nice if TCP could be selected on a topic by topic basis (not clear from looking at  http://community.rti.com/docs/html/tcp_transport/main.html#configuring - is a node a 'domain participant'?  Or a topic?).  Or even better use tcp locally by default and udp when needed to communicate with other systems even on the same topic.
I suppose if the tools (especially python ones) for intra-process become nearly seamless it's less of an issue.  Making the command line, rviz, and gui tools work intra process seems challenging- each one would spawn nodes inside of every local process they are trying to interact with to get at the data without having to use the udp dds?
Comment by William on 2019-03-28:
Yes, there are "locators" for TCP in addition to UDP or UDP multicast or even shared memory, it just depends on the implementation if it supports it. I think Fast-RTPS also has a TCP option https://eprosima-fast-rtps.readthedocs.io/en/latest/advanced.html#tcp-transport. However, it's not as awesome as you'd like because it still has to do the RTPS framing which is redundant with a lot of what is in the TCP headers. Depending on the implementation and the size of the messages, it might be much better or only marginally better. More work needs to be done here to see what the benefit might be.


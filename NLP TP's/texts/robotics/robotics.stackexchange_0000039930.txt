Q:

Avoiding overhead when nothing subscribed

Formerly entitled "Does ROS publish messages if no nodes are subscribed"
I'm making a node to process data from a kinect and return a transform.  I'll only need the transform message every once in a while in a service, so I was debating different ways of setting the node up and how efficient those ways are.  I see two options:
Option 1: I could make the node offer a service to get the desired transform.  This way, I would use waitForMessage in the node's service function to get the kinect data and return a response for each request.
Option 2: I could make the node subscribe to the kinect topic and continuously publish the transform.  Since in this scenario, I don't want to do something EVERY time I get the transform message, I could use waitForMessage in the client to get a transform message at the proper time.
Now the problem comes with adding debug messages while keeping it efficient.  It would be nice to publish image messages at different points in the node's pipeline and to publish the transform message that would be retrieved from a request without actually having to make a request.
Option 1 isn't so great for doing this. Since in the service you have to make a request in order to get the transform, you'd have to make a separate image callback function subscribed to the kinect topic.  This callback would have basically the same code as the service code, only this time publishing extra images.  To keep it efficient, you could have some way to enable and disable the callback code.
Option 2 seems easier and seems more like the ROS way to do things, but it's inefficient if the computation is done at all times without the client code caring and without rviz subscribing to debug.
So if nothing is subscribed or waiting on a topic, is the computation still performed?  Or is there another reason why I should choose one option or another?  The best practice on using services vs topics hasn't been written yet.
EDIT FOR POSTERITY:
I've realized that I didn't name this question very well. (I wonder if I should rename it..) I'm concerned about all the computation in a callback, not just the publishing.  The wiki says right here that publish() doesn't do anything if nothing is subscribed.
I really wanted to know if the computation that creates the data to publish still gets done.  And the answer is yes: the callback isn't result oriented, it's a result of getting a message, and if you get a message, it'll execute whether there are subscribers or not.
So as the answers suggest, this question is really about the best way to solve the scenario above.
EDIT 2 I changed the name of the question for your searching convenience.

Originally posted by thebyohazard on ROS Answers with karma: 3562 on 2012-04-26
Post score: 3

Original comments
Comment by joq on 2012-04-27:
Quite right. As you say, the title is confusing. Perhaps something like: "How to avoid message creation overhead when no nodes are subscribed?"

A:

I recommend the following simple logic in your publisher:
/** @brief Callback for raw scan messages. */
void Convert::processScan(const velodyne_msgs::VelodyneScan::ConstPtr &scanMsg)
{
  if (output_.getNumSubscribers() == 0)         // no one listening?
    return;                                     // avoid much work

  ...                                           // PointCloud2 conversion

  output_.publish(outMsg);                      // publish the message
}

Originally posted by joq with karma: 25443 on 2012-04-26
This answer was ACCEPTED on the original site
Post score: 9

Original comments
Comment by thebyohazard on 2012-04-27:
Thanks, this is exactly what I wanted!  Though when I tried it, there's still a bit of a delay (at least 30 seconds on my computer) between the time a subscriber (such as rviz or the waitForMessage function in a client) closes and the time my node realises there are no more subscribers.
Comment by joq on 2012-04-27:
Interesting, I didn't know the delay was that long.
Comment by Stephan on 2012-04-27:
See this question and ticket 3403 for another discussion on this time delay.


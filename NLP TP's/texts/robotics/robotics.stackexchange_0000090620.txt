Q:

Callbackfunction is not called even though messages are published

Hey there,
I am using Ros kinetic on Linux and have used cpp nodes so far. Now I added a python node which should publish a message to a cpp node.
During debugging I found out the following. My cpp node is initialized and the subscriber started. I have a ros::spin() there as well.
int main(int argc, char** argv)
{
    // initialize ros node
    ros::init(argc, argv, "velocity_planner");
    std::cout<<"node started"<<std::endl;

    // create node handle
    ros::NodeHandle handler;

    ros::Subscriber new_simulation
        = handler.subscribe("/new_simulation", 1, NewSimulationCallback);
    std::cout <<"Subscriber activated"<<std::endl;

    ros::spin();

    return 0;

The Callback is defined as follows:
void NewSimulationCallback(const velocity_planner::NewSimulation::ConstPtr& msg){
    std::cout<<"rakada calllback"<<std::endl;
    set_theta.theta_scale = msg->theta_scale;
    set_theta.theta_limit = msg->theta_limit;
    velocity_planner_.set_theta(set_theta);
    velocity_planner_.reset_sim_stats();
    std::cout << "jipidududud"<<std::endl;
    system("gnome-terminal -x bash ~/Desktop/TCLServer.bash"); // start simulation in Carmaker
}

My publisher node is set up like this:
#initialize the rosnode
pub = rospy.Publisher('/new_simulation', NewSimulation, queue_size=1)
rospy.init_node('spearmint', anonymous=True)

theta = NewSimulation()
theta.theta_scale = x
theta.theta_limit = y
pub.publish(theta)
print 'waiting for message'

When I open the rqt graph I can the the New Simulation topic as well as both nodes
When I echo for the topic /new_simulation I am reciving the correct messages. The python code is called as a submodul from a main node and then I initialize the submodual as a Ros node with the code shown above. After the Publish I use a try wait_for_message to get something back from the velocity planner node.
Since I get the output "Subscriber activated" I now it starts the Cpp node (as well as from the rqt_graph) but I never get the std::outs from the Callback.
Any help greatly appreciated.
I am running on Linux 16.04. I use catkin build to build four packages and it doesnt give me an error. The message file NewSimulation is found in both packages.
I am happy to provide any other information if needed.

Originally posted by Lorry_Ros on ROS Answers with karma: 26 on 2019-02-22
Post score: 0

A:

So what I basically did is I added a return between the void statement and the curlly bracket like this:
void NewSimulationCallback(const velocity_planner::NewSimulation::ConstPtr& msg)
{

Now it is all working fine. If anybody knows the turns and twists of cpp I am still highly interested what the difference is or how my compiler takes this as something differnt.
Cheers for now!
Edit 1: Actually that didnt help. Just by chance the subscriber got this single sent message. Many messages in Ros get los in gerneral. So I did another trick with a while loop seeting it to a slow but not too slow rate in publishing for a while and using an if statement on the cpp side to just recieve the first message. Hope that might help people. You can also check out a post about just sending one message over a publisher.
Edit 2: Just for notice.  Sending single messages in the other direction works perfectly fine using wait_for_message. Unfortunatly I can't use it in the first case on the cpp side even though it should be recommended for usage. Addition to edit 1: I set rate to 1 Hz and sent 4 message via the while loop. Works fine for me.

Originally posted by Lorry_Ros with karma: 26 on 2019-02-22
This answer was ACCEPTED on the original site
Post score: 1


Q:

How to get started using the C++ API for Gazebo Harmonic?

I'm completely new to gazebo and did some of the well explained tutorials to learn how the basic functionality of gazebo is working. So this is my setup:
I'm using Windows 10 and installed gazebo with WSL2 on a Ubuntu distribution. From here I did some of the tutorials and was able to interact with the simulation with the gui and also via messages from the powershell (using wsl). So from the powershell I'm able to start the simulation and also can send and receive commands to move the robot or read out some sensor data.
My plan is, to use this functionality inside of a C++ or C# application without using the powershell. So I like to use the C++ API given by gazebo.
My idea is, to write some code in Visual Studio on my Windows machine and execute this code via cross compilation on my wsl2 instance, where my actual gazebo instance is running.
My key question is, how to integrate the gazebo library into Visual Studio and to be able to interact with my gazebo instance? For the beginning i would just start a scene "my_world.sdf" and read out some sensor data.
Currently I am struggeling with the integration into Visual Studio 2022.
I would be really grateful for any advice given to this topic.
Update
I think I'm getting closer here, so a short recap what I did so far:
I created a cmake-project in Visual Studio 2022, because this seems to be the recommended way to be able to connect via WSL.
There is a nice tutorial for this here.
Running a simple Hello World output via WSL2 in terminal works fine.
Then I built harmonic source files in a fresh ubuntu distribution (see also my different post).
I wasn't able to run gz sim after building the source files, so I installed gz from the binaries, but kept the source files to be able to link the header files and libraries in my CMake project.
From here I copied the contents from the source files from {workspace}/install/include and {workspace}/install/lib to my CMake project dir.
In my CMakeProject in the CMakeLists.txt I added:
include_directories(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/include/gz/cmake3)
include_directories(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/include/gz/common5)
include_directories(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/include/gz/fuel_tools9)
include_directories(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/include/gz/gui8)
include_directories(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/include/gz/launch7)
include_directories(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/include/gz/math7)
include_directories(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/include/gz/msgs10)
include_directories(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/include/gz/physics7)
include_directories(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/include/gz/plugin2)
include_directories(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/include/gz/rendering8)
include_directories(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/include/gz/sdformat14)
include_directories(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/include/gz/sensors8)
include_directories(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/include/gz/sim8)
include_directories(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/include/gz/transport13)
include_directories(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/include/gz/utils2)

link_directories(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/lib)

In my CMakeProject.cpp I simply added:
#include "gz/transport.hh"

There have been some issues with missing files, like:

google/protobuf
tinyxml2.h
zmq.hpp
uuid/uuid.h

I fixed the missing dependencies while installing the packages with apt-get, but I don't know why they were missing initially.
Now I got a lot of undefined references from the linker:

gzTransportNodeCreate
gzTransportNodeDestroy
gzTransportAdvertise
...

To fix this I tried to add this to my CMakeLists.txt:
link_libraries(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/lib/libgz-transport13.so.13.0.0)
link_libraries(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/lib/libgz-transport13-log.so.13.0.0)
link_libraries(${CMakeProject_SOURCE_DIR}/CMakeProject/gz-harmonic/install/lib/libgz-transport13-parameters.so.13.0.0)

Unfortunately this didn't help, I still got the undefined references.
Am I missing out something here? I have been working on this for over a week now and don't just want to quit here, but I'm running out of ideas.

A:

Finally I'm able to communicate with the Gazebo API. So following steps worked out for me:
1. Installing Ubuntu with WSL2
Make sure to use WSL2. You can meet this condition with wsl --set-default-version 2 before installing Ubuntu or changing the Version of a existing distribution with wsl --set-version Ubuntu 2. Double check the version with wsl -l -v. I would also recommend to use a fresh installation to build from your Gazebo source, since I could solve some weird errors just by setting up a new distribution.
Stick to this guide for more detailled information.
2. Building from Gazebo src
The official tutorial describes this process pretty well and with a fresh distribution I nearly had no problems. But you should consider to copy the multi-line code instructions to your favorite text editor first, so you can see which code lines are interrupted by a line break, since the formatting of the webpage can be a bit confusing here. Best practice for me was to not copy multiple commands at once.
3. Install Gazebo from binaries
I only installed the source to compile the needed libraries, but my actual Gazebo instance is running from the binaries.
Stick to the official guide and you are fine.
4. Create your CMake Project
There is an official help page from Microsoft especially for this. In short I did this:

Installed following components for Visual Studio 2022

C++ Cmake -Tools for Windows
C++ Cmake -Tools for Linux
C++ for Linux development

Create your CMake Project from the CMake Project Template
Select WSL: Ubuntu (if Ubuntu is the name of your distro) as connection an Linux Debug as your configuration.
Run the Hello World example program to check if your system is set up properly (Hello World should be printed by your Linux terminal)

5. Configure your CMake Project
First I copied the header files and the libraries into my own CMakeProject directory.
The /include and /lib directories are copied from the /install dir of the source dir from step 2.2.
Make sure to delete all 0KB sized files from the /lib dir and it's subdirectories, because this will lead to errors with rsync in later steps.
For Gazebo API Integration, modify your CMakeLists.txt from your CMake Project main dir like this:
cmake_minimum_required (VERSION 3.20)
Gazebo is using the function cmake_path that was just introduced with cmake 3.20.
In my case Visual Studio was using version 3.19 and it wasn't that easy to change the cmake version used by Visual Studio. This line just makes sure that the minimal required cmake version is used.
My CMakeLists.txt from my executable project looks like this:
include_directories(${CMakeProject_SOURCE_DIR}/CMakeProject/include/)

find_package(gz-msgs10 QUIET REQUIRED OPTIONAL_COMPONENTS log)
find_package(gz-transport13 QUIET REQUIRED OPTIONAL_COMPONENTS log)

set(GZ_MSGS_VER ${gz-msgs10_VERSION_MAJOR})
set(GZ_TRANSPORT_VER ${gz-transport13_VERSION_MAJOR})

target_link_libraries(CMakeProject gz-transport${GZ_TRANSPORT_VER})
target_link_libraries(CMakeProject gz-msgs${GZ_MSGS_VER})

My problem with the missing libraries got fixed with the functions find_package and target_link_libraries.
Including <gz/transport.hh> and <gz/msgs.hh> should be working fine if you didn't encounter any problems in the prior steps. From here on I recommend to have a look in the examples directories from gz-transport or any other plugin you want to integrate.
I still got a problem with Intellisense not recognizing the members from the namespace gz:transport, but that doesn't affect the linking process. Maybe I can give a heads up for this as soon as it's working, too.


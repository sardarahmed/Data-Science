Q:

rospy subscriber buffer length

Hi
This is from the C++ subscriber tutorial
   * The second parameter to the subscribe() function is the size of the message
   * queue.  If messages are arriving faster than they are being processed, this
   * is the number of messages that will be buffered up before beginning to throw
   * away the oldest ones.
   */
  ros::Subscriber sub = n.subscribe("chatter", 1000, chatterCallback);

In the python tutorial it is
rospy.Subscriber("chatter", String, callback)

//This declares that your node subscribes to the chatter topic which is of type std_msgs.msgs.String. When new messages are received, callback is invoked with the *message as the first argument. 

I am wondering if the python version supports a message queue?
Also why is the same method different between C++ and Python for instance in the python subscriber you have to declare what type of message you are subscribing to...
Is this because python is an interpreted language?
Also do you find it easier to code in python over C++ in terms of development time for a ROS project?

Originally posted by Sentinal_Bias on ROS Answers with karma: 418 on 2013-03-09
Post score: 1

A:

In rospy, queue_size can be used a named parameter:
x = rospy.Subscriber("topic_name", String, callback, queue_size = 10)

See the API docs for rospy. I think this is considered an advanced topic that isn't frequently used, and as such hasn't really been covered in the tutorials.

Originally posted by fergs with karma: 13902 on 2013-03-09
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by Sentinal_Bias on 2013-03-10:
Oh i see, it was in the C++ tutorial, the API mentioned that there could be problems if multiple nodes subscribe to the topic, which wont be a problem in my case. Well this is good i guess i can remove my circular buffer code.


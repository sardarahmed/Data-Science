Q:

Network data loss using 4 robots

I have a group of four robots. Right now I am doing testings on the data transmission over a wireless network, the output of rqt_graph is shown below.

Robot 1, 2 and 3 are different robots sending a message.
Leader 1, 2 and 3 are the same leader robot running the listener 3 times.

So, I have 4 robots, 3 sending, 1 receiving. I want my application to be as real time as possible. I am running at 30 Hz. First I tough to put nothing on the stack, so the data I receive is always the newest one, the publishers and subscribers are set with a stack size of 1, but with that I lose a lot of data. The output is shown below:

Machine is the robot sending data
Message is the message number received
Counter is the message number expected

I print out whenever Message and Counter are different and at every second.
[ INFO] [1458884633.094665493]: Machine <0> Message<150>
[ WARN] [1458884633.249164663]: Machine <1> Message<188> Counter <186>
[ WARN] [1458884633.249326863]: Machine <1> Message<192> Counter <189>
[ INFO] [1458884633.261020475]: Machine <2> Message<270>
[ WARN] [1458884633.367932119]: Machine <0> Message<154> Counter <152>
[ WARN] [1458884633.368090775]: Machine <0> Message<158> Counter <155>
[ WARN] [1458884633.619671753]: Machine <1> Message<202> Counter <196>
[ WARN] [1458884633.720845046]: Machine <0> Message<165> Counter <163>
[ WARN] [1458884633.721000330]: Machine <0> Message<168> Counter <166>
[ INFO] [1458884633.832237240]: Machine <1> Message<210>
[ WARN] [1458884633.972283715]: Machine <2> Message<289> Counter <285>
[ WARN] [1458884633.972402930]: Machine <2> Message<291> Counter <290>
[ INFO] [1458884634.102028388]: Machine <0> Message<180>
[ WARN] [1458884634.154272541]: Machine <1> Message<217> Counter <214>
[ WARN] [1458884634.154369931]: Machine <1> Message<219> Counter <218>
[ INFO] [1458884634.262470496]: Machine <2> Message<300>
[ INFO] [1458884634.832749255]: Machine <1> Message<240>
[ WARN] [1458884635.340362798]: Machine <0> Message<215> Counter <209>
[ WARN] [1458884635.340468232]: Machine <0> Message<217> Counter <216>

Then, I tried increasing the stack to 10 elements, and the output was improved:
[ INFO] [1458885577.781345375]: Machine <0> Message<150>
[ INFO] [1458885578.197521359]: Machine <1> Message<180>
[ INFO] [1458885578.806767762]: Machine <0> Message<180>
[ INFO] [1458885578.973456886]: Machine <2> Message<240>
[ WARN] [1458885578.973578372]: Machine <2> Message<249> Counter <241>
[ INFO] [1458885579.348755549]: Machine <2> Message<270>
[ INFO] [1458885579.417701869]: Machine <1> Message<210>
[ INFO] [1458885579.781167298]: Machine <0> Message<210>
[ WARN] [1458885580.121854098]: Machine <1> Message<222> Counter <218>
[ WARN] [1458885580.121951202]: Machine <1> Message<228> Counter <223>
[ INFO] [1458885580.390034144]: Machine <1> Message<240>

If I increase the stack then I start experiencing a lag. I think I will have to do a trade between the speed in the transmission and the stack size to something that suits my application. But, I was wondering if there is a way to improve the network communication? Maybe some settings in ROS or my network that I am not taking into account.
EDIT 1
As al_dev suggested, changing to UDP improved the transmission, but now I can't get to work one detail. I am using the MultiThreadedSpinner as shown, it works well:
ros::MultiThreadedSpinner multi_spinner( 3 );
multi_spinner.spin();

But what I actually want is:
ros::CallbackQueue callback_queue;
callback_queue.callOne( ros::WallDuration( 0 ) );
ros::MultiThreadedSpinner multi_spinner( 3 );

while( ros::ok() )
{
    loop_rate.sleep();
    multi_spinner.spin( &callback_queue );
}

But when I use this, it never enters the callback. How to use  callOne?

Originally posted by Luis Ruiz on ROS Answers with karma: 114 on 2016-03-25
Post score: 0

Original comments
Comment by gvdhoorn on 2016-03-25:
Just an FYI: stack == queue.
Comment by al-dev on 2016-03-28:
@luis-ruiz, are you using TCPROS or UDPROS here?
Comment by Luis Ruiz on 2016-03-30:
I am connecting via ssh, so I think I am using TCP. I followed this tutorial

A:

For multi-robot systems where you have a crowded network and delayed data becomes quickly irrelevant (e.g sharing position/velocities to neighbors in a swarming formation), UDP can a better choice, at the expense of less reliability.
If leader 1,2,3 are the same robot and run the same listener, you might want to try using a single node with N subscribers and a Multi-threaded spinner instead of the default ros::spin() ( http://wiki.ros.org/roscpp/Overview/Callbacks%20and%20Spinning ).
If you really cannot get the performance you want, it might be good to stress test your network without ROS to understand exactly where the bottlenecks are.

Originally posted by al-dev with karma: 883 on 2016-04-01
This answer was ACCEPTED on the original site
Post score: 1


Q:

Call multiple subscriber periodically at the same time

Hello. I would like to write a program that calls multiple subscribers periodically at the same time. Therefore, at the beginning, I wrote the program as shown in program1, but only rewritten main() like program2. In the program of program1, ros::spin() called three subscribers separately. So I decided to call them periodically using while. However, even in program2, they were called differently. Moreover, in program1, the publisher written in depthCb which was being executed also is not executed. How can I write the program to call multiple subscribers periodically at the same time? Thank you.
program1
#include <ros/ros.h>
...

void messageCallback(const sensor_msgs::JointState::ConstPtr& msg3)
{
   ...
}

void imageCb(const sensor_msgs::ImageConstPtr& msg2)
{
   ...
}

void depthCb( const sensor_msgs::ImageConstPtr& msg1)
{
   ...
   ros::Publisher pub = n.advertise<PointCloud> ("points2", 1);
   PointCloud::Ptr cloud (new PointCloud);
   cloud->header.frame_id = "/base";
   pcl_conversions::toPCL(ros::Time::now(), cloud->header.stamp);
   ...
   cloud->points.push_back (cloud->points[0]);
   pcl_conversions::toPCL(ros::Time::now(), cloud->header.stamp);
   pub.publish (cloud);
}

int main( int argc, char* argv[])
{
   ros::init( argc, argv, "depth_viewer" );
   ros::NodeHandle n;

   ros::Subscriber joint = n.subscribe("/hp3j/joint_states", 1000, messageCallback);
   ros::Subscriber color = n.subscribe("/pico_flexx_link_ir/image_raw", 1000, imageCb);
   ros::Subscriber depth = n.subscribe("/pico_flexx_link/depth_registered/image_raw", 3, &depthCb);

   ros::spin();
   return 0;
}

program2
int main(argc, char* argv[])
{
   ros::init( argc, argv, "depth_viewer" );
   ros::NodeHandle n;

   ros::Subscriber joint = n.subscribe("/hp3j/joint_states", 1000, messageCallback);
   ros::Subscriber color = n.subscribe("/pico_flexx_link_ir/image_raw", 1000, imageCb);
   ros::Subscriber depth = n.subscribe("/pico_flexx_link/depth_registered/image_raw", 3, &depthCb);

   ros::Rate loop_rate(0.1);
   while (ros::ok()) {
      ros::spinOnce();
      loop_rate.sleep();
   }

   return 0;
}

Originally posted by Akitoshi on ROS Answers with karma: 11 on 2017-08-04
Post score: 0

Original comments
Comment by naveedhd on 2017-08-04:
I think it would be technically incorrect to say "call subscibers". The callbacks are called whenever a message is received on the topic, when you call spin or spin_once. So if these three topics are being published (from other nodes,at higher frequency than loop_rate=0.1), all 3 would be called
Comment by Akitoshi on 2017-08-08:
Thank @naveedhd. I'm sorry for the late reply. I understood what I was misunderstanding as you said. However, nevertheless, depending on the timing, will the callback function be called or not called? For example, does not happen that depthCb is called but imageCb is not called?
Comment by naveedhd on 2017-08-08:
That depends on the node publishing these topics. Assuming both the topics are published together/with same rate, then most probably both Cbs would be called. If you are interested in getting the image and depth of the same instant, then look into what @NEngelhard has pointed to.
Comment by Akitoshi on 2017-08-08:
Thank @naveedhd for your early reply. In addition to the two data I would like to acquire the joint angle of the manipulator. Is message synchronizers a valid method even in that case?

A:

I think you want to look at Message synchronizers

Originally posted by NEngelhard with karma: 3519 on 2017-08-04
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Akitoshi on 2017-08-08:
Thank @NEngelhard. I'm sorry for the late reply. As you say, I programmed while watching 4.2 Example (C ++) of wiki. However, the following error occurred. How do you know what to do?
error: ‘TimeSynchronizer’ was not declared in this scope

Comment by NEngelhard on 2017-08-08:
looks like a namespace problem
Comment by Akitoshi on 2017-08-08:
Thank @NEngelhard! As you said, adding using namespace message_filters; has solved it!


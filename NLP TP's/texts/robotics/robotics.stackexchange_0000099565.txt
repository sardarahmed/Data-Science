Q:

PointCloud2 Storage Format

Hi,
I am trying to implement in FPGA a ROS publisher node of PointCloud2 messages. As a first step, i have already implemented a publisher node on the FPGA that is publishing strings. Now, i am trying to do the same but for the PointCloud2 message format.
It is very simple to understand how a string is stored, basically each character is converted to its ASCII value and stored (as it can be seen here). On the other hand, a PointCloud2 is a complex data type that is not so easy to understand.
I have made some progress on understanding how the metadata of a PointCloud2 is stored, however, it is being very difficult to understand the storage of the data part of the PointCloud2 data type. To simplify, I have also tried a PointCloud2 with only one point but i couldn't decode it either. I know that the X, Y and Z are sequentially ordered with 4 bytes each (the datatype is a Float32). Therefore, i can isolate the 4 bytes corresponding to one of the coordinates. I have tried to assign to the X coordinate the values from 0 to 17 (in decimal). This are the values stored when using these values (they are all in decimal):
1 = [0, 0, 128, 63] -> little-endian so, the most significant byte is 63 followed by, 128, 0, 0
2 = [0, 0, 0, 64]
3 = [0, 0, 64, 64]
4 = [0, 0, 128, 64]
5 = [0, 0, 160, 64]
6 = [0, 0, 192, 64]
7 = [0, 0, 224, 64]
8 = [0, 0, 0, 65]
9 = [0, 0, 16, 65]
10 = [0, 0, 32, 65]
11 = [0, 0, 48, 65]
12 = [0, 0, 64, 65]
13 = [0, 0, 80, 65]
14 = [0, 0, 96, 65]
15 = [0, 0, 112, 65]
16 = [0, 0, 128, 65]
17 = [0, 0, 136, 65]
So, my question is, how are the values stored? Supposedly the data part is stored in binary blobs according to here. However, i don't understand what does this mean and how it works. Also, i have not found any concrete example on how to convert a decimal value to this representation.
For a PointCloud2 with X, Y and Z my current understanding is the following (here is the corresponding data):
header:

seq (4 bytes)
stamp (16 bytes)
frame_id (1 byte per character)

height: 4 bytes
width: 4 bytes
fields:

number of fields (4 bytes)

field 1

dimension (4 bytes)
name (1 byte)
offset (4 bytes)
datatype (1 byte)
count (4 bytes)

field 2

dimension (4 bytes)
name (1 byte)
offset (4 bytes)
datatype (1 byte)
count (4 bytes)

field 3

dimension (4 bytes)
name (1 byte)
offset (4 bytes)
datatype (1 byte)
count (4 bytes)

is_bigendian: 1 byte
point_step: 4 bytes
row_step: 4 bytes
size: 4 bytes
data: size bytes
is_dense: 1 byte

Originally posted by Simao_Araujo on ROS Answers with karma: 16 on 2021-07-08
Post score: 0

A:

As I selected the datatype 7 (FLOAT32) the data part is stored as indicated in the standard IEEE 754 (which is a widely used standard to efficiently store floating-point numbers). Thankfully, there is already a Xilinx IP (Floating-Point Operator) to deal with floating-point numbers, including conversions from other types such as INT32 and mathematical operations such as multiplications.
Hope this helps.
Best regards,
Simão Araújo

Originally posted by Simao_Araujo with karma: 16 on 2021-07-14
This answer was ACCEPTED on the original site
Post score: 0


Q:

Parent TF frame in camera_pose_calibration

The individual calibrations are correct, but the calibration_tf_publisher saves all of the transforms relative to the /world frame (e.g. /world -> cam1 and /world -> /cam2 instead of /cam1 -> /cam2). The resulting TF tree is incorrect because /world is different for each pairwise calibration [1].
Is there any way I can save the transformation between the cameras without including the /world parent frame?
[1]: There is very little overlap between the cameras' fields of view and it is not possible to have one chessboard in view of all of the cameras at once. Instead, I would like to chain pairwise calibrations to build the TF tree.

If I was calibrating three cameras (cam1 through cam3), I would calibrate cam1-cam2
and cam2-cam3 separately. Currently, the calibration_tf_publisher would save the following transforms:

/world-/cam1 (calibration 1)
/world-/cam2 (calibration 1)
/world-/cam2 (calibration 2)
/world-/cam3 (calibration 2)

Because the world frame is arbitrary and differs between the two calibrations, there are two conflicting transforms from /world to /cam2. I would prefer that calibration_tf_publisher directly publish the transformation between the cameras (with no /world intermediate):

/cam1-/cam2 (calibration 1)
/cam2-/cam3 (calibration 2)

I don't think this would cause any problems with multiple-camera calibration, either: all of the transforms could be published as children of the first camera.

Originally posted by mkoval on ROS Answers with karma: 524 on 2011-05-28
Post score: 0

A:

You point out correctly that the camera_pose_calibration package only supports the case where all camera's simultaneously can see the same checkerboard target. The usecase where you calibrate different sets of camera's at different times is not well supported.
You could modify the calibration_tf_publisher (or the calibrator itself, either way works) to publish frames relative to one of the camera's you are calibrating. This can work, but be careful because the resulting code can easily be used wrongly: when you first calibrate cam1 -> cam2, and then you calibrate cam3 -> cam2, then cam2 will have two parent frames in tf (cam1 and cam3). This means the tf tree is invalid and you won't be able to do any meaningful tf queries. So to use your workaround correctly, you would have to calibrate cam1- -> cam2 first, and then cam2 -> cam3 (and not cam3 -> cam2).
It would be better to design a full solution to calibrate more distributed sets of camera's, but that would obviously be much more involved than the suggested workaround.

Originally posted by Wim with karma: 2915 on 2011-05-31
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by mkoval on 2011-06-01:
Thanks for the insight. I realized that forming cycles in the TF tree would be a problem, but hadn't considered a transform having multiple parents. I guess I will write a custom transform publisher for my specific use case.


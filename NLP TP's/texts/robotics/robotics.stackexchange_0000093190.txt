Q:

Unable to visualise point cloud in RViz even with header.frame_id selected

Hi all, I very new to ROS, so please bear with me. I am trying to render sample point cloud in the RViz, but for some reason it just won't show. I have set fixed frame to map which is the value of header.frame_id. rostopic echo on the point cloud topic returns data, so my take is that the point cloud is correctly generated but cannot be properly displayed in rviz. Here's the code for publishing the point cloud:
void Node::PublishMapPoints (std::vector<ORB_SLAM2::MapPoint*> map_points) {
  sensor_msgs::PointCloud2 cloud = MapPointsToPointCloud (map_points);
  map_points_publisher_.publish (cloud);
}

sensor_msgs::PointCloud2 Node::MapPointsToPointCloud (std::vector<ORB_SLAM2::MapPoint*> map_points) {
  if (map_points.size() == 0) {
    std::cout << "Map point vector is empty!" << std::endl;
  }

  sensor_msgs::PointCloud2 cloud;

  const int num_channels = 3; // x y z

  cloud.header.stamp = current_frame_time_;
  cloud.header.frame_id = "map";
  cloud.height = 1;
  cloud.width = map_points.size();
  cloud.is_bigendian = false;
  cloud.is_dense = true;
  cloud.point_step = num_channels * sizeof(float);
  cloud.row_step = cloud.point_step * cloud.width;
  cloud.fields.resize(num_channels);

  std::string channel_id[] = { "x", "y", "z"};
  for (int i = 0; i<num_channels; i++) {
    cloud.fields[i].name = channel_id[i];
    cloud.fields[i].offset = i * sizeof(float);
    cloud.fields[i].count = 1;
    cloud.fields[i].datatype = sensor_msgs::PointField::FLOAT32;
  }

  cloud.data.resize(cloud.row_step * cloud.height);

    unsigned char *cloud_data_ptr = &(cloud.data[0]);

  float data_array[num_channels];
  for (unsigned int i=0; i<cloud.width; i++) {
    if (map_points.at(i)->nObs >= min_observations_per_point_) {
      data_array[0] = map_points.at(i)->GetWorldPos().at<float> (2); //x. Do the transformation by just reading at the position of z instead of x
      data_array[1] = -1.0* map_points.at(i)->GetWorldPos().at<float> (0); //y. Do the transformation by just reading at the position of x instead of y
      data_array[2] = -1.0* map_points.at(i)->GetWorldPos().at<float> (1); //z. Do the transformation by just reading at the position of y instead of z
      //TODO dont hack the transformation but have a central conversion function for MapPointsToPointCloud and TransformFromMat

      memcpy(cloud_data_ptr+(i*cloud.point_step), data_array, num_channels*sizeof(float));
    }
  }

  return cloud;
}

Here's my RViz:

Any help would be much appreciated.

Originally posted by mun on ROS Answers with karma: 32 on 2019-09-03
Post score: 0

Original comments
Comment by gvdhoorn on 2019-09-03:
I'm not sure it really matters, but you seem to be setting width and height, but not depth of your pointcloud. A cloud with a depth of 0 would perhaps not work.
Comment by mun on 2019-09-03:
@gvdhoorn I thought I have here: cloud.data.resize(cloud.row_step * cloud.height); where cloud.row_step = cloud.point_step * cloud.width;. Am I missing something?
Comment by gvdhoorn on 2019-09-03:
No. I hadn't had my coffee yet. Ignore my comment.
Comment by mun on 2019-09-03:
@gvdhoorn All good. I did hope it could be as straightforward as that though... :(
Comment by gvdhoorn on 2019-09-03:
Btw: I rarely create PointCloud2 messages by hand. Is there any particular reason you're not creating a regular pcl::PointCloud<> and then convert it using pcl::toROSMsg(..) (from pcl_conversions)?
Also documented here.
Comment by mun on 2019-09-03:
@gvdhoorn Oh, I'll try that. I should also add that rostopic echo on the map points topic gives data but it's all zeros.
Comment by SamsAutonomy on 2019-09-03:
I definitely agree with @gvdhoorn, it's way easy that way.
Also, when you say it's all zeros, what do you mean? If all of your points are honestly 0,0,0, your point cloud is rather boring and all the points are going to be at the origin. Take a look at your Rviz screenshot, there is one white dot at the origin. Try increasing the point size to 0.1m or something in Rviz and if the white dot at the origin is larger, all of your points are probably sitting at the origin.
Comment by mun on 2019-09-03:
I've fixed my code now that they aren't all zeros. I'm getting some variations in the point cloud, but it's clearly not a point cloud. Here's a video: https://youtu.be/Yr9Qsx_Bpns
Comment by mun on 2019-09-03:
@gvdhoorn Can I ask why PointCloud is preferred over PointCloud2?
Comment by mun on 2019-09-03:
@gvdhoorn rostopic echo can return nonzero data, so the point cloud message is correct, right? The header looks like this:
header: 
  seq: 3658
  stamp: 
    secs: 1567488578
    nsecs:  26397067
  frame_id: "map"
height: 1
width: 1194
fields: 
  - 
    name: "x"
    offset: 0
    datatype: 7
    count: 1
  - 
    name: "y"
    offset: 4
    datatype: 7
    count: 1
  - 
    name: "z"
    offset: 8
    datatype: 7
    count: 1
is_bigendian: False
point_step: 12
row_step: 14328

Could it be that I've got the scale wrong?
Comment by gvdhoorn on 2019-09-03:\

Can I ask why PointCloud is preferred over PointCloud2?

The former is a C++ type in the pcl library, the latter is a ROS message in the sensor_msgs package.
These are two different things.
The pcl_conversions package knows how to convert between these two.

Could it be that I've got the scale wrong?

how could we know? You don't give any information about that.
But just for you to check: everything in ROS uses metres for distances. RViz will assume metres in your PointCloud2 as well.
And again: I would really recommend not creating a sensor_msgs/PointCloud2 message by hand.

A:

I indeed had the scale wrong. It's all good now! Thanks!

Originally posted by mun with karma: 32 on 2019-09-03
This answer was ACCEPTED on the original site
Post score: 0


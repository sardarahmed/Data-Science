Q:

What linux signal is sent when roslaunch kills a node?

My launch file spawns a ros qt node. After launching, i tried to quit using ctrl+c, but the ros qt node is not terminating. Few other nodes are also present in the launch file with required == "true", When any of that node terminates, launch process tries to kill the ros qt node, no success in the first attempt, but after that it escalates to SIGTERM and then the node terminates. I tried to check the signal sent by the launch process, by writing a signal handler inside ros qt. But no signal is caught when launch initiates the first kill attempt.

Originally posted by dharanikumar on ROS Answers with karma: 35 on 2016-11-10
Post score: 0

A:

You have to do 2 things :

Tell ros you are handling the signal to kill the node
This is done by adding ros::init_options::NoSigintHandler to your ros::init call :
ros::init(argc, argv, "YourNodeName", ros::init_options::NoSigintHandler);

Register a sigint handler to handle the node termination (I assume you use Qt4)
I show you the simple way here:

#include <QCoreApplication>   
#include <ros/ros.h>  
#include <signal.h>

void signalhandler(int sig)
{
    qApp->quit();
}

int main(int argc, char *argv[])
{
    //initialize Ros environment
    ros::init(argc, argv, "YourNodeName", ros::init_options::NoSigintHandler);
    QCoreApplication app(argc, argv);

    signal(SIGQUIT, signalhandler);
    signal(SIGINT, signalhandler);
    signal(SIGTERM, signalhandler);
    signal(SIGHUP, signalhandler);
    
    return app.exec();
}

There exist a more object oriented way to do this, documented here : Calling Qt Function From Unix Signal Handlers

Originally posted by Inounx with karma: 293 on 2016-11-10
This answer was ACCEPTED on the original site
Post score: 1


Q:

"True" parallelization in rospy with subscribers

Hey everyone,
Using Rospy (python 2.7) with Indigo.
I ran into the issue that once I command a moveit group to "go" with wait=True it will be a blocking call that causes my subscription to topics to stop / pause until I run something like rospy.sleep() or something similar to let it catch up and get some data. I think it issues a global lock that blocks all running threads (even subscribers). Is there a better way to do this? I was thinking maybe multiprocessing but I could not get a simple example like this to work:
#! /usr/bin/env python

import rospy
import multiprocessing as mp
from geometry_msgs.msg import PoseStamped

class P1(mp.Process):

    def __init__(self):
        super(P1, self).__init__()
        rospy.init_node('p1')
        self.data = PoseStamped()
        pass

    def run(self):
        rospy.Subscriber("/listener", PoseStamped, self.receive_pose_data)
        rospy.spin()

    def receive_pose_data(self, data):
        print(data)
        self.data = data

    def get_data(self):
        return self.data    

p = P1()
p.start()
while not rospy.is_shutdown():
   rospy.sleep(1)
   print(p.get_data())

Thankful for any advice of what I might be doing wrong here!

Originally posted by afm on ROS Answers with karma: 1 on 2018-03-08
Post score: 0

A:

Have you tried the threading module? I use that in some of my nodes to do background processing, and that works fine. The multiprocessing module might run into some issues since it creates new processes by trying to fork the existing process, which confuses roscore since it expects each process to be uniquely named. There's probably a work around, but I'd start with threading first, since that has less overhead.

Originally posted by Cerin with karma: 940 on 2018-03-09
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by afm on 2018-03-09:
I looked into the threading module but had the issue with the global process lock from the moveit commander. Thats why I looked into different processes. I currently found a workaround by basically basically checking the velocity of the robot to determin if it still moves. Its a bit hacky but yeah


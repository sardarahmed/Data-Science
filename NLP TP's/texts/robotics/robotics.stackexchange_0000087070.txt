Q:

Linking problem with ${catkin_LIBRARIES}

Hi everyone!
I'm currently trying to become familiar with ROS (I'm using Kinetic on Ubuntu 16.04 LTS) and followed the beginner tutorials. However, when I try to build the simple publisher/subscriber with catkin_make (http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28c%2B%2B%29, Section 3.), I get the following error:
[ 64%] Built target beginner_tutorials_generate_messages_py
[ 70%] Linking CXX executable /home/fabian/catkin_ws/devel/lib/beginner_tutorials/talker
[ 82%] Built target beginner_tutorials_generate_messages_nodejs
[ 88%] Linking CXX executable /home/fabian/catkin_ws/devel/lib/beginner_tutorials/listener
[ 88%] Built target beginner_tutorials_generate_messages
CMakeFiles/talker.dir/src/talker.cpp.o: In function `main':
talker.cpp:(.text+0x70): undefined reference to `ros::init(int&, char**, std::string const&, unsigned int)'
talker.cpp:(.text+0xcc): undefined reference to `ros::NodeHandle::NodeHandle(std::string const&, std::map<std::string, std::string, std::less<std::string>, std::allocator<std::pair<std::string const, std::string> > > const&)'
talker.cpp:(.text+0x29a): undefined reference to `ros::console::initializeLogLocation(ros::console::LogLocation*, std::string const&, ros::console::levels::Level)'

etc...
So from my understanding (I did quite a lot of research in several discussion forums), this error actually appears, because the ROS libraries are not linked correctly to the executable. In my CMakeLists.txt I made sure that I added target_link_libraries(listener ${catkin_LIBRARIES}), the CMakeLists.txt looks as follows:
cmake_minimum_required(VERSION 2.8.3)
project(beginner_tutorials)

## Find catkin and any catkin packages
find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs genmsg)

## Declare ROS messages and services
add_message_files(FILES Num.msg)
add_service_files(FILES AddTwoInts.srv)

## Generate added messages and services
generate_messages(DEPENDENCIES std_msgs)

## Declare a catkin package
catkin_package()

## Build talker and listener
include_directories(include ${catkin_INCLUDE_DIRS})

add_executable(talker src/talker.cpp)
## Debug Message
message(STATUS "catkin_LIBRARIES: " ${catkin_LIBRARIES})
target_link_libraries(talker ${catkin_LIBRARIES})
add_dependencies(talker beginner_tutorials_generate_messages_cpp)

add_executable(listener src/listener.cpp)
## Debug Message
message(STATUS "catkin_LIBRARIES: " ${catkin_LIBRARIES})
target_link_libraries(listener ${catkin_LIBRARIES})
add_dependencies(listener beginner_tutorials_generate_messages_cpp)

For debug purposes I added the message command to double-check the value of ${catkin_LIBRARIES}, it is
/opt/ros/kinetic/lib/libroscpp.so/usr/lib/x86_64-linux-gnu/libboost_filesystem.so/usr/lib/x86_64-linux-gnu/libboost_signals.so/opt/ros/kinetic/lib/librosconsole.so/opt/ros/kinetic/lib/librosconsole_log4cxx.so/opt/ros/kinetic/lib/librosconsole_backend_interface.so/usr/lib/x86_64-linux-gnu/liblog4cxx.so/usr/lib/x86_64-linux-gnu/libboost_regex.so/opt/ros/kinetic/lib/libxmlrpcpp.so/opt/ros/kinetic/lib/libroscpp_serialization.so/opt/ros/kinetic/lib/librostime.so/opt/ros/kinetic/lib/libcpp_common.so/usr/lib/x86_64-linux-gnu/libboost_system.so/usr/lib/x86_64-linux-gnu/libboost_thread.so/usr/lib/x86_64-linux-gnu/libboost_chrono.so/usr/lib/x86_64-linux-gnu/libboost_date_time.so/usr/lib/x86_64-linux-gnu/libboost_atomic.so/usr/lib/x86_64-linux-gnu/libpthread.so/usr/lib/x86_64-linux-gnu/libconsole_bridge.so

Since I'm pretty new to ROS and Ubuntu in general, I don't really know how to proceed. Seems like someone had a similar problem before, but never really solved it: https://answers.ros.org/question/206214/error-for-catkin_make-even-after-adding-target_link_libraries/
So if you have any ideas on that, let me know.
Thanks in advance!
EDIT 01: Added Code of listener.cpp and talker.cpp
listener.cpp
#include "ros/ros.h"
#include "std_msgs/String.h"

/**
 * This tutorial demonstrates simple receipt of messages over the ROS system.
 */
void chatterCallback(const std_msgs::String::ConstPtr& msg)
{
  ROS_INFO("I heard: [%s]", msg->data.c_str());
}

int main(int argc, char **argv)
{
  /**
   * The ros::init() function needs to see argc and argv so that it can perform
   * any ROS arguments and name remapping that were provided at the command line.
   * For programmatic remappings you can use a different version of init() which takes
   * remappings directly, but for most command-line programs, passing argc and argv is
   * the easiest way to do it.  The third argument to init() is the name of the node.
   *
   * You must call one of the versions of ros::init() before using any other
   * part of the ROS system.
   */
  ros::init(argc, argv, "listener");

  /**
   * NodeHandle is the main access point to communications with the ROS system.
   * The first NodeHandle constructed will fully initialize this node, and the last
   * NodeHandle destructed will close down the node.
   */
  ros::NodeHandle n;

  /**
   * The subscribe() call is how you tell ROS that you want to receive messages
   * on a given topic.  This invokes a call to the ROS
   * master node, which keeps a registry of who is publishing and who
   * is subscribing.  Messages are passed to a callback function, here
   * called chatterCallback.  subscribe() returns a Subscriber object that you
   * must hold on to until you want to unsubscribe.  When all copies of the Subscriber
   * object go out of scope, this callback will automatically be unsubscribed from
   * this topic.
   *
   * The second parameter to the subscribe() function is the size of the message
   * queue.  If messages are arriving faster than they are being processed, this
   * is the number of messages that will be buffered up before beginning to throw
   * away the oldest ones.
   */
  ros::Subscriber sub = n.subscribe("chatter", 1000, chatterCallback);

  /**
   * ros::spin() will enter a loop, pumping callbacks.  With this version, all
   * callbacks will be called from within this thread (the main one).  ros::spin()
   * will exit when Ctrl-C is pressed, or the node is shutdown by the master.
   */
  ros::spin();

  return 0;
}

talker.cpp
#include "ros/ros.h"
#include "std_msgs/String.h"

#include <sstream>

/**
 * This tutorial demonstrates simple sending of messages over the ROS system.
 */
int main(int argc, char **argv)
{
  /**
   * The ros::init() function needs to see argc and argv so that it can perform
   * any ROS arguments and name remapping that were provided at the command line.
   * For programmatic remappings you can use a different version of init() which takes
   * remappings directly, but for most command-line programs, passing argc and argv is
   * the easiest way to do it.  The third argument to init() is the name of the node.
   *
   * You must call one of the versions of ros::init() before using any other
   * part of the ROS system.
   */
  ros::init(argc, argv, "talker");

  /**
   * NodeHandle is the main access point to communications with the ROS system.
   * The first NodeHandle constructed will fully initialize this node, and the last
   * NodeHandle destructed will close down the node.
   */
  ros::NodeHandle n;

  /**
   * The advertise() function is how you tell ROS that you want to
   * publish on a given topic name. This invokes a call to the ROS
   * master node, which keeps a registry of who is publishing and who
   * is subscribing. After this advertise() call is made, the master
   * node will notify anyone who is trying to subscribe to this topic name,
   * and they will in turn negotiate a peer-to-peer connection with this
   * node.  advertise() returns a Publisher object which allows you to
   * publish messages on that topic through a call to publish().  Once
   * all copies of the returned Publisher object are destroyed, the topic
   * will be automatically unadvertised.
   *
   * The second parameter to advertise() is the size of the message queue
   * used for publishing messages.  If messages are published more quickly
   * than we can send them, the number here specifies how many messages to
   * buffer up before throwing some away.
   */
  ros::Publisher chatter_pub = n.advertise<std_msgs::String>("chatter", 1000);

  ros::Rate loop_rate(10);

  /**
   * A count of how many messages we have sent. This is used to create
   * a unique string for each message.
   */
  int count = 0;
  while (ros::ok())
  {
    /**
     * This is a message object. You stuff it with data, and then publish it.
     */
    std_msgs::String msg;

    std::stringstream ss;
    ss << "hello world " << count;
    msg.data = ss.str();

    ROS_INFO("%s", msg.data.c_str());

    /**
     * The publish() function is how you send messages. The parameter
     * is the message object. The type of this object must agree with the type
     * given as a template parameter to the advertise<>() call, as was done
     * in the constructor above.
     */
    chatter_pub.publish(msg);

    ros::spinOnce();

    loop_rate.sleep();
    ++count;
  }

  return 0;
}

Originally posted by FabianKu on ROS Answers with karma: 3 on 2018-05-22
Post score: 0

Original comments
Comment by simbha on 2018-05-22:
please share the talker.cpp code. i guess, something wrong with cpp file
Comment by FabianKu on 2018-05-22:
To be honest, I just copied the code from this tutorial: http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber(c++) (see EDIT 01)
Moreover, I get the same error when I try to build other nodes, for example https://github.com/ros-drivers/velodyne

A:

There seems to be something wrong with how you've set up your computer or how you've installed ROS.
In particular, it looks like all of the unresolved symbols involve std::string, which changed between gcc 4.9 and gcc 5.
The default compiler on 16.04 looks like it's gcc 5.3, and the ROS packages will be compiled with that version of gcc, but your ticket on the velodyne repo indicates that you've building with gcc 4.9. (This demonstrates the reverse problem: https://askubuntu.com/questions/770358/how-should-i-handle-abi-incompatability-between-gcc-4-9-and-gcc-5?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa )
I am not sure that gcc 4.9 can build code that is compatible with the standard library that ships with gcc 5 and newer.
I strongly recommend that you use the default compiler that comes with your system.

Originally posted by ahendrix with karma: 47576 on 2018-05-22
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by ipgvl on 2019-02-04:
@ahendrix Please, how do you use the default compiler?
Comment by ahendrix on 2019-02-04:
The default compiler is the default; you shouldn't need to do anything special to use it, but if you've done anything to change the default compiler, you should undo that. There are so many different ways to override the default compiler, that I can't describe how to check for or undo all of them.
Comment by ahendrix on 2019-02-04:
If you know that you have changed your default compiler and do not know how to restore it, perhaps consult a local linux expert, stackoverflow.com , or as a last resort reinstall Linux.
Comment by ipgvl on 2019-02-05:
Thank you.
Comment by gvdhoorn on 2019-02-05:
Note: this was fixed in #q314609 and/or #q313955.


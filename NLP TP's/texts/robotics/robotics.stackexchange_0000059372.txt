Q:

Depth image stream from kinect in matlab with ROS IO package

Hello all,
I'm currently trying to generate image streams in Matlab from Kinect with the relatively new ROS IO Package.
I am able to generate an RGB stream with the following code:
figure(1)
 width = message.getWidth();
        height = message.getHeight();
        offset = message.getData().arrayOffset();
        indexB = offset+1:3:width*height*3+offset;
        indexG = indexB+1;
        indexR = indexG+1;
        
        imgCol = typecast(message.getData().array(), 'uint8');
        img = reshape([imgCol(indexR); imgCol(indexG); imgCol(indexB)], width, height, 3);
        img = permute(img, [2 1 3]);
        imshow(img);
 drawnow;

But I have no idea how to generate the depth stream. For the master, I'm running the freenect package in a terminal. Here's how I'm setting up the node:
>> node = rosmatlab.node('kinect', master_uri);
>> subdep = node.addSubscriber('/camera/depth/image_rect', 'sensor_msgs/Image', 10);
>> subdep.setOnNewMessageListeners({@function});

I read somewhere that the encoding type for the /image_rect topic is 32FC1 and for /image_raw is 16UC1. Is that relevant somehow?
Thanks for the help.

Originally posted by renangm on ROS Answers with karma: 183 on 2014-05-14
Post score: 3

A:

Figured it out. Might help someone down the line.
The /camera/depth/image_raw topic provides data in a 8-bit integer array format of 307234 positions, which can be read with the getData().array() method. It has to be converted to the correct matrix format to be displayed as an image in matlab. Basically, you have to transform a 307234x1 vector into a 640x480 matrix. The code below gets the message array and transforms it to the matrix to be displayed. It was based on the one I used for RGB imaging.
function function2(message) 

width = message.getWidth();
height = message.getHeight();
offset = message.getData().arrayOffset();
index = offset+2:2:width*height*2+offset;

%Get the data in unsigned int8 format
msg = typecast(message.getData().array(), 'uint8');

%Reshape 614469x1 (614469 bytes) into 640x480 (307200 bytes)
img = reshape(msg(index), width, height);

%Flip dimensions
img = flipdim(img, 2);

%Rotate image in 90 degrees
img_rot = imrotate(img, 90);

%Show rotated image
figure(2)
imshow(img_rot);
drawnow;

end

I chose to use the flipdim() and imrotate() methods because I am more familiarized with them. The permute method should have the same result. It's also possible to use imagesc() instead of imshow(), for a different visual result.

Originally posted by renangm with karma: 183 on 2014-05-14
This answer was ACCEPTED on the original site
Post score: 4


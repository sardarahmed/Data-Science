Q:

Interrupting a topic callback to call a service

I am currently facing an issue with my code, which both subcribes to a topic, and runs the server side of a service.
The problem i am currently facind is that the topic which i am subscribing to is constantly being published to making, making it impossible for me to call my
service.  The service response is empty, which i assume i due to the topic callback constantly being running.
Here is the code:
#include "subscriber_and_server.h"

subscriber_and_server::subscriber_and_server() :
    n_("~"),
    state_listener_sub_(n_.subscribe("/states", 1, &subscriber_and_server::callback, this)),
    getCurrent_Event_Service(n_.advertiseService("/state_listener/Get_Current_Event", &subscriber_and_server::get_current_event_callback, this))
{
    std::cout << "subscriber_and_server -  constructed" << std::endl;
}

void subscriber_and_server::callback(const std_msgs::String& input)
{
    if(old_event == current_event){}
    else
    {
        this->current_event = input.data;
        this->old_event = this->current_event;
    }
}

bool subscriber_and_server::get_current_event_callback(state_listener::get_current_event::Request &req, state_listener::get_current_event::Response &res)
{
    res.current_event = this->current_event;
    return true;
}

My main is creating a object of the class subscriber_and_server and ros::spin();.
Anyway to handle this issue?
I am currently thinking of making a seperating both callback into seperates nodes, publish the new state if one occur, such that service can handle the issue?
Is it somehow possible to avoid this??

Originally posted by 215 on ROS Answers with karma: 156 on 2016-12-07
Post score: 0

A:

ros::spin() should be fair about the scheduling of the different ROS capabilities, so I'm not sure your actual problem is that you can't call the service because of the subscriber. Did you validate this by disabling the subscriber or throttling the topic?
If this is the deterministic problem you describe, please file a detailed issue at https://github.com/ros/ros_comm that allows others to analyze and address this.
Alternatively, you can consider multithreading your node to allow background processing of messages even when a service call is received. This is as easy as adding ros::AsyncSpinner spinner(1); spinner.start() to your main function.

Originally posted by v4hn with karma: 2950 on 2016-12-08
This answer was ACCEPTED on the original site
Post score: 1


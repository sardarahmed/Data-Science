Q:

Confused about publishing msgs in a synchronous way

Hello,
I'm studying the communication of ROS recently. And I saw this article Choose a good queue_size, which tells that the rospy can  publish msgs sychronously  by setting queue_size=None or omitted.
pub = rospy.Publisher('topic_name', std_msgs.msg.String, queue_size=None) 
pub.publish("hello world")

I tried to set queue_size=None, but the publisher is not blocked. It publishes whether there is a subscriber. Both pub and sub are asynchronous.
And I read that publish() in roscpp is totally asynchronous. And one introduction says  ***The asynchronous nature of publish/subscribe messaging works for many communication needs in robotics, but sometimes you want synchronous request/response interactions between ***
These articles really confuse me. So I just want to ask :

Can msgs be published to a topic in a synchronous way?
If it can, can you give me an example?

Originally posted by Changkun on ROS Answers with karma: 31 on 2017-10-10
Post score: 2

Original comments
Comment by gvdhoorn on 2017-10-10:
I think the documentation means to say: invoking publish(..) is synchronous, not that messages are exchanged in a synchronous manner. For that, we have services (or actions).
Comment by Changkun on 2017-10-10:
Can you please explain invoking publish(..) synchronously ?
I thought that in Topics, everything is asynchronous. And it is Service or Action synchronous.
Comment by CodeFinder on 2017-10-10:
I think that the documentation/wiki is probrably wrong (... and/or it is only supported in older versions of ROS. According to the docs, since >= Indigo, you get a warning). AFAIK, topic are always asynchronous and you have no control of when your message is actually being send over the wire.
Comment by gvdhoorn on 2017-10-10:
There is a difference between queueing a message and the middleware transmitting your message. I think the documentation talks about the former, while you are referring to the latter.
Comment by CodeFinder on 2017-10-10:
@gvdhoorn: I don't think so because queuing a message (= calling publish()) is always synchronous in ROS.

A:

Synchronous / asynchronous in this context refers to the queuing of the published message.
The triggering of the callback of subscribers is always asynchronous. So when the publish() call returns the subcriber has not been invoked yet.
If the queuing is synchronous the publish() call returns after the message has been serialized and written to the buffer of each connection. In the case where the subscriber on a network connection isn't reading the data fast enough the buffer of the socket might get full which would make the call block until after the buffer has been emptied enough to take the message. So this would block even if only a single of N connections is not draining the data quickly enough.
If the queuing is asynchronous the publish() call will never block. The message is serialized into a queue (actually multiple queues, one per connection) and the call returns before the data is actually written to the socket(s). Separate threads will then write the data from the queues to the sockets.
As mentioned already in Python you can choose by passing either a queues size or None. In C++ you can only pass a queue size.

Originally posted by Dirk Thomas with karma: 16276 on 2017-10-10
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by Changkun on 2018-06-08:
thank you, that makes sense


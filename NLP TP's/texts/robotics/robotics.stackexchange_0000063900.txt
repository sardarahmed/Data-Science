Q:

Sending map co-ordinates as goal to move_base

I have an occupancy grid map and an exploration algorithm that provides me with 2 dimensional co-ordinates to travel to. The mapping and goal generation are working perfectly. Unfortunately, an error arises when I send the goal to move_base. The robot does not move and I get the following error:
The robot's start position is off the global costmap. Planning will always fail, are you sure the robot has been properly localized?
This is the part of the code that sends the goal:
MoveBaseClient ac("move_base", true); 
move_base_msgs::MoveBaseGoal goal; 
goal.target_pose.header.frame_id = "base_link"; 
goal.target_pose.header.stamp = ros::Time::now(); 
goal.target_pose.pose.position.x = goalx; 
goal.target_pose.pose.position.y = goaly;
goal.target_pose.pose.orientation.w = 1.0;     //Edit made based on David Lu's answer
ac.sendGoal(goal);

where goalx and goaly are integers that contain the map co-ordinates of the goal. MoveBaseClient has been defined earlier, as given in this link.
Also, if someone has links/documentation on move_base, quaternions in ROS or examples of sending goals to move_base apart from this tutorial link, please post them as well, I would be extremely grateful. I haven't perfectly understood how to programmatically send goals to move_base.
Thank You!

Originally posted by Ashwin27 on ROS Answers with karma: 34 on 2014-11-08
Post score: 0

Original comments
Comment by lebowski on 2014-11-10:
goalx and goaly are map-coordinates. according to that you have to define the right frame_id:
goal.target_pose.header.frame_id = "/map";

Comment by sobot on 2015-03-24:
hello @Ashwin27 , can I ask you about the goal generation algorithm that you used here? I had problems to find such algorithm for my experimental project. it would be very nice of you if u help me with it, thanks mate.

A:

Thank you, Lebowski and David. I modified the code as you guys suggested and solved the error.
goal_m.target_pose.header.frame_id =
"/map";
goal_m.target_pose.header.stamp =
ros::Time();
goal_m.target_pose.pose.position.x =mCurrentMap.getOriginX() +
(((double)goal_x+0.5) *
mCurrentMap.getResolution());
goal_m.target_pose.pose.position.y =
mCurrentMap.getOriginY() +
(((double)goal_y+0.5) *
mCurrentMap.getResolution());
goal_m.target_pose.pose.orientation.w=
1.0;

Originally posted by Ashwin27 with karma: 34 on 2014-12-18
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by tanghz on 2015-03-09:
Sorry to disturb you.  But could you tell me to define the variable mCurrentMap, which header file shoul I useï¼Ÿ
Comment by RND on 2015-03-26:
Quick question, how are you calculating the position.x ? you are doing origin.x + ((goal_x + 0.5)* resolution). What does the 0.5 stand for? I have a similar issue and in my case, position.x = (x coordinate * resolution) - origin.x.


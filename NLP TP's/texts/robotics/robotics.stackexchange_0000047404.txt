Q:

ROS Answers SE migration: simulation

Hi!
When I ran a simulation in gazebo and I use rviz to send goals what my robot does in rviz is different from what it does in gazebo.
More precisely if I set a goal with the rviz tool 2d nav goal i can see the robot in gazebo moving in a smooth way but not in the right direction to reach the goal and the robot in rviz which change its position in a non-continuous way (e.g. it disappear from (x,y) and reapper in (x2,y2) which is far from the previous position). Further more while the robot in gazebo does a rotation of k rad the one in rviz does a rotation of h rad (with h < k). 
Setting the laser decay time to 10 and teleoperating the robot I can see that the scans are coinciding if I move the robot forward or backward but they're totally not coinciding if I let the robot rotate in place.
Instead I was expecting to see the same translation and rotation performed by the robot in gazebo and the robot in rviz.
What could be the issue?
What i do is:
To launch pioneer3dx.gazebo.launch to simulate the p3dx robot.
<launch>

  <include file="$(find gazebo_worlds)/launch/office_world.launch"/>

  <include file="$(find p2os_urdf)/launch/upload_pioneer3dx.xml"/>

  <!-- push robot_description to factory and spawn robot in gazebo -->
  <node name="spawn_pioneer" pkg="gazebo" type="spawn_model" 
    args="-z 0.051 
          -urdf 
          -param robot_description  
          -model robot_description" 
    respawn="false" output="screen" />

  <!-- Controller Manager -->
  <include file="$(find pr2_controller_manager)/controller_manager.launch" />

  <!-- load controllers -->
  <node name="diffdrive" pkg="gazebo_plugins" type="gazebo_ros_diffdrive" respawn="true" output="screen"/>

</launch>

Then I'm launching the navigation.launch file:
<launch>
    <master auto="start"/>

    <!-- Run the map server (you can run it here or in another terminal) -->
    <node name="map_server" pkg="map_server" type="map_server" args="$(find p2os_nav)/simple_office_map.yaml" respawn="true"/> 

    <!--- Run AMCL -->
    <include file="$(find p2os_launch)/amcl.launch" />

    <node pkg="move_base" type="move_base" respawn="false" name="move_base" output="screen">
        <rosparam file="$(find p2os_launch)/costmap_common_params.yaml" command="load" ns="global_costmap" />
        <rosparam file="$(find p2os_launch)/costmap_common_params.yaml" command="load" ns="local_costmap" />
        <rosparam file="$(find p2os_launch)/local_costmap_params.yaml" command="load" />
        <rosparam file="$(find p2os_launch)/global_costmap_params.yaml" command="load" />
        <rosparam file="$(find p2os_launch)/base_local_planner_params.yaml" command="load" />
        <param name="base_global_planner" type="string" value="navfn/NavfnROS" />
        <param name="conservative_reset_dist" type="double" value="3.0" />
        <param name="controller_frequency" type="double" value="15.0" />
        <remap from="odom" to="erratic_odometry/odom"/>
    </node>

</launch>

and also rviz (with the command rosrun rviz rviz).
Surfing on the web i read that it could be a problem of too slow odometry, but what to do to fix it?
The /tf between /odom and /base_link and the nav_msgs odom received by move_base is published by the gazebo diffdrive plugin:
#include <gazebo/gazebo.h>
#include <gazebo/GazeboError.hh>
#include <gazebo/Quatern.hh>

#include <ros/ros.h>
#include <tf/transform_broadcaster.h>
#include <geometry_msgs/Twist.h>
#include <nav_msgs/Odometry.h>

#include <boost/bind.hpp>

class DiffDrive {
public:
  libgazebo::PositionIface *posIface;
  ros::NodeHandle* rnh_;
  ros::Subscriber  sub_;
  ros::Publisher   pub_;
  
  void cmdVelCallBack(const geometry_msgs::Twist::ConstPtr& cmd_msg) {
        std::cout << " pos " << this->posIface
                  <<    " x " << cmd_msg->linear.x
                  <<    " y " << cmd_msg->linear.y
                  <<    " z " << cmd_msg->angular.z
                  << std::endl;
        
    if (this->posIface) {
      this->posIface->Lock(1);
      this->posIface->data->cmdVelocity.pos.x = cmd_msg->linear.x;
      this->posIface->data->cmdVelocity.pos.y = cmd_msg->linear.y;
      this->posIface->data->cmdVelocity.yaw = cmd_msg->angular.z;
      this->posIface->Unlock();
    }
  }

  DiffDrive() {
    libgazebo::Client *client = new libgazebo::Client();
    libgazebo::SimulationIface *simIface = new libgazebo::SimulationIface();
    this->posIface = new libgazebo::PositionIface();
  
    int serverId = 0;
    
    /// Connect to the libgazebo server
    try {
      client->ConnectWait(serverId, GZ_CLIENT_ID_USER_FIRST);
    } catch (gazebo::GazeboError e) {
      std::cout << "Gazebo error: Unable to connect\n" << e << "\n";
      return;
    }
    
    /// Open the Simulation Interface
    try {
      simIface->Open(client, "default");
    } catch (gazebo::GazeboError e) {
      std::cout << "Gazebo error: Unable to connect to the sim interface\n" << e << "\n";
      return;
    }
    
    /// Open the Position interface
    try {
      this->posIface->Open(client, "robot_description::position_iface_0");
    } catch (std::string e) {
      std::cout << "Gazebo error: Unable to connect to the position interface\n" << e << "\n";
      return;
    }
    
    // Enable the motor
    this->posIface->Lock(1);
    this->posIface->data->cmdEnableMotors = 1;
    this->posIface->Unlock();

    this->rnh_ = new ros::NodeHandle();
    //this->sub_ = rnh_->subscribe<geometry_msgs::Twist>("/cmd_vel", 100, boost::bind(&DiffDrive::cmdVelCallBack,this,_1));
    this->sub_ = rnh_->subscribe<geometry_msgs::Twist>("/cmd_vel", 100, &DiffDrive::cmdVelCallBack,this);
    this->pub_ = rnh_->advertise<nav_msgs::Odometry>("/erratic_odometry/odom", 1);
   
    // spawn 2 threads by default, ///@todo: make this a parameter
    ros::MultiThreadedSpinner s(2);
    boost::thread spinner_thread( boost::bind( &ros::spin, s ) );

    nav_msgs::Odometry odom;

    // setup transform publishers, need to duplicate pr2_odometry controller functionalities
    tf::TransformBroadcaster transform_broadcaster_ ;

    ros::Duration d; d.fromSec(0.01);
    
    while(rnh_->ok()) { 
      if (this->posIface) {
        this->posIface->Lock(1);
        
        // duplicate pr2_odometry functionalities, broadcast
        // transforms from base_footprint to odom
        // and from base_link to base_footprint

        // get current time
        ros::Time current_time_ = ros::Time::now();

        // getting data for base_link to odom transform
        btQuaternion qt;
        qt.setRPY(this->posIface->data->pose.roll, this->posIface->data->pose.pitch, this->posIface->data->pose.yaw);
        btVector3 vt(this->posIface->data->pose.pos.x, this->posIface->data->pose.pos.y, this->posIface->data->pose.pos.z);
        tf::Transform base_link_to_odom(qt, vt);
        transform_broadcaster_.sendTransform(tf::StampedTransform(base_link_to_odom,ros::Time::now(),"odom","base_link"));

        // publish odom topic
        odom.pose.pose.position.x = this->posIface->data->pose.pos.x;
        odom.pose.pose.position.y = this->posIface->data->pose.pos.y;

        gazebo::Quatern rot;
        rot.SetFromEuler(gazebo::Vector3(this->posIface->data->pose.roll,this->posIface->data->pose.pitch,this->posIface->data->pose.yaw));

        odom.pose.pose.orientation.x = rot.x;
        odom.pose.pose.orientation.y = rot.y;
        odom.pose.pose.orientation.z = rot.z;
        odom.pose.pose.orientation.w = rot.u;

        odom.twist.twist.linear.x = this->posIface->data->velocity.pos.x;
        odom.twist.twist.linear.y = this->posIface->data->velocity.pos.y;
        odom.twist.twist.angular.z = this->posIface->data->velocity.yaw;
        
        odom.header.frame_id = "odom"; 
        
        odom.header.stamp = ros::Time::now();
        
        this->pub_.publish(odom); 

        this->posIface->Unlock();
      }
      d.sleep();
    }
  }
  ~DiffDrive() {
    delete this->rnh_;
  }
};

int main(int argc, char** argv) {
  ros::init(argc,argv,"gazebo_ros_diffdrive",ros::init_options::NoSigintHandler|ros::init_options::AnonymousName);

  DiffDrive d;
  return 0;
}

And the one between /map and /odom is published by amcl node.
This is my rxgraph:
image description

Originally posted by camilla on ROS Answers with karma: 255 on 2013-01-18
Post score: 0

Original comments
Comment by davinci on 2013-01-18:
Your question is a bit vague. Please clarify what you mean with goals and list the commands you are using.
Comment by camilla on 2013-01-18:
I added some infos
Comment by joq on 2013-01-19:
Please edit your question so we know what you expected to happen, and what happened instead.
Comment by joq on 2013-01-19:
Is this a duplicate of the other question?
Comment by camilla on 2013-01-20:
edited! :)
Comment by dornhege on 2013-01-22:
You need to describe precisely what the actual problem is by stating/showing what exactly happens and what you would expect, i.e. the symptoms. Listing possible guesses where the problem lies is not helpful as currently no one else understands what the problem is.
Comment by camilla on 2013-01-22:
thx i added a more detailed description
Comment by joq on 2013-01-22:
Is rviz displaying Odometry published by gazebo_ros_diffdrive or by amcl?
Comment by camilla on 2013-01-22:
by gazebo_ros_diffdrive
Comment by joq on 2013-01-22:
Does the /amcl_pose topic agree?
Comment by camilla on 2013-01-22:
No they gave me different values
Comment by joq on 2013-01-22:
Since amcl publishes the /map to /odom transform displayed by rviz, that seems significant. Is your environment difficult to localize?
Comment by camilla on 2013-01-22:
I'm using the office_world that is in the gazebo_wordls folder
Comment by camilla on 2013-01-22:
Further more I've seen that if I display in rviz the odometry message published on /base_pose_ground_truth which shows the position of the base_link on the /map frame it shows a position which corresponds to the one of the robot in gazebo

A:

I solved the problem of the rotation:

Further more while the robot in gazebo
does a rotation of k rad the one in
rviz does a rotation of h rad (with h
< k).

changing the value of the wheel radius in pioneer3dx.xacro from 0.15 to 0.22.
But I still have problem in the robot localization.

Originally posted by camilla with karma: 255 on 2013-02-03
This answer was ACCEPTED on the original site
Post score: 0


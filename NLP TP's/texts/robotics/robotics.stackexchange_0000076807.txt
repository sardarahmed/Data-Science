Q:

Robot planner tuning - does not plan down the middle of small pathways

Hello All,
I've had some difficulty tuning the global planner. The basic problem is the plan ends up hugging one side of the path. In this case we are using "unknown" cells to restrict the robots path. Here we want the robot to drive between low lying objects that it can not observe.
Here we can see the problem I am facing: http://imgur.com/YRjQHtm

It seems that the created path is not in the middle, instead it is adjacent to lethal cost cells and at times crosses over lethal cost. If the path is sufficiently wide it appears the plan stays somewhat in the middle but as the path gets smaller and smaller it eventually hugs one side.
Currently, we are using Navfn however I tested the planning behavior of global planner and it did the same or similar. I can show how that behaves too if necessary.
Move_base parameters:
edit* yikes this is unreadable, any easy way to format this?
NavfnROS: {allow_unknown: false}
TrajectoryPlannerROS: {acc_lim_th: 9.0, acc_lim_theta: 3.2, acc_lim_x: 3.0, acc_lim_y: 2.5,
  angular_sim_granularity: 0.025, dwa: false, escape_reset_dist: 0.1, escape_reset_theta: 1.57079632679,
  escape_vel: 0.0, gdist_scale: 0.8, heading_lookahead: 0.325, heading_scoring: false,
  heading_scoring_timestep: 0.1, holonomic_robot: false, max_rotational_vel: 0.5,
  max_vel_theta: 1.0, max_vel_x: 0.6, meter_scoring: true, min_in_place_rotational_vel: 0.2,
  min_in_place_vel_theta: 0.4, min_vel_theta: -1.0, min_vel_x: 0.25, occdist_scale: 0.01,
  oscillation_reset_dist: 0.05, pdist_scale: 1.2, restore_defaults: false, sim_granularity: 0.025,
  sim_time: 1.7, simple_attractor: false, vtheta_samples: 20, vx_samples: 20, xy_goal_tolerance: 0.2,
  y_vels: '-0.3,-0.1,0.1,-0.3', yaw_goal_tolerance: 0.25}
aggressive_reset: {reset_distance: 1.84}
base_global_planner: navfn/NavfnROS
base_local_planner: base_local_planner/TrajectoryPlannerROS
clearing_rotation_allowed: true
conservative_reset: {reset_distance: 3.0}
conservative_reset_dist: 3.0
controller_frequency: 10.0
controller_patience: 5.0
global_costmap:
  footprint: '[]'
  footprint_padding: 0.01
  global_frame: map
  height: 10
  inflation_layer: {cost_scaling_factor: 4.0, enabled: true, inflation_radius: 2.0}
  map_type: costmap
  obstacle_layer:
    combination_method: 1
    enabled: true
    laser_scan_sensor: {clearing: true, data_type: LaserScan, marking: true, sensor_frame: LMS151,
      topic: bottom_scan}
    laser_scan_sensor2: {clearing: true, data_type: LaserScan, marking: true, sensor_frame: TiM551,
      topic: top_scan}
    map_cloud: {clearing: true, data_type: PointCloud2, marking: true, sensor_frame: base_link,
      topic: map_pointcloud}
    max_obstacle_height: 2.0
    observation_sources: velodyne_scan map_cloud laser_scan_sensor laser_scan_sensor2
    obstacle_range: 5.0
    raytrace_range: 6.0
    track_unknown_space: true
    velodyne_scan: {clearing: true, data_type: LaserScan, marking: true, sensor_frame: velodyne,
      topic: velodyne_scan}
  obstacle_layer_footprint: {enabled: true}
  origin_x: 0.0
  origin_y: 0.0
  plugins:
  - {name: static_layer, type: 'costmap_2d::StaticLayer'}
  - {name: obstacle_layer, type: 'costmap_2d::ObstacleLayer'}
  - {name: inflation_layer, type: 'costmap_2d::InflationLayer'}
  publish_frequency: 0.0
  resolution: 0.05
  robot_base_frame: base_link
  robot_radius: 0.5
  static_layer: {enabled: true, track_unknown_space: true, unknown_cost_value: 253}
  static_map: true
  transform_tolerance: 0.3
  update_frequency: 5.0
  width: 10
local_costmap:
  footprint: '[]'
  footprint_padding: 0.01
  global_frame: map
  height: 10
  inflation_layer: {cost_scaling_factor: 0.8, enabled: true, inflation_radius: 2.0}
  map_type: costmap
  obstacle_layer:
    combination_method: 1
    enabled: true
    laser_scan_sensor: {clearing: true, data_type: LaserScan, marking: true, sensor_frame: LMS151,
      topic: bottom_scan}
    laser_scan_sensor2: {clearing: true, data_type: LaserScan, marking: true, sensor_frame: TiM551,
      topic: top_scan}
    map_cloud: {clearing: true, data_type: PointCloud2, marking: true, sensor_frame: base_link,
      topic: map_pointcloud}
    max_obstacle_height: 2.0
    observation_sources: velodyne_scan map_cloud laser_scan_sensor laser_scan_sensor2
    obstacle_range: 5.0
    raytrace_range: 6.0
    velodyne_scan: {clearing: true, data_type: LaserScan, marking: true, sensor_frame: velodyne,
      topic: velodyne_scan}
  obstacle_layer_footprint: {enabled: true}
  origin_x: 0.0
  origin_y: 0.0
  plugins:
  - {name: obstacle_layer, type: 'costmap_2d::ObstacleLayer'}
  - {name: inflation_layer, type: 'costmap_2d::InflationLayer'}
  publish_frequency: 5.0
  resolution: 0.05
  robot_base_frame: base_link
  robot_radius: 0.5
  rolling_window: true
  static_map: false
  transform_tolerance: 0.3
  update_frequency: 10.0
  width: 10
oscillation_distance: 0.5
oscillation_timeout: 0.0
planner_frequency: 0.5
planner_patience: 5.0
recovery_behavior_enabled: false
restore_defaults: false
shutdown_costmaps: false

Originally posted by nxydes on ROS Answers with karma: 81 on 2016-10-18
Post score: 0

Original comments
Comment by Yang on 2016-10-23:
I met the same problem,the global path is not the middle of road.And sometimes navigation is failed,because the robot met the inflation_layer.Do you have solved the problem?
Comment by nxydes on 2016-10-24:
Yang, I have not solved the problem.
"And sometimes navigation is failed,because the robot met the inflation_layer"
This also happens a lot to me. I've been looking at the parameters on the global planner and will be looking at code but so far no luck. Let me know if you find anything
Comment by Yang on 2016-10-25:
Hi,you can increase  inflation_layer value up to 0.55 .
Comment by Yang on 2016-11-16:
cosmap_commom_params.yaml is important.inflation_radius value must is bigger than robot_radius value.

A:

Hi, Kaiyu Zheng provides a good disucssion on this topic in his guide "ROS Navigation Tuning Guide". Check out pages 11 & 12. Download the PDF of this guide HERE.
In short, increase your inflation_radius and decrease your cost_scaling_factor parameters in your local_costmap_params.yaml. I am using inflation_radius = 1.0 and cost_scaling_factor = 2.5.
This way, the planner will prefers paths as far away from both walls as possible as this will minimise the cost.

Originally posted by mcarr with karma: 145 on 2017-05-17
This answer was ACCEPTED on the original site
Post score: 2


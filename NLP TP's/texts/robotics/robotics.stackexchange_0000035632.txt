Q:

Euler to quaternion conversion error

I try to convert Euler values into quaternion. Some parts of it are as follow:
       //data_set[t][8] = yaw = y, data_set[t][7] = pitch = x, data_set[t][6] = roll = z
        btQuaternion q(pcl::deg2rad(data_set[t][8]), pcl::deg2rad(data_set[t][7]), pcl::deg2rad(data_set[t][6]));

        new_pose.orientation.x = q.x();
        new_pose.orientation.y = q.y();
        new_pose.orientation.z = q.z();
        new_pose.orientation.w = q.w();

        cout << "new_pose.orientation.x = " << new_pose.orientation.x << endl;
        cout << "new_pose.orientation.y = " << new_pose.orientation.y << endl;
        cout << "new_pose.orientation.z = " << new_pose.orientation.z << endl;
        cout << "new_pose.orientation.w = " << new_pose.orientation.w << endl;

I have cross-checked with an  on-line converter  and found that the values returned somehow swapped and have sign(+ve and -ve) problem. The outputs are as below:
From my code:
new_pose.orientation.x = 0.0419219
new_pose.orientation.y = -0.0300053
new_pose.orientation.z = -0.184328
new_pose.orientation.w = 0.981512

From the on-line converter:
u0 = 0.9811347012447917 
u1 = -0.18632481923344862   
u2 = -0.04192188282716083   
u3 = -0.030005257724968114

I guess u0 corresponds to w, u1 corresponds to x and so on..
What is actually the problem of this conversion?

Originally posted by alfa_80 on ROS Answers with karma: 1053 on 2011-11-10
Post score: 1

A:

Why do you manually create the Quaternion? I would suggest using tf::createQuaternionFromRPY() in tf/transform_datatypes.h.
Given that there are 24 difference possibilities to specify "Euler angles", it's hard to tell what goes wrong here and which format the online converter expects.

Originally posted by AHornung with karma: 5904 on 2011-11-10
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by alfa_80 on 2011-11-11:
oo the new_pose is from "geometry_msgs::Pose new_pose;" It is of type Pose.
Comment by AHornung on 2011-11-11:
I use it regularly and it works fine in any context. However, you did not post complete code thus I can only guess of what type new_pose is. (I assumed a tf::Transform which is a btTransform). Positions can usually be directly assigned, there are no conversions necessary.
Comment by alfa_80 on 2011-11-11:
@Ahornung: I think this tf::createQuaternionFromRPY() cannot be used because it's a static function while the input arguments need to be fed are a vector of values..Please correct me if I'm wrong.
Comment by alfa_80 on 2011-11-11:
new_pose.orientation = tf::createQuaternionFromRPY(data_set[t][6]/180.0M_PI, data_set[t][7]/180.0M_PI, data_set[t][8]/180.0*M_PI); Why am I still getting error of matching template problem? t is running in a loop for about 200 times..and the data_set is of type double already..
Comment by alfa_80 on 2011-11-11:
Any such thing for position which is coupled with TF like in orientation that you just pointed out?
Comment by AHornung on 2011-11-11:
Yes the better way would be to just use new_pose.orientation = tf::createQuaternionFromRPY(roll, pitch, yaw). Still, that leaves the question where your original data (data_set) comes from and what "roll", "picth", and "yaw" means in their representation!
Comment by alfa_80 on 2011-11-11:
I didn't manually create it, i just used "btQuaternion" class functionality there.. or is it easier using "tf::createQuaternionFromRPY()"?


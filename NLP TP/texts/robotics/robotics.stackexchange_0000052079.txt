Q:

p2os groovy C++ Velocity and C++ Pose Listener

We need help in compiling the test sketches for listening and sending information to the robot from the tutorial http: //www. ros. org/wiki/p2os-vanderbilt/Tutorials.
How to set the dependencies and set the right paths to  header files? Will it be enough to compile them with g++ and then start it using the line from the Tutorial rosrun p2osTutorial eo_pose. But what is the p2osTutorial? Is it some package, from which the compiled file will be started?

We have created p2osTutorials package and C++ listener works correctly.
Unfortunately C++ velocity doesn't make the robot move. The first problem was solved adding the line  ros::init(argc, argv, "velo"); to the file, but the robot still didn't move. We build the driving file the same way as the pose file (just added a new velo.cc file to the p2osTutorial/src) and edited the CMakeList.txt. I think we are doing something wrong?

Thanks for your answer. We compiled it the normal way but it seems that the cmd_pub.publish(cmd_msg); line does not move the robot
When we start the node we printed out the cmd_msg it looks fine to us (robot should move).
linear:
x: 0.5
y: 0
z: 0
angular:
x: 0
y: 0
z: 0
After looking at the tutorials (again ;) with the new informations that we have now) i can see that the code from your tutorial C++ Velocity is almost the same. I guess we still have any problems in our dependencies or something like that.
Thanks and regards

Thank you for the fast anwser and sorry that we did not tell this the motors are enabled and the robot drives over the simple commandline like: rostopic pub /cmd_vel geometry_msgs/Twist -r 10000 '[1, 0, 0]' '[0, 0, 0]'
in the scenario we try to test the C++ Velocity program we can not "move" the robot because the weels are "blocked"
or do we need to enable the motors in the way you actually described
Thanks again

Thank you for the tutorial, it worked fine everything could be compiled and also the program starts. The motors are enabled by the enableMotor command.
But the robot won't drive neither with the GUI_Command nor with the C++ Velocity program. We see that some kind of data is send in the output of the terminals. The question is if this is a ROS problem or is something missing that is essentially is needed to drive with the robot.
Thanks and regards

We will geht with the ropstopic list:

/aio /base_controller/command
/battery_state /cmd_motor_state
/cmd_vel /diagnostics /dio
/gripper_control /gripper_state
/motor_state /pose /ptz_control
/ptz_state /rosout /rosout_agg /sonar
/tf

C++ Velocity and echo_pose is active (p2os driver and so on also). I hope there is something in this list that is missing...
Thanks

image description http://oi43.tinypic.com/2dmgt3l.jpg
I hope this will clear things up thank you gain

sorry found out that there is another mode and i can see where the problem is. The Veloce program has no connection to the p2os driver
image description http://i39.tinypic.com/2r2qfsw.jpg

Originally posted by roman27 on ROS Answers with karma: 5 on 2013-06-18
Post score: 0

Original comments
Comment by allenh1 on 2013-06-19:
hm... That's odd. Why don't you try using the gui_command program? Just rosmake it and see if you can control it. It's in the vanderbilt-ros-pkg.
Comment by allenh1 on 2013-06-20:
do a rostopic list and post the output for me
Comment by allenh1 on 2013-06-20:
Hm... Ok. Now do an rxgraph and post the screenshot. (sudo apt-get install rox-groovy-rxgraph)
Comment by allenh1 on 2013-06-20:
After you install it, just run the command "rxgraph" with no rosrun in front of it.
Comment by allenh1 on 2013-06-20:
By the way, feel free to just email me if you have p2os specific questions: hunter.allen@vanderbilt.edu
Comment by allenh1 on 2013-06-20:
This is entirely my fault. You were publishing to the wrong topic... You need to publish to "/cmd_vel." Check the code I put in my answer.
Comment by allenh1 on 2013-06-20:
Also, do a git pull in the root of the vanderbilt-ros-pkg. I forgot to change that code back, so I have been doing that on the wrong topic as well. It should work now. So sorry for that.
Comment by roman27 on 2013-06-20:
Thanks no problem in the meantime i figured it even out by myself ;) (the /cmd_vel problem)  and finally got to drive it :) the rxgraph is a really good thing thanks for that. Now i hope we can finally start with our project :). Thank you very much for the help.
Comment by allenh1 on 2013-06-20:
Glad to hear it! I'm glad I was able to help. Learning to debug with ROS is an important thing.

A:

No... Sorry for the misunderstanding... You need to create a package. Navigate to your ROS workspace (for you it should be done by cd ~/ros_workspace) then run the following command.
roscreate-pkg p2osTutorial roscpp geometry_msgs nav_msgs 

Then add the following line to the CMakeLists.txt:
rosbuild_add_executable(eo_pose src/eo_pose.cc)

Note: you need to move your source to the subdirectory src.

Update: I have now added a new tutorial called Setup. I also updated the tutorial you are using with some more detail.

Ok, so I see the confusion now... You will not need to run any g++ commands at all. If you have not done so, I recommend that you go through the ROS tutorials to get a better understanding of how the build process works. To answer your question, yes, it is a package. You will have ROS run the program with a rosrun command.

I think I know the issue... You might not be enabling the motors. Run the p2os_dashboard and enable the motors. Alternatively, you can use the vanderbilt-ros-pkg. A lab member wrote a node to do this. It's called p2os_enableMotor.
Here's how you can use it:
roscd && cd ../src
git clone https://github.com/allenh1/vanderbilt-ros-pkg.git
source ../devel/setup.bash
rosmake p2os_enableMotor
rosrun p2os_enableMotor enableMotor

That should make the pioneer movable. The motors are not enabled by default.

Huzzah! I see it now. The controller node is not interfacing with the p2os node. Could you email me/post the code for your controller? I want to make sure there isn't something weird going on.

My goodness... This is my fault. Try this code:
const double TWIST_LINEAR = 0.5; //.5 m/s forward
const double TWIST_ANGULAR = 0; //0 rad/s 
int main(int argc, char **argv)
{
    ros::NodeHandle n;
    
    ros::Publisher cmd_pub = n.advertise<geometry_msgs::Twist>("/cmd_vel", 100);
    
    ros::Rate loop_rate(10);
    
    while (ros::ok())
    {
        geometry_msgs::Twist cmd_msg;
        cmd_msg.linear.x = TWIST_LINEAR;
        cmd_msg.angular.z = TWIST_ANGULAR;
        
        
        cmd_pub.publish(cmd_msg);
        
        ros::spinOnce();
        
        loop_rate.sleep();
    }
    
    
    return 0;
}

Originally posted by allenh1 with karma: 3055 on 2013-06-18
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by allenh1 on 2013-06-19:
I updated the setup tutorial to give you some more information.
Comment by roman27 on 2013-06-19:
Thanks we test it tomorrow it is already late here ;) regards


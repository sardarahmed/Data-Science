Q:

Synchronizer.h Errors

Hi guys,
I've been trying to do approximate time synchronization, and have been adapting tutorial examples for my own needs. I was facing some errors with sync_policies not having a type, synchronizer not being declared in the scope, and so on. Seeing some other forum posts, I added

using namespace message_filters

and got a wall of errors:
/home/pi/ros_ws/src/link/src/roscomm.cpp: In function ‘int main(int, char**)’:   
/home/pi/ros_ws/src/link/src/roscomm.cpp:222:85: error: ‘IMU’ is not a member of ‘sensor_msgs’                     
   typedef sync_policies::ApproximateTime<sensor_msgs::NavSatFix, std_msgs::Float64, sensor_msgs::IMU> NavSyncPolicy;
                                                                                     ^~~~~~~~~~~
/home/pi/ros_ws/src/link/src/roscomm.cpp:222:85: error: ‘IMU’ is not a member of ‘sensor_msgs’                   
/home/pi/ros_ws/src/link/src/roscomm.cpp:222:101: error: template argument 3 is invalid
   typedef sync_policies::ApproximateTime<sensor_msgs::NavSatFix, std_msgs::Float64, sensor_msgs::IMU> NavSyncPolicy;
                                                                                                     ^                                                                                 
In file included from /home/pi/ros_ws/src/link/src/roscomm.cpp:21:0:                                                                                                                                        
/opt/ros/kinetic/include/message_filters/synchronizer.h: In instantiation of ‘class message_filters::Synchronizer<int>’:
/home/pi/ros_ws/src/link/src/roscomm.cpp:223:49:   required from here
/opt/ros/kinetic/include/message_filters/synchronizer.h:68:7: error: base type ‘int’ fails to be a struct or class type
 class Synchronizer : public boost::noncopyable, public Policy
       ^~~~~~~~~~~~
/opt/ros/kinetic/include/message_filters/synchronizer.h:71:37: error: ‘int’ is not a class, struct, or union type
   typedef typename Policy::Messages Messages;
                                     ^~~~~~~~
/opt/ros/kinetic/include/message_filters/synchronizer.h:72:35: error: ‘int’ is not a class, struct, or union type
   typedef typename Policy::Events Events;
                                   ^~~~~~
/opt/ros/kinetic/include/message_filters/synchronizer.h:73:35: error: ‘int’ is not a class, struct, or union type
   typedef typename Policy::Signal Signal;
                                   ^~~~~~
/opt/ros/kinetic/include/message_filters/synchronizer.h:74:49: error: ‘int’ is not a class, struct, or union type
   typedef typename mpl::at_c<Messages, 0>::type M0;
                                                 ^~
/opt/ros/kinetic/include/message_filters/synchronizer.h:75:49: error: ‘int’ is not a class, struct, or union type
   typedef typename mpl::at_c<Messages, 1>::type M1;
                                                 ^~
/opt/ros/kinetic/include/message_filters/synchronizer.h:76:49: error: ‘int’ is not a class, struct, or union type
   typedef typename mpl::at_c<Messages, 2>::type M2;
                                                 ^~
/opt/ros/kinetic/include/message_filters/synchronizer.h:77:49: error: ‘int’ is not a class, struct, or union type
   typedef typename mpl::at_c<Messages, 3>::type M3;
                                                 ^~
/opt/ros/kinetic/include/message_filters/synchronizer.h:78:49: error: ‘int’ is not a class, struct, or union type
   typedef typename mpl::at_c<Messages, 4>::type M4;
                                                 ^~
/opt/ros/kinetic/include/message_filters/synchronizer.h:79:49: error: ‘int’ is not a class, struct, or union type
   typedef typename mpl::at_c<Messages, 5>::type M5;
                                                 ^~
/opt/ros/kinetic/include/message_filters/synchronizer.h:80:49: error: ‘int’ is not a class, struct, or union type
   typedef typename mpl::at_c<Messages, 6>::type M6;
                                                 ^~
/opt/ros/kinetic/include/message_filters/synchronizer.h:81:49: error: ‘int’ is not a class, struct, or union type
   typedef typename mpl::at_c<Messages, 7>::type M7;
                                                 ^~
/opt/ros/kinetic/include/message_filters/synchronizer.h:82:49: error: ‘int’ is not a class, struct, or union type
   typedef typename mpl::at_c<Messages, 8>::type M8;
                                                 ^~
/opt/ros/kinetic/include/message_filters/synchronizer.h:83:47: error: ‘int’ is not a class, struct, or union type
   typedef typename mpl::at_c<Events, 0>::type M0Event;
                                               ^~~~~~~
/opt/ros/kinetic/include/message_filters/synchronizer.h:84:47: error: ‘int’ is not a class, struct, or union type
   typedef typename mpl::at_c<Events, 1>::type M1Event;
                                               ^~~~~~~
/opt/ros/kinetic/include/message_filters/synchronizer.h:85:47: error: ‘int’ is not a class, struct, or union type
   typedef typename mpl::at_c<Events, 2>::type M2Event;
                                               ^~~~~~~
/opt/ros/kinetic/include/message_filters/synchronizer.h:86:47: error: ‘int’ is not a class, struct, or union type
   typedef typename mpl::at_c<Events, 3>::type M3Event;
                                               ^~~~~~~
/opt/ros/kinetic/include/message_filters/synchronizer.h:87:47: error: ‘int’ is not a class, struct, or union type
   typedef typename mpl::at_c<Events, 4>::type M4Event;
                                               ^~~~~~~
/opt/ros/kinetic/include/message_filters/synchronizer.h:88:47: error: ‘int’ is not a class, struct, or union type
   typedef typename mpl::at_c<Events, 5>::type M5Event;
                                               ^~~~~~~
/opt/ros/kinetic/include/message_filters/synchronizer.h:89:47: error: ‘int’ is not a class, struct, or union type
   typedef typename mpl::at_c<Events, 6>::type M6Event;
                                               ^~~~~~~
/opt/ros/kinetic/include/message_filters/synchronizer.h:90:47: error: ‘int’ is not a class, struct, or union type
   typedef typename mpl::at_c<Events, 7>::type M7Event;
                                               ^~~~~~~
/opt/ros/kinetic/include/message_filters/synchronizer.h:91:47: error: ‘int’ is not a class, struct, or union type
   typedef typename mpl::at_c<Events, 8>::type M8Event;
                                               ^~~~~~~
In file included from /home/pi/ros_ws/src/link/src/roscomm.cpp:21:0:
/opt/ros/kinetic/include/message_filters/synchronizer.h:337:17: error: type ‘int’ is not a base type for type ‘message_filters::Synchronizer<int>’
   using Policy::add;
                 ^~~
/opt/ros/kinetic/include/message_filters/synchronizer.h:340:8: error: ‘int’ is not a class, struct, or union type
   void add(const boost::shared_ptr<typename mpl::at_c<Messages, i>::type const>& msg)
        ^~~
/opt/ros/kinetic/include/message_filters/synchronizer.h:356:8: error: ‘int’ is not a class, struct, or union type
   void cb(const typename mpl::at_c<Events, i>::type& evt)
        ^~
In file included from /home/pi/ros_ws/src/link/src/roscomm.cpp:21:0:
/opt/ros/kinetic/include/message_filters/synchronizer.h: In instantiation of ‘message_filters::Synchronizer<Policy>::Synchronizer(const Policy&, F0&, F1&, F2&) [with F0 = message_filters::Subscriber<senso
r_msgs::NavSatFix_<std::allocator<void> > >; F1 = message_filters::Subscriber<std_msgs::Float64_<std::allocator<void> > >; F2 = message_filters::Subscriber<sensor_msgs::Imu_<std::allocator<void> > >; Poli
cy = int]’:
/home/pi/ros_ws/src/link/src/roscomm.cpp:223:81:   required from here
/opt/ros/kinetic/include/message_filters/synchronizer.h:166:18: error: type ‘int’ is not a direct base of ‘message_filters::Synchronizer<int>’
   : Policy(policy)
                  ^
In file included from /home/pi/ros_ws/src/link/src/roscomm.cpp:21:0:
/opt/ros/kinetic/include/message_filters/synchronizer.h: In instantiation of ‘message_filters::Connection message_filters::Synchronizer<Policy>::registerCallback(const C&) [with C = boost::_bi::bind_t<voi
d, void (*)(const boost::shared_ptr<const sensor_msgs::Imu_<std::allocator<void> > >&, const boost::shared_ptr<const sensor_msgs::NavSatFix_<std::allocator<void> > >&, const boost::shared_ptr<const std_ms
gs::Float64_<std::allocator<void> > >&), boost::_bi::list3<boost::arg<1>, boost::arg<2>, boost::arg<3> > >; Policy = int]’:
/home/pi/ros_ws/src/link/src/roscomm.cpp:224:62:   required from here
/opt/ros/kinetic/include/message_filters/synchronizer.h:310:12: error: using invalid field ‘message_filters::Synchronizer<Policy>::signal_’
     return signal_.addCallback(callback);
            ^~~~~~~
In file included from /usr/include/boost/lexical_cast/detail/converter_lexical.hpp:54:0,
                 from /usr/include/boost/lexical_cast/try_lexical_convert.hpp:42,
                 from /usr/include/boost/lexical_cast.hpp:32,
                 from /opt/ros/kinetic/include/ros/transport_hints.h:34,
                 from /opt/ros/kinetic/include/ros/subscribe_options.h:33,
                 from /opt/ros/kinetic/include/ros/node_handle.h:42,
                 from /opt/ros/kinetic/include/ros/ros.h:45,
                 from /home/pi/ros_ws/src/link/src/roscomm.cpp:13:
/usr/include/boost/lexical_cast/detail/converter_lexical_streams.hpp: In instantiation of ‘class boost::detail::lexical_istream_limited_src<char, std::char_traits<char>, false, 21u>’:
/usr/include/boost/lexical_cast/detail/converter_lexical.hpp:476:36:   required from ‘static bool boost::detail::lexical_converter_impl<Target, Source>::try_convert(const Source&, Target&) [with Target = 
std::__cxx11::basic_string<char>; Source = int]’
/usr/include/boost/lexical_cast/try_lexical_convert.hpp:196:44:   required from ‘bool boost::conversion::detail::try_lexical_convert(const Source&, Target&) [with Target = std::__cxx11::basic_string<char>
; Source = int]’
/usr/include/boost/lexical_cast.hpp:41:60:   required from ‘Target boost::lexical_cast(const Source&) [with Target = std::__cxx11::basic_string<char>; Source = int]’
/opt/ros/kinetic/include/ros/transport_hints.h:115:74:   required from here
/usr/include/boost/lexical_cast/detail/converter_lexical_streams.hpp:136:15: error: duplicate base type ‘boost::noncopyable_::noncopyable’ invalid
         class lexical_istream_limited_src: boost::noncopyable {
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/include/boost/lexical_cast/detail/converter_lexical.hpp:54:0,
                 from /usr/include/boost/lexical_cast/try_lexical_convert.hpp:42,
                 from /usr/include/boost/lexical_cast.hpp:32,
                 from /opt/ros/kinetic/include/ros/transport_hints.h:34,
                 from /opt/ros/kinetic/include/ros/subscribe_options.h:33,
                 from /opt/ros/kinetic/include/ros/node_handle.h:42,
                 from /opt/ros/kinetic/include/ros/ros.h:45,
                 from /home/pi/ros_ws/src/link/src/roscomm.cpp:13:
/usr/include/boost/lexical_cast/detail/converter_lexical_streams.hpp: In instantiation of ‘class boost::detail::lexical_ostream_limited_src<char, std::char_traits<char> >’:
/usr/include/boost/lexical_cast/detail/converter_lexical.hpp:482:36:   required from ‘static bool boost::detail::lexical_converter_impl<Target, Source>::try_convert(const Source&, Target&) [with Target = 
std::__cxx11::basic_string<char>; Source = int]’
/usr/include/boost/lexical_cast/try_lexical_convert.hpp:196:44:   required from ‘bool boost::conversion::detail::try_lexical_convert(const Source&, Target&) [with Target = std::__cxx11::basic_string<char>
; Source = int]’
/usr/include/boost/lexical_cast.hpp:41:60:   required from ‘Target boost::lexical_cast(const Source&) [with Target = std::__cxx11::basic_string<char>; Source = int]’
/opt/ros/kinetic/include/ros/transport_hints.h:115:74:   required from here
/usr/include/boost/lexical_cast/detail/converter_lexical_streams.hpp:501:15: error: duplicate base type ‘boost::noncopyable_::noncopyable’ invalid
         class lexical_ostream_limited_src: boost::noncopyable {
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/include/boost/lexical_cast/detail/converter_lexical.hpp:54:0,
                 from /usr/include/boost/lexical_cast/try_lexical_convert.hpp:42,
                 from /usr/include/boost/lexical_cast.hpp:32,
                 from /opt/ros/kinetic/include/ros/transport_hints.h:34,
                 from /opt/ros/kinetic/include/ros/subscribe_options.h:33,
                 from /opt/ros/kinetic/include/ros/node_handle.h:42,
                 from /opt/ros/kinetic/include/ros/ros.h:45,
                 from /home/pi/ros_ws/src/link/src/roscomm.cpp:13:
/usr/include/boost/lexical_cast/detail/converter_lexical_streams.hpp: In instantiation of ‘class boost::detail::lexical_istream_limited_src<char, std::char_traits<char>, false, 2u>’:
/usr/include/boost/lexical_cast/detail/converter_lexical.hpp:476:36:   required from ‘static bool boost::detail::lexical_converter_impl<Target, Source>::try_convert(const Source&, Target&) [with Target = 
int; Source = std::__cxx11::basic_string<char>]’
/usr/include/boost/lexical_cast/try_lexical_convert.hpp:196:44:   required from ‘bool boost::conversion::detail::try_lexical_convert(const Source&, Target&) [with Target = int; Source = std::__cxx11::basi
c_string<char>]’
/usr/include/boost/lexical_cast.hpp:41:60:   required from ‘Target boost::lexical_cast(const Source&) [with Target = int; Source = std::__cxx11::basic_string<char>]’
/opt/ros/kinetic/include/ros/transport_hints.h:131:47:   required from here
/usr/include/boost/lexical_cast/detail/converter_lexical_streams.hpp:136:15: error: duplicate base type ‘boost::noncopyable_::noncopyable’ invalid
         class lexical_istream_limited_src: boost::noncopyable {
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
link/CMakeFiles/roscomm.dir/build.make:62: recipe for target 'link/CMakeFiles/roscomm.dir/src/roscomm.cpp.o' failed
make[2]: *** [link/CMakeFiles/roscomm.dir/src/roscomm.cpp.o] Error 1
CMakeFiles/Makefile2:1159: recipe for target 'link/CMakeFiles/roscomm.dir/all' failed
make[1]: *** [link/CMakeFiles/roscomm.dir/all] Error 2
Makefile:138: recipe for target 'all' failed
make: *** [all] Error 2
Invoking "make -j4 -l4" failed

Is this an error with synchronizer.h I can't fix, was it caused by a minor error in my code?
Thanks

Originally posted by Old Meme on ROS Answers with karma: 40 on 2018-08-20
Post score: 0

A:

/.../src/roscomm.cpp:222:85: error: ‘IMU’ is not a member of ‘sensor_msgs’                     

   typedef sync_policies::ApproximateTime<sensor_msgs::NavSatFix, std_msgs::Float64, sensor_msgs::IMU> NavSyncPolicy;
                                                                                     ^~~~~~~~~~~
/.../src/roscomm.cpp:222:85: error: ‘IMU’ is not a member of ‘sensor_msgs’                   

Note: the message name is Imu, not IMU.
If you've fixed that and still get the same error, it's likely you forgot to include the sensor_msgs/Imu.h header.
another note: time synchronisation is only possible with message types that have a header: std_msgs/Float64 doesn't have one, so it cannot be used.

Edit:

Is this an error with synchronizer.h I can't fix, was it caused by a minor error in my code?

seeing as these packages have been around for at least 10 years, I would always assume your code is at fault -- at first.
However, no code is faultless, so if you've assured that you're doing the right thing, then suspecting message_filters starts to make sense.

Originally posted by gvdhoorn with karma: 86574 on 2018-08-20
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Old Meme on 2018-08-20:
So the original issue was fixed, but now there's something wrong with my boost statement that I don't know how to fix (see edit)
Comment by gvdhoorn on 2018-08-20:
Please don't post follow-up issues in the same question.
If you have a new problem, post a new question.
Comment by Old Meme on 2018-08-20:
If time sync can't be used with message types without headers, is there any way to sync those types of messages then?
Comment by gvdhoorn on 2018-08-20:\

If time sync can't be used with message types without headers, is there any way to sync those types of messages then?

Not with message_filters with C++ afaik. Without access to a stamp, how would you think synchronisation should work?
The Python version does support it, but it inserts a stamp.


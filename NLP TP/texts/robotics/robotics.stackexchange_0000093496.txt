Q:

callback function doesnt printout the subscribe msg

hello guys iam new at ROS and iam trying to print the msg and some how it doesnt print it and i cant find where is the problem
this is my code
#include <moveit/move_group_interface/move_group_interface.h>
#include <moveit/planning_scene_interface/planning_scene_interface.h>
#include <moveit_msgs/DisplayRobotState.h>
#include <moveit_msgs/DisplayTrajectory.h>
#include <moveit_msgs/AttachedCollisionObject.h>
#include <moveit_msgs/CollisionObject.h>
#include <moveit_visual_tools/moveit_visual_tools.h>
#include <iostream>
#include <moveit/robot_model/robot_model.h>
#include <moveit/robot_state/robot_state.h>
#include <ros/ros.h>
#include "geometry_msgs/PointStamped.h"
#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/Quaternion.h>
#include <tf/transform_broadcaster.h>
#include <message_filters/sync_policies/approximate_time.h>
#include <sensor_msgs/PointCloud.h>
#include <sensor_msgs/PointCloud2.h>
#include <sensor_msgs/point_cloud_conversion.h>
#include <tf/LinearMath/Quaternion.h>
#include <tf/transform_datatypes.h>

using namespace message_filters;
using namespace sensor_msgs;
using namespace std;
using namespace geometry_msgs;
namespace rvt = rviz_visual_tools;

class kuka
{

private:
    ros::Subscriber sub;
    ros::NodeHandle nh_;

public:
        kuka(ros::NodeHandle &nh) //constructor 
      {
      nh_=nh;   
      }

        void status() //func showing the actual position (case0)
    {
        sub = nh_.subscribe("/robposi", 1000, &kuka::callback, this); 
        cout<<"status";
    }
    
        
        
        void callback(const geometry_msgs::PointStamped::ConstPtr& rob)
        {
        cout<<"callback  ";
        ROS_INFO_STREAM(endl << "RobCoor.x: "<< rob->point.x << endl << "RobCoor.y: "<< rob->point.y << endl << "RobCoor.z: "<< rob->point.z << endl);
        }

    
};

int main(int argc, char** argv)
{
    ros::init(argc, argv, "kuka");
        int j;char loop='*';

    ros::NodeHandle nh;

do
    {
     cout<<"-------------------------------------------"<<std::endl;
     cout<<"|0 |check position of robot               |"<<std::endl;
     cout<<"|1 |go to home                            |"<<std::endl;
     cout<<"|2 |go to stored position                 |"<<std::endl;
     cout<<"|3 |enter the position w,x,y,z            |"<<std::endl;
     cout<<"|4 |enter the position of joints          |"<<std::endl;
     cout<<"|5 | exit                                 |"<<std::endl;
     cout<<"-------------------------------------------"<<std::endl;
     cin>>j;
    kuka listen_0(nh);

cout<<"i =   "<<j;

    switch (j){
    case(0):{
cout<<"i hekkddddddddddd   ";
    listen_0.status();
cout<<"i hekk.lj,hk....   ";
    }
    
    break;
    
}

    cout <<"would you like to enter new choice y/n?"<<endl;
    cin>> loop;
    }while (loop == 'y');

    return 0;
 }

Originally posted by sadeksadek on ROS Answers with karma: 3 on 2019-10-07
Post score: 0

Original comments
Comment by lmathieu on 2019-10-07:
Hello ! Can you put the whole code ? Because we only this part, it look like you forgot to call ros::spin() or ros::spinOnce().
These 2 functions are used by roscpp to check if any message has been received by your subscribers
Comment by Delb on 2019-10-08:
Based on OP's "answer" that indeed looks like the solution.
Comment by sadeksadek on 2019-10-08:
its the hole program , that my supervisor recommended me to make do while instead of ros spin because it make problems with switch case  but i will try to use ros spin and see the result
Comment by sadeksadek on 2019-10-08:
i tried ros::spinOnce() and also i add  do{ /somecode/ }while(loop=='y' && ros::ok())  at the end but the problem still happening callback function doesn't call though when i make rostopic echo i can see the msg that i publish

A:

I think I got it :
In your code, you are calling listen_0.status(); when a user press '0', this function is creating a new subscriber. If you added a ros::spinOnce(), the callback is never called if a user never pressed '0' before. But there is another problem, you recreate the class  kuka listen_0(nh); at the beginning of the loop, hence destroying the old class instance and losing your subscriber.
When using ROS, you should only create a subscriber (or publisher) once, often in the constructor of a class or in an init() function, and delete it at the end of your program. This allow your rosnode to "tell" the roscore that there is a new node with a subscriber (or publisher), and he should receive (or send) message (this take some times in background, you can't create a publisher or subscriber and instantly receive or publish a message).
I recommend you to take a look at the ros tutorial about Subscribing to have a better understanding of the ROS ecosystem.
Normally, your code should look like this (I added /// comment where I edited your file):
Be carefull, as this is not optimal at all. Since your cin are blocking, i placed the ros::spinOnce() before the code needs the messages values. You may want to take a look at Async Spinner once you have fully grasped the basics
..skipping includes...
class kuka
{

private:
    ros::Subscriber sub;
    ros::NodeHandle nh_;

    ///We save the last robot coordinate here
    geometry_msgs::PointStamped lastCoordinate;

public:
    kuka(ros::NodeHandle &nh) // constructor
    {
        nh_ = nh;

        ///Create the subscriber here
        sub = nh_.subscribe("/robposi", 1000, &kuka::callback, this);
    }

    void status() // func showing the actual position (case0)
    {
        cout << "status";
        ROS_INFO_STREAM(endl
                        << "RobCoor.x: " << lastCoordinate->point.x << endl
                        << "RobCoor.y: " << lastCoordinate->point.y << endl
                        << "RobCoor.z: " << lastCoordinate->point.z << endl);
    }

    void callback(const geometry_msgs::PointStamped::ConstPtr &rob)
    {
        cout << "callback  ";
        lastCoordinate = rob; ///we save the robot position for later
    }
};

int main(int argc, char **argv)
{
    ros::init(argc, argv, "kuka");
    int j;
    char loop = '*';

    ros::NodeHandle nh;

    ///Creation of the class outside the main loop
    kuka listen_0(nh);

    do
    {
        cout << "-------------------------------------------" << std::endl;
        cout << "|0 |check position of robot               |" << std::endl;
        cout << "|1 |go to home                            |" << std::endl;
        cout << "|2 |go to stored position                 |" << std::endl;
        cout << "|3 |enter the position w,x,y,z            |" << std::endl;
        cout << "|4 |enter the position of joints          |" << std::endl;
        cout << "|5 | exit                                 |" << std::endl;
        cout << "-------------------------------------------" << std::endl;
        cin >> j;

        cout << "i =   " << j;

        ros::spinOnce();///we spin here since this is the optimal place

        switch (j)
        {
        case (0):
        {
            cout << "i hekkddddddddddd   ";
            listen_0.status(); ///Display current position if pressed 0
            cout << "i hekk.lj,hk....   ";
        }

        break;
        }

        cout << "would you like to enter new choice y/n?" << endl;
        cin >> loop;
    } while (loop == 'y' && ros::ok()); ///continue until ros is stopped, ctrl+c is pressed or user didn't entered Y

    return 0;
}

Originally posted by lmathieu with karma: 591 on 2019-10-08
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by sadeksadek on 2019-10-08:
it works finally thanks very much for your help though the callback function was repeated somehow when i call the 0 option again but at least it worked and now i just should figure out how to make it work once when i call it
Comment by lmathieu on 2019-10-08:
The callback function will get called everytime the code pass through ros::spinOnce().
If you add an asyncspinner, the callback function will get called everytime a message is received.
that because ROS keep the message received in a queue, if the queue is not empty, the callback will be called. Your queue can actually keep 1000 messages, so the callback can be called up to 1000 times in a row everytime the user press something (you will see up to 1000 times "callback" written on the screen actually if the user wait to much to choose something), and that probably not what you want ( But I don't know your use case so maybe it is)
Again, do the tutorial, that will keep you away from a lot of cppain in the future :)
Comment by sadeksadek on 2019-10-09:
yea i am doing the tutorial again because i just need it to receive the message only once only when i call the case . but really thanks you very much for your help


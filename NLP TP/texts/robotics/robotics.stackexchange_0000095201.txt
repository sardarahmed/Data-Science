Q:

Best way of publishing to /clock topic type rosgraph_msgs/Clock?

Ultimately I need to publish an accelerated time to the /clock topic which the rest of my simulation nodes are using.  I have managed to concoct two separate launch files;

the first launch file includes all my nodes which are driven from the /clock topic which has type rosgraph_msgs/Clock, and
the second launch file instantiates a python coded node that is driven by the system (wall) clock in real time.

I wish to use this python node to accelerate time, and publish to the /clock topic, thereby driving all the simulated nodes at faster than real time.
My problem is that the /clock topic uses type rosgraph_msgs/Clock which contains a field of type time called clock.  If I simply try to define and calculate an accelerated time using the Time type available in std_msgs.msg and push this into the /clock, roscore understandably detects the type mismatch as an error.  If I try to access the definition of rosgraph_msgs.msg and the clock type, and push a Time type into that, again I fail.
Sample code follows below.  'pub' is fine, but 'pub1' is the version of time_dat that I want to produce as if it was of type rosgraph_msgs/Clock.
If I can appropriately get this fixed, I will be writing up a tutorial on this subject, as it appears to be a common desire to create this sort of facility.
Thanks for any/all feedback, Curlyfrond
#!/usr/bin/env python
import rospy
from std_msgs.msg import Time
from rosgraph_msgs.msg import Clock

def simtime_talker():
    pub = rospy.Publisher('timey',Time, queue_size=10)
    pub1 = rospy.Publisher('clockey',Clock, queue_size=10)
    rospy.init_node('talker', anonymous=True)
    rate = rospy.Rate(10) # 10hz
    sim_speed_multiplier = 10

   zero_time = rospy.get_time()

   while not rospy.is_shutdown():

       timepassed_dat = rospy.get_time() - zero_time
       timepassedaccelerated_dat = sim_speed_multiplier*timepassed_dat
       time_dat = rospy.Time.from_sec(timepassedaccelerated_dat)

       pub.publish(rospy.get_time())
       pub1.publish(time_dat)
       rate.sleep()

if __name__ == '__main__':
try:
    simtime_talker()
except rospy.ROSInterruptException:
    pass

Originally posted by Craigstar on ROS Answers with karma: 36 on 2020-03-27
Post score: 0

Original comments
Comment by gvdhoorn on 2020-03-27:\

My problem is [..] roscore understandably detects the type mismatch as an error. If I try to access the definition of rosgraph_msgs.msg [..] again I fail.

This is going to sound snarky, but really: please always show us any errors or warnings or other such information, as without that, we cannot help you.
What does "I fail" mean?
Comment by Craigstar on 2020-03-29:
Thanks, I will remember to add the error messages next time.  However, the error was simply in my rather "inept" misunderstanding of Python, and I've fixed it.  I needed to simply declare the Clock object I was using, and suitably fill it in with a Time.  Below I have included the fixed code that works, for those interested in doing this.  I will also try to write up a short example ('tutorial') for how to set the simulation clock like this, as it is a common question on ROS.  Thanks gvdhoom for taking the time to read the query.

A:

Fixed it myself :-)
Here's the working code sample.
import rospy
from rosgraph_msgs.msg import Clock

def simtime_talker():
    pub1 = rospy.Publisher('clock',Clock, queue_size=10)
    rospy.init_node('talker', anonymous=True)
    rate = rospy.Rate(10) # 10hz
    sim_speed_multiplier = 10    
    sim_clock = Clock()
    zero_time = rospy.get_time()

    while not rospy.is_shutdown():
       sim_clock.clock = rospy.Time.from_sec(sim_speed_multiplier*(rospy.get_time() - zero_time))
       rospy.loginfo(sim_clock)
       pub1.publish(sim_clock)
       rate.sleep()

if __name__ == '__main__':
    try:
        simtime_talker()
    except rospy.ROSInterruptException:
        pass

Originally posted by Craigstar with karma: 36 on 2020-03-29
This answer was ACCEPTED on the original site
Post score: 1


Q:

Moveit! Processing is done normally, but the hardware does not work

Currently, I want to control mycobot (6-axis manipulator) with Moveit control based on the position information acquired from find_object_2d, but it seems that Moveit processing is working properly on the terminal, but after that [WARN] ] [1642379377.552406518]: The actual machine does not work, probably because of Messages of type 0 arrived closer. Does anyone know a solution to this phenomenon?
Startup procedure
roslaunch object_detection_with_intel_D415 object_detect_using_find2d_object.launch
rosrun rsj_2017_pick_and_placer pick_and_placer
roslaunch mycobot_moveit mycobot_moveit.launch 

⇧Startup procedure
[ INFO] [1642379368.179417955]: Combined planning and execution request received for MoveGroup action. Forwarding to planning and execution pipeline.
[ INFO] [1642379368.179702211]: Planning attempt 1 of at most 1
[ INFO] [1642379368.181693195]: Planner configuration 'mycobot_arm' will use planner 'geometric::RRTConnect'. Additional configuration parameters will be set when the planner is constructed.
[ INFO] [1642379368.182528240]: RRTConnect: Starting planning with 1 states already in datastructure
[ INFO] [1642379368.211282483]: RRTConnect: Created 4 states (2 start + 2 goal)
[ INFO] [1642379368.211327863]: Solution found in 0.029233 seconds
[ INFO] [1642379368.245646100]: SimpleSetup: Path simplification took 0.034228 seconds and changed from 3 to 2 states
[ INFO] [1642379368.247162454]: Disabling trajectory recording
[INFO] [1642379368.379956]: /hardware_interface(5.6661323469597846e-05, 9.375524678034708e-05, 8.57722043292597e-05, 8.2327016571071e-05, 8.735547453397885e-05, -5.648820661008358e-05)
[INFO] [1642379368.480028]: /hardware_interface(5.870570748811588e-05, 9.050820517586544e-05, 8.25183597044088e-05, 8.439325029030442e-05, 8.942599379224703e-05, -5.5870932555990294e-05)
[ INFO] [1642379368.480582121]: Controller mycobot_trajectory_controller successfully finished
[ INFO] [1642379368.779190688]: Completed trajectory execution with status SUCCEEDED ...
[ WARN] [1642379377.552406518]: Messages of type 0 arrived closer (0.109201117) than the lower bound you provided (0.500000000) (will print only once)
QObject::connect: Cannot queue arguments of type 'QVector<int>'
(Make sure 'QVector<int>' is registered using qRegisterMetaType().)
QObject::connect: Cannot queue arguments of type 'QVector<int>'
(Make sure 'QVector<int>' is registered using qRegisterMetaType().)
[ WARN] [1642379377.835367333]: Messages of type 1 arrived closer (0.001305093) than the lower bound you provided (0.500000000) (will print only once)

As a control, Pose Stamped is used from the tf_example node and published with the topic name "/ block". We are subscribing to the pick_and_placer node.
C:\fakepath\Screenshot from 2022-01-17 08-47-51.png
pick_and_placer.cpp
Coordinate values ​​are acquired at line numbers 80 and 81.
float tx = pose.pose.position.x;
float ty = pose.pose.position.y;
// Copyright 2017 Geoffrey Biggs (geoffrey.biggs@aist.go.jp)

#include <ros/ros.h>
#include <rsj_2017_pick_and_placer/GripperStatus.h>
#include <moveit/move_group_interface/move_group_interface.h>
#include <unistd.h>

#include <moveit/planning_scene_interface/planning_scene_interface.h>

#include <actionlib/client/simple_action_client.h>
#include <control_msgs/GripperCommandAction.h>

#include <geometry_msgs/Pose.h>
#include <geometry_msgs/Pose2D.h>
#include <geometry_msgs/PoseStamped.h>

#include <moveit_msgs/CollisionObject.h>

#include <moveit_msgs/Grasp.h>

#include <shape_msgs/SolidPrimitive.h>

#include <string>
#include <vector>
#include <mutex>

std::mutex m;

// Class to provide the node's behaviour and store its state between callbacks
class PickNPlacer {
 public:
  explicit PickNPlacer(ros::NodeHandle& node_handle)
      : arm_("mycobot_arm") {
    // Get the value for the configurable values from the parameter server, and
    // set sensible defaults for those values not specified on the parameter
    // server
    ros::param::param<float>(
      "~place_x",
      place_x_,
      0.1);
    ros::param::param<float>("~place_y", place_y_, -0.2);
    ros::param::param<std::string>("~task_frame", scene_task_frame_,"base_link");
    ros::param::param<float>("~pick_prepare_z", pick_prepare_z_, 0.1);
    ros::param::param<float>("~pick_z", pick_z_, 0.05);
    ros::param::param<float>("~place_prepare_z", place_prepare_z_, 0.1);
    ros::param::param<float>("~place_z", place_z_, 0.05);

    // Specify end-effector positions in the configured task frame
    arm_.setPoseReferenceFrame(scene_task_frame_);
    // Start by moving to the vertical pose
    arm_.setNamedTarget("vertical");
    arm_.move();

    // Subscribe to the "/block" topic to receive object positions; excecute
    // DoPickAndPlace() when one is received
    sub_ = node_handle.subscribe("/block", 1, &PickNPlacer::DoPickAndPlace, this);
    
  }

  void DoPickAndPlace(geometry_msgs::PoseStamped::ConstPtr const& msg) {
    // Add the newly-detected object
    //AddBoxToScene(msg);
    // Do the pick-and-place
  
    if (DoPick(msg)) {
    }
    // Remove the object now that we don't care about it any more
    //RemoveBoxFromScene();
  }

  bool DoPick(geometry_msgs::PoseStamped::ConstPtr const& msg) {
    std::lock_guard<std::mutex> lock(m); 
    // Prepare
    ROS_INFO("Moving to prepare pose %f, %f, %f", msg->pose.position.x, msg->pose.position.y, msg->pose.position.z);
    geometry_msgs::PoseStamped pose;
    pose.header.frame_id = "base_link";
    float tx = pose.pose.position.x;
    float ty = pose.pose.position.y;
    float tz = 0.20;
    arm_.setPoseTarget(pose);
    // Execute the move
    if (!arm_.move()) {
    ROS_INFO("Could Not Gripper Open");
    arm_.setNamedTarget("vertical");
      ROS_WARN("Could not move to prepare pose");
      return false;
    }
  }
 private:
  // Planning interface for the arm
  moveit::planning_interface::MoveGroupInterface arm_;

  // Object to manage the planning scene
  moveit::planning_interface::PlanningSceneInterface scene_;
  // Topic to receive object positions
  ros::Subscriber sub_;
  // Variables to hold configured parameters
  float place_x_;
  float place_y_;
  std::string scene_task_frame_;
  float pick_prepare_z_;
  float pick_z_;
  float place_prepare_z_;
  float place_z_;

};

int main(int argc, char **argv) {
  ros::init(argc, argv, "pickandplacer");

  ros::AsyncSpinner spinner(2);
  spinner.start();

  ros::NodeHandle nh;

  // Create an instance of the class that implements the node's behaviour
  PickNPlacer pnp(nh);

  // Wait until the node is shut down
  ros::waitForShutdown();

  ros::shutdown();
  return 0;
}

tf_example.cpp
    #include <ros/ros.h>
    #include <tf/transform_listener.h>
    #include <find_object_2d/ObjectsStamped.h>
    #include <geometry_msgs/PoseStamped.h>
    #include <QtCore/QString>
    
    class TfExample
    {
    public:
        TfExample() :
            objFramePrefix_("object")
        {
            ros::NodeHandle pnh("~");
            pnh.param("target_frame_id", targetFrameId_, targetFrameId_);
            pnh.param("object_prefix", objFramePrefix_, objFramePrefix_);
            
            ros::NodeHandle nh;
            subs_ = nh.subscribe("objectsStamped", 1, &TfExample::objectsDetectedCallback, this);
            blockPub_ = nh.advertise<geometry_msgs::PoseStamped>("block", 1);
        }

    // Here I synchronize with the ObjectsStamped topic to
    // know when the TF is ready and for which objects
    void objectsDetectedCallback(const find_object_2d::ObjectsStampedConstPtr & msg)
    {
        if(msg->objects.data.size())
        {
            std::string targetFrameId = targetFrameId_;
            if(targetFrameId.empty())
            {
                targetFrameId = msg->header.frame_id;
            }
            char multiSubId = 'b';
            int previousId = -1;
            for(unsigned int i=0; i<msg->objects.data.size(); i+=12)
            {
                // get data
                int id = (int)msg->objects.data[i];

                QString multiSuffix;
                if(id == previousId)
                {
                    multiSuffix = QString("_") + multiSubId++;
                }
                else
                {
                    multiSubId = 'b';
                }
                previousId = id;

                // "object_1", "object_1_b", "object_1_c", "object_2"
                std::string objectFrameId = QString("%1_%2%3").arg(objFramePrefix_.c_str()).arg(id).arg(multiSuffix).toStdString();

                tf::StampedTransform pose;
                try
                {
                    // Get transformation from "object_#" frame to target frame
                    // The timestamp matches the one sent over TF
                    tfListener_.lookupTransform(targetFrameId, objectFrameId, msg->header.stamp, pose);
                }
                catch(tf::TransformException & ex)
                {
                    ROS_WARN("%s",ex.what());
                    continue;
                }

                // Here "pose" is the position of the object "id" in target frame.
                ROS_INFO("%s [x,y,z] [x,y,z,w] in \"%s\" frame: [%f,%f,%f] [%f,%f,%f,%f]",
                        objectFrameId.c_str(), targetFrameId.c_str(),
                        pose.getOrigin().x(), pose.getOrigin().y(), pose.getOrigin().z(),
                        pose.getRotation().x(), pose.getRotation().y(), pose.getRotation().z(), pose.getRotation().w());

                        geometry_msgs::PoseStamped poseMsg;
                        poseMsg.header.stamp = msg->header.stamp;
                        poseMsg.header.frame_id = objectFrameId;
                        tf::poseTFToMsg(pose, poseMsg.pose);
                        blockPub_.publish(poseMsg);
            }
        }
    }

    private:
    std::string targetFrameId_;
    std::string objFramePrefix_;
    ros::Subscriber subs_;
    tf::TransformListener tfListener_;
    ros::Publisher blockPub_;

     };

    int main(int argc, char * argv[])
    {
    ros::init(argc, argv, "tf_example_node");

    TfExample sync;
    ros::spin();
}

Please help if you know the solution.
Thank you

Originally posted by yo4hi6o on ROS Answers with karma: 71 on 2022-01-16
Post score: 1

A:

I was able to solve myself.
float tx = pose.pose.position.x;
float ty = pose.pose.position.y;

Instead of this, it was here below. I was coding wrong. Therefore, it seems that Move it could not recognize the route.
pose.pose.position.x = msg->pose.position.x;
pose.pose.position.y = msg->pose.position.y;

Originally posted by yo4hi6o with karma: 71 on 2022-01-16
This answer was ACCEPTED on the original site
Post score: 0


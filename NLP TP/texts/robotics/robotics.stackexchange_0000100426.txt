Q:

Rosserial deserialization error when receiving Serial2

I'm very close to getting my robot project working the way I had hope. A summary of the structure is that I have a Raspberry Pi 2 connected to 2 Arduino MEGAs: 1 for motor control and sensor connectivity and another for interfacing with an NMEA0183 marine sensor. I have been able to receive serial data from the sensor separately but when I connect to ROS and rosserial, I get the following error:

Traceback (most recent call last):
File "/opt/ros/melodic/lib/rosserial_python/serial_node.py", line 89, in 
client.run()

File "/opt/ros/melodic/lib/python2.7/dist-packages/rosserial_python/SerialClient.py", line 540, in run
self.callbackstopic_id

File "/opt/ros/melodic/lib/python2.7/dist-packages/rosserial_python/SerialClient.py", line 111, in handlePacket
m.deserialize(data)

File "/home/ubuntu/ros_ws/devel/lib/python2.7/dist-packages/floatbot_msgs/msg/_Float64Stamped.py", line 110, in deserialize
genpy.message.DeserializationError: unpack requires a string argument of length 4

[depth_serial_node-3] process has died [pid 4523, exit code 1, cmd /opt/ros/melodic/lib/rosserial_python/serial_node.py __name:=depth_serial_node __log:=/home/ubuntu/.ros/log/2770e2da-3a91-11ec-9518-0f4138ab90b7/depth_serial_node-3.log].
log file: /home/ubuntu/.ros/log/2770e2da-3a91-11ec-9518-0f4138ab90b7/depth_serial_node-3*.log

Here is the loop() function of my Arduino code:
void loop() {
     nh.spinOnce();

    if (isConnected && !nh.connected()) {
    relayOutput(false);
    } else if (nh.connected()) {
    t.update();
    
    if (Serial2.available()) {
        parser << Serial2.read();
    }
   }
   isConnected = nh.connected();
}

When I remove the parser section (that is read from Serial2), I don't get a crash but of course that means my data is no longer read. The Float64Stamped is a custom message type.

Originally posted by Wes G on ROS Answers with karma: 33 on 2021-10-31
Post score: 0

A:

As usual after spending time working on this and writing a question, I was able to find the right answer and get it working.
In the interest of community knowledge, the problem was that my custom message type used 64 bit data types while the Arduino does not support that. The Raspi decoder was looking for 64 bits but only receiving 32.
I updated the message type to use 32 bit types and the error went away and I was able to load the data I wanted.

Originally posted by Wes G with karma: 33 on 2021-10-31
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by osilva on 2021-10-31:
Glad you found the solution


Q:

A question about AsyncSpinner

Dear all,
I would like to know what would happen withros::AsyncSpinner spinner(0);
Does that mean the callback is still in the same thread as the main program?

Originally posted by ZiyangLI on ROS Answers with karma: 93 on 2015-01-27
Post score: 0

A:

According to the ros::AsyncSpinner Class Reference (from the roscpp API docs):

ros::AsyncSpinner::AsyncSpinner(uint32_t thread_count)
Simple constructor. Uses the global callback queue.
Parameters:
      thread_count: The number of threads to use. A value of 0 means to use the number of processor cores

Edit:

Then the question becomes, what would happens if I use 1?

From the source of AsyncSpinnerImpl::start() (lines 143-167):
void AsyncSpinnerImpl::start()
{
  [..]

  for (uint32_t i = 0; i < thread_count_; ++i)
  {
    threads_.create_thread(boost::bind(&AsyncSpinnerImpl::threadFunc, this));
  }
}

In this, thread_count_ is set in the ctor of AsyncSpinnerImpl to be either equal to the nr of cpus, or to the value passed in via the ctor of AsyncSpinner.

Does that mean the callback is still in the same thread as the main program? will the callback blocks the main loop?

If you specify a thread_count of 1, a single additional thread is created. So no, iiuc, the callback processing should not happen in the 'main loop'.
PS: I would've found it rather odd for a class called AsyncSpinner to return to synchronous behaviour only be changing the nr of threads it uses.
PPS: this is also partly explained in roscpp/Overview/Callbacks and Spinning - Multi-threaded Spinning on the ROS wiki.

Originally posted by gvdhoorn with karma: 86574 on 2015-01-27
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by ZiyangLI on 2015-01-27:
Thank you! Then the question becomes, what would happens if I use 1? Does that mean the callback is still in the same thread as the main program? will the callback blocks the main loop?


Q:

Does ros::Timer::hasPending method actually work?

I used it expecting that it will return true after starting the timer, until the callback get's called (in a one-shot timer). But I turned out to be wrong; the following program will return always false:
#include "ros/ros.h"

void callback(const ros::TimerEvent &event)
{
 ROS_INFO("CB!");
}

int main(int argc, char **argv)
{
 ros::init(argc, argv, "timer_test");

 ros::NodeHandle nh;
 ros::Timer timer = nh.createTimer(ros::Duration(1.0), callback, true);
 ROS_INFO("%d", timer.hasPending());
 ros::spinOnce();
 ROS_INFO("%d", timer.hasPending());
 ros::Duration(0.5).sleep();
 ros::spinOnce();
 ROS_INFO("%d", timer.hasPending());
 ros::Duration(0.5).sleep();
 ros::spinOnce();
 ROS_INFO("%d", timer.hasPending());
 ros::Duration(0.5).sleep();
 ros::spinOnce();
 ROS_INFO("%d", timer.hasPending());
 ros::spinOnce();
}

Am I misunderstanding what the method actually does?
Thanks

Originally posted by jorge on ROS Answers with karma: 2284 on 2017-12-20
Post score: 1

A:

I checked the underlying source code to figure out what hasPending() checks. Here is what  bool TimerManager<T, D, E>::hasPending(int32_t handle) returns:
return info->next_expected <= T::now() || info->waiting_callbacks != 0;

It looks like hasPending() will only return true when a timer event is past due or just about to tick. I assume the code below will print true, CB!, then false.
#include "ros/ros.h"

void callback(const ros::TimerEvent &event)
{
 ROS_INFO("CB!");
}

int main(int argc, char **argv)
{
 ros::init(argc, argv, "timer_test");
 ros::NodeHandle nh;
 ros::Timer timer = nh.createTimer(ros::Duration(1.0), callback, true);
 ros::Duration(2).sleep(); // wait for longer than the timer period
 ROS_INFO(timer.hasPending() ? "true" : "false");
 ros::spinOnce();
 ROS_INFO(timer.hasPending() ? "true" : "false");

}

I hope this helps.

Originally posted by Link with karma: 228 on 2017-12-20
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by jorge on 2017-12-21:
right. but it seems to me that this behavior is neither expected nor useful... so I think we can consider this an issue on Timer class code. @Link, do you agree?


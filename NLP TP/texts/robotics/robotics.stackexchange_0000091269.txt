Q:

ROS2: Running subscriber_lambda and publisher_lambda on different machines (in the same network)

Hello,
I have two machines connected via ethernet cable, configured to be in the same network and they can ping each other successfully. What I would like to know is what would be the necessary steps to run build/examples_rclcpp_minimal_subscriber/subscriber_lambda on one machine and build/examples_rclcpp_minimal_publisher/publisher_lambda on another? I have tried it but the subscriber never gets anything.
Note that I cannot use ros2 run demo_nodes_cpp on one of the machines because it has not been ported yet so that example is not a choice.
Thank you in advance.

Originally posted by nickcage on ROS Answers with karma: 38 on 2019-04-05
Post score: 0

Original comments
Comment by gvdhoorn on 2019-04-05:
@nickcage: I've changed the title of your question slightly so as to better reflect what you are asking.
Comment by gvdhoorn on 2019-04-05:\

Note that I cannot use ros2 run demo_nodes_cpp on one of the machines because it has not been ported yet so that example is not a choice.

what do you mean exactly by this? What hasn't been "ported yet"?
Comment by nickcage on 2019-04-05:
The thing is one of the machines is an ARM of Texas Instruments SoC, the other one is Intel PC. We have got a ros2 workspace from our clients that we are to use on ARM. Actually the talker and listener demos work on ARM when run locally (from two terminals within the same system) but also output a number of 'Failed to load entry point' messages before they start. They work properly afterwards, though. So maybe they can be used but I have not been able to make them work over network.
Comment by gvdhoorn on 2019-04-05:
I'm confused: are you trying to run ARM binaries on an amd64 PC or the other way around?
Edit: O wait, you have an ARM install made available by your client, and have installed ROS2 on an amd64 machine yourself. You're now trying to make those two "see" each other.
Correct?
Comment by nickcage on 2019-04-05:
Yes, that is mostly correct. What I mean by that is that we have also been provided a workspace for the PC but I think it was installed by standard procedure. Both distros are bouncy (on ARM and on PC).
Comment by gvdhoorn on 2019-04-05:
I would at least replace the PC side of this with a proper install, instead of a "reused workspace". Debugging issues with this sw is hard enough without a lot of things being unknown variables.
Comment by nickcage on 2019-04-08:
Hi, thank you for sticking around. Will do that and come back to you with an update.
Comment by nickcage on 2019-04-08:
I can't seem to get ROS2 bouncy from the repos, I always end up having crystal after executing 'printenv ROS_DISTRO'. I followed this tutorial https://index.ros.org/doc/ros2/Installation/Linux-Development-Setup/ and only changed the --rosdistro parameter from crystal to bouncy in "Install dependencies using rosdep" section. However, I still got crystal.
Comment by gvdhoorn on 2019-04-08:
Can you clarify why you want to build ROS2 from source?

Edit: because this is a Xenial system (#q320563).
Comment by nickcage on 2019-04-08:
So, I have now installed ROS2 Bouncy on my Intel Ubuntu 16.04 system and tried running a talker from the board and a listener from the PC, it still doesn't work. Any idea how to proceed?
Comment by nickcage on 2019-04-09:
When I start the talker node on one machine and the listener on the other I can observe Membership Report / Join Group message in wireshark from both machines. Is this ok? However, nothing shows in the listener's terminal.
Comment by nickcage on 2019-04-09:
I have just tried testing over Internet and it works. Not in a local network, though.
Comment by gvdhoorn on 2019-04-09:
It might be good at this point if you could describe your network setup a little.
What does "testing over Internet" mean? Which network interfaces do your hosts have? How are those configured? Which IP addresses do they have? Netmasks? Etc.
Comment by nickcage on 2019-04-10:
Well, I have connected the PC to a wider network (Internet) as well as the ARM. I managed to run talker/listener via ros2 run demo_nodes_cpp and they are communicating. However, when on a point-to-point network it doesn't work. The interfaces are configured to have IPs 192.168.1.100 and 192.168.1.101 and the subnet mask is 255.255.255.0.
Comment by nickcage on 2019-04-11:
I have verified that multicast works using iperf. One machine generates data and sends it to a multicast address and the other machine listens on that address and gets the data.
As I said, when I run the talker and listener examples, both the machines become members of the same multicast group (shown by wireshark) but there simply is no feedback from the machine running listener example.
Comment by gvdhoorn on 2019-04-11:
If it does work when you change your network setup, I would start to suspect the setup when you use the direct cable connection.
Can you please update your question (use the edit button/link) with the pertinent information for both cases (ie: direct and "wider network" IP addresses, netmasks, can they ping each other, etc)? Any firewalls active?
Are both installations using the same RMW implementation (ie: both FastRTPS or something else)?
Comment by gvdhoorn on 2019-07-08:
From your new question (#q327515) I'm guessing you got things to work?
Comment by nickcage on 2019-07-10:
Oh yes, but there is one thing that absolutely needed to be done on both machines and that is the following command:
route add -net 224.0.0.0 netmask 240.0.0.0 dev ethX
This could be written somewhere so people don't have similar problems.
Comment by gvdhoorn on 2019-07-10:
That looks like routing for multicast wasn't / isn't setup correctly on your machine without that.
Comment by nickcage on 2019-07-10:
Yes, it looks like it. You can close this thread, too.
Comment by gvdhoorn on 2019-07-10:
If the added route was what fixed everything in the end you might want to post that as an answer here.
That way it may help future visitors.
Comment by nickcage on 2019-07-10:
Oh, sure, will do.

A:

OP here, actually I have solved this issue. The problem was the routing for multicast was not setup correctly on participating machines. The solution was to run the following command on appropriate eth port on both machines:
route add -net 224.0.0.0 netmask 240.0.0.0 dev ethX

That should enable the node discovery mechanism in a local network.

Originally posted by nickcage with karma: 38 on 2019-07-10
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by ljaniec on 2022-07-20:
This worked for me after adding the gw argument with my gateway's IP and properly renamed ethX under what I got from ifconfig.


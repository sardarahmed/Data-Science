Q:

How to convert slot_types of messages to actual data types

Hi All,
I am currently implementing a little python script that takes parameters for actions from a string and automatically populates an action goal to send it to the action server. The goal obviously defines all the correct message types like string, float64, etc. The problem is, that I read these params from a string that does not necessarily tell me the type, e.g. "30" could be 30, 30.0, or '30', that would depend on the type specified in the goal. I know that for ROS message types like std_msgs/Float64 one can use roslib.message.get_message_class("std_msgs/Float64") to get the correct python class. But for entries like float64 this becomes more complicated. Even using std_msgs/Float64 does not help because that also contains a float64 in the data field. My question is, is there a function to get the python type numpy.float64 from 'float64' in the message definition?
I know there is check_type but that only checks the type to raise an exception but does not return it.
I am on Indigo btw. Here a very small example
def create_goal(str_array):
    g = myactionGoal()
    for s, slot, t in zip(str_array, g.__slots__, g._slot_types):
        t = magic_function_to_get_type_from_string(t)
        setattr(g, slot, t(s))
    return g

EDIT:
One way of achieving this for simple datatypes would be:
def create_goal(str_array):
    g = myactionGoal()
    for s, slot, t in zip(str_array, g.__slots__, g._slot_types):
        t = type(getattr(g, slot)) # Get type of default value
        setattr(g, slot, t(s))
    return g

Because after the creation of the goal message, all the slots are intialised with the correct data type. This however does not work for things like float64[] because that would only tell me that it is supposed to be a list but not the expected type of the elements.
Thanks for your help!

Originally posted by Chrissi on ROS Answers with karma: 1642 on 2016-07-21
Post score: 2

A:

Found a possible solution: pydoc.locate is able to import datatypes based on string descriptors. Most of the basic datatypes in the messages are actually numpy types. Hence, t = locate("numpy."+t) solves most of the problems. string has to be shortened to str and char doesn't exist and has to be replaced by str as well but the rest matches quite well. By just removing [] like t = t.replace("[]","") in case of arrays you can find the type they are supposed to contain.
Still grateful for any other comments or possible solutions though. Just thought I'd share my findings ;)

Originally posted by Chrissi with karma: 1642 on 2016-07-28
This answer was ACCEPTED on the original site
Post score: 0


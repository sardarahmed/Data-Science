Q:

Joint Trajectory Controller with velocity command interface reports success to early

I want to control a manipulator with the Joint Trajectory Controller (JTC) by using the velocity command interface. I am using ros2_control respectively ros2_controllers on the master branch and I have a setup where I use a velocity command interface together with a position and velocity state interface for real hardware.
I am planning a trajectory with MoveIt MotionPlanning of RViz. After hitting Plan & Execute the JTC reports "Goal reached, success!" always far to early although there is still a big position error (e.g. the joint is only making 70% of the way). And when the JTC reports "Goal reached, success!" the line traj_msg_external_point_ptr_.initRT(set_hold_position()); makes the JTC try to hold the wrong position if I understand it correctly.
It seems to me that the sampling of the trajectory is not working properly or rather I have a setup that makes it operate incorrectly. I tried to debug this a little and found that the trajectory, that MoveIt generates, looks okay, at least the desired positions look fine.
I tried to tweak the gains for the JTC in a lot of combinations but it mostly gets worse.
Any idea what could cause such a behavior or what parameter I should tune?
EDIT:
I used PlotJuggler to capture the data of the controller_state to better visualize the problem:

These are my settings for the JTC:
joint_trajectory_controller:
  ros__parameters:
    joints:
      - joint_1
    command_interfaces:
      - velocity
    state_interfaces:
      - position
      - velocity

    state_publish_rate: 50.0 # Defaults to 50
    action_monitor_rate: 20.0 # Defaults to 20

    gains:
      joint_1:
        p: 0.5
        i: 0.0
        d: 0.0
        i_clamp: 0.0
        ff_velocity_scale: 1.0

A:

I found the solution to my problem thanks to introspecting the ~/controller_state topic with PlotJuggler.
The problem was with the joint limits. Lowering the max_velocity and the max_acceleration in the joint_limits.yaml fixed the problem for me. I think the joint limits within my hardware made it impossible to follow the trajectory. Planing a much slower trajectory on the other hand fixed that.


Q:

Rosserial multiple publishers

I'm running a fresh install of Ubuntu 13.04, rosserial, hydro.
Using an arduino uno, the following code works and publishes messages:
#include <ros.h>
#include <std_msgs/Int16.h>

ros::NodeHandle nh;
std_msgs::Int16 ultrasound_msg;
std_msgs::Int16 ir_msg;
ros::Publisher ultrasound_pub("ultrasound", &ultrasound_msg);
ros::Publisher infrared_pub("infrared", &ir_msg);

void setup() {
  // Initialize sensors, etc
    nh.initNode();
    nh.advertise(ultrasound_pub);
    //nh.advertise(infrared_pub);
}

void loop() {
  
  ultrasound_msg.data = 42;
  ultrasound_pub.publish( &ultrasound_msg );
  
  nh.spinOnce();
  delay(1000);
  
}

If I un-comment the second advertise:
void setup() {
  // Initialize sensors, etc
    nh.initNode();
    nh.advertise(ultrasound_pub);
    nh.advertise(infrared_pub);
}

I get 'Creation of publisher failed: unpack requires a string argument of length 4', when I try to start the node on the ROS side.
When I try to initialize only the second publisher:
void setup() {
  // Initialize sensors, etc
    nh.initNode();
    //nh.advertise(ultrasound_pub);
    nh.advertise(infrared_pub);
}

Starting the node says 'Unable to sync with device; possible link problem or link software version mismatch such as hydro rosserial_python with groovy Arduino'
I saw 2 posts with similar problems, solved by updating the rosserial-arduino and rosserial installations.  I have fresh installations from apt-get, so I'm not sure why they'd be mismatched.
Any ideas?
UPDATE
If I replace the second publisher with a subscriber like so:
void ROS_CALLBACK(const std_msgs::Int16 &msg)
{
  // do stuff
}
ros::Publisher ultrasound_pub("ultrasound", &ultrasound_msg);
ros::Subscriber<std_msgs::Int16> sub("arduino_listener", &ROS_CALLBACK);
...
void setup() {
  // Initialize sensors, etc
    nh.initNode();
    nh.advertise(ultrasound_pub);
    nh.subscribe(sub);
}

I get the same errors for the same sequence.  'Failed to unpack' for the code shown below.  'Unable to sync with device' if I advertise subscribe without advertising the publisher.

Originally posted by stebl on ROS Answers with karma: 45 on 2013-10-03
Post score: 1

Original comments
Comment by stebl on 2013-10-04:
Rolling back the rosserial libraries to 0.5.1 provides a workaround.

A:

Fixed in latest rosserial source. New release of rosserial debs coming out in the next few days. See Issue 76 for an explanation of the problem. In a nutshell, an uninitialized data situation was introduced, which caused the upper two bytes of string length to contain random data. The fault was introduced in 0.5.2, which explains why 0.5.1 works.

Originally posted by PaulBouchier with karma: 300 on 2013-10-13
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by stebl on 2013-10-14:
confirmed working :)


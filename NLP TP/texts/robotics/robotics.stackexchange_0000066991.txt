Q:

How to fill up a PointCloud Message with data in Python?

Hey guys,
I want to set up a PointCloud Message in my python main.
I already read the docs: http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud.html
But I don't catch it. This is what I got so far (spread over the different classes):
import rospy
from geometry_msgs.msg import Point
from sensor_msgs.msg import PointCloud

self.stelldaten = self.rospy.Publisher('Stelldaten', PointCloud, queue_size=10)

rospy.init_node('LaserCutter GUI', anonymous=True)

    try:
        rospy.spin()
    except KeyboardInterrupt:
        print "Shutting Down"

I don't understand how to fill up the PointCloud with data. I googled quite a bit, but the most, if not all, examples are for C++. Can somebody enlighten me, please?
edit according to marguedas comment/answer:
I think i got the basic idea, the problem is that the program shuts down without any error which makes debugging quite hard. First of all, let me answer your questions. The points are generated in a Kivy based gui, so I basically got three arrays (one for x, one for y and one for the time - so I am using the z coordinate to transmit information about the time). The information i collect in the x and y vectors are speed values for a stepper motor. To conlude: for each point I have two speed values and one time value. I tryed to use the PointCloud, cause I don't like the way to publish matrices in ROS (at least so far...). The following shows the code i got so far (only the parts important for this specific problem):
import rospy
import std_msgs.msg
from geometry_msgs.msg import Point
from sensor_msgs.msg import PointCloud

class Lasercutter(TabbedPanel):
        def __init__(self, **kwargs):
            super(Lasercutter, self).__init__(**kwargs)

            self.stelldaten = rospy.Publisher('Stelldaten', PointCloud, queue_size=10)
            self.stelldaten_tabelle = PointCloud()
            self.h = std_msgs.msg.Header()
            self.h.stamp = rospy.Time.now()

    def bahnberechnung(self):
        anzahl_punkte = 10 # i got 10 points, for example
        self.stelldaten_tabelle.header = self.h
        self.stelldaten_tabelle.points = anzahl_punkte
        self.stelldaten_tabelle.channels = 3
        point = Point()

        for i in range(0, anzahl_punkte):
            
            point.x = self.q1_v[i]
            point.y = self.q2_v[i]
            point.z = self.tges[i]
            self.stelldaten_tabelle.points[i] = point.x
            self.stelldaten_tabelle.points[i] = point.y
            self.stelldaten_tabelle.points[i] = point.z

        self.stelldaten.publish(self.stelldaten_tabelle)

class TabbedPanelApp(App):

    def build(self):
        # diese Node arbeitet unter folgendem Namen
        rospy.init_node('LaserCutterGUI', anonymous=True)
        return Lasercutter()

if __name__ == '__main__':
    TabbedPanelApp().run()

As I mentioned i get no errors, the program just gets killed (sometimes you can blame it on Kivy, but that doesnt help me to find the problem, right? :D). I get prints until the line : point = Point()
Thanks again for any advice, I really appreciate it!

Originally posted by Holzroller on ROS Answers with karma: 62 on 2015-04-13
Post score: 2

A:

It's more a comment but I publish it as an answer because of the lack of space.
Where does your pointcloud come from? a callback ? What information do you have ? only range or also intensity ?
Steps:

create a PointCloud
fill header: http://answers.ros.org/question/60209/what-is-the-proper-way-to-create-a-header-with-python/ + set a frame_id (link of your depth sensor)
resize pointcloud according to your number of points
fill pointcloud

for i in range(numberOfPoints):
pointcloud.points[i].x = inputPoints[i].x
pointcloud.points[i].y = inputPoints[i].y
pointcloud.points[i].z = inputPoints[i].z

publish the pointcloud

EDIT:
Your current error is due to the fact that you need to resize the channel data structure instead of assigning it a scalar value.
I've never tried to use pointcloud for this kind of purpose. I'm not sure that is the best structure for your application. To my understanding you just need a way to convey tuples of size3. Is that right?
If I was you I would not be using a PointCloud structure but rather something like a Vector3 Array.
You create a custom message which is an array of Vector3
You can check here for custom message generation
you do the following

   self.vectordaten_tabelle = Vector3Array()
   anzahl_punkte = 10 # Assming that you know the size will be 10, otherwise you can check the size of your input arrays
   vec3 = Vector3()

    for i in range(0, anzahl_punkte):
        vec3.x = self.q1_v[i]
        vec3.y = self.q2_v[i]
        vec3.z = self.tges[i]
        self.vectordaten_tabelle.append(vec3)

This way you will endup with a vector array filled with your data without bothering with all the additional fields that would be useless in PoinCloud in your case.
Hope this suits your application,

Originally posted by marguedas with karma: 3606 on 2015-04-13
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by Holzroller on 2015-04-16:
i edited my question accordingly to your answer, can you pls take another look? Thanks :)
Comment by Holzroller on 2015-04-18:
thats right! Ill give it a shot on monday, but your way seems much more appropriate than mine. Thanks so much for your help :)
Comment by Holzroller on 2015-04-20:
Just one more question! I made it pretty far with your excellent explanation! self.vectordaten_tabelle.append(vec3) in that line the programm crushes. My custom message looks like: geometry_msgs/Vector3[] Vector3DArray. Everything else is equivalent to your code above. Any ideas?
Comment by marguedas on 2015-04-22:
my bad, you have to specify the structure you want to add your element to, if your message is geometry_msgs/Vector3[] Vector3DArray
you need to add element to the Vector3DArray array, so:
self.vectordaten_tabelle.Vector3DArray.append(vec3)
Comment by Holzroller on 2015-04-24:
thanks again! you saved me a ton of research! the array gets appended now, but every entry gets overridden with the newest vec3. So my message is an array of vector3() (with anzahl_punkte entrys), but every entry is e.g. x = 0, y = 0, z = 0.5, cause those are the values of the last vec3() i appended
Comment by marguedas on 2015-04-28:
My bad, I haven't tested any of this. You need to create vec3 inside the loop.


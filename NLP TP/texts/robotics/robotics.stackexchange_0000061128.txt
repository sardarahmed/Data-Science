Q:

Pointer image multi-channel access

Using that simple program how can I access to different channels:
void imageCallback(const sensor_msgs::ImageConstPtr& msg)
    {
        
        cv_bridge::CvImagePtr cv_ptr;
        try
        {
            cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);
        }
    
        catch (cv_bridge::Exception& e)
        {
            ROS_ERROR("cv_bridge exception: %s", e.what());
            return;
        }
        
        
        cv::imshow("OpenCV viewer uEye RGB", cv_ptr->image);
        cv::waitKey(3);
    
    }

How can I access to different channel using cv_ptr ?

Originally posted by ROSkinect on ROS Answers with karma: 751 on 2014-07-24
Post score: 0

A:

cv_ptr->image is an instance of cv::Mat (http://docs.opencv.org/modules/core/doc/basic_structures.html#mat). There are serveral ways to access the channels, e. g.:
split up to entire image separate images:
std::vector<cv::Mat> channels;
cv::split( cv_ptr->image, channels );

cv::imshow("OpenCV viewer uEye RGB Blue", channels[0] );
cv::imshow("OpenCV viewer uEye RGB Red", channels[1] );
cv::imshow("OpenCV viewer uEye RGB Green", channels[2] );
cv::waitKey(3);

or access one pixel:
cv::Vec3b rgb_pix = cv_ptr->image.at<cv::Vec3b>( 10, 10 );

ROS_INFO_STREAM( "Blue value at pos 10, 10" << static_cast<int>( rgb_pix[0] ) );
ROS_INFO_STREAM( "Green value at pos 10, 10" << static_cast<int>( rgb_pix[1] ) );
ROS_INFO_STREAM( "Red value at pos 10, 10" << static_cast<int>( rgb_pix[2] ) );

or iterate the entire image, manipulating the pixels
cv::MatIterator_<cv::Vec3b> iter = cv_ptr->image.begin<cv::Vec3b>();
cv::MatIterator_<cv::Vec3b> iter_end = cv_ptr->image.end<cv::Vec3b>();

for ( ; iter != iter_end ; ++iter )
{
   (*iter)[2] = 255; // set red channel to 255, i. e. maxium value, for every pixel
}

 cv::imshow("OpenCV viewer uEye RGB manipulated", cv_ptr->image);
 cv::waitKey(3);

See: http://docs.opencv.org/

Originally posted by Wolf with karma: 7555 on 2014-07-24
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by ROSkinect on 2014-07-24:
ah this is what I'm looking for
std::vector<cv::Mat> channels;
cv::split( cv_ptr->image, channels );
last question how can I combine the 3 channels (after doing some image processing on each channel)
Comment by Wolf on 2014-07-24:
After you have done something with the channels in the channels vector you can assemble them back to the image using cv::merge ........ like: cv::merge( channels, cv_ptr->image );
Comment by ROSkinect on 2014-07-24:
Thank you.
(just add " _ " to cv::MatIterator_<cv::Vec3b>)


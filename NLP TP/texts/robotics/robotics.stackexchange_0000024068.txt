Q:

simulating transfer function with python

I've been trying for quite a while to simulate a transfer function using control library on python but I keep getting the wrong result, does anyone know the reason?
This is what I get:

This is what I want:

This is the transfer function I'm trying to simulate:

Code I used in python (I just assumed that value for K)
s = ctl.tf('s')
K = 180
G1 = (K) * (s+0.1) / s
G2 = (1) / ((s+1)*(s+2)*(s+10))
G3 = G1*G2
t = np.linspace(0, 20, 1000) #Tempo de 0s a 20s
_, y = ctl.impulse_response(G3, t) #calculando a resposta de G1
plt.plot(t,y)
plt.xlabel('Time in seconds')
plt.ylabel('Amplitude')
plt.title('Impulse response')
plt.grid()

A:

Expanding on kucar's excellent answer, you have not modeled the whole system. Looking at the block diagram reduction rules, follow item 4 "Eliminating a Feedback Loop." I'll abbreviate the diagram here:

So you need another step, G4. Since you're using negative feedback, you get
G4 = G3/(1+G3)

which, with your code as-written, gives you the following plot:

Had to scratch my head for a moment as to why this doesn't look like the desired output in your question, and then I realized you're plotting the impulse response instead of the step response. The impulse response is as if you tapped the system with a hammer, and you're seeing the ringing response. The step response is what's shown in your desired output, where the input is a constant value (instead of an impulse).
Using _, y = ctl.step_response(G4, t) with K = 180 gives the following plot:


Q:

OpenCV can't be used in ROS

I have been trouble by opencv problems. I have planed to transport my windows's code into ROS, which I have tested by local video files. I found that ROS doesn't support local video files, until ffmpeg has been installed. And Checking my ubuntu that it had been installed, I find ROS didn't support local video files neither.
I reinstall my ffmpeg and my opencv2.2, which I find my ROS doesn't support opencv unluckily. I test my older packages, such as gencam_cu. It all doesn't work, while it will works very well without opencv, like usb_cam. I think my ROS system maybe disorder. So I reinstall my ROS refer to ROS.
But also it doesn't work. Especially, when uses "cvCaptureFromCAM" it can't get frames information. Try to find the reason for this problem, but I am so disappointed. I have been bored for many days. Could some one give me helps?
Given a example, codes below
Class UsbCamNode {Public :

ros::NodeHandle &node_;
sensor_msgs::Image img_;

std::string video_device_name_;
std::string io_method_name_;
int image_width_, image_height_;
std::string pixel_format_name_;

ros::Time next_time_;
int count_;

IplImage* src;
IplImage* src_canny;
CvCapture* capture;

image_transport::Publisher image_pub;

UsbCamNode(ros::NodeHandle &node):node_(node)
{
    src=NULL;
    capture=NULL;

    image_transport::ImageTransport it(node);

    image_pub=it.advertise("image_raw",1);
    int camera_num=0;
    ros::NodeHandle nh("~");
    nh.getParam("camera_index",camera_num);
    printf("%d",camera_num);
    
    if(NULL==(capture=cvCaptureFromCAM(camera_num)))
    {
        printf("\nError on cvCaptureFromCAM");
    }
    if(NULL==(src=cvQueryFrame(capture)))
    {
        printf("\nError on cvQueryFrame");  
    }

    

    printf("Acquired image (%d/%d%)\n",src->width,src->height);
    printf("Channels (%d)\n",src->nChannels);
    printf("Depth (%d)\n",src->depth);

cvNamedWindow("Capture",CV_WINDOW_AUTOSIZE);
cvNamedWindow("Canny",CV_WINDOW_AUTOSIZE);
cvMoveWindow("Capture",60,70);
next_time_=ros::Time::now();
count_=0;
}

virtual ~UsbCamNode()
{
    cvReleaseCapture(&capture);

    cvDestroyWindow("Capture");
    cvDestroyWindow("Canny");
}

bool take_and_send_image()
{
    int key;
    if(NULL==(src=cvQueryFrame(capture)))
    {   
        printf("\nError on cvQueryFrame");
    }
    else
    {

        cvShowImage("Capture",src);
        src_canny=DoCanny(src);
        cvShowImage("Canny",src_canny);
        key=cvWaitKey(10);

    //fill image message
    fillImage(img_,"mono8",src_canny->height,src_canny->width,src_canny->nChannels*src_canny->width,src_canny->imageData);
    //publish
    image_pub.publish(img_);
    return true;
    }
}

bool spin()
{
    while(node_.ok())
    {   
          if(take_and_send_image())
      {
        count_++;
        ros::Time now_time=ros::Time::now();
        if(now_time>next_time_)
        {   
            std::cout<<count_<<"frames/sec at"<<now_time<<std::endl;
            count_=0;
            next_time_=next_time_+ros::Duration(1,0);
        }
      } else {
        ROS_ERROR("could not take the image");
        usleep(1000000);
        }
    }
    return true;
} };

And it will show the results that:
0
Error on cvCaptureFromCAM
Segmentation fault
More, I find my problems are similar with dkst. I try all my methods as possible as I can think,but I did solve these problems. So call for help here
Thanks.

Originally posted by Yongqiang Gao on ROS Answers with karma: 133 on 2011-06-10
Post score: 0

A:

You should compare the configuration flags that you used on your working version of OpenCV vs. the flags that ROS compiles with. The flags can be found in the opencv2 makefile. For example, I'm guessing cvCaptureFromCAM requires perhaps v4l support or ffmpeg, but those are both turned off by the ROS OpenCV build.
If you do need to add other flags or turn those on, you can check out the vision_opencv stack from source onto your ROS_PACKAGE_PATH, modify the Makefile and recompile the stack.

Originally posted by Eric Perko with karma: 8406 on 2011-06-11
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by Eric Perko on 2011-07-22:
You will need to checkout the vision_opencv stack for your ROS distro from source, get it on your package path and then edit the flags and build. It is not recommend to change the precompiled packages in /opt or you may encounter conflicts later.
Comment by Bruno Normande on 2011-07-22:
on ubuntu, i changed the vision_opencv/opencv2/MakeFile flags 'v4l' and 'ffmpeg' to ON, re-maked the stack with ' rosmake vision_opencv --pre-cleanbut' and cvCaptureFromCAM still returns null for me =/ (maybe it is 'couse my installation - from repository- is pre-compiled?
Comment by Yongqiang Gao on 2011-06-11:
Thanks to Eric, and my process is that i copy "vision_opencv" in ros which can't be recompiled into "~/", then I turn on "ffmpeg" and "v4l", and then I "make" it.  That is right?  Anyway, it is been solved. So happy. Thanks again.


Q:

Does ros::shutdown() also stop all Async spinner threads?

This might be a very basic question but I couldn`t find an exact answer anywhere . Does the ros::shutdown() command also stop all the Async spinner threads automatically?
I have a lot of blocking functions in my main loop so I created a custom SIGINT signal to close the node as such:
void nodeShutdown(int sig)
{
    ROS_INFO("Closing socket connection ...");
    close(client);
    close(s);
    ros::shutdown();
}

This doesnt give me a chance to call stop on the spinner. It works but I`m not sure if this is safe. If there is a better way can someone point me towards it?

Originally posted by ashu on ROS Answers with karma: 17 on 2020-07-29
Post score: 0

A:

Hi @ashu,
If you take a look at the documentation it says: "[...]  and will automatically stop when it is destroyed". Following the code, when you see its destructor here you will see that the spinner is stopped when is destroyed, that is the same to have a ros::shutdown() or SIGINT (Ctrl-C) signal sent since the memory will be freed automatically. And if you do not want to call ros::shutdown() you can call directly the destructor.
However to be more clear, in C++ for instance, by default, most signals cause an immediate, abnormal exit of the program but the particular thing in ROS is that ros::shutdown() is doing all the nasty work for you.
Regards.

Originally posted by Weasfas with karma: 1695 on 2020-08-01
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by ashu on 2020-08-01:
Thank you for the clear explanation. This was very helpful.


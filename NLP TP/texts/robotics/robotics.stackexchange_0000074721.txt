Q:

High CPU usage for AMCL and move_base under namespace

I am trying to run the ROS navigation stack on a turtlebot, with everything under a namespace (in this case, the namespace is robot_0).  The netbook that everything is running on has a dual-core Intel Atom processor with 2GB of RAM, and is running ROS Indigo on Ubuntu 14.04.  Everything is fine when I run the sample navigation launch files that do not use namespaces (i.e. minimal.launch from turtlebot_bringup and amcl_demo.launch from turtlebot_navigation).  In this configuration, move_base uses approximately 22% of one core, and amcl uses under 10% of one core.  Amcl then publishes the transform from the /map frame to the /odom frame at 30Hz, as expected.
However, when I switch to my custom configuration file that has everything running under a namespace, the cpu usage for amcl and for move_base each jump to approximately 80%, pushing the total usage for each core to 100%.  Amcl is only able to publish the transform at around 5Hz, and the most recent transform available from /map to /robot_0/odom (the equivalent of /odom under the namespace) is over 2 seconds old.  I tried the commonly suggested solutions of turning down costmap publishing frequency, and that didn't help (I also don't think it should be necessary because everything runs fine using the default parameters).  The configuration I have causes the following warnings from the costmap:
[ WARN] [1466518518.525473823]: Costmap2DROS transform timeout. Current time: 1466518518.5254, global_pose stamp: 1466518518.0204, tolerance: 0.5000
[ WARN] [1466518518.525571024]: Could not get robot pose, cancelling pose reconfiguration

This warning is published at approximately 2Hz.  If I increase the transform_tolerance on the costmaps to 3.5s (as you can see I did in the configurations I included below), then the warnings become much less frequent, but don't always disappear completely.
However, even if I increase the transform tolerance, I still occasionally get the following warnings:
[ WARN] [1466518719.455966268]: MessageFilter [target=map ]: Dropped 100.00% of messages so far. Please turn the [ros.costmap_2d.message_notifier] rosconsole logger to DEBUG for more information.
[ WARN] [1466518719.713827484]: MessageFilter [target=robot_0/odom ]: Dropped 100.00% of messages so far. Please turn the [ros.costmap_2d.message_notifier] rosconsole logger to DEBUG for more information.

The percentage of messages dropped varies from around 90% to 100%.
And I get errors like the following sporadically whether or not I increase the transform_tolerance:
[ERROR] [1466518772.987647336]: Extrapolation Error looking up robot pose: Lookup would require extrapolation into the past.  Requested time 1466518762.913725848 but the earliest data is at time 1466518762.988183070, when looking up transform from frame [robot_0/base_footprint] to frame [map]

I have assumed that all of these problems are caused by amcl not publishing the transform as quickly as it should because of some performance issue, but I have not come across any differences between my launch configuration and the default that would increase the cpu load.
All of the configuration files are located in the testing branch of the git repository here.  The tf trees are also there, with good_frames being the tf tree when running the default provided configuration, and bad_frames being the tf tree under the namespace.  I have included below all of my launch files and parameter files that I think might be relevant; the main launch file is robot_under_namespace.launch.  If another file might be helpful, I can add it.  Unfortunately I can't just attach them because I don't have enough reputation, so I've pasted their contents here.
robot_under_namespace.launch:
<launch>
    <arg name="robotName1" default="robot_0" />

    <arg name="base"              default="$(env TURTLEBOT_BASE)"         doc="mobile base type [create, roomba]"/>
    <arg name="stacks"            default="$(env TURTLEBOT_STACKS)"       doc="stack type displayed in visualisation/simulation [circles, hexagons]"/>
    <arg name="3d_sensor"         default="$(env TURTLEBOT_3D_SENSOR)"    doc="3d sensor types [kinect, asux_xtion_pro]"/>
    <include file="$(find turtlebot_bringup)/launch/includes/description.launch.xml">
        <arg name="base" value="$(arg base)" />
        <arg name="stacks" value="$(arg stacks)" />
        <arg name="3d_sensor" value="$(arg 3d_sensor)" />
    </include>

    <arg name="map_file" default="$(find navigation_under_namespace)/maps/twoRooms.yaml" />
    <node pkg="map_server" type="map_server" name="map_server" args="$(arg map_file)" respawn="false" >
        <param name="frame_id" value="/map" />
    </node>
    <group ns="robot_0">
        <param name="tf_prefix" value="$(arg robotName1)" />
        <include
            file="$(find navigation_under_namespace)/launch/includes/single_robot_wild.launch">
            <arg name="namespace" value="$(arg robotName1)" />
            <arg name="initial_pose_x" value="0.0" />
            <arg name="initial_pose_y" value="0.0" />
            <arg name="initial_pose_a" value="0.0" />
        </include>
    </group>
</launch>

single_robot_wild.launch:
<launch>
    <arg name="map_file" default="$(find navigation_under_namespace)/maps/twoRooms.yaml" />
    <arg name="base" default="$(optenv TURTLEBOT_BASE kobuki)" />  <!-- create, rhoomba -->
    <arg name="stacks" default="$(optenv TURTLEBOT_STACKS hexagons)" />  <!-- circles, hexagons -->
    <arg name="3d_sensor" default="$(optenv TURTLEBOT_3D_SENSOR kinect)" />  <!-- kinect, asus_xtion_pro -->
    <arg name="custom_param_file" default="$(find turtlebot_navigation)/param/dummy.yaml"/>
    <arg name="central_master_name" default="10.42.0.100"/>
    <!-- <param name="/use_sim_time" value="true" /> -->

    <!-- ***************** Robot Model ***************** -->

<arg name="namespace" default="robot_0"/>
 <arg name="initial_pose_x" default="0"/>
 <arg name="initial_pose_y" default="0"/>
 <arg name="initial_pose_a" default="0"/>
 
 <node pkg="move_base" type="move_base" respawn="false" name="move_base_node" output="screen">
      <remap from="map" to="/map" />
      <param name="controller_frequency" value="10.0" />
      <rosparam file="$(find navigation_under_namespace)/params/move_base_config/costmap_common_params.yaml" command="load" ns="global_costmap" />
      <rosparam file="$(find navigation_under_namespace)/params/move_base_config/costmap_common_params.yaml" command="load" ns="local_costmap" />
      <rosparam file="$(find navigation_under_namespace)/params/move_base_config/local_costmap_params.yaml" command="load" />
      <rosparam file="$(find navigation_under_namespace)/params/move_base_config/global_costmap_params.yaml" command="load" />
      <rosparam file="$(find navigation_under_namespace)/params/move_base_config/base_local_planner_params.yaml" command="load" />
    </node>
    
     <include file="$(find navigation_under_namespace)/launch/includes/amcl.launch">
        <arg name="tf_prefix" value="$(arg namespace)"/>
        <arg name="scan_topic" value="scan" />
        <arg name="use_map_topic" value="true" />
        <arg name="initial_pose_x" value="$(arg initial_pose_x)" />
        <arg name="initial_pose_y" value="$(arg initial_pose_y)" />
        <arg name="initial_pose_a" value="$(arg initial_pose_a)" />
        <arg name="global_frame_id" value="/map"/>
    </include>

    <include file="$(find navigation_under_namespace)/launch/includes/turtlebot_minimal.launch">
        <arg name="base" value="$(arg base)" />
        <arg name="stacks" value="$(arg stacks)" />
        <arg name="3d_sensor" value="$(arg 3d_sensor)" />
        <arg name="namespace" value="$(arg namespace)"/>
    </include>
    <!-- <node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher"> 
        <param name="use_gui" value="true" /> </node> -->
    <include file="$(find navigation_under_namespace)/launch/includes/3dsensor.launch">
        <arg name="namespace" value="$(arg namespace)"/>
        <arg name="rgb_processing" value="false" />
        <arg name="depth_registration" value="false" />
        <arg name="depth_processing" value="false" />
        <arg name="publish_tf" value="true"/>
        
        <arg name="scan_topic" value="scan" />
    </include>
</launch>

amcl.launch:
<launch>
  <arg name="use_map_topic"   default="false"/>
  <arg name="scan_topic"      default="scan"/> 
  <arg name="initial_pose_x"  default="0.0"/>
  <arg name="initial_pose_y"  default="0.0"/>
  <arg name="initial_pose_a"  default="0.0"/>
  <arg name="odom_frame_id"   default="odom"/>
  <arg name="base_frame_id"   default="base_footprint"/>
  <arg name="global_frame_id" default="map"/>
  <arg name="tf_prefix" default="tf_p"/>

  <node pkg="amcl" type="amcl" name="amcl">
    <param name="tf_broadcast" value="true"/>
    <param name="use_map_topic"             value="$(arg use_map_topic)"/>
    <param name="tf_prefix" value="$(arg tf_prefix)"/>
    <!-- Publish scans from best pose at a max of 10 Hz -->
    <param name="odom_model_type"           value="diff"/>
    <param name="odom_alpha5"               value="0.1"/>
    <param name="gui_publish_rate"          value="10.0"/>
    <param name="laser_max_beams"             value="60"/>
    <param name="laser_max_range"           value="12.0"/>
    <param name="min_particles"             value="500"/>
    <param name="max_particles"             value="2000"/>
    <param name="kld_err"                   value="0.05"/>
    <param name="kld_z"                     value="0.99"/>
    <param name="odom_alpha1"               value="0.2"/>
    <param name="odom_alpha2"               value="0.2"/>
    <!-- translation std dev, m -->
    <param name="odom_alpha3"               value="0.2"/>
    <param name="odom_alpha4"               value="0.2"/>
    <param name="laser_z_hit"               value="0.5"/>
    <param name="laser_z_short"             value="0.05"/>
    <param name="laser_z_max"               value="0.05"/>
    <param name="laser_z_rand"              value="0.5"/>
    <param name="laser_sigma_hit"           value="0.2"/>
    <param name="laser_lambda_short"        value="0.1"/>
    <param name="laser_model_type"          value="likelihood_field"/>
    <!-- <param name="laser_model_type" value="beam"/> -->
    <param name="laser_likelihood_max_dist" value="2.0"/>
    <param name="update_min_d"              value="0.25"/>
    <param name="update_min_a"              value="0.2"/>
    <param name="odom_frame_id"             value="$(arg tf_prefix)/$(arg odom_frame_id)"/> 
    <param name="base_frame_id"             value="$(arg tf_prefix)/$(arg base_frame_id)"/> 
    <param name="global_frame_id"           value="$(arg global_frame_id)"/>
    <param name="resample_interval"         value="1"/>
    <!-- Increase tolerance because the computer can get quite busy -->
    <param name="transform_tolerance"       value="1.0"/>
    <param name="recovery_alpha_slow"       value="0.0"/>
    <param name="recovery_alpha_fast"       value="0.0"/>
    <param name="initial_pose_x"            value="$(arg initial_pose_x)"/>
    <param name="initial_pose_y"            value="$(arg initial_pose_y)"/>
    <param name="initial_pose_a"            value="$(arg initial_pose_a)"/>
    <remap from="scan"                      to="$(arg scan_topic)"/>
    <remap from="map" to="/map"/>
  </node>
</launch>

move_base.launch:
<!-- 
    ROS navigation stack with velocity smoother and safety (reactive) controller
-->
<launch>
  <include file="$(find turtlebot_navigation)/launch/includes/velocity_smoother.launch.xml"/>
  <include file="$(find turtlebot_navigation)/launch/includes/safety_controller.launch.xml"/>
  
  <arg name="odom_frame_id"   default="odom"/>
  <arg name="base_frame_id"   default="base_footprint"/>
  <arg name="global_frame_id" default="/map"/>
  <arg name="odom_topic" default="odom" />
  <arg name="laser_topic" default="scan" />
  <arg name="custom_param_file" default="$(find turtlebot_navigation)/param/dummy.yaml"/>

  <node pkg="move_base" type="move_base" respawn="false" name="move_base" output="screen">
    <remap from="map" to="/map" />
    <rosparam file="$(find turtlebot_navigation)/param/costmap_common_params.yaml" command="load" ns="global_costmap" />
    <rosparam file="$(find turtlebot_navigation)/param/costmap_common_params.yaml" command="load" ns="local_costmap" />   
    <rosparam file="$(find turtlebot_navigation)/param/local_costmap_params.yaml" command="load" />   
    <rosparam file="$(find turtlebot_navigation)/param/global_costmap_params.yaml" command="load" />
    <rosparam file="$(find turtlebot_navigation)/param/dwa_local_planner_params.yaml" command="load" />
    <rosparam file="$(find turtlebot_navigation)/param/move_base_params.yaml" command="load" />
    <rosparam file="$(find turtlebot_navigation)/param/global_planner_params.yaml" command="load" />
    <rosparam file="$(find turtlebot_navigation)/param/navfn_global_planner_params.yaml" command="load" />
    <!-- external params file that could be loaded into the move_base namespace -->
    <rosparam file="$(arg custom_param_file)" command="load" />
     
    <!-- reset frame_id parameters using user input data -->
    
    <param name="global_costmap/global_frame" value="$(arg global_frame_id)"/>
    <param name="global_costmap/robot_base_frame" value="$(arg base_frame_id)"/>
    <param name="local_costmap/global_frame" value="$(arg odom_frame_id)"/>
    <param name="local_costmap/robot_base_frame" value="$(arg base_frame_id)"/>
    <param name="DWAPlannerROS/global_frame_id" value="$(arg odom_frame_id)"/>

    <remap from="cmd_vel" to="navigation_velocity_smoother/raw_cmd_vel"/>
    <remap from="odom" to="$(arg odom_topic)"/>
    <remap from="scan" to="$(arg laser_topic)"/>
  </node>
</launch>

costmap_common_params.yaml:
max_obstacle_height: 0.60  # assume something like an arm is mounted on top of the robot

# Obstacle Cost Shaping (http://wiki.ros.org/costmap_2d/hydro/inflation)
robot_radius: 0.20  # distance a circular robot should be clear of the obstacle (kobuki: 0.18)
# footprint: [[x0, y0], [x1, y1], ... [xn, yn]]  # if the robot is not circular

map_type: voxel

obstacle_layer:
  enabled:              true
  max_obstacle_height:  0.6
  origin_z:             0.0
  z_resolution:         0.2
  z_voxels:             2
  unknown_threshold:    15
  mark_threshold:       0
  combination_method:   1
  track_unknown_space:  true    #true needed for disabling global path planning through unknown space
  obstacle_range: 2.5
  raytrace_range: 3.0
  origin_z: 0.0
  z_resolution: 0.2
  z_voxels: 2
  publish_voxel_map: false
  observation_sources:  scan bump
  scan:
    data_type: LaserScan
    topic: scan
    marking: true
    clearing: true
    min_obstacle_height: 0.25
    max_obstacle_height: 0.35
  bump:
    data_type: PointCloud2
    topic: mobile_base/sensors/bumper_pointcloud
    marking: true
    clearing: false
    min_obstacle_height: 0.0
    max_obstacle_height: 0.15
  # for debugging only, let's you see the entire voxel grid

#cost_scaling_factor and inflation_radius were now moved to the inflation_layer ns
inflation_layer:
  enabled:              true
  cost_scaling_factor:  5.0  # exponential rate at which the obstacle cost drops off (default: 10)
  inflation_radius:     0.5  # max. distance from an obstacle at which costs are incurred for planning paths.

static_layer:
  enabled:              true
  

global_costmap_params.yaml:
global_costmap:
   global_frame: /map
   robot_base_frame: base_footprint
   update_frequency: 1.0
   publish_frequency: 0.5
   static_map: true
   transform_tolerance: 3.5
   plugins:
     - {name: static_layer,            type: "costmap_2d::StaticLayer"}
     - {name: obstacle_layer,          type: "costmap_2d::VoxelLayer"}
     - {name: inflation_layer,         type: "costmap_2d::InflationLayer"}

local_costmap_params.yaml:
local_costmap:
   global_frame: odom
   robot_base_frame: base_footprint
   update_frequency: 5.0
   publish_frequency: 2.0
   static_map: false
   rolling_window: true
   width: 4.0
   height: 4.0
   resolution: 0.05
   transform_tolerance: 3.5
   plugins:
    - {name: obstacle_layer,      type: "costmap_2d::VoxelLayer"}
    - {name: inflation_layer,     type: "costmap_2d::InflationLayer"}

move_base_params.yaml:
# Move base node parameters. For full documentation of the parameters in this file, please see
#
#  http://www.ros.org/wiki/move_base
#
shutdown_costmaps: false

controller_frequency: 5.0
controller_patience: 3.0

planner_frequency: 1.0
planner_patience: 5.0

oscillation_timeout: 10.0
oscillation_distance: 0.2

# local planner - default is trajectory rollout
base_local_planner: "dwa_local_planner/DWAPlannerROS"

base_global_planner: "navfn/NavfnROS" #alternatives: global_planner/GlobalPlanner, carrot_planner/CarrotPlanner

#We plan to integrate recovery behaviors for turtlebot but currently those belong to gopher and still have to be adapted.
## recovery behaviors; we avoid spinning, but we need a fall-back replanning
#recovery_behavior_enabled: true

#recovery_behaviors:
  #- name: 'super_conservative_reset1'
    #type: 'clear_costmap_recovery/ClearCostmapRecovery'
  #- name: 'conservative_reset1'
    #type: 'clear_costmap_recovery/ClearCostmapRecovery'
  #- name: 'aggressive_reset1'
    #type: 'clear_costmap_recovery/ClearCostmapRecovery'
  #- name: 'clearing_rotation1'
    #type: 'rotate_recovery/RotateRecovery'
  #- name: 'super_conservative_reset2'
    #type: 'clear_costmap_recovery/ClearCostmapRecovery'
  #- name: 'conservative_reset2'
    #type: 'clear_costmap_recovery/ClearCostmapRecovery'
  #- name: 'aggressive_reset2'
    #type: 'clear_costmap_recovery/ClearCostmapRecovery'
  #- name: 'clearing_rotation2'
    #type: 'rotate_recovery/RotateRecovery'

#super_conservative_reset1:
  #reset_distance: 3.0
#conservative_reset1:
  #reset_distance: 1.5
#aggressive_reset1:
  #reset_distance: 0.0
#super_conservative_reset2:
  #reset_distance: 3.0
#conservative_reset2:
  #reset_distance: 1.5
#aggressive_reset2:
  #reset_distance: 0.0

Originally posted by amiller27 on ROS Answers with karma: 23 on 2016-06-21
Post score: 2

A:

The problem was that you had a circle in your tf tree.
I found it out by running roswtf - it informed me that there are cycles and that both robot_state_publisher and camera_base_link are publishing same transforms.
After changing the parameter publish_tf of 3dsensor.launch to false, the circularity was removed and the problem is not there anymore.

Originally posted by gavran with karma: 526 on 2017-03-10
This answer was ACCEPTED on the original site
Post score: 1


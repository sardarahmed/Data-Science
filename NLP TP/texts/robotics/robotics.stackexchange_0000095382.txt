Q:

Segmentation Fault with SendingGoal Client and actionlib

I'm using Melodic, Ubuntu 18.04 and  I'm trying to run a sample code for a basic C++ SimpleActionClient, it compiles correctly but when I run it I immediately get:
rosrun beginner_tutorials send_goal
Segmentation fault (core dumped)

the line that generates the error is this one:
  actionlib::SimpleActionClient<beginner_tutorials::PointAction> ac("planner", true);

and I cannot understand the reason since it is the same used in the tutorial.
This is my code:
#include <ros/ros.h>
#include <actionlib/client/simple_action_client.h>
#include <actionlib/client/terminal_state.h>
#include <beginner_tutorials/PointAction.h>

    int main (int argc, char **argv)
    {
      ros::init(argc, argv, "planner");
      
      // create the action client
      // true causes the client to spin its own thread
      actionlib::SimpleActionClient<beginner_tutorials::PointAction> ac("planner", true);
      ROS_INFO("Waiting for action server to start.");
      // wait for the action server to start
      ac.waitForServer(); //will wait for infinite time
    
      ROS_INFO("Action server started, sending goal.");
      // send a goal to the action
      beginner_tutorials::PointGoal goal;
      goal.x = 20;
      ac.sendGoal(goal);
    
      //wait for the action to return
      bool finished_before_timeout = ac.waitForResult(ros::Duration(30.0));
    
      if (finished_before_timeout)
      {
        actionlib::SimpleClientGoalState state = ac.getState();
        ROS_INFO("Action finished: %s",state.toString().c_str());
      }
      else
        ROS_INFO("Action did not finish before the time out.");
    
      //exit
      return 0;
    }

Why the segmentation fault is generated and how can I solve it?
Thank you!
EDIT 1:
I compiled the code in DEBUG mode by using catkin_make:
catkin_make -DCMAKE_BUILD_TYPE=Debug

and then I run gdb in this way:
rosrun --prefix 'gdb --args' beginner_tutorials send_goal 
GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /home/isola/catkin_ws/devel/lib/beginner_tutorials/send_goal...done.
(gdb) run
Starting program: /home/isola/catkin_ws/devel/lib/beginner_tutorials/send_goal 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
[New Thread 0x7ffff1418700 (LWP 39204)]
[New Thread 0x7ffff0c17700 (LWP 39205)]
[New Thread 0x7fffebfff700 (LWP 39206)]
[New Thread 0x7fffeb7fe700 (LWP 39207)]
[New Thread 0x7fffeaffd700 (LWP 39208)]

Thread 6 "send_goal" received signal SIGSEGV, Segmentation fault.
[Switching to Thread 0x7fffeaffd700 (LWP 39208)]
0x00007ffff6a9af63 in ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
(gdb) 

but it says the send_goal generates a SIGSEGV which is something we already know.
How can I go deeper into the problem?
This is what happens if I set a breakpoint:
(gdb) break SimpleActionClient
Breakpoint 1 at 0x8c4ae: file /opt/ros/melodic/include/actionlib/client/simple_action_client.h, line 93.
(gdb) run
Starting program: /home/isola/catkin_ws/devel/lib/beginner_tutorials/send_goal 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, actionlib::SimpleActionClient<beginner_tutorials::PointAction_<std::allocator<void> > >::SimpleActionClient (this=0x7fffffffd780, name="planner", 
    spin_thread=true) at /opt/ros/melodic/include/actionlib/client/simple_action_client.h:93
93    SimpleActionClient(const std::string & name, bool spin_thread = true)
(gdb) continue
Continuing.
[New Thread 0x7ffff1418700 (LWP 39269)]
[New Thread 0x7ffff0c17700 (LWP 39270)]
[New Thread 0x7fffebfff700 (LWP 39271)]
[New Thread 0x7fffeb7fe700 (LWP 39272)]
[New Thread 0x7fffeaffd700 (LWP 39273)]

Thread 6 "send_goal" received signal SIGSEGV, Segmentation fault.
[Switching to Thread 0x7fffeaffd700 (LWP 39273)]
0x00007ffff6a9af63 in ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
(gdb)

EDIT2:
This is the output of ldd on the working system:
 ldd devel/lib/beginner_tutorials/send_goal 
    linux-vdso.so.1 (0x00007ffc8c9fb000)
    libactionlib.so => /opt/ros/melodic/lib/libactionlib.so (0x00007f5f96089000)
    libroscpp.so => /opt/ros/melodic/lib/libroscpp.so (0x00007f5f95cf5000)
    librosconsole.so => /opt/ros/melodic/lib/librosconsole.so (0x00007f5f95abf000)
    libroscpp_serialization.so => /opt/ros/melodic/lib/libroscpp_serialization.so (0x00007f5f958bc000)
    librostime.so => /opt/ros/melodic/lib/librostime.so (0x00007f5f9569c000)
    libboost_system.so.1.65.1 => /usr/lib/x86_64-linux-gnu/libboost_system.so.1.65.1 (0x00007f5f95497000)
    libboost_thread.so.1.65.1 => /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.65.1 (0x00007f5f95272000)
    libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f5f95053000)
    libstdc++.so.6 => /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f5f94cca000)
    libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f5f94ab2000)
    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5f946c1000)
    libxmlrpcpp.so => /opt/ros/melodic/lib/libxmlrpcpp.so (0x00007f5f944a2000)
    libcpp_common.so => /opt/ros/melodic/lib/libcpp_common.so (0x00007f5f94297000)
    libboost_chrono.so.1.65.1 => /usr/lib/x86_64-linux-gnu/libboost_chrono.so.1.65.1 (0x00007f5f94092000)
    libboost_filesystem.so.1.65.1 => /usr/lib/x86_64-linux-gnu/libboost_filesystem.so.1.65.1 (0x00007f5f93e78000)
    libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f5f93ada000)
    librosconsole_log4cxx.so => /opt/ros/melodic/lib/librosconsole_log4cxx.so (0x00007f5f938bf000)
    librosconsole_backend_interface.so => /opt/ros/melodic/lib/librosconsole_backend_interface.so (0x00007f5f936bd000)
    liblog4cxx.so.10 => /usr/lib/x86_64-linux-gnu/liblog4cxx.so.10 (0x00007f5f932f4000)
    libboost_regex.so.1.65.1 => /usr/lib/x86_64-linux-gnu/libboost_regex.so.1.65.1 (0x00007f5f92fec000)
    librt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007f5f92de4000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f5f9658e000)
    libconsole_bridge.so.0.4 => /usr/lib/x86_64-linux-gnu/libconsole_bridge.so.0.4 (0x00007f5f92bdf000)
    libapr-1.so.0 => /usr/lib/x86_64-linux-gnu/libapr-1.so.0 (0x00007f5f929aa000)
    libaprutil-1.so.0 => /usr/lib/x86_64-linux-gnu/libaprutil-1.so.0 (0x00007f5f9277f000)
    libicui18n.so.60 => /usr/lib/x86_64-linux-gnu/libicui18n.so.60 (0x00007f5f922de000)
    libicuuc.so.60 => /usr/lib/x86_64-linux-gnu/libicuuc.so.60 (0x00007f5f91f26000)
    libuuid.so.1 => /lib/x86_64-linux-gnu/libuuid.so.1 (0x00007f5f91d1f000)
    libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f5f91b1b000)
    libcrypt.so.1 => /lib/x86_64-linux-gnu/libcrypt.so.1 (0x00007f5f918e3000)
    libexpat.so.1 => /lib/x86_64-linux-gnu/libexpat.so.1 (0x00007f5f916b1000)
    libicudata.so.60 => /usr/lib/x86_64-linux-gnu/libicudata.so.60 (0x00007f5f8fb08000)

and this is the output omn the system which generates the SIGSEGV:
ldd /home/isola/catkin_ws/devel/lib/beginner_tutorials/send_goal 
    linux-vdso.so.1 (0x00007ffdcb33b000)
    libactionlib.so => /opt/ros/melodic/lib/libactionlib.so (0x00007f920c742000)
    libroscpp.so => /opt/ros/melodic/lib/libroscpp.so (0x00007f920c3a5000)
    librosconsole.so => /opt/ros/melodic/lib/librosconsole.so (0x00007f920c16f000)
    libroscpp_serialization.so => /opt/ros/melodic/lib/libroscpp_serialization.so (0x00007f920bf6c000)
    librostime.so => /opt/ros/melodic/lib/librostime.so (0x00007f920bd4c000)
    libboost_thread.so.1.65.1 => /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.65.1 (0x00007f920bb27000)
    libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f920b908000)
    libstdc++.so.6 => /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f920b57f000)
    libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f920b367000)
    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f920af76000)
    libboost_system.so.1.65.1 => /usr/lib/x86_64-linux-gnu/libboost_system.so.1.65.1 (0x00007f920ad71000)
    libxmlrpcpp.so => /opt/ros/melodic/lib/libxmlrpcpp.so (0x00007f920ab53000)
    libcpp_common.so => /opt/ros/melodic/lib/libcpp_common.so (0x00007f920a948000)
    libboost_chrono.so.1.65.1 => /usr/lib/x86_64-linux-gnu/libboost_chrono.so.1.65.1 (0x00007f920a743000)
    libboost_filesystem.so.1.65.1 => /usr/lib/x86_64-linux-gnu/libboost_filesystem.so.1.65.1 (0x00007f920a529000)
    libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f920a18b000)
    librosconsole_log4cxx.so => /opt/ros/melodic/lib/librosconsole_log4cxx.so (0x00007f9209f70000)
    librosconsole_backend_interface.so => /opt/ros/melodic/lib/librosconsole_backend_interface.so (0x00007f9209d6e000)
    liblog4cxx.so.10 => /usr/lib/x86_64-linux-gnu/liblog4cxx.so.10 (0x00007f92099a5000)
    libboost_regex.so.1.65.1 => /usr/lib/x86_64-linux-gnu/libboost_regex.so.1.65.1 (0x00007f920969d000)
    librt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007f9209495000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f920cc47000)
    libconsole_bridge.so.0.4 => /usr/lib/x86_64-linux-gnu/libconsole_bridge.so.0.4 (0x00007f9209290000)
    libapr-1.so.0 => /usr/lib/x86_64-linux-gnu/libapr-1.so.0 (0x00007f920905b000)
    libaprutil-1.so.0 => /usr/lib/x86_64-linux-gnu/libaprutil-1.so.0 (0x00007f9208e30000)
    libicui18n.so.60 => /usr/lib/x86_64-linux-gnu/libicui18n.so.60 (0x00007f920898f000)
    libicuuc.so.60 => /usr/lib/x86_64-linux-gnu/libicuuc.so.60 (0x00007f92085d7000)
    libuuid.so.1 => /lib/x86_64-linux-gnu/libuuid.so.1 (0x00007f92083d0000)
    libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f92081cc000)
    libcrypt.so.1 => /lib/x86_64-linux-gnu/libcrypt.so.1 (0x00007f9207f94000)
    libexpat.so.1 => /lib/x86_64-linux-gnu/libexpat.so.1 (0x00007f9207d62000)
    libicudata.so.60 => /usr/lib/x86_64-linux-gnu/libicudata.so.60 (0x00007f92061b9000)

EDIT3:
This is the backtrace from the machine with the error:
(gdb) run
Starting program: /home/isola/catkin_ws/devel/lib/beginner_tutorials/send_goal 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
[New Thread 0x7ffff1418700 (LWP 41427)]
[New Thread 0x7ffff0c17700 (LWP 41428)]
[New Thread 0x7fffebfff700 (LWP 41429)]
[New Thread 0x7fffeb7fe700 (LWP 41430)]
[New Thread 0x7fffeaffd700 (LWP 41431)]

Thread 6 "send_goal" received signal SIGSEGV, Segmentation fault.
[Switching to Thread 0x7fffeaffd700 (LWP 41431)]
0x00007ffff6a9af63 in ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
(gdb) bt
#0  0x00007ffff6a9af63 in ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
#1  0x00007ffff6faa69c in boost::detail::add_new_tss_node(void const*, boost::shared_ptr<boost::detail::tss_cleanup_function>, void*) ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.65.1
#2  0x00007ffff6fab5cc in boost::detail::set_tss_data(void const*, boost::shared_ptr<boost::detail::tss_cleanup_function>, void*, bool) ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.65.1
#3  0x00007ffff7905216 in ros::CallbackQueue::setupTLS() () from /opt/ros/melodic/lib/libroscpp.so
#4  0x00007ffff7907f3f in ros::CallbackQueue::callAvailable(ros::WallDuration) () from /opt/ros/melodic/lib/libroscpp.so
#5  0x00005555555eaa2f in actionlib::SimpleActionClient<beginner_tutorials::PointAction_<std::allocator<void> > >::spinThread (this=0x7fffffffd780)
    at /opt/ros/melodic/include/actionlib/client/simple_action_client.h:297
#6  0x000055555560fb75 in boost::_mfi::mf0<void, actionlib::SimpleActionClient<beginner_tutorials::PointAction_<std::allocator<void> > > >::operator() (
    this=0x555555862dc8, p=0x7fffffffd780) at /usr/include/boost/bind/mem_fn_template.hpp:49
#7  0x000055555560f1fd in boost::_bi::list1<boost::_bi::value<actionlib::SimpleActionClient<beginner_tutorials::PointAction_<std::allocator<void> > >*> >::operator()<boost::_mfi::mf0<void, actionlib::SimpleActionClient<beginner_tutorials::PointAction_<std::allocator<void> > > >, boost::_bi::list0> (this=0x555555862dd8, f=..., a=...)
    at /usr/include/boost/bind/bind.hpp:259
#8  0x000055555560e5c0 in boost::_bi::bind_t<void, boost::_mfi::mf0<void, actionlib::SimpleActionClient<beginner_tutorials::PointAction_<std::allocator<void> > > >, boost::_bi::list1<boost::_bi::value<actionlib::SimpleActionClient<beginner_tutorials::PointAction_<std::allocator<void> > >*> > >::operator() (this=0x555555862dc8)
    at /usr/include/boost/bind/bind.hpp:1294
#9  0x000055555560cea0 in boost::detail::thread_data<boost::_bi::bind_t<void, boost::_mfi::mf0<void, actionlib::SimpleActionClient<beginner_tutorials::PointAction_<std::allocator<void> > > >, boost::_bi::list1<boost::_bi::value<actionlib::SimpleActionClient<beginner_tutorials::PointAction_<std::allocator<void> > >*> > > >::run (
    this=0x555555862c90) at /usr/include/boost/thread/detail/thread.hpp:120
#10 0x00007ffff6faabcd in ?? () from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.65.1
#11 0x00007ffff6d816db in start_thread (arg=0x7fffeaffd700) at pthread_create.c:463
#12 0x00007ffff650988f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95

Originally posted by Marcus Barnet on ROS Answers with karma: 287 on 2020-04-09
Post score: 0

Original comments
Comment by gvdhoorn on 2020-04-10:
Make sure you have no outstanding updates on ROS packages, and after you've made sure, completely clean your workspace (ie: catkin clean -y when using catkin_tools, or rm -rf devel build install in the root of your catkin_ws when using catkin_make), then rebuild your workspace.
Unexplainable SEGFAULTs can sometimes be caused by binary incompatibilities.
Comment by Marcus Barnet on 2020-04-10:
I got always the same error! Nothing changed! is anything else I can check to understand why I get that error?
Comment by gvdhoorn on 2020-04-10:
As always with SEGFAULTs: build everything in Debug mode and run the binary in gdb (or use the equivalent functionality of your IDE, if you're using one).
Comment by Marcus Barnet on 2020-04-10:
I followed your suggestion on this #q200155 and I tried to use gdb, but this didn't add useful information to my problem since it only says that there is a SIGSEGV error. I added the output of gdb in my first post.
Comment by gvdhoorn on 2020-04-10:
You'll need to ask gdb to print a backtrace for you. After you get the prompt, enter bt and then press enter.
Note: it's not going to magically solve things for you. It'll only provide you more information on where the SEGFAULT happens. It'll still be up to you to figure out what is going on then.
Comment by Marcus Barnet on 2020-04-11:
I found out that it is not a code error since I'm able to correctly build and run the same node on another computer with same Ubuntu version and ROS. How is it possible?
Comment by gvdhoorn on 2020-04-11:
My guess would still be an ABI issue, due to ABI incompatibilities between packages you have installed on the machine it crashes on.
Note that initially I only thought about deb packages, but it could really also be anything you've installed on your machine.
Did you ever build anything from source? A Boost version perhaps (installed in /usr/local)? Or something a driver for some piece of hw installed? Do you happen to have any custom versions of ROS packages in your workspace?
If those get linked in before the one the default ROS packages link to, SEGFAULTs are almost bound to happen.
You could compare the output of ldd /path/to/your/crashing/binary on both the machine on which it crashes, adn the one on which it doesn't.
Comment by Marcus Barnet on 2020-04-11:
I've added the outputs of the ldd command on both systems. It seems that the Boost version is the same on both the machines.
Comment by gvdhoorn on 2020-04-11:
Looks identical. Have you tried getting a backtrace from gdb?
Comment by Marcus Barnet on 2020-04-11:
I added the backtrace output from gdb, it seems something related to the pointer, thread and libboost, but it's the same code and library version used on the second machine.
Comment by Marcus Barnet on 2020-04-11:
If I set  false in  actionlib::SimpleActionClient<beginner_tutorials::PointAction> ac("planner", false); then the program doesn't give the SIGSEGV on the machine with the problem. This is very strange!
Comment by Marcus Barnet on 2020-04-12:
I was thinking: could it be that the problem is the virtual machine? The system where the SIGSEGV is generated is installed on a Virtual Machine, the host machine is Windows, while the system where the node works fine is Ubuntu stand alone, no virtualization. EDIT: the problem is surely related to threading and boost libraries.
Comment by Marcus Barnet on 2020-04-12:
@gvdhoorn: you had reason, I went deeper in my system and I found out that on November 2019, I installed libboost 1.71 from source! There are two versions in my system, if I run cat /usr/include/boost/version.hpp | grep "BOOST_LIB_VERSION" -> BOOST_LIB_VERSION "1_71" while dpkg -s libboost-dev | grep 'Version' -> Version: 1.65.1.0ubuntu1. May be, the catkin_make compiles the code with the 1.71 version while ROS uses the 1.65.1 version. What do you think?

A:

I solved it. The problem was related to libboost-dev version since there were two library versions installed in the system. I removed the version 1.71 and I reinstalled ROS from apt-get and this solved the issue. Now the code works fine also with the emulated Ubuntu system.

Originally posted by Marcus Barnet with karma: 287 on 2020-04-12
This answer was ACCEPTED on the original site
Post score: 0


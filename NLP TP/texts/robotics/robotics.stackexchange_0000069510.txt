Q:

Catkin Tools: How to include source file from another package?

[Ubuntu 14.04, ROS Hydro, Catkin Tools]
I have a number of packages in my source tree and  catkin_make successfully builds all of them, but takes a long time.  So whilst I'm continuing with my developments, I'm using catkin build instead.
The package I'm trying to build with catkin tools (package3) has a couple dependencies (package1 & package2) which are successfully built.  package3 itself, however, fails because the ${package2_SOURCE_DIR} variable returns an empty string and the source file I need from package2 can't be located.  The associated header files are found successfully because ${package2_INCLUDE_DIR} mentions the correct path (along with a number of other paths). I'm not sure why _INCLUDE_DIR is working, but _SOURCE_DIR isn't.
What I've discovered is that under catkin_make, CMake variables are global across the whole build. (Though this might not be an entirely correct statement.)  Under catkin build, package variables are kept local (even when I use find_package(package2)).
I would like to avoid hard coding an absolute path into my add_executable() statement, but I don't know how to get the <package_name>_SOURCE_DIR for package2.  My add_executable() statement, which works with catkin_make is:
add_executable(programA
    /src/programA.cpp
    ${Package2_SOURCE_DIR}/src/common.cpp
)

Is there a variable I can use that points to the catkin workspace?  I don't mind using a line like:
${catkin_ws_BASE_DIR}/src/package2/src/common.cpp

Anyone able to help me solve this in an elegant way?
Cheers,
Nap

Originally posted by Nap on ROS Answers with karma: 302 on 2015-09-07
Post score: 1

Original comments
Comment by Felix Duvallet on 2015-09-07:
Have you tried ${Package2_DIR} (note: not SOURCE_DIR)?
Comment by Nap on 2015-09-07:
${package2_DIR} returns: "/home/me/catkin_ws/devel/share/package2/cmake"

A:

Anyone able to help me solve this in an elegant way?

Do you have a reason for wanting to directly include src files from package2 into programA?
We normally (not just in ROS / with catkin) solve these kind of things by creating a library in package2, making sure package2/include is on the include path of whatever pkg programA is in, and then linking libpkg2 to programA.
I would consider using libraries like this an elegant way.

Edit:

Whilst your suggestion is fine, it's not the way we handle this kind of situation in our Lab, when using our own build system. Catkin/CMake is not our preferred tool chain. With that in mind, I prefer to reference it in the other package than create a duplicate.

Well, I must say that I wouldn't put recompiling source files for every target under elegant, but just to answer your question:
it would appear the variable <pkg_name>_SOURCE_PREFIX contains the path your are looking for. I haven't used this myself, and afaict it is undocumented (which means it may stop working / be removed at any time), but it should get you what you are after. Note that you must've find_package(..) the pkg first, or have included it in a find_package(catkin .. COMPONENTS ..) call.

Originally posted by gvdhoorn with karma: 86574 on 2015-09-07
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by Nap on 2015-09-07:
Thanks gvdhoorn. Whilst your suggestion is fine, it's not the way we handle this kind of situation in our Lab, when using our own build system.  Catkin/CMake is not our preferred tool chain.   With that in mind, I prefer to reference it in the other package than create a duplicate.
Comment by Nap on 2015-09-07:
Thanks, <pkg_name>_SOURCE_PREFIX worked.
Would you be so kind as to provide a link to the page where you found that info?
Comment by gvdhoorn on 2015-09-07:
As I said, the variable is undocumented. I found it by searching a devel and build space.
What you are doing is also really not recommended (it's brittle). See catkin_tools/issues/83 for some discussion and also an alternative.
Comment by Dirk Thomas on 2015-09-07:
A package A should never depend on the source directory of package B. E.g. you won't be able to release these packages because B has been built and installed and afterwards the source folder has been removed before A is being compiled.
Comment by Dirk Thomas on 2015-09-07:
As @gvdhoorn suggested you should either build a library and install the headers or if you really don't want to do that install the source files and compile them in the downstream packages.


Q:

What is the difference between StringConstPtr and String::ConstPtr?

I just would like to know the difference between those two pointers and when to use one or another. or are the same thing?
Sorry for the trivial question.

Originally posted by eliocon on ROS Answers with karma: 33 on 2021-05-12
Post score: 2

A:

I'll give answering this a try:
The long story short is StringConstPtr is just a shortcut  to String::ConstPtr and can be used interchangeably. There may be some implications but I have not found them yet.
For the longer answer we have to look at the relevant code. If you have a strong grasp of cpp you can probably pick out what is going on in the code which looks like this (in ROS1) from std_msgs/String.h:
namespace std_msgs
{
template <class ContainerAllocator>
struct String_
{
  typedef String_<ContainerAllocator> Type;

  String_()
    : data()  {
    }
  String_(const ContainerAllocator& _alloc)
    : data(_alloc)  {
  (void)_alloc;
    }

  typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _data_type;
  _data_type data;

  typedef boost::shared_ptr< ::std_msgs::String_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::std_msgs::String_<ContainerAllocator> const> ConstPtr;

}; // struct String_

typedef ::std_msgs::String_<std::allocator<void> > String;

typedef boost::shared_ptr< ::std_msgs::String > StringPtr;
typedef boost::shared_ptr< ::std_msgs::String const> StringConstPtr;
}

If you don't have a strong grasp on cpp (or at least templating), I will try and explain below.
The following block of code defines the template of a struct that represents our string message. It is templated based on the type of allocator you give it. It internally has some type definitions, constructors, and the storage of our message data (named data in this case).
template <class ContainerAllocator>
struct String_
{
  typedef String_<ContainerAllocator> Type;

  String_()
    : data()  {
    }
  String_(const ContainerAllocator& _alloc)
    : data(_alloc)  {
  (void)_alloc;
    }

  typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _data_type;
  _data_type data;

  typedef boost::shared_ptr< ::std_msgs::String_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::std_msgs::String_<ContainerAllocator> const> ConstPtr;

}; // struct String_

The next line gives that template an allocator of type std::allocator<void> and allows you to access the resulting struct through the type String. Note that internally the struct gives us the Ptr and ConstPtr type. Combined this gives us the String::Ptr and String::ConstPtr types.
typedef ::std_msgs::String_<std::allocator<void> > String;

The final two lines are essentially the shortcuts. They are redundant to the types defined in the struct.
typedef boost::shared_ptr< ::std_msgs::String > StringPtr;
typedef boost::shared_ptr< ::std_msgs::String const> StringConstPtr;

It should be noted that ALL of these are creating the message using the default allocator std::allocator. It is possible to create custom allocators but that is probably beyond the scope of this question.

Originally posted by djchopp with karma: 328 on 2021-05-27
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by eliocon on 2021-05-27:
Excellent! thanks very much for the answer. I think I will have to improve my knowledge about cpp templating.


Q:

DWB Controller struggles with navigation in tight scenarios

Hello again, some of you may remember me from my planner troubles.  I'm running ROS2 Galactic on Ubuntu 20.04, attempting to use the SmacPlannerHybrid planner and DWB Controller to navigate some unusual constraints, such as our tight (barn) environment and elongated differential robot.
In the other question, I talk about situations where the planner has trouble making paths through certain places. When the planner does produce a valid path, the DWB controller acts very strangely when executing it. Here's an example.
The controller has the robot drive at full speed until it approaches the tight spot, at which point it dramatically slows down except for occasional hard jerks forward,. RVIZ shows these jerks as sudden increases and decreases in the length of the local plan line (in the center of our coffin-shaped robot footprint). These seem to have to do with the arrival of updated plans from the planner. After getting right up to the tight spot, the controller stops entirely until the progress checker aborts navigation.
The strange behavior seems to have to do with the inscribed inflation layer. Here's another example that really highlights that. The article on costmap_2d states that the radius of the inscribed inflation layer is calculated from the footprint we give it. It's the radius of the largest circle that could fit within our footprint. However, it indicates that the controller should only use this region as a place that the center of the robot should never intersect. Instead, this region seems to be getting treated as something the entire perimeter of the robot should never intersect. Of course, the robot will never fit down this narrow lane if that's the case.
In our testing, the robot will happily drive out of the inscribed region, but never in. Furthermore, we can physically move the robot into the inflation layer while navigation is stuck, and as soon as the edge of the robot crosses into the inflation layer, the robot will suddenly pick up to full speed and continue.
Let me know if this tickles any ideas in your minds! I'm willing to bet there's a flaw in my conceptual understandings here. Also, if nothing is obviously wrong - does anyone know how to turn the inscribed region off completely without disabling the inflation layer?
Our controller config:
controller_server:
  ros__parameters:
    use_sim_time: False
    controller_frequency: 20.0
    min_x_velocity_threshold: 0.001
    min_y_velocity_threshold: 0.5
    min_theta_velocity_threshold: 0.001
    failure_tolerance: 5.0 # NOTE: This might be too high and may cause synchronization issues
    odom_topic: "odometry/local"
    progress_checker_plugin: "progress_checker"
    goal_checker_plugins: ["general_goal_checker"] # "precise_goal_checker"
    current_goal_checker: ["general_goal_checker"] # "precise_goal_checker"
    controller_plugins: ["FollowPath"]
    # Progress checker parameters
    progress_checker:
      plugin: "nav2_controller::SimpleProgressChecker"
      required_movement_radius: 0.5
      movement_time_allowance: 30.0
    # Goal checker parameters
    general_goal_checker:
      stateful: True
      plugin: "nav2_controller::SimpleGoalChecker"
      xy_goal_tolerance: 0.35
      yaw_goal_tolerance: 0.25
    FollowPath:
      plugin: "dwb_core::DWBLocalPlanner"
      debug_trajectory_details: True
      min_vel_x: 0.0
      min_vel_y: 0.0
      max_vel_x: 0.15
      max_vel_y: 0.0
      max_vel_theta: 0.6
      min_speed_xy: 0.0
      max_speed_xy: 0.15
      min_speed_theta: 0.0
      # Add high threshold velocity for turtlebot 3 issue.
      # https://github.com/ROBOTIS-GIT/turtlebot3_simulations/issues/75
      acc_lim_x: 2.0
      acc_lim_y: 0.0
      acc_lim_theta: 2.0
      decel_lim_x: -2.0
      decel_lim_y: 0.0
      decel_lim_theta: -2.0
      vx_samples: 20
      vy_samples: 5
      vtheta_samples: 20
      sim_time: 1.7
      linear_granularity: 0.05
      angular_granularity: 0.025
      transform_tolerance: 0.2
      xy_goal_tolerance: 0.35
      trans_stopped_velocity: 0.1
      short_circuit_trajectory_evaluation: True
      stateful: True
      critics: [
          "RotateToGoal",
          # "Oscillation",
          "ObstacleFootprint",
          "GoalAlign",
          "PathAlign",
          "PathDist",
          "GoalDist",
        ]
      RotateToGoal.scale: 32.0
      RotateToGoal.xy_goal_tolerance: 0.35
      RotateToGoal.slowing_factor: 1.0
      RotateToGoal.lookahead_time: 1.0

Originally posted by hermanoid on ROS Answers with karma: 176 on 2022-08-16
Post score: 1

A:

DWB is just an trajectory planner that scores based on objective functions and their relative importance weights. You may need to heavily tune DWB's objective functions (or critics) for a given application and use or not use some of those critics.
For example, you use obstacle footprint and it looks to me like you have set its scale so large that the robot refuses to drive into higher cost areas. It seems to drive out of them fine, but then gets stuck when all of the points on the footprint are out of the high cost areas and then starts to struggle to then make progress.
You can definitely tune yourself into a hole with any of the local trajectory planners, its important to take your time and tune carefully knowing what you're trying to accomplish and making sure each of the critics weights are proportional to how much you care about them relative to each other.

Originally posted by stevemacenski with karma: 8272 on 2022-08-17
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by hermanoid on 2022-08-18:
That does add up with what we've been seeing.  We'll give tuning it a shot.


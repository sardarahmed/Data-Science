Q:

Hector_path_follower interrupted by hector_exploration controller call to service for hector_exploration_planner?

Hello Everyone,
I am running the hector_navigation stack on my robot (icreate2 running create_autonomy) with a Hokuyo UTM 30-LX lidar sensor in a flat-environment using ros indigo. I quickly realized that my robot stops following the path generated by the planner whenever the service from hector_exploration_node is called.
I looked into the source code and realized that the call to this service from hector_exploration_controller is on a 15 second timer, which isn’t enough time for my robot to complete it’s path in most situations. So, I made a small workaround for this by waiting to call the service to the planner until the path_follower reads that it has reached its goal.
While this significantly improves the speed of navigation, there is still a 5-10 second period where the robot is stopped, while the planner generates a path. In an ideal world, this new path would be generated while the robot continues the old path and the robot would be in continuous motion for navigation.
I’ve become stuck looking through the source code because I cannot figure out what part of the planner would interrupt the path_follower. Rviz even shows the path while the planner is running, so shouldn’t the path_follower continue its path during this?
I was wondering if anybody knows what causes the hector_exploration_planner service to stop the path_follower from continuing its previous path and if there is any way for the robot to stay in continuous motion while it explores to optimize map building.
Thanks in advance!

Originally posted by Joseph Dyer on ROS Answers with karma: 31 on 2018-06-27
Post score: 0

A:

After testing some more, I realized that no cmd_vel were being published during the path planning. Looking into hector_exploration controller I realized that ros::timer doesn't multithread by default and that's why the publishing of cmd_vel  was interrupted by the call to the hector_exploration_node. In place of ros::spin(), I used MultiThreadSpinner() to open 2 threads and allow for the timers to run simultaneously. This answers the question as to why the service was interrupting the movement. However, I don't recommend this workaround because the planner node is rather slow in generating a path and it is based on the position of the robot at the instance of the call. Because pose_follower follows a specific line of poses, the robot will return to the beginning of the path, losing all the progress done during the path planning, so far the best way I can think for this to work is using the workaround that I mentioned in the question.

Originally posted by Joseph Dyer with karma: 31 on 2018-06-29
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Joseph Dyer on 2018-06-29:
Just another quick note, move_base from the navigation stack can subscribe to PoseStamped for a target to go to and if the final pose generated on the path is published in this format, move_base will create its own path and should be able to run continuously.


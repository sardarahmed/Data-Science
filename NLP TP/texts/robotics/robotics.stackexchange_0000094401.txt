Q:

cannot find -lMylib

I have two ROS packages. Package A loads the library Mylib, which is a .so file.
package B uses package A with find packages().
Package A compiles without any issues, while package B fails for the reason: cannot find -lMylib.
I don't understand why Mylib is required by package B if Package A loaded it without problems
---EDIT----
These are the Cmake Formats
packageA
cmake_minimum_required(VERSION 2.8.3)
project(PackageA)
set(CMAKE_CXX_COMPILER_ID "--with-cc=/usr/bin/mpicc --with-cxx=/usr/bin/mpicxx -lmpi_cxx")
add_compile_options(-std=c++14)
find_package(Eigen3 REQUIRED)
find_package(catkin REQUIRED COMPONENTS
    roscpp
    moveit_core
    moveit_ros_planning
    moveit_ros_planning_interface
    moveit_msgs
    
    )
catkin_package(
    INCLUDE_DIRS include
    CATKIN_DEPENDS
    message_runtime
    roscpp moveit_msgs moveit_ros_planning
    moveit_ros_planning_interface
    moveit_core
    DEPENDS
    EIGEN3

)
include_directories(
    include
    ${catkin_INCLUDE_DIRS}
    lib
    ${EIGEN3_INCLUDE_DIRS}
)
link_directories(lib/myLibFolder/)
set(MY_LIB_NAME MyLib)

add_library(some_lib src/some_lib.cpp)
target_link_libraries(some_lib ${MY_LIB_NAME} ${catkin_LIBRARIES})

add_library(some_lib_2 src/some_lib_2.cpp)
target_link_libraries(some_lib_2 some_lib ${catkin_LIBRARIES})

add_library(packageA_launcher src/PackageA_launcher.cpp)
target_link_libraries( packageA_launcher some_lib_2 ${catkin_LIBRARIES})

packageB
cmake_minimum_required(VERSION 2.8.3) 
project(PackageB) 
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++14 ") 
find_package(catkin REQUIRED COMPONENTS
    cmake_modules
    PackageA       ) 
find_package(Boost REQUIRED COMPONENTS system) catkin_package(
    INCLUDE_DIRS
    include
    LIBRARIES
    CATKIN_DEPENDS
    DEPENDS
    PackageA)
add_executable(some_PackageB_cpp
    src/some_PackageB_cpp.cpp        )
target_link_libraries(some_PackageB_cpp packageA_launcher  ${catkin_LIBRARIES} ) }

The error comes from package B.Package A compiles.
@mgruhler
How can I say

"hey package B, just link against
everything that package A links
against"?

Originally posted by os on ROS Answers with karma: 7 on 2020-01-15
Post score: 0

Original comments
Comment by mgruhler on 2020-01-16:
just to clarify, MyLib is some third-party (or whatever) compiled library file (.so, so a shared library), that you put into PackageA/lib/myLibFolder, right?
It is not located somewhere outside of PackageA?
Comment by os on 2020-01-16:
@mgruhler Exactly, it's a .so file located inside PackageA

A:

I don't understand why Mylib is required by package B if Package A loaded it without problems

Well, package A doesn't load the shared library Mylib. You specify that whatever you compile in package A should dynamically link to Mylib.so. It is not included in package A in any way.
Now, if you use whatever you compile in package A in package B, you need to tell package B that it needs to link against whatever package A needs to link to as well. You don't have to explicitly do this, you can actually do this as in "hey package B, just link against everything that package A links against", by specifying this correctly in the CMakeLists.txt of package A.
This should explain why it is not working. If you want to know how to make it work, please post a new question and don't forget to include a copy of your CMakeLists.txt, ideally of both packages (and please remove any comments).

Update

How can I say

"hey package B, just link against everything that package A links against"?

You've already done that, via find_package(catkin REQUIRED COMPONENTS ... PackageA) and target_link_libraries(some_PackageB_cpp ${catkin_LIBRARIES}).
You don't have to specify package_A_launcher there explicitely.
Minor note on the CMakeLists.txt of PackageB: you should have PackageA specified as a CATKIN_DEPENDS, not as a DEPEND in the catkin_package macro. Other than that, this one seems fine. (Though I wonder why you use mpicc in packageA, but not in B. Maybe this also has some influence?)
You need to properly specify PackageA, though. I.e. you have to export to catkin/cmake, which libraries you provide from your PackageA. Otherwise, package B cannot find them.
You do this also in the catkin_package call by adding the LIBRARIES and INCLUDE_DIRS sections. See the catkin docs.
As you provide myLib as a compiled .so, you'll have to work around a few things, though.
I'd recommend investigating if there is another way, e.g.

Check, if you can get it from apt (you'll probably have done that, though)
If it is a cmake project, follow the advice from #q246012
If it is something else, you're probably best of by providing a wrapper package for this. Take cob_extern/libntcan as an example on what needs to be done...
you can also do the above within your package, but I'd recommend keeping those two (PackageA and MyLib) separate...

Originally posted by mgruhler with karma: 12390 on 2020-01-16
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by os on 2020-01-16:
Thanks! I Edited the question


Q:

Build Architecture Question

So I have been working on using IRI's segway library to implement a segway driver for ROS, and I have run into a situation where I don't know how to proceed.
IRI is setting up a port of their stuff for ROS, so at this point it is more educational for me.
So, the IRI segway library relies on some of their other libraries.
Here is the dependency Structure:

My ROS Node depends on iri_segway_rmp200.
iri_segway_rmp200 depends on iricomms and iriutils.
iricomms depends on iriutils.

All of the IRI stuff is in SVN and is LGPL licensed, my stuff can be considered MIT.  They are setup to build dynamically linked libraries (.so on linux and .dylib on osx).
The way I see it there are a few ways to approach this setup in ROS: (Maybe there is a 4th, correct setup)

Put a script in rosdep.yaml to (svn co; make; sudo make install) each of the libraries from IRI.

This is good because the libraries are installed and no further configuration is required, but requires root access
Also, they install Find.cmake files in the cmake shared Modules folder, which is nice

Create a ROS pkg for each library and use rosmake to build them, using the svn_checkout.mk make script and patches to build and install them to the pkg dir

This is nice because the libraries are contained in the ros pkg
But, you need to export cpp flags to include and link directories
How do you handle runtime dynamic linking?

Download/Distribute and build the libraries in your ROS pkg and statically link your node to the libraries

Doesn't allow multiple nodes to link to a single source for the libraries (build the libs for each node that uses them)

So here are my questions:

What is the preferred method of build architecture?
How do you handle dynamic linking at runtime? (the .so file is in package A, and how does a binary in package B find it at runtime?)
How can you handle installing and referencing Find.cmake files that libraries have? (use manifext.xml's <depend .../> instead, is my guess)
What if any licensing concerns are there? (patches and static linking, etc)

Sorry if some of these questions are silly, I am still learning these more complicated build systems (rosmake/cmake).
Thanks in advanced!

Originally posted by William on ROS Answers with karma: 17335 on 2011-02-14
Post score: 3

A:

Currently your option #2 is basically the recommended technique.  The manifest provides a way to export the compile and linking flags.
Ken recently put together a Tutorial about Wrapping External Libraries It's a new tutorial and any feedback on clarity etc is always welcomed.
In our review of the build system targeted for E Turtle we are shooting for a solution more like option #1 but that's in progress still.
To answer your specific questions:

Option 2
You can use rpath to set the linking search directories.  (See the Tutorial and examples linked from within)
We don't have a good solution right now.  There are several ways this could be done using exports but we haven't used Find modules yet.
Linking to LGPL code requires changes to the LGPL'd code to be released but not works which are linked against the libraries.  For example glibc is under the LGPL license.

Originally posted by tfoote with karma: 58457 on 2011-02-14
This answer was ACCEPTED on the original site
Post score: 4


Q:

how to include catkin package?

suppose i have directory tree like this :
.
├── .catkin_tools
│   ├── CATKIN_IGNORE
│   ├── profiles
│   │   └── default
│   ├── README
│   └── VERSION
└── src
    ├── pkg_a
    │   ├── CMakeLists.txt
    │   ├── mutiply.cpp
    │   ├── package.xml
    │   └── sumfunc.cpp
    └── pkg_b
        ├── CMakeLists.txt
        ├── main.cpp
        └── package.xml

6 directories, 10 files

how can i edit  CMakeLists.txt So that i can use those file in pkg_a inside pkg_b/main.cpp like  this :
#include <pkg_a/mutiply.cpp>
#include <pkg_a/sumfunc.cpp>
#include <pkg_a/someheader.h>// or maybe this one

int main(void) {
    int sum_result = sum(5,5);
    int muli_result = muti(5,5);
    return 0;
}

NOTE : i already take a look at this recommend but i not quite understand it.
Edit :
after @Weasfas Answer i have create func_terminal.h file in pkg_a and have this tree file :
└── src
    ├── pkg_a
    │   ├── CMakeLists.txt
    │   ├── func_terminal.h
    │   ├── mutiply.cpp
    │   ├── package.xml
    │   └── sumfunc.cpp
    └── pkg_b
        ├── CMakeLists.txt
        ├── main.cpp
        └── package.xml

and add some command in cmakeList.txt in pkg_b : add find package
find_package(catkin REQUIRED COMPONENTS roscpp pkg_a)

add include_directories
include_directories(
  include
  ${catkin_INCLUDE_DIRS}

)

add catkin package
catkin_package(
  CATKIN_DEPENDS pkg_a
)

and in building
add_executable(main_node main.cpp) 
target_link_libraries(main_node ${catkin_LIBRARIES}) 
add_dependencies(main_node ${catkin_EXPORTED_TARGETS})

then edit package.xml by add these line
  <build_depend>pkg_a</build_depend>
  <build_export_depend>pkg_a</build_export_depend>
  <exec_depend>pkg_a</exec_depend>

but i will get an error
fatal error: pkg_a/func_terminal.h: No such file or directory

from catkin build if i try to add this line #include <pkg_a/func_terminal.h> in pkg_b/main.cpp file
Edit #2(RECAP):
I'll explain the solution i have got thank to @Weasfas steb by steb here :
first i need to create a proper catkin_work_space for example in my case i use these command :
mkdir tryCatkin && mkdir tryCatkin/src && cd tryCatkin && catkin_make

then i can either use catkin_create_pkg command or just create out of of nowhere by following catkin package format which will create directory tree like this:
├── src
│   ├── CMakeLists.txt -> /opt/ros/kinetic/share/catkin/cmake/toplevel.cmake
│   ├── pkg_a
│   │   ├── CMakeLists.txt
│   │   ├── include
│   │   │   └── pkg_a
│   │   │       └── fuction_terminal.hpp
│   │   ├── package.xml
│   │   └── src
│   │       └── function_terminal.cpp
│   └── pkg_b
│       ├── CMakeLists.txt
│       ├── include
│       │   └── pkg_b
│       ├── package.xml
│       └── src
│           └── main.cpp

in pkg_b/src/main.cpp  :
#include <iostream>
#include <pkg_a/fuction_terminal.hpp>

int main(void) {
    int sum_result = sumation(5,5); ///sumation is function in func_terminal.hpp
    std::cout << "test :  " << sum_result;

    return 0;
}

then setup those package.xml and CmakeList.txt which i follow from @Weasfas instruction. first in pkg_a/Cmakelist.txt :
cmake_minimum_required(VERSION 2.8.3)
project(pkg_a)

find_package(catkin REQUIRED COMPONENTS)

catkin_package(
  INCLUDE_DIRS include
  LIBRARIES SumFunc
)

include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)

add_library(SumFunc
   src/function_terminal.cpp
)

pkg_b/CmakeList.txt :
cmake_minimum_required(VERSION 2.8.3)
project(pkg_b)

find_package(catkin REQUIRED COMPONENTS
  pkg_a
)
catkin_package()

include_directories(
  ${catkin_INCLUDE_DIRS}
)

add_executable(main_node src/main.cpp)

target_link_libraries(main_node
  ${catkin_LIBRARIES}
)

and then in pkg_b/package.xml add this line:
  <depend>pkg_a</depend>

Originally posted by Cry-A-Lot on ROS Answers with karma: 15 on 2020-07-24
Post score: 1

A:

Hi @Cry-A-Lot,
The recommended link you posted explains you how to compile a target against a library of the same package.
The first recommendation is that you should not include cpp files in your code but hpp or or h (header) since with that intruction (E.g.: #include <pkg_a/mutiply.cpp>) the compiler will probably throw an error because of the multiples and function duplications.
After you have generated properly your headers you should compile your targets against your libraries. It means that, if for instance you have in sumfunc.cpp something you want to use in main.cpp you should compile your main.cpp as:
EDIT:
I have managed to achieve what you want, first of all the package structure is the following:
└── src
    ├── pkg_a
    │   ├── CMakeLists.txt
    │   ├── include
    │   │  ├── package_a
    │   │  │   ├── some_func.hpp
    │   ├── src
    │   │  ├── some_func.cpp
    │   └── package.xml
    └── pkg_b
    │   ├── CMakeLists.txt
    │   ├── src
    │   │   ├── main.cpp
    │   └── package.xml

Then in CmakeList.txt of package_a:
find_package(catkin REQUIRED COMPONENTS
  roscpp
  std_msgs
  ...
)

catkin_package(
  INCLUDE_DIRS include
  LIBRARIES SumFunc
)

include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)

add_library(SumFunc
   src/sum_func.cpp
)

And to use in package_b:
find_package(catkin REQUIRED COMPONENTS
  roscpp
  std_msgs
  package_a
  ...
)

catkin_package()

include_directories(
  ${catkin_INCLUDE_DIRS}
)

add_executable(main_node src/main.cpp)

target_link_libraries(main_node
  ${catkin_LIBRARIES}
)

Hope that solve your problem.
Regards.

Originally posted by Weasfas with karma: 1695 on 2020-07-24
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Cry-A-Lot on 2020-07-29:
i try to edit like you said but i still got an error: "fatal error: pkg_a/func_terminal.h: No such file or directory" what am i miss
Comment by Weasfas on 2020-07-29:
Mmm how is your package structure? Maybe you forgot a dependency.
Comment by Weasfas on 2020-07-31:
So I have edited my answers to a achievable solution to see if that can help you.
Comment by Cry-A-Lot on 2020-08-03:
i have follow instruction from you EDIT section , but i still doesn't work with me and got an error : "Could not find a package configuration file provided by "package_a" " could you please re-check it.
Comment by Weasfas on 2020-08-03:
@Cry-A-Lot , that is a usual problem when the CMakeList.txt of one package is bad implemented. How is your cmake. That message is telling you that catkin is unable to find the package_a in the workspace so, either you defined bad your CMakeList.txt or you package.xml is not well formed.
Comment by Cry-A-Lot on 2020-08-04:
it only occur when i add package_a inside
find_package(catkin REQUIRED COMPONENTS
  roscpp
  std_msgs
  # package_a)

this is  my pgk_a/CmakeList.txt :
cmake_minimum_required(VERSION 3.0.2)
project(pkg_a)
  
find_package(catkin REQUIRED COMPONENTS
  roscpp
  std_msgs
)

catkin_package(
  INCLUDE_DIRS include
  LIBRARIES SumFunc
)

include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)

add_library(SumFunc
   src/func_terminal.cpp
)

this is my pkg_b/CmakeList.txt :
cmake_minimum_required(VERSION 3.0.2)
project(pkg_b)

find_package(catkin REQUIRED COMPONENTS
  roscpp
  std_msgs
  # package_a
)

catkin_package()

include_directories(
  ${catkin_INCLUDE_DIRS}
)

add_executable(main_node src/main.cpp)

target_link_libraries(main_node
  ${catkin_LIBRARIES}
)

Comment by Weasfas on 2020-08-04:
Well the package name you gave is not package_a but pkg_a. That may be the problem of catkin not finding it.
Comment by Cry-A-Lot on 2020-08-04:
if i replace package_a with pkg_a it still give an error : Project 'pkg_a' specifies 'include' as an include dir, which is not found.
Comment by Weasfas on 2020-08-04:
Then you have problems with the workspace not with the packages themselves. It looks like catkin is unable to find the package pkg_a so either you configured bad your workspace or your enviromental variables are not properly set. Did you source the workspace?
Comment by Cry-A-Lot on 2020-08-05:
it work now, THANK!!!


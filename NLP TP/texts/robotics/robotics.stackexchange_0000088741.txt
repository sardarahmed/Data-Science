Q:

The source of topics in someone else's package

I'm going through this package, and in particular this file in which I found three topics whose "source packages" and meaning are unknown to me:

/right_constraint_index,
/left_constraint_index, and
/lsr/angle

I would like to be able to run this package (roslaunch seems to be working according to the instructions in the README), but I don't know how to resolve the above three topics.
I'm new to ROS and the only means of finding the "source" of these topics (nodes that publish to them) is by going through the package's dependencies. But that didn't help.
I obviously googled them and searched for their parent packages on ros.org -- but to no avail. Also, I tried to get in touch with the author of the package but, again, no luck there.
Hence, I turn to you with the question: what do you think is their origin?
But more generally: what are the standard methods of identifying mysterious topics found when going through somebody else's code?
As a side note: I have an idea that these three topics are a means of parametrizing the behavior of the robot during the run (so that one might find the right values of the parameters that correspond to the best local solution), but I wasn't able to verify it.
EDIT: to summarize the discussion in the comments below, my question boils down to:
Is there is a "standard topic repository" that I can use to better understand the use of topics in somebody else's code?

and the short answer is: no, there isn't. You're dependent on the authors and the documentation provided with the code.

Originally posted by MTDzi on ROS Answers with karma: 3 on 2018-08-27
Post score: 0

Original comments
Comment by gvdhoorn on 2018-08-28:
If with "the source of topics" you mean: where are the publishers defined that publish to them, or the subscribers that subscribe, then you'll have to read the source, yes.
If you are asking something else, please clarify, as I have a hard time figuring out what you're asking.
Comment by MTDzi on 2018-08-29:
My question boils down to the following: "If I don't know what kind of information the node expects through these unknown topics, what methods of finding this out can I follow?"
In other languages / libraries, if I encounter a function that I don't know, I can read the documentation, or...
Comment by MTDzi on 2018-08-29:
...if there is none, I can go through its implementation. In the example above,
this approach doesn't apply.
If, however, I was able to find packages that use topics named as those above,
I could figure out whether this is what the node expects. And if so, I would
use those packages to supply...
Comment by MTDzi on 2018-08-29:
...the node with the required information.
Is my reasoning wrong?
Comment by gvdhoorn on 2018-08-29:
re: read documentation: I would say that is exactly the same in this case. Many ROS pkgs document the types and semantics of the topics they use/expect. See abb_driver as an example.
But just as with other software: you're dependent on the authors ..
Comment by gvdhoorn on 2018-08-29:
.. to have provided you with that documentation. If they didn't, then you can't use that.
re: go through its implementation: I'm not sure how ROS nodes are different here. It's all C++/Python/some other language. Provided you know those languages, you could read the sources.
Comment by gvdhoorn on 2018-08-29:
re: use topics names: no, this is not something you can do. Topic names do not encode sufficiently the types of info that flow across the topic. I can create a /chatter topic that carries geometry_msgs/PoseStamped, while the ROS tutorials use std_msgs/String. You'll have to look at ..
Comment by gvdhoorn on 2018-08-29:
.. the type of the topic to see whether things are compatible. And here again you will be somewhat dependent on the authors of the node(s): if they used primitive types like Int32 and Float64, then those msgs carry almost no semantic meaning. If however they used something like ..
Comment by gvdhoorn on 2018-08-29:
.. geometry_msgs/PoseStamped, that tells you the topic carries 6D poses with an associated timestamp and a reference coordinate frame. Of course that is not enough to know exactly what the subscribing node expects, but it's much better than a simple vector of length 6.
Comment by gvdhoorn on 2018-08-29:\

I can go through its implementation. In the example above, this approach doesn't apply.

Just to clarify: the source of all ROS (open-source) packages is available. So you can read the source. If you're referring to a proprietary pkg the authors don't want to provide the source for, ..
Comment by gvdhoorn on 2018-08-29:
.. you'll be dependent on them having written (and made available) sufficient documentation. But that would again seem to be the exact same situation as with any software product or component.
Comment by MTDzi on 2018-08-29:
OK, thanks for the clarifications. Regarding other languages, I agree that nodes are perfectly "self-explanatory". I was referring to topics (for which I have only their names), for which it's hard to guess their purpose only based on their usage and their types.
Comment by gvdhoorn on 2018-08-29:\

the short answer is: no, there isn't. You're dependent on the authors and the documentation provided with the code.

That isn't entirely true. See my answer.

A:

I think I was hoping there is a "standard topic repository" that would provide this kind of information.

Now I think I know what you're asking: topic names are almost arbitrary, types are not however. Topics are typed, so both participants in pub-sub need to declare the same types. That avoids the situation where you attempt to send incorrectly formatted information to a certain subscriber.
But that doesn't solve the complete problem. Typing addresses the syntax part of communication. But for semantics we still need something more.
So besides typing, additional semantics are captured in what is typically called a "ROS API". For serious systems, those are captured in REPs. Those REPs provide additional information on the types that should be used for certain topics, their names and what their intended use is.
See REP 138: LaserScan Common Topics, Parameters, and Diagnostic Keys for an example, but there are some others as well (and some REPs standardise entities other than topics or parameters, such as REP 103: Standard Units of Measure and Coordinate Conventions and REP 105: Coordinate Frames for Mobile Platforms).
REPs have not been used that much in more recent years, but I believe they are something that comes close to your "standard topic repository", at least conceptually.

Originally posted by gvdhoorn with karma: 86574 on 2018-08-29
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by MTDzi on 2018-08-29:
Thanks  :)
Comment by gvdhoorn on 2018-08-29:
Note that this also isn't a complete solution: even if there are standards, you're still dependent on the package authors to have implemented them. And then additionally: there aren't standards for everything. So sometimes developers don't have a choice but to come up with something themselves.


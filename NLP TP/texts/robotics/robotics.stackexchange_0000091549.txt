Q:

How to solve different ros::Time error message

I have a total of N. 7 .csv files. Those files are the result of N.7 sensors mounted on an underwater system. After packing both custom and standard messages according to available documentation and playing them in a test.bag file I am able to see the majority of them being broadcasted.
Every file is composed of a different type of column but there is the same column in every file, which is timestamp.
The procedure
I am showing here N.3 print screen to replicate the problem.
The first file is composed of N.4 columns as it is possible to see below:

The second file is composed of N.3 columns as it is possible to see below:

The third file I am showing is composed of 18 columns but I am showing only the last columns (that has the timestamp) as it is possible to see below:

The way I am packing all the customized and non-customized ROS messages is shown below, and it is done in the same way for all the N.7 files. So for brevity I am only including one that is related to the first file shown above. Here is the most important part of the code:
keller_reader.h
#include "csv.h"
#include <string>
#include "ros_float/pressure.h"
#include "ros_float/depth.h"
#include "ros_float/temperature.h"
struct KELLER_DATA
{
    unsigned long timestamp;
    double depth;
    double temperature;
    double pressure;
};

class Keller_reader
{
public:
  Keller_reader(std::string filename);
  bool nextLine();
  KELLER_DATA keller_data;
  sensor_msgs::FluidPressure pressureMsg;
  ros_float::pressure pMsg;
  ros_float::temperature tMsg;
  ros_float::depth dMsg;

private:
  io::CSVReader<4> keller_reader;
  unsigned int msgNumKeller;
  void packPressureMsg();
  // Custom Pressure Message
  void packCustom_TemperatureMsg();
  void packCustom_DepthMsg();
};

keller_reader.cpp
#include "keller_reader.h" 
Keller_reader::Keller_reader(std::string filename):
    keller_reader(filename)
{
    msgNumKeller = 0;
    keller_reader.read_header(io::ignore_extra_column,
                              "timestamp", "depth", "temp","pressure");
}

bool Keller_reader::nextLine()
{
    if(keller_reader.read_row(keller_data.timestamp, keller_data.depth,
                              keller_data.temperature, keller_data.pressure))
    {
        packPressureMsg();
        packCustom_TemperatureMsg();
        packCustom_DepthMsg();
        msgNumKeller++;
        return true;
    }
    else
    {
        return false;
    }
}

void Keller_reader::packPressureMsg()
{
    double doubleTime = double(keller_data.timestamp)/1e6;
    ros::Time stamp(doubleTime);
    pMsg.header.stamp = stamp;
    pMsg.header.frame_id = "/pressure";
    pMsg.header.seq = msgNumKeller;
    pMsg.fluid_pressure = keller_data.pressure;
}

void Keller_reader::packCustom_TemperatureMsg()
{
    // same procedure as above
}

void Keller_reader::packCustom_DepthMsg()
{
   // same procedure as above
}

Notice that the timestamp is treated in the same way in all files so that can be brought to a standard readable ROS time:
    double doubleTime = double(keller_data.timestamp)/1e6;
    ros::Time stamp(doubleTime);

Because remember from above that what I have in the .csv file is this:

The Problem
This approach works well for all N.6 files. However when I do the same with the last file I have very different errors.
The most important part of the code is below:
usbl_reader.h
struct USBL_DATA
{
    int prop_time;
    double accuracy;
    double e;
    unsigned long ctime;
    double h_reader;
    int remote_id;
    int rssi;
    double n;
    double p;
    double depthUSBL;
    double r;
    double u;
    unsigned long mtime;
    double xPosition;
    double yPosition;
    double zPosition;
    int integrity;
    unsigned long timestamp;
};

class USBL_reader
{
public:
  USBL_reader(std::string filename);
  bool nextLine();

  USBL_DATA usbl_data;
  ros_float::accuracy accuracyMsg;
 // other custom messages
  geometry_msgs::PoseWithCovarianceStamped poseWithCovStamped;

private:
  io::CSVReader<18> usbl_reader; // number of columns of the file
  unsigned int msgNumUSBL;
  void pack_XYZ_Pose_WithCovariance_Msg();

  void pack_Prop_Time_Msg();
  // packing other custom messages 
};

usbl_reader.cpp
USBL_reader::USBL_reader(std::string filename):
    usbl_reader(filename)
{
    msgNumUSBL = 0;
    usbl_reader.read_header(io::ignore_extra_column,
                            "prop_time", "accuracy", "e", "ctime", "h", "remote_id",
                            "rssi", "n", "p", "depth", "r", "u", "mtime",
                            "y", "x", "z", "integrity", "timestamp");
}

bool USBL_reader::nextLine()
{
    if(usbl_reader.read_row(usbl_data.prop_time, usbl_data.accuracy, usbl_data.e,
                            usbl_data.ctime, usbl_data.h_reader, usbl_data.remote_id,
                            usbl_data.rssi, usbl_data.n, usbl_data.p,
                            usbl_data.depthUSBL, usbl_data.r, usbl_data.u,
                            usbl_data.mtime, usbl_data.yPosition, usbl_data.xPosition,
                            usbl_data.zPosition, usbl_data.integrity , usbl_data.timestamp))
    {
        pack_XYZ_Pose_WithCovariance_Msg();
        // packing other messages .... 
        msgNumUSBL++;
        return true;
    }
    else
    {
        return false;
    }
}

void USBL_reader::pack_XYZ_Pose_WithCovariance_Msg()
{
    double doubleTime = double(usbl_data.timestamp)/1e6;
    ros::Time stamp(doubleTime);
    poseWithCovStamped.header.stamp = stamp;
    poseWithCovStamped.header.frame_id = "/PoseWithCovariance";
    poseWithCovStamped.header.seq = msgNumUSBL;
    poseWithCovStamped.pose.pose.position.x = usbl_data.xPosition;
    poseWithCovStamped.pose.pose.position.y = usbl_data.yPosition;
    poseWithCovStamped.pose.pose.position.z = usbl_data.zPosition;
}

// other messages implementation

The Error
The current settings of the usbl_reader file above throws the following error when running the test.bag file:
terminate called after throwing an instance of 'rosbag::BagException' what():  Tried to insert a message with time less than ros::TIME_MIN Aborted (core dumped)
Some possible solution I tried were writing a global_t_stamp.h header file that looks like this:
#ifndef GLOBAL_T_STAMP_H
#define GLOBAL_T_STAMP_H

#include <stdint.h>
typedef uint64_t timestamp_t;
typedef uint64_t ctime_t;
typedef uint64_t mtime_t;
#endif // GLOBAL_T_STAMP_H

And substitute the message in the usbl_reader.cpp with the following message:
void USBL_reader::pack_XYZ_Pose_WithCovariance_Msg()
{
    timestamp_t currentTime = usbl_data.timestamp;
    ros::Time stamp(currentTime);
    poseWithCovStamped.header.stamp = stamp;
    poseWithCovStamped.header.frame_id = "/PoseWithCovariance";
    poseWithCovStamped.header.seq = msgNumUSBL;
    poseWithCovStamped.pose.pose.position.x = usbl_data.xPosition;
    poseWithCovStamped.pose.pose.position.y = usbl_data.yPosition;
    poseWithCovStamped.pose.pose.position.z = usbl_data.zPosition;
}

But this time I obtained a different error when running the test.bag file see below:
terminate called after throwing an instance of 'std::runtime_error' what():  Time is out of dual 32-bit range Aborted (core dumped)
The last solution I tried was changing the unsigned long format of the timestamp with unsigned int as below
struct USBL_DATA
{
    // data structure
    unsigned int timestamp;
};

But this time I got another different error that seems to send the message in overflow see below the result after running the test.bag file
terminate called after throwing an instance of 'io::error::integer_overflow' what():  The integer "1517940547956428" overflows in column "timestamp" in file "/home/emanuele/Desktop/file.csv" in line "2".
which in this case as it is possible to see from line 2 of the file is just the beginning of the file:

I don't understand what is going on and why I am receiving this error if I applied the same exact conversion of the timestamp into a ROS readable format as shown below:
    double doubleTime = double(usbl_data.timestamp)/1e6;
    ros::Time stamp(doubleTime);

Can anyone shed light on this matter and why this is behaving like this?

Originally posted by RayROS on ROS Answers with karma: 108 on 2019-04-30
Post score: 0

A:

The timestamps in ROS bag files, and by extension your original CSV files, are stored in integer nanoseconds. Therefore, I think your problem is that you are assuming the timestamps are in microseconds when you convert them to a double representation. I think if you divide by 1e9 instead of 1e6 it will fix it.

Originally posted by robustify with karma: 956 on 2019-04-30
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by RayROS on 2019-05-01:
@robustify, thank you very much, that was exactly what was happening! :)
Comment by robustify on 2019-05-01:
You're welcome!


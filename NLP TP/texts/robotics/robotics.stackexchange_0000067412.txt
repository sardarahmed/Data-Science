Q:

shared variable between callbacks

Hi all,
I have a ros node that is supposed to accept two sources (IMU and PointCloud) with two different frequecies (Imu is ~200 Hz, PointCloud is ~30 Hz). So expect around 7 IMU messages for every cloud message.
If I use a message filter, I can collect in a single callback the two closest signals.
Instead, I would like to independently collect all the occurences of IMU between two point cloud messages, so that I can use them to get a better interpolation of the IMU signal to synchronize the two signals.
Would two callbacks + a global variable (a std::vector) suffice?
Should I implement some blocking mechanism to prevent the global variable from being modified when I'm inside the cloud callback?
Are the callbacks sequential? In that case, how can I make them concurrent?

Originally posted by mark_vision on ROS Answers with karma: 275 on 2015-05-05
Post score: 0

A:

The answer depends on whether you are using roscpp or rospy. It seems you are using roscpp because you mentioned std::vector. If you are simply using ros::spin or ros::spinOnce there is only a single thread handling callbacks so there should be no need for any sort of mutex.
If you'd like to use a multi-threaded approach to processing your callbacks, roscpp includes the ros::MultiThreadedSpinner and ros::AsyncSpinner. If using one of these spinners, you should take care to prevent access collisions.
This information was pulled from the Callbacks and Spinning roscpp Overview page.
EDIT
IMO, it can be a bit difficult to find documentation on the rospy threading model (and I'm apparently too lazy to write a wiki page about it), but this ROS answers post has a clear and concise description.

Originally posted by jarvisschultz with karma: 9031 on 2015-05-05
This answer was ACCEPTED on the original site
Post score: 2


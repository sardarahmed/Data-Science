Q:

Optimizing Swerve Drive Robot Performance for Real-world Implementation with MPPI Controller

We are currently developing a swerve drive robot utilizing the MPPI controller, but we're encountering challenges in transitioning from simulation to real-world operation. To provide context on the swerve drive system, our robot consists of four "legs," each equipped with a motor to control wheel orientation/direction relative to the robot and another motor to manage wheel speed.
In simulation, the robot moves smoothly and follows the desired trajectory accurately. However, in the real world, we observe that the robot's wheel orientations rapidly fluctuate between random positions while at idle before initiating its intended trajectory. Moreover, during movement, the trajectory deviates, resulting in a snake-like pattern, and the robot struggles to react effectively to dynamic obstacles.
The problem seems to be that our direction motors move instantly to their intended positions in simulation while in reality there is a noticeable delay. Our guess is that the MPPI controller generates trajectories for the next time step, aiming for motor angles that may not be achievable within a single time step due to the speed constraints of the direction motors.
My question is therefore:

Is there a way to add the speeds and accelerations of our direction motors to the MPPI controller for the computation of feasible paths?
Is there an alternative solution to our problem?

A:

Its a good question, but unfortunately I don't have a robot remotely like that which I have access to to play around with and test. I can say though from user videos provided for me for my ROSCon 2023 talk, we have a robot exactly like you describe using MPPI successfully. That's not to say that perhaps behavior specialized to robots of this nature couldn't be made, I'm just unfortunately not in a position to do evaluation and testing to implement it myself or have the experience to give you a straight-forward answer about what changes specifically would be necessary to make easier.
Perhaps acceleration constraints (which are planned) would do the trick. Perhaps not fully is my intuition.
Ex. https://youtu.be/1n2bGVIe7Gs?si=yDbrOyzjANmQhSK1&t=48
My email's pretty easy to find - if you have the time to implement / test & this is something you'd like to collaborate over to make work, let me know!


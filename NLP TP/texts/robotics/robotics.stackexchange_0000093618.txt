Q:

When exactly is a connect callback of a publisher called?

Hi all,
I would like to know when precisely the connect_cb is being invoked, specified in
Publisher ros::NodeHandle::advertise(const std::string &    topic,
    uint32_t    queue_size,
    const SubscriberStatusCallback &    connect_cb,
    const SubscriberStatusCallback &    disconnect_cb = SubscriberStatusCallback(),
    const VoidConstPtr &    tracked_object = VoidConstPtr(),
    bool    latch = false 
) 

(see http://docs.ros.org/melodic/api/roscpp/html/classros_1_1NodeHandle.html#ae4711ef282892176ba145d02f8f45f8d). More specifically, I know that if I do a NodeHandle:advertise(), the underlying (TCP) connection is not established directly, i. e., upon returning from advertise(), subscribers may not already be connected even if they are already "there" (= known to the master) since this clearly also takes time. So, publishing messages right after the advertise() can causes messages not being received by all "relevant nodes" at that time. (IIRC, this issue has been discussed frequently here on ros.answers.org and one nasty workaround is a delay after the advertise.) Assume I know about the existance of another node that will eventually/finally subscribe to the advertised topic. (Please, I don't want to discuss here that this may not be the idea of a decoupled communication concept, i.e., what pub/sub was designed for.)
TL;DR: Is it safe to assume that once the above mentioned connect_cb is triggered, the underlying TCP connection must have been established so that publishing messages using the returned ros::Publisher object will definitely deliver the message to the node denoted by ros::SingleSubscriberPublisher::getSubscriberName() (= argument of the callback)?
I was already grep'ping through ROS' source code but was not able to find the location where the callbacks are being invoked.
Thanks you very much!

Originally posted by CodeFinder on ROS Answers with karma: 100 on 2019-10-21
Post score: 0

A:

TL;DR: the connect_cb is called AFTER the underlying TCP connection was created. So once the callback is triggered, a publisher knows for sure that messages being published will be received by the node denoted by the callback-provided ros::SingleSubscriberPublisher object. :-)
I was following a similar path through the ROS code but was unsure if the peerConnect() function really triggers the callback. After a 2nd thought/look, also due to your efforts, it seems that it "just" adds them to the callback queue so that some idle spinning thread will catch it up later. And it seems (according to your findings), that this is done after the connection is established. Indeed, the onConnectionHeaderReceived() callback is invoked upon tcprosAcceptConnection() which seems like an evidance for my assumption. Also according to my further investigations, this cannot fail or cause the just created TCP connection to fail anymore. (As a sidenote, the ros::SingleSubscriberPublisher object provided to the callback also underpins the fact since one can send messages to the other node that just subscribed.)
I know that the connect_cb is invoked once for every new subscription. Its exactly what I need. :-)
Now, regarding your question wrt. the underlying application architecture that requires this kind of callback: I am working on / doing research on a local planning algorithm that entirely prevents collisions given some reasonable contraints. This requires that every robot knows about all others in the system. I am using a topic to allow robots to discover others but once discovered, I require somewhat (rather tightly) coupled communication between the robots in order to guarantee safety (collision free motions). It is somewhat in contrast to all these DWA, VFH, etc. planners out there. ;-) And the decoupled nature of pub/sub made it difficult to send messages while ensuring that a designated receiver is actually receiving it. (Does this answer your question?)
Ah and yes, sure: state-based conditions are always better (= more precise) than time-based ones. That's why I am intending to use these callbacks. The problem with Publisher::getNumSubscribers() is that some (e.g.)  rostopic echo ...also accounts for a subscriber and somewhat "disorts" the actual number of subscribers. :-)
Thanks again for your super fast and detailed reply!

Originally posted by CodeFinder with karma: 100 on 2019-10-23
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by gvdhoorn on 2019-10-23:\

Also according to my further investigations, this cannot fail or cause the just created TCP connection to fail anymore. (As a sidenote, the ros::SingleSubscriberPublisher object provided to the callback also underpins the fact since one can send messages to the other node that just subscribed.)

it can certainly fail. This is all based on TCP/IP, so if the remote side goes off-line, becomes unresponsive or for some other reason does not keep up its end of the connection, all subsequent writes (and reads) will fail.
So pedantically I would say the answer to your question should be "no" (we cannot be certain there is a connection at all) . But for practical purposes you can probably assume that there is one after this callback is invoked.
Comment by gvdhoorn on 2019-10-23:
Your post is also not really an answer btw. More a further clarification of your question combined with responses to my answer + comment.
Comment by CodeFinder on 2019-10-23:
Sure, connections can always fail. But this should cause the disconnect_cb to be called (may be another topic on its own). Pedantically, no, okay. But since my disconnect_cb will catch the case when the connection fails, it shouldn't be an issue. But generally, this is a problem of all coupled systems (relying on others causes somewhat "dangerous" dependencies but IMHO, this is inevitable anyway.)
I was asking whether the connect_cb is called after the connection was established. One phase of establishing a TCP connection is listening for it, and finally (if there's one) accepting it. So,  tcprosAcceptConnection() is the correct location to conclude that it's true which answers my question (disregarding the fact that it can fail at any time anyway). Accepting my answer was just to let others know that they will find this information in this thread (and its worth reading). If you prefer to not mark my post as an answer (?), I am okay with that, too...


Q:

What are possible reasons for empty service responses?

Hey, I have a problem regarding a service call. My code is very similar to the example given below. This example WORKS WELL, I am aware of that. However, in my very long code I have the problem that in a similar situation, the response in printer.cpp is empty after the service call. The service call itself is executed and the result is calculated, but the response object after the call is empty. That is very strange as I give the request and response as references and thus it should work on the given object.
I would like to provide you with the relevant code, but I have not a single clue where the issue lies and thus would have to paste everything here, which would be way too much.
So, basically, I would like to know what possible reasons there are for a service response to be empty/uninitialized.
Any help is appreciated.
calcu.cpp
#include "ros/ros.h"
#include "std_msgs/String.h"
#include "beginner_tutorials/AddTwoInts.h"
#include <sstream>

bool calcuCallback(beginner_tutorials::AddTwoInts::Request &req,
                    beginner_tutorials::AddTwoInts::Response &res)
{
    res.sum = req.a + req.b;
}
int main (int argc, char** argv)
{
    ROS_INFO("calcu running");
    ros::init (argc, argv, "calcu");
    ros::NodeHandle nh;
    // create a ROS service
    ros::ServiceServer service= nh.advertiseService("add_two_ints", &calcuCallback);
    // spin
    ros::spin();
    return (0);
}

printer.cpp
#include <ros/ros.h>
#include <opencv2/opencv.hpp>
#include "beginner_tutorials/AddTwoInts.h"
#include "beginner_tutorials/Num.h"

void numCallback(const beginner_tutorials::NumPtr msg)
{
    static beginner_tutorials::AddTwoInts::Request request;
    static beginner_tutorials::AddTwoInts::Response response;
    request.a = msg->num;
    request.b = 3;
    ros::service::call("add_two_ints", request, response);
    std::cout << "Response sum = " << response.sum << "\n"; // RESPONSE WOULD BE EMPTY/UNINITIALIZED
}
int main (int argc, char** argv)
{
    ROS_INFO("printer running");
    ros::init (argc, argv, "printer");
    ros::NodeHandle nh;
    if(!ros::service::waitForService("add_two_ints",10000)) return -1;
    // create ROS subscribers for local landmarks and dGPS pose estimates
    ros::Subscriber sub = nh.subscribe("inputs", 1, &numCallback);
    // spin
    ros::spin();
    return (0);
}

addTwoInts.srv
int64 a
int64 b
---
int64 sum

Num.msg
int64 num

Originally posted by anonymous28046 on ROS Answers with karma: 65 on 2016-11-07
Post score: 0

Original comments
Comment by Felix Endres on 2016-11-07:
Hard to tell. Sounds like a problem on the service-server side. Does calling the service from the command line also result in an empty response?
Comment by anonymous28046 on 2016-11-08:
Alright, so when calling the service from the command line it prints ERROR: service [/add_two_ints] responded with an error: . Any idea how to procede? I googled this error and found that maybe a ros::service::waitForService call is the reason, but no idea why. I added the code in my question.
Comment by anonymous28046 on 2016-11-08:
Should add that I called the service by invoking rosservice call /add_two_ints "args" and the service callback is doing its work until the last line, but leads to the error. Note that in my actual program no error is printed out, but the response is empty.

A:

After adding return true; to my bool callback, it works now. Whole example function (obviously my function is way bigger):
bool calcuCallback(beginner_tutorials::AddTwoInts::Request &req,
                    beginner_tutorials::AddTwoInts::Response &res)
{
    res.sum = req.a + req.b;
    return true; // this was needed
}

Any idea when the return true; statement is needed and when it is not (or if it is just a workaround for another deeper issue)? When someone knows it, he can give the whole answer so I can mark it. Thanks Felix for setting me on track.

Originally posted by anonymous28046 with karma: 65 on 2016-11-08
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by Felix Endres on 2016-11-10:
The return value signals whether the callback was processed successfully. The code still compiles (btw you should compile with warnings: -Wall -Wextra) but uses the byte in memory where the return value would be. In your case that byte was 0 and the callback is thus assumed to be failed.


Q:

rgbdslam freiburg hydro

I am editing my problem and leaving previous versions- I know this post looks very large now but if somebody will have same problem in futer maby he can track down some of my mistakes and use them.
I'm using
ubuntu 12.04
ROS hydro medusa
From several days I'm trying to use some how rgbdslam but I get several errors.
I tried to do what is written here:
http://answers.ros.org/question/91111/rgbdslam-in-ros-hydro/
but after executing:
rosdep install rgbdslam_freiburg
I receive this error:
ERROR: the following packages/stacks could not have their rosdep keys resolved
to system dependencies:
rgbdslam: Missing resource pcl
ROS path [0]=/opt/ros/hydro/share/ros
ROS path [1]=/home/wilk/catkin_ws/src
ROS path [2]=/opt/ros/hydro/share
ROS path [3]=/opt/ros/hydro/stacks
Does it means that there is no pcl library provided with my ros installation or that I should made conversions from older pcl library as it worked for somebody here:
http://answers.ros.org/question/74899/rosmake-rgbdslam_freiburg-error-in-groovy/
I read also this but I don't know if I should also make it:
http://www.pcl-users.org/How-do-I-use-PCL-from-ROS-Hydro-td4029613.html
Could any one be as kind to tell me what I should do? or even which commands should I use in terminal. I would also d'like to know if making those conversations will solve the problem, if there is any one who can share it. I really don't like the idea of manually changing code without knowing if it will help.
Edit1:
Is it possible to use rosbuild and catkin workspaces simultaniously? Despite trying to use code writen for older version of ROS I'm trying to convert it too catkin_ws too. There are only a few files that need to be changed so I will pase them here. Please help.
I receave fallowing error:
CMake Error at rgbdslam_freiburg/rgbdslam/CMakeLists.txt:240 (add_executable):
  add_executable cannot create target "rgbdslam" because another target with
  the same name already exists.  The existing target is a shared library
  created in source directory
  "/home/wilk/catkin_ws/src/rgbdslam_freiburg/rgbdslam".  See documentation
  for policy CMP0002 for more details.

My files looks like that:
CMakeLists.txt

This code block was moved to the following github gist:
https://gist.github.com/answers-se-migration-openrobotics/3ecc59d1a1602e0a07acac59966bd314

package.xml
<package>
  <name>rgbdslam</name>
  <version>0.1.0</version>
  <description>This package can be used to register the point clouds from RGBD sensors such as the kinect or stereo cameras.
    The created world model can be saved as point cloud or integrated into an octomap.</description>
  <author>Felix Endres</author>
  <maintainer email="endres@informatik.uni-freiburg.de">Felix Endres</maintainer>

  <license>GPL v3</license>

  <url type="website">http://ros.org/wiki/rgbdslam</url>
  <!-- <url type="bugtracker"></url> -->

  

  <!-- Dependencies which this package needs to build itself. -->
  <buildtool_depend>catkin</buildtool_depend>

  <!-- Dependencies needed to compile this package. -->
  <build_depend>tf</build_depend>
  <build_depend>pcl_conversions</build_depend>
  <build_depend>rospy</build_depend>
  <build_depend>roscpp</build_depend>
  <build_depend>rosbag</build_depend>
  <build_depend>pcl_ros</build_depend>
  <build_depend>cv_bridge</build_depend>
  <build_depend>sensor_msgs</build_depend>
  <build_depend>octomap_server</build_depend>
  <build_depend>octomap_ros</build_depend>
  <build_depend>geometry_msgs</build_depend>
  <build_depend>visualization_msgs</build_depend>

  <!-- Dependencies needed after this package is compiled. -->
  <run_depend>tf</run_depend>
  <run_depend>pcl_conversions</run_depend>
  <run_depend>rospy</run_depend>
  <run_depend>roscpp</run_depend>
  <run_depend>rosbag</run_depend>
  <run_depend>pcl_ros</run_depend>
  <run_depend>cv_bridge</run_depend>
  <run_depend>sensor_msgs</run_depend>
  <run_depend>octomap_server</run_depend>
  <run_depend>octomap_ros</run_depend>
  <run_depend>geometry_msgs</run_depend>
  <run_depend>visualization_msgs</run_depend>

  <!-- Dependencies needed only for running tests. -->
  <!-- <test_depend>tf</test_depend> -->
  <!-- <test_depend>pcl_conversions</test_depend> -->
  <!-- <test_depend>rospy</test_depend> -->
  <!-- <test_depend>roscpp</test_depend> -->
  <!-- <test_depend>rosbag</test_depend> -->
  <!-- <test_depend>pcl_ros</test_depend> -->
  <!-- <test_depend>cv_bridge</test_depend> -->
  <!-- <test_depend>sensor_msgs</test_depend> -->
  <!-- <test_depend>octomap_server</test_depend> -->
  <!-- <test_depend>octomap_ros</test_depend> -->
  <!-- <test_depend>geometry_msgs</test_depend> -->
  <!-- <test_depend>visualization_msgs</test_depend> -->

<export>
    <rosdoc config="rosdoc.yaml"/>
    <nodelet plugin="${prefix}/nodelet_plugins.xml"/>
    <cpp cflags="-I${prefix}/srv_gen/cpp"/>
</export>

</package>

Now I will paste headers that needs pcl conversions. I have no idea if i made them good
gic-fallback.h
/* This file is part of RGBDSLAM.
 * 
 * RGBDSLAM is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * RGBDSLAM is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with RGBDSLAM.  If not, see <http://www.gnu.org/licenses/>.
 */

 /*
 * gicp.cpp
 *
 *  Created on: Jan 23, 2011
 *      Author: engelhar
 */

#include "gicp-fallback.h"

#include <fstream>
#include <sstream>
#include <iostream>
#include <pcl/filters/voxel_grid.h>
using namespace std;

void saveCloud(const char* filename, const pointcloud_type& pc, const int max_cnt, const bool color){

    ofstream of;
    of.open(filename);
    assert(of.is_open());

    
    int write_step = 1;
    if (max_cnt>0 && (int)pc.points.size()>max_cnt)
        write_step = floor(pc.points.size()*1.0/max_cnt);
    
    int cnt = 0;
    assert(write_step > 0);

    
    // only write every write_step.th points
    for (unsigned int i=0; i<pc.points.size(); i += write_step)
    {
        point_type p = pc.points[i];

        bool invalid = (isnan(p.x) || isnan(p.y) || isnan(p.z));
        if (invalid)
            continue;

        
        of << p.x << "\t" << p.y << "\t" << p.z;
        /*
        if (color) {
            
            int color = *reinterpret_cast<const int*>(&p.rgb); 
            int r = (0xff0000 & color) >> 16;
            int g = (0x00ff00 & color) >> 8;
            int b = 0x0000ff & color; 
            of << "\t \t" << r << "\t" << g << "\t" << b << "\t" << endl;
        }   
        else
        */
            of << endl;
       // cout << p.x << "\t" << p.y << "\t" << p.z << endl;
                       
        cnt++;
    }
    

   // ROS_INFO("gicp.cpp:  saved %i pts (of %i) to %s", cnt,(int) pc.points.size(), filename);
   // printf("gicp.cpp:  saved %i pts (of %i) to %s \n", cnt,(int) pc.points.size(), filename);

    of.close();

}

void downSample(const pointcloud_type& src, pointcloud_type& to){
    pcl::VoxelGrid<point_type> down_sampler;
    down_sampler.setLeafSize (0.01, 0.01, 0.01);
    pcl::PCLBase<point_type>::PointCloudConstPtr const_cloud_ptr = boost::make_shared<pointcloud_type> (src);
    down_sampler.setInputCloud (const_cloud_ptr);
    down_sampler.filter(to);
    ROS_INFO("gicp.cpp: Downsampling from %i to %i", (int) src.points.size(), (int) to.points.size());
}

bool gicpfallback(const pointcloud_type& from, const pointcloud_type& to, Eigen::Matrix4f& transform){

    // std::clock_t starttime_gicp = std::clock();
    
    FILE *fp;
    char f1[200];
    char f2[200];

    char line[130];
    char cmd[200];

    sprintf(f1, "pc1.txt");
    sprintf(f2, "pc2.txt");

    // default values for algo work well on this data
    sprintf(cmd, "/home/endres/Phd/rospacks/rgbdslam/external/gicp/test_gicp %s %s --d_max 0.1  --debug 0",f1,f2); 

    int N = 10000;
    
    saveCloud(f1,from,N);
    saveCloud(f2,to,N);

    // cout << "time for writing: " << ((std::clock()-starttime_gicp*1.0) / (double)CLOCKS_PER_SEC) << endl;
    // std::clock_t starttime_gicp2 = std::clock();
    
    /*
     ICP is calculated by external program. It writes some intermediate results
     and the final homography on stdout, which is parsed here.
     Not very beautiful, but works :)
     */
    fp = popen(cmd, "r");

    std::vector<string> lines;

    // collect all output
    while ( fgets( line, sizeof line, fp))
    {
        lines.push_back(line);
        // ROS_INFO("gicp.cpp: %s", line);
    }
    int retval = pclose(fp);
   // cout << "time for binary: " << ((std::clock()-starttime_gicp2*1.0) / (double)CLOCKS_PER_SEC) << endl;

   // std::clock_t starttime_gicp3 = std::clock();
        
    if(retval != 0){
        ROS_ERROR_ONCE("Non-zero return value from %s: %i. Identity transformation is returned instead of GICP result.\nThis error will be reported only once.", cmd, retval);
        transform = Eigen::Matrix<float, 4, 4>::Identity();
        return false;
    }

    int pos = 0;
    // last lines contain the transformation:
    for (unsigned int i=lines.size()-5; i<lines.size()-1; i++){
        
        stringstream ss(lines.at(i));
        for (int j=0; j<4; j++)
        {
            ss >> line;
            transform(pos,j) = atof(line);
        }
        // cout << endl;
        pos++;
    }
    
    // read the number of iterations:
    stringstream ss(lines.at(lines.size()-1));
    ss >> line; // Converged in
    ss >> line;
    ss >> line;
        
    int iter_cnt;
    iter_cnt = atoi(line);
    
    return iter_cnt < 200; // check test_gicp for maximal allowed number of iterations
    
    // ROS_INFO_STREAM("Parsed: Converged in " << iter_cnt << "iterations");
    
    
    // ROS_DEBUG_STREAM("Matrix read from ICP process: " << transform);
    // ROS_INFO_STREAM("Paper: time for icp1 (internal): " << ((std::clock()-starttime_gicp*1.0) / (double)CLOCKS_PER_SEC));
}

node.h

This code block was moved to the following github gist:
https://gist.github.com/answers-se-migration-openrobotics/67d19860165c1eedc1fce77a85e66c89

parameter_server.h
/* This file is part of RGBDSLAM.
 * 
 * RGBDSLAM is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * RGBDSLAM is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with RGBDSLAM.  If not, see <http://www.gnu.org/licenses/>.
 */
#ifndef PARAMETER_SERVER_H_
#define PARAMETER_SERVER_H_
#include <string>
#include <ros/ros.h>
#include <boost/any.hpp>

//this is a global definition of the points to be used
//changes to omit color would need adaptations in 
//the visualization too
#include "pcl/point_cloud.h"
#include "pcl/point_types.h"
#ifndef RGB_IS_4TH_DIM
typedef pcl::PointXYZRGB point_type;
#else
typedef pcl::PointXYZ point_type;
#endif
typedef pcl::PointCloud<point_type> pointcloud_type;
//#define CONCURRENT_EDGE_COMPUTATION
//Compile out DEBUG Statements. Hardly benefitial though
#define ROSCONSOLE_SEVERITY_INFO 1

/*!
 * \brief Getting values from parameter server.
 * This class is used for getting the parameters from
 * the parameter server
 */
class ParameterServer {
public:
    /*!
     * Returns the singleton instance
     */
    static ParameterServer* instance();

    /*!
     * The method sets a value in the local cache and on the Parameter Server.
     * You can use bool, int, double and std::string for T
     *
     * \param param the name of the parameter
     * \value the new parameter value
     */
    template<typename T>
    void set(const std::string param, T value) {
        if(config.count(param)==0){
          ROS_ERROR("ParameterServer: Ignoring invalid parameter: \"%s\"", param.c_str());
          return;
        }
        try{
          boost::any_cast<T>(value); //fails if wrong param type
        } catch (boost::bad_any_cast e) {
          ROS_ERROR("ParameterServer: Ignoring invalid parameter type: %s", e.what());
          return;
        }
        config[param] = value;
        setOnParameterServer(pre+param, value);
    }

    /*!
     * The method returns a value from the local cache.
     * You can use bool, int, double and std::string for T
     *
     * \param param the name of the parameter
     * \return the parameter value
     */
    template<typename T>
    T get(const std::string param) {
        if(config.count(param)==0){
          ROS_FATAL("ParameterServer object queried for invalid parameter \"%s\"", param.c_str());
          assert(config.count(param)==0);
        }
        boost::any value = config[param];
        try{
          return boost::any_cast<T>(value);
        } catch( boost::bad_any_cast bac){
          ROS_ERROR_STREAM("Bad cast: Requested data type <" << typeid(T).name() << "> for parameter '" << param << "'");
          throw; //Programmer needs to fix this. Rethrow.
        }
    }

    /*!
     * Returns the description text for the named option
     */
    std::string getDescription(std::string param_name);

    /*!
     * Provides access to the raw config data
     */
    std::map<std::string, boost::any>& getConfigData(){
      return config;
    }

    /*!
     * Receives all values from the parameter server and store them
     * in the map 'config'.
     * Will be called in the constructor
     */
    void getValues();
private:
    void addOption(std::string name, boost::any value, std::string description);
    std::map<std::string, boost::any> config;
    std::map<std::string, std::string> descriptions;

    static ParameterServer* _instance;
    std::string pre;
    ros::NodeHandle handle;

    /*!
     * Default constructor
     * private, because of singleton
     */
    ParameterServer();

    /*!
     * Loads the default configuration
     */
    void defaultConfig();

    /*!
     * Checks, whether the parameters are ok
     */
    void checkValues();

    /*!
     * Returns a value from the parameter server
     * Will only be used by getValue()
     *
     * \param param name of the parameter
     * \param def default value (get through defaultConfig())
     *
     * \return the parameter value
     */
    template<typename T>
    T getFromParameterServer(const std::string param, T def) {
        T result;
        handle.param(param, result, def);
        return result;
    }

    template<typename T>
    void setOnParameterServer(const std::string param, T new_val) {
        handle.setParam(param, new_val);
    }
};

#endif /* PARAMETER_SERVER_H_ */

Recently I have found that I dont have libgsl. To install it the easies way is:
sudo apt-get install gsl-bin libgsl0-dev
libqt4, libglev, libdevil and libg2o are not catkin dependencies right?
hmm its seems like g2o is catkin dependency but doesn't provieds it pkg-config file yet ;/
Still got other problems with other things. Please help
I was playing a bit with CmakeLists and now i get this  error:
CMake Error at rgbdslam_freiburg/rgbdslam/CMakeLists.txt:83 (target_link_libraries):
  Cannot specify link libraries for target "rgbdslam" which is not built by
  this project.

-- Configuring incomplete, errors occurred!
make: *** [cmake_check_build_system] Błąd 1
Invoking "make cmake_check_build_system" failed

My CmakeLists looks like that:

This code block was moved to the following github gist:
https://gist.github.com/answers-se-migration-openrobotics/f2d8cdc69dd684dc1b54ab37bd93fcf7

Originally posted by Wilk on ROS Answers with karma: 67 on 2013-12-15
Post score: 1

A:

The error you get is because the pcl library in Hydro is standalone and it isn't anymore a ros package. So you have to comment the corresponding line in the manifest
  <!--<depend package="pcl"/>-->

What you should do is to install the pcl library 1.7 and then use the pcl_conversions package of ros to convert Pointcloud2 headers from pcl type to ros msg and vice-versa where needed, as explained here.

Originally posted by Tirjen with karma: 808 on 2013-12-15
This answer was ACCEPTED on the original site
Post score: 4

Original comments
Comment by Wilk on 2013-12-16:
Thanks You for fast response- I will try it in hope in fallowing days
Comment by Wilk on 2013-12-29:
I still have some problems: I don't know if I understend it well. I'm using catkin tool instead of rosbuild one but I think it is not an issue. All I need to do is to change headers in rgbdslam? Or I need also to change something in pcl library? Is using script posted here a good idea?:
https://github.com/PointCloudLibrary/pcl/pull/110


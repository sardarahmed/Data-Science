Q:

Handling two nodes

Hello guys !
I have created two nodes In my first  node pilot, I am trying to make the quadrotor scan the whole room until it finds a color box and when it finds the color box i stopped my quadrotor and the publish my coordinates to another node 2. But I am getting some errors like in my node 1 my quadrotor stops above the blue box and after the completing of the node i got the following error:
[ERROR] [WallTime: 1403691673.456236] bad callback: <function callback at 0x233ade8>
Traceback (most recent call last):
  **File "/opt/ros/hydro/lib/python2.7/dist-packages/rospy/topics.py", line 682, in _invoke_callback
    cb(msg)
  File "/home/user/catkin_ws/src/my_package/scripts/pilot.py", line 84, in callback
    permanent_stop()
  File "/home/user/catkin_ws/src/my_package/scripts/pilot.py", line 117, in permanent_stop
    cmd.publish(motion)
  File "/opt/ros/hydro/lib/python2.7/dist-packages/rospy/topics.py", line 798, in publish
    self.impl.publish(data)
  File "/opt/ros/hydro/lib/python2.7/dist-packages/rospy/topics.py", line 957, in publish
    raise ROSException("publish() to a closed topic")
ROSException: publish() to a closed topic**

Node 1 (pilot) Code. The following is the first node1 (pilot) . :
#!/usr/bin/env python
import roslib
import sys
import time
import math
import rospy
import cv2
import time
#import cv2.cv as cv
import numpy as np
from std_msgs.msg import Float64
from geometry_msgs.msg import PoseStamped
from geometry_msgs.msg import Vector3
from geometry_msgs.msg import Twist
from geometry_msgs.msg import Wrench
from geometry_msgs.msg import Pose
from geometry_msgs.msg import Point
from sensor_msgs.msg import NavSatFix
from sensor_msgs.msg import CameraInfo
from sensor_msgs.msg import Image
from sensor_msgs.msg import RegionOfInterest
from cv_bridge import CvBridge, CvBridgeError
from rospy.numpy_msg import numpy_msg
a=0
b=0
c=0
timer = 0
#class my_class:
 
def bridge_opencv():
        image_pub = rospy.Publisher("quadrotor/videocamera1/camera_info",Image)

            cv2.namedWindow("Image window", 1)
        
        image_sub = rospy.Subscriber("quadrotor/videocamera1/image",Image, callback)
        
            
def callback(data):
        global timer
        global dis
        global my_var1
        global my_var2
        global my_var3
        global a
        global b
        global c
        bridge = CvBridge()
        try:
            cv_image = bridge.imgmsg_to_cv2(data, "bgr8")
        except CvBridgeError, e:
            print e
        (rows,cols,channels) = cv_image.shape
        if cols > 60 and rows > 60 :
            cv2.circle(cv_image, (50,50), 10, 255)
        #converting bgr to hsv  
        hsv=cv2.cvtColor(cv_image,cv2.COLOR_BGR2HSV)
        # define range of blue color in HSV
            lower_blue = np.array([60,0,0],dtype=np.uint8)
            upper_blue = np.array([255,255,255],dtype=np.uint8)
        # Threshold the HSV image to get only blue colors
            mask = cv2.inRange(hsv, lower_blue, upper_blue)
        new_mask = mask.copy()
        # Bitwise-AND mask and original image
            res = cv2.bitwise_and(cv_image,cv_image, mask= mask)
        #removing noise 
        kernel = np.ones((12,12),np.uint8)
        new_mask = cv2.morphologyEx(new_mask, cv2.MORPH_CLOSE, kernel)
        new_mask = cv2.morphologyEx(new_mask, cv2.MORPH_OPEN, kernel)
        contours, hierarchy = cv2.findContours(new_mask,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)
        cv2.drawContours(cv_image, contours, -1, (0,0,0), 3)
        if(contours):
            cv2.drawContours(cv_image, contours, -1, (0,0,0), 3)
            cnt = contours[0]
            area = cv2.contourArea(cnt)
            #print area 
            if area > 6000:
                print('i found the object')
                print 'timer',timer
                dis = timer*0.4
                print 'dis',dis
                my_var1= a+dis
                my_var2 = b
                my_var3 = c
                permanent_stop()        
        cv2.imshow('mask',mask)
            cv2.imshow('res',res)
        cv2.imshow("Image window", cv_image)
        cv2.waitKey(3)
        
        
def permanent_stop():
    cmd = rospy.Publisher("/quadrotor/rotorcraftvelocity", Twist)   
    global puba
    global pubb
    global pubc
    global my_var1
    global my_var2
    global my_var3  
    print 'var1',my_var1
    print 'var2',my_var2
    print 'var3',my_var3    
    a = my_var1
    b = my_var2
    c = my_var3
    puba.publish(a)
    pubb.publish(b)
    pubc.publish(c)     
    while 1:
        
        motion = Twist()
        motion.linear.x = +0.0
        motion.linear.y = +0.0
        motion.linear.z = +0.0
        cmd.publish(motion) 
        
def stop(x):
        now=time.time()
        global timer
        print 'stop'    
        cmd = rospy.Publisher("/quadrotor/rotorcraftvelocity", Twist)   
        while timer !=x:
            motion = Twist()
            motion.linear.x = +0.0
            motion.linear.y = +0.0
            motion.linear.z = +0.0
            cmd.publish(motion) 
            end = time.time()
            timer = round(end-now)
        
def left():
        now = time.time()
        global timer
        print 'left'
        global b
        cmd = rospy.Publisher("/quadrotor/rotorcraftvelocity", Twist)   
        while timer !=10:   
            motion = Twist()        
            motion.linear.y = -0.4
            cmd.publish(motion)     
            end = time.time()
            timer = round(end-now)
        b = b-4 

def right():
        now=time.time()
        global timer
        print 'right'
        global b
        cmd = rospy.Publisher("/quadrotor/rotorcraftvelocity", Twist)
        while timer !=5:                
            motion = Twist()
            motion.linear.y = +0.4
            cmd.publish(motion) 
            end = time.time()
            timer = round(end-now)
        b = b+2

def straight(x):
        now = time.time()
        global timer
        print 'straight'
        global a
        cmd = rospy.Publisher("/quadrotor/rotorcraftvelocity", Twist)
        while timer !=x:    
            motion = Twist()
            motion.linear.x = -0.4
            cmd.publish(motion)         
            end = time.time()
            timer = round(end-now)
        a = a+16

def back(x):
        now = time.time()
        global timer
        print 'back'
        global a 
        cmd = rospy.Publisher("/quadrotor/rotorcraftvelocity", Twist)
        while timer !=x:
            motion = Twist()
            motion.linear.x = +0.4
            cmd.publish(motion)         
            end = time.time()
            timer = round(end-now)
        a = a-16
        
def up():
        now=time.time()
        global timer
        print 'up'
        global c
        cmd = rospy.Publisher("/quadrotor/rotorcraftvelocity", Twist)
        
        while timer !=10:   
            motion = Twist()
            motion.linear.z = +0.4
            cmd.publish(motion)         
            end = time.time()
            timer = round(end-now)
        c=c+4
    
def my_print():
        global a 
        global b
        global c
        print "a",a
        print "b",b
        print "c",c 
        

def pilot():
    global puba
    global pubb
    global pubc
    rospy.init_node("pilot")    
    #rospy.Subscriber("/quadrotor/pose", PoseStamped, where)
    puba = rospy.Publisher("box_positiona", Float64)
    pubb = rospy.Publisher("box_positionb", Float64)
    pubc = rospy.Publisher("box_positionc", Float64)
    print "my inital position"
    bridge_opencv()
    #mob = my_class()
    my_print() 
    up()
    my_print()
    stop(x=5)   
    left()
    my_print()
    for i in range(1,4):        
        stop(x=20)
        straight(x=40)
        my_print()
        stop(x=20)
        right()
        my_print()
        stop(x=20)
        back(x=40)
        my_print()
        stop(x=20)
        right()
        my_print()
    stop(20)
    
        print('hi') 
    #rospy.spin() # this will block untill you hit Ctrl+C
if __name__ == '__main__':
        pilot()

And in my second node, i tried to move the ground robot to that box(color box). but when i run the node i got the following error :
****user@user-HP-ProBook-6550b:~/catkin_ws$ rosrun my_package ground.py

Traceback (most recent call last):
  File "/home/user/catkin_ws/src/my_package/scripts/ground.py", line 108, in <module>
    ground()
  File "/home/user/catkin_ws/src/my_package/scripts/ground.py", line 32, in __init__
    self.motion()
  File "/home/user/catkin_ws/src/my_package/scripts/ground.py", line 86, in motion
    a = self.x1*self.x1
AttributeError: ground instance has no attribute 'x1'

The following is my node 2 (ground):-
#!/usr/bin/env python
import roslib
import sys
import time
import math
import rospy
import numpy as np
from std_msgs.msg import Float64
from geometry_msgs.msg import PoseStamped
from geometry_msgs.msg import Vector3
from geometry_msgs.msg import Twist
from geometry_msgs.msg import Wrench
from geometry_msgs.msg import Pose
from geometry_msgs.msg import Point
from sensor_msgs.msg import NavSatFix
from sensor_msgs.msg import CameraInfo
from sensor_msgs.msg import Image
from sensor_msgs.msg import RegionOfInterest
from cv_bridge import CvBridge, CvBridgeError
from rospy.numpy_msg import numpy_msg

        

class ground():
    def __init__(self):
        rospy.init_node("ground")
        self.cmd = rospy.Publisher("/atrv/motion", Twist)
            
        rospy.Subscriber("/box_positiona", Float64, self.where1)
        rospy.Subscriber("/box_positionb", Float64, self.where2)
        self.motion()
        #rospy.spin() # this will block untill you hit Ctrl+C
    
    def straight(self,x):
        now=time.time()
        global timer
        while timer !=x:
            motion = Twist()
            motion.linear.x = +0.7
            cmd.publish(motion) 
            end = time.time()
            timer = round(end-now)
    def clockwise(self,x):
        now=time.time()
        global timer
        print 'clockwise'
        while timer !=x:
            motion = Twist()
            motion.angular.z = -2.0
            cmd.publish(motion)         
            cmd.publish(motion)
            end = time.time()
            timer = round(end-now)
    def anticlockwise(self,x):
        now=time.time()
        global timer
        print 'anticlockwise'
        while timer !=x:
            motion = Twist()
            motion.angular.z = +2.0
            cmd.publish(motion)         
            cmd.publish(motion)
            end = time.time()
            timer = round(end-now)
    def stop(self,x):
        now=time.time()
        global timer
        print 'stop'
        while timer !=self.x:
            motion = Twist()
            motion.angular.z = +0.0
            motion.linear.x = +0.0
            cmd.publish(motion)
            end = time.time()
            timer = round(end-now)
    
    def where1(self,msg):
        x1 = self.msg.data
        print x1
    def where2(self,msg):
        y1 = self.msg.data
        print y1
    def motion(self):   
        print 'hi'
    a = self.x1*self.x1
    b = self.y1*self.y1
    c = math.sqrt(a+b)
    #print c
    Z = math.atan2(self.y1,self.x1)
    Z1 = math.degrees(Z)
    print Z1
    if self.Z1 <= 0:
        x = self.Z/2
        anticlockwise(x)
        stop(20)
    elif self.Z1 > 0:
        x = self.Z/2
        clockwise(x)
        stop(20)

    x = c/0.7
    straight(x)
    stop(x=20)
        
if __name__ == '__main__':
    try:
            ground()
    except rospy.ROSInterruptException:
            rospy.loginfo("Ground node is shut down.")

Hoping to see the answers ! I will be really helpful if you could pin point the mistakes and tell me where I am going wrong.

Originally posted by jashanvir on ROS Answers with karma: 68 on 2014-06-25
Post score: 1

Original comments
Comment by dornhege on 2014-06-25:
It might be a good idea to point out, which lines cause the traces. Nobody wants to count lines here. Usually the error messages point to the problem.
Comment by jashanvir on 2014-06-25:
in node 1 its in permanent_stop(): cmd.publish(motion) and in node 2 its self.a =  x1*x1

A:

The publisher cmd is permanent_stop is probably not connected as it is just constructed a couple of lines before.
For the second error: x1 simply does not exist in this function. You probably want to refer to self.x1 everywhere.

Originally posted by dornhege with karma: 31395 on 2014-06-25
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by jashanvir on 2014-06-25:
In node 1. so how can connect the publisher. i mean where i can write that command.
in node 2 . I tried that. and got AttributeError: ground instance has no attribute 'x1'
Comment by dornhege on 2014-06-25:\

This usually happens once when you initialize the node and then you'll pass that around. It is common to put things like this in a class so you don't mess with global variables.

Comment by dornhege on 2014-06-25:
2. You'll have to set that first and/or make sure that it is set.
Comment by jashanvir on 2014-06-30:
can you tell me about the second error. Node 2. ?
Comment by dornhege on 2014-06-30:
You need to set self.x1 somewhere. You only set x1.
Comment by jashanvir on 2014-06-30:
what if i dont use oop ... can i use this by
def where1(msg):
x1=msg.data
def where2(msg):
y1=msg.data
def ground():
rospy.init_node("ground")
rospy.Subscriber("/box_positiona", Float64, where1)
rospy.Subscriber("/box_positionb", Float64, where2)
print x1
print y1
Comment by dornhege on 2014-06-30:
Code in a comment is unreadable. As these are basic python questions unrelated to ROS I'd suggest getting familiar with python, especially scoping, first.


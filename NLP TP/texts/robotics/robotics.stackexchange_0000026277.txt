Q:

SetAngle/SetPosition having erratic effect on Robot model

I have a robot model and I am trying to generate trajectories for each joint of the model. I wan to initilize all the joints to 0. I am using the SetAngle(I also tried set SetJointPosition) to do this for me.
1)All the joints are initially at 0. but as simulation time goes on , the robot as a whole starts moving. i.e it translates Why do I see such a behavior ?
2)After a few seconds the robot completely looses stability and all the joints start to move(change from 0). What is the reason being this ? THough all that the controller does is keeps setting the angle for each joint to 0 every loop iteration.
Is there a solution or a way around this ? I have tried using the PID controller but the problem with it is I do not get good response and I do not reach my exact pointin the required time I want. I have about 10 DOF to control so setting all the right PID gains seem to be tough. Is there a way around this ?
Thanks

Originally posted by Bharadwaj Ramesh on Gazebo Answers with karma: 51 on 2013-04-24
Post score: 0

Original comments
Comment by ffurrer on 2013-04-24:
What version of Gazebo are you using and can you share your model?

A:

In general I would not use setJointPosition or setAngle if you have the physics on, but use some sort of a controller.
If you want a simple one, just use the gazebo PID controller and therefore I use dynamic reconfigure to set the PID values, which is quite convenient for me.
Here's an example of a controller of the drcsim car.
And that's an example how you would get the dynamic reconfigure in. (Or you can check out gazebo_ros_multicamera_utils.cpp
dyn_srv_ = new dynamic_reconfigure::Server<some_plugins::MyConfig>(*this->rosnode_);
dynamic_reconfigure::Server<some_plugins::MyConfig>::CallbackType f = boost::bind(&MyClass::DynamicReconfigureCallback, this, _1, _2);
dyn_srv_->setCallback(f);

void MyClass::DynamicReconfigureCallback(some_plugins::MyConfig &config, uint32_t level)
{
    // Wheel gains
    oneWheelPID.SetPGain(config.p_wheel);
    oneWheelPID.SetIGain(config.i_wheel);
    oneWheelPID.SetDGain(config.d_wheel);
    // Steering gains
    oneWheelSteeringPID.SetPGain(config.p_steering);
    oneWheelSteeringPID.SetIGain(config.i_steering);
    oneWheelSteeringPID.SetDGain(config.d_steering);
}

Originally posted by ffurrer with karma: 349 on 2013-04-24
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Bharadwaj Ramesh on 2013-04-24:
Hi, Thanks for the reply. Like I mentioned in my post I have a PID but I am not able to reach the desired position in desired time and thats the problem that I am trying to correct by using set angles. But to impliment PID control I create PID parameters as described in the following tutorial link :
http://gazebosim.org/wiki/Tutorials/1.3/intermediate/pid_control_joint
Q1) the PID you just suggested much better than the one in the link ?
Q2) y Do you say I shouldnt use the SetAngle commands?
Comment by ffurrer on 2013-04-25:
well the PID in the link is definitely not worse than my suggestion but exactly the same. On the other hand yes, I would say, unless you want to turn off the physics you probably don't want to use the set angle command, since then you are setting values which have nothing to do with the physical course of the links.
Comment by Bharadwaj Ramesh on 2013-04-29:
Hi ffurrer,
I eventually used the PID and it works fine. I had to do a lot of test to tune it though.
Comment by Bharadwaj Ramesh on 2013-04-29:
Hi ffurrer,
I eventually used the PID and it works fine. I had to do a lot of test to tune it though.
Comment by ffurrer on 2013-04-29:
Good, I'm glad it worked out. If you don't want to fiddle with the parameters of a PID, consider using a more sophisticated controller ;)


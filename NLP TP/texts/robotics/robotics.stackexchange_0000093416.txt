Q:

How to stabilize a joint -- keep Ackermann wheels from wobbling

I have an Ackermann steering vehicle I made, which works well enough at slow speed, but when speed increases, the wheels wobble. How can I keep the joints from being pushed around?
I'm accepting a twist message and converting it to the joint controllers.
Here is an example of the wheel.
 <!-- Left Wheel - Start  -->
    <link name="left_wheel"> 
        
        <collision> 
          <origin xyz="0 0 0" rpy="0 1.5708 1.5708" />
          <geometry> 
           <cylinder length="0.05" radius="0.1"/> 
          </geometry> 
        </collision> 

        <visual> 
          <origin xyz="0 0 0" rpy="0 1.5708 1.5708" /> 
          <geometry> 
            <cylinder length="0.05" radius="0.1"/> 
          </geometry> 
          <material name="black"/> 
        </visual>       

        <inertial> 
          <origin xyz="0 0 0" rpy="0 1.5708 1.5708" /> 
          <mass value="0.2"/> 
          <cylinder_inertia m="0.2" r="0.3" h="0.1"/> 
      <inertia ixx="0.4" ixy="0.1" ixz="0.1" iyy="0.4" iyz="0.1" izz="0.2"/> 
      </inertial> 

    </link> 
  <gazebo reference="left_wheel"> 
    <mu1 value="2.0"/> 
    <mu2 value="2.0"/> 
    <kp  value="10000000.0" /> 
    <kd  value="1.0" /> 
    <fdir1 value="0 1 0"/> 
    <material>Gazebo/Blue</material> 
  </gazebo>

    <link name="left_wheel_assembly">
        <collision> 
          <origin xyz="0 0 0" rpy="0 1.5708 1.5708" />
          <geometry> 
           <cylinder length="0.001" radius="0.04"/> 
          </geometry> 
        </collision> 

        <visual> 
          <origin xyz="0 0 0" rpy="0 1.5708 1.5708" /> 
          <geometry> 
            <cylinder length="0.001" radius="0.04"/> 
          </geometry> 
          <material name="white"/> 
        </visual>       

        <inertial> 
          <origin xyz="0 0 0" rpy="0 1.5708 1.5708" /> 
          <mass value="0.2"/> 
          <cylinder_inertia m="0.2" r="0.3" h="0.1"/> 
      <inertia ixx="0.4" ixy="0.1" ixz="0.1" iyy="0.4" iyz="0.1" izz="0.2"/> 
      </inertial>
    </link>  

  <gazebo reference="left_wheel_assembly"> 
    <mu1 value="2.0"/> 
    <mu2 value="2.0"/> 
    <kp  value="10000000.0" /> 
    <kd  value="1.0" /> 
    <fdir1 value="0 1 0"/> 
    <material>Gazebo/White</material> 
  </gazebo>

  <joint name="left_wheel_hinge" type="revolute"> 
    <parent link="chassis"/> 
    <child link="left_wheel_assembly"/> 
    <origin xyz="0.4 -0.125 0.3" rpy="0 0 0" />  
    <axis xyz="0 0 1" rpy="0 0 0" /> 
    <limit effort="100" velocity="1" lower="-1" upper="1"/> 
    <dynamics damping="0.0" friction="0.0"/> 
  </joint> 

  <joint name="left_wheel_rotate" type="continuous"> 
    <parent link="left_wheel_assembly"/> 
    <child link="left_wheel"/> 
    <origin xyz="0.0 -0.025 0.0" rpy="0 0 0" />  
    <axis xyz="0 1 0" rpy="0 0 0" /> 
    <limit effort="0" velocity="0"/> 
    <dynamics damping="0.0" friction="0.0"/> 
  </joint>

  <transmission name="tran2">
    <type>transmission_interface/SimpleTransmission</type>
    <joint name="left_wheel_hinge">
      <hardwareInterface>EffortJointInterface</hardwareInterface>
    </joint>
    <actuator name="motor2">
      <hardwareInterface>EffortJointInterface</hardwareInterface>
      <mechanicalReduction>1</mechanicalReduction>
    </actuator>
  </transmission>

  <transmission name="trans_left_wheel_rotate">
    <type>transmission_interface/SimpleTransmission</type>
    <joint name="left_wheel_rotate">
      <hardwareInterface>EffortJointInterface</hardwareInterface>
    </joint>
    <actuator name="motor_left_wheel_rotate">
      <hardwareInterface>EffortJointInterface</hardwareInterface>
      <mechanicalReduction>1</mechanicalReduction>
    </actuator>
  </transmission>

  <!-- Left Wheel - End -->

And here is my control node:
class TwistToAackermann {
    public:
        TwistToAackermann()
        {
        //Topic you want to publish 
        pubLeftWheelHinge_ = n_.advertise<std_msgs::Float64>("/ack/joint_lwh_position_controller/command", 1);
        pubRightWheelHinge_ = n_.advertise<std_msgs::Float64>("/ack/joint_rwh_position_controller/command", 1);
        pubLeftWheelRotate_ = n_.advertise<std_msgs::Float64>("/ack/joint_lw_velocity_controller/command", 1);
        pubRightWheelRotate_ = n_.advertise<std_msgs::Float64>("/ack/joint_rw_velocity_controller/command", 1); 

        //Topic you want to subscribe
        sub_ = n_.subscribe("/twist_to_ackermann", 1, &TwistToAackermann::callback, this);
        }

        void callback(const geometry_msgs::Twist& msg) {
            // Vehicle wheel base geometry. wheelBase is the distance between front
            // and back axles, track is the distance between left and right wheels.    
            double wheelBase = 1.753;
            double track = 1.245; 
            std_msgs::Float64 lwh; 
            std_msgs::Float64 rwh;
            std_msgs::Float64 lwr;
            std_msgs::Float64 rwr;
            double r = 0;  

            if (msg.angular.z==0 || msg.linear.x==0) {
                lwh.data = 0;
                rwh.data = 0;
                lwr.data = msg.linear.x;
                rwr.data = msg.linear.x;
            }
            else {
                r = msg.linear.x/msg.angular.z; 
                lwh.data = atan(wheelBase/(r-(track/2)));
                rwh.data = atan(wheelBase/(r+(track/2)));
                lwr.data = (r-(track/2))*msg.angular.z;
                rwr.data = (r+(track/2))*msg.angular.z;             }

            //double R = static_cast<double>(msg.linear.x/msg.angular.z); 
            ROS_DEBUG("Test"); 

            //pubADS_.publish(ads); 
            pubLeftWheelHinge_.publish(lwh);
            pubRightWheelHinge_.publish(rwh); 
            pubLeftWheelRotate_.publish(lwr); 
            pubRightWheelRotate_.publish(rwr); 
        }
    private:
        ros::NodeHandle n_;
        ros::Publisher pubLeftWheelHinge_;
        ros::Publisher pubRightWheelHinge_;
        ros::Publisher pubLeftWheelRotate_;
        ros::Publisher pubRightWheelRotate_; 
        ros::Subscriber sub_;
};

int main(int argc, char **argv) {
    ros::init(argc, argv, "twist_to_ackermann");
    
    TwistToAackermann SAPObject; 
    ros::spin(); 

    return 0; 
}

Originally posted by horseatinweeds on ROS Answers with karma: 160 on 2019-09-26
Post score: 0

Original comments
Comment by ahendrix on 2019-09-26:
On real vehicles, we typically increase the caster angle to improve passive stability. See: https://en.wikipedia.org/wiki/Caster_angle

A:

It looks like you might have a cylinder_inertia tag in your links, but then follow up with another inertia tag. If the cylinder_inertia tag sets the inertia property correctly then you can probably delete the next line.
Otherwise, look at the matrix here for a solid cylinder: https://en.wikipedia.org/wiki/List_of_moments_of_inertia#List_of_3D_inertia_tensors
Basically, ixy,  ixz, and iyz should be zero and update ixx, iyy, and izz to be correct (the diagonals of the matrix).

Originally posted by 404RobotNotFound with karma: 331 on 2019-09-27
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by horseatinweeds on 2019-09-28:
Thanks 404RobotNotFound. Fixing the inertia really helped to stabilize the wheels.


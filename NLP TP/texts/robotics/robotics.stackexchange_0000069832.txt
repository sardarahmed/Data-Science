Q:

Best practice: one git repo per package?

Is it against ROS best practices, in our post-stack world, to have multiple ROS packages in a single Git repo?
Conversely, is it ok to have a git repo with several very related packages within? I know some projects do this, and historically this was very common.
Thanks!

Originally posted by Dave Coleman on ROS Answers with karma: 1396 on 2015-10-01
Post score: 5

Original comments
Comment by gvdhoorn on 2015-10-01:
Hesitate to post an answer (as that seems to discourage other contributions), but I've generally put things in one repository only if they should be versioned (released) in sync. Repos per pkg can become difficult to manage / complex for users (what is where?).

A:

I don't think there's a best practice, but there are trade-offs to consider. I try to keep a few potential use cases in mind when deciding how to organize the code:

A user wants to build a few of your packages but not all of them.
The maintainer wants to patch just one package.
The maintainer wants to do a first release of each package.
I want to test a set of changes across multiple packages before merging a pull request.

There are certainly other use cases, but I think these are the ones I run into most often. The two strategies in question are:

to put related packages in the same git/hg repository or
to put each package in a single repository.

For the first use case, the ROS tools make it easier to build only a few packages if they each come from different repositories. If they're all in separate repositories then the user can be provided with a .rosinstall file or use the rosinstall_generator --upstream-development command to get the packages they desire. If instead the packages share a repository with other packages the user doesn't want, then they need to get the common repository and then selectively disable what packages to build by using CATKIN_IGNORE files or by clever us of the build tools, e.g. using catkin_make_isolated --only-pkg-with-deps <leaf package> or catkin build <leaf package>.
For the second use case, if you have one package per repository, then you can increment the version of each package individually. Releasing a patch release in the narrowest scope possible. If you combine packages into a single repository then you're required to have all packages share the same version number, which leads to you needing to increment version numbers of packages even when they do not have changes. This is required because conceptually there is no way to create a version tag, e.g. 0.1.0, for the whole repository if packages don't have the same version. This is also why stacks had versions and packages did not in rosbuild. If you can avoid extraneous new versions of packages it helps the build farm since we don't make use of the ABI versioning and a new version of a package requires all down stream packages to be rebuilt, even if nothing actually changed in that package. Also, unnecessary package version updates require the end-users to download the new .deb files when they do apt-get dist-upgrade, even though they didn't actually change. Later, if we start using ABI compatibility correctly, then some of the negatives from use case are mitigated, but I don't think that's likely to start happening since it requires structural changes the code and extra infrastructures, not just flipping a switch.
For the third use case, you can get a complication when trying to do a first release when packages share a repository but they have indirect dependencies on each other with intermediate dependencies in other repositories. This stems from bloom-release only operating on one repository at a time. For example, if you have repoA which contains pkgA and pkg C as well as repoB which contains pkgB, and pkgA depends on pkgB which depends on pkgC. So now you cannot run bloom on repoA because pkgA depends on pkgB which hasn't been released yet and you cannot run bloom on repoB either since pkgB needs pkgC to be released first. This is uncommon, but I thought I'd mention it.
Finally, one use case which make having one repo for each package cumbersome is testing. In ROS 2 this has been something I've spent time trying to solve, but it's not easy. What happens is that you have a pr against a package's repository which needs changes in another package which is in another repository in order to work. But you cannot use simple tools like travis-ci to test these more complex changes. If you combine packages into a single repository it makes it easier to test cross package changes since the chance that all of the changes are contained within a single repository. Though it doesn't eliminate the problem, since you can have changes across packages which really shouldn't share a repository.
If I try to sum up the issue, it seems that you can make some tasks easier for users of your code by splitting packages into separate repositories and encouraging them to use the ROS dev tools, but that comes at the cost of increased overhead for the maintainer. Splitting packages across repositories also seems to make it more likely that a package can be reused in other projects or even other domains, but that probably depends at least as much on whether you choose to make it a catkin package or just a plain CMake package. The only other thing to consider is discoverability to users. Having code in many places does make it harder for people grok your software stack, but in my experience having a "main" repository with some good leading documentation which points the parts of the system and how to work with it using tools like wstool can overcome this. But again, it's more work for the maintainer to provide a good user experience.

Originally posted by William with karma: 17335 on 2015-10-02
This answer was ACCEPTED on the original site
Post score: 16

Original comments
Comment by Dave Coleman on 2015-10-02:
Wow, what a comprehensive answer, thanks! To sum you up, it really just depends on what packages your are thinking of grouping in a repo and what their relationship is to each other.
Comment by gvdhoorn on 2015-10-02:
Yeah, I would say that is an important factor. Also: developer / maintainer sanity I think :).


Q:

Simple tf transform without broadcaster/listener

I have a vision based control application, where a drone is flying around, finds a visual marker, extracts the coordinates of the visual marker in body frame coordinates and finally flies to the marker with a position setpoint in local NED frame coordinates.
I need to transform the coordinates of the visual marker from body frame to local NED frame based on the position of the drone in local NED coordinates.
I understand that this is possible with a broadcaster + listener, but I don't want to complicate things with extra nodes, all I need is a simple mathematical transformation. Is there a simple function available to do this in C++?

Originally posted by chillax on ROS Answers with karma: 45 on 2018-04-22
Post score: 3

A:

BufferCore is the best way to do it while also maintaining a similar api to regular tf transform sets and lookups ( see also #q258116 ).  There aren't a lot of examples available however.
Python
Here is a simple python example (I adapted it from http://docs.ros.org/diamondback/api/tf2/html/python/tf2.html where the api is different, but did the example survive into kinetic somewhere?  I also had to look at /opt/ros/kinetic/lib/python2.7/dist-packages/tf2_ros/buffer.py)
#!/usr/bin/env python
import rospy
import tf2_ros
from geometry_msgs.msg import TransformStamped

buffer_core = tf2_ros.BufferCore(rospy.Duration(10.0))
ts1 = TransformStamped()
ts1.header.stamp = rospy.Time(0)
ts1.header.frame_id = 'map'
ts1.child_frame_id = 'frame1'
ts1.transform.translation.x = 2.71828183
ts1.transform.rotation.w = 1.0
buffer_core.set_transform(ts1, "default_authority")

# print(dir(buffer_core))
a = buffer_core.lookup_transform_core('map', 'frame1', rospy.Time(0))
print(a)
# ((2.71828183, 0.0, 0.0), (0.0, 0.0, 0.0, 1.0))
b = buffer_core.lookup_transform_core('frame1', 'map', rospy.Time(0))
print(b)
# ((-2.71828183, 0.0, 0.0), (0.0, 0.0, 0.0, 1.0))

ts2 = TransformStamped()
ts2.header.stamp = rospy.Time(0)
ts2.header.frame_id = 'frame1'
ts2.child_frame_id = 'frame2'
ts2.transform.translation.y = 0.5
ts2.transform.rotation.w = 1.0
buffer_core.set_transform(ts2, "default_authority")

print(buffer_core.lookup_transform_core('map', 'frame2', rospy.Time(0)))

https://github.com/lucasw/tf_demo/blob/master/scripts/buffer_core_demo.py
I'm not sure why there isn't a lookup_transform, just lookup_transform_core.
Maybe I should be using a BufferClient?
Rotations can be handled with transforms3d/transformations.py, I'll update the above with an example of that.
C++
Haven't tested this yet but it is very similar to python:
#include <tf2/buffer_core.h>
...
tf2::BufferCore buffer_core;
geometry_msgs::TransformStamped ts1;
ts1.header.frame_id = "map";
ts1.child_frame_id = "frame1";
ts1.transform.rotation = tf::createQuaternionMsgFromRollPitchYaw(0, 0.32, 0);
const bool is_static = true;
buffer_core.setTransform(ts1, "default_authority",
    is_static);
geometry_msgs::TransformStamped ts_lookup;
ts_lookup = buffer_core.lookupTransform("map", "frame1",
    ros::Time(0));

Originally posted by lucasw with karma: 8729 on 2018-04-22
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by chillax on 2018-04-22:
Thank you so much for the quick reply. I am working with C++, therefore the example would be very much appreciated.
Comment by lucasw on 2018-04-22:
Take a look at the updated answer


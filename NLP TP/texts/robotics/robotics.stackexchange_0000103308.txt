Q:

MoveItPy vs MoveItCommander/MoveGroupPython

I am confused on the new MoveItPy python bindings  for MoveIt2.
I used moveit_commander or move_group_python_interface python interface in MoveIt in the past, and thought the new bindings would be equivalent, but I don't think they are.
The tutorial for MoveItPy did not reveal the difference, which is quite fundamental IMHO and can influence how to setup the pipeline or how to migrate an old pipeline.  I also did not find an updated Concept diagram replacing moveit_commander with MoveItPy to help clarify where MoveItPy inserts itself.
I use this question to ask for a confirmation that I understood the difference, and maybe guide others.

moveit_commander: In my understanding, moveit_commander worked like this :

UserApp (py) -> moveit_commander
(binding) ->  MoveGroupInterface (cpp)
-> actions -> MoveGroup capability (cpp) -> MoveitCPP core functions
(cpp)

MoveGroup capability was started in a node for a specific robot + planner + controller settings. There could be several UserApps running in nodes, connecting to "MoveIt" core functions in a separate unit via the move_group_interface and actions. Usually one would startup a robot_bringup + moveit move_group node for that robot, and later user apps would connect to the running MoveIt core through the actions.

MoveItPy What I understood from MoveItPy:

UserApp (py) -> MoveItPy (binding)->
MoveitCPP

The UserApp in python instantiates MoveItPy, which itself starts up the whole Moveit2 core, for a specific robot (all robot and moveit params must be given). There is no "core" MoveIt running independently of the user app.
Is that correct ?
So in that diagram for a python only usage, MoveGroup block should be replaced directly by MoveItPy and moveit commander does not exist, and there is no arrow between the user app (black terminal above moveit commander) and MoveItPy as it needs to be instantiated by the user app.
In case I am correct, for existing pipelines based on the availability of MoveGroup actions, and then connecting to them and/or using MoveItCommander to do so, MoveItPy is not a straight forward switch, especially if the startup of the UserApp + access to MoveIt was done separately from the MoveIt core functions.

Originally posted by GuiHome on ROS Answers with karma: 242 on 2023-05-25
Post score: 1

A:

Your answer is correct and especially for people expecting the traditional use-case it would be a good idea to add a disclaimer to the tutorial page pointing out that difference.
Concerning the ROS one moveit_commander, you described the usual use-case correctly, but keep in mind that especially inverse kinematics is also implemented directly in the wrapped cpp methods:
UserApp (py) -> moveit_commander (binding) -> MoveGroupInterface (cpp) -> MoveitCPP core functions (cpp)

This mix is rather powerful, but also quite hard to maintain.
A python-only interface that focuses only on ROS interfaces is moveit_python, but it is also rather limited and does not support ROS2 yet afaik.
As of today there is no official python-only wrapper that replicates the ROS-interface-based use in ROS2.
We definitely endorse such a wrapping again. It should not replicate the API of moveit_commander though, but be more aligned with the current moveit_py.
Please also note that the decision to keep a single move_group node around with some C++ data structures was taken over a decade ago, also due to more-limited resources, and comes with its pros and cons (mainly, reducing problems with data consistency vs planning limited to sequential requests) and many use-cases these days have different requirements.
That does, of course, not mean that the move_group approach is bad, just that it's good to keep an open mind.

Originally posted by v4hn with karma: 2950 on 2023-05-26
This answer was ACCEPTED on the original site
Post score: 1


Q:

Is there any way to subscribe a topic in message_filter and not filtering it?

Hi,
I am subscribing two topics (servo position and laser scan) in message_filter for my application. Now, when I use approximate_time_synchronizer, as laser scan publishes in low frequency, callback function provides servo data at the laser scan frequency. I also need to use the original servo position topic along with these two (laser and servo) that comes as output of message_filter. I am finding trouble in using shared_memory access to access the original servo data across multiple processes. Is there any provision in ros message_filter that I subscribe some topic in message_filter and do not use it during filtering and that is accessible in the callback as well. Please let me know if any thing like that is feasible?
code:
void callback(const dynamixel_msgs::JointState::ConstPtr& msg, const sensor_msgs::LaserScan::ConstPtr& scan_in)
{
    ROS_ERROR("Enter Publish");
    servo_pos = servo_position.push_front();
    lidar_scan = laser_frame.push_front();
}

int main(int argc, char** argv)
{
    ros::init(argc, argv, "message_filter_node");
    //  ros::Time::init();
    ros::NodeHandle nh;
    //  ROS_INFO("start message filter");
    // subscribers *********************************************************************************
    message_filters::Subscriber<dynamixel_msgs::JointState> position_sub(nh, "/tilt_controller/state", 1);
    message_filters::Subscriber<sensor_msgs::LaserScan> Hokuyo_sub(nh,"/scan" , 1);
    // *********************************************************************************************
    typedef message_filters::sync_policies::ApproximateTime<dynamixel_msgs::JointState, sensor_msgs::LaserScan> MySyncPolicy;

    // ApproximateTime takes a queue size as its constructor argument, hence MySyncPolicy(10)
    message_filters::Synchronizer<MySyncPolicy> sync(MySyncPolicy(10), position_sub, Hokuyo_sub);
//    message_filters::Cache<std_msgs::String> cache(position_sub, 10);
//    cache.registerCallback(callback);
    //  message_filters::TimeSequencer<std_msgs::String> seq(sub, ros::Duration(0.1), ros::Duration(0.01), 10);
    sync.registerCallback(boost::bind(&callback, _1, _2));

    ros::spin();
    return 0;
}

Originally posted by Spartan_007 on ROS Answers with karma: 73 on 2017-11-06
Post score: 0

Original comments
Comment by ahendrix on 2017-11-06:
I don't understand what you're asking. The message_filter callback will be called at the slowest rate with the most recent message on both topics, so you already have the most recent data in your callback.
Comment by Spartan_007 on 2017-11-06:
you are right that message_filter callback will be called at the slowest rate. I need the original servo topic also in the same program to do further processing of laser data. Is there any way to access the unfiltered version as well? Because I can't subscribe it without using threading right?
Comment by ahendrix on 2017-11-06:
You can create an additional subscriber with a different callback which receives just the server data.
Comment by Spartan_007 on 2017-11-06:
This is what I don't understand. I edited my original question and provided section of code. I want two dynamixel_msgs::JointState topic and one laser scan topic available within the 'Callback' function. If I create additional subscriber I doubt if there will be any problem with the performance.
Comment by Spartan_007 on 2017-11-06:
If I write one callback within message_filter callback, and store  the original dynamixel_msgs topic in a global variable within inner callback, and then come out of inner callback and perform the processing that I want; does it sound reasonable. I am not sure.

A:

I am finding trouble in using
shared_memory access to access the
original servo data across multiple
processes.

This is not possible. If the publisher and subscriber run in different processes, i.e., nodes, the subscriber will receive a copy of the published Message Data. The value will be the same, but it won't point the same memory. If you Change anything in the received Message, the publisher won'tâ€‹ bei effected.
In case of nodelets no copy ist done, i.e., Publisher and subscriber use shared memory, if shared pointers are Usedom. However, modifying the ptr in the callback, Reading after publish is not allowed/intended and may result in undefined behavior.
If you need to share Information From the subscribing node to the publishing node, you will need a different architecture, e.g., publishing Back the modified Message or Set Up a service call...

Originally posted by Wolf with karma: 7555 on 2017-11-08
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Spartan_007 on 2017-11-08:
I agree. But I was looking into various inter process communication methods. Even though I publish a topic and subscribe the same from different node, there must be some way to access the memory (memory mapping) across multiple processes.
Comment by Wolf on 2017-11-09:
Nodes may run on different machines an in this constellation this would be physically Not possible.


Q:

Is it safe and efficient for several threads to share a single tf::TransformListener object?

I am developing a multi-threaded ROS (kinetic/melodic) node that will rely on tf::TransformListener to wait until it is possible to perform transformations (using waitForTransform(...)), and then perform the transformations (using lookupTransform(...)), if the transform exists.
My question is whether or not it is safe and efficient for all threads to share a single tf::TransformListener object:

Is it safe for several threads to call methods on a single tf::TransformListener object simultaneously?
If a thread calls one of the above-mentioned methods, will any other thread be able to call the same (or another) method on the same tf::TransformListener object and run in parallel with the first thread, or will the second thread be blocked until the first thread has finished its call? Having the threads running in parallel, without blocking, is of high importance.
In case threads would block (then to avoid threads from blocking), would it be okay to have several tf::TransformListener objects running inside a single node (one listener for each thread inside the node)? My intuition says that the same transformation trees would be built and maintained for each thread, which I think seems very bad from an efficiency point of view.

I apologize for any duplicate posting (I was unable to find the answer in the forum) but would be grateful for any answer you could provide!

Originally posted by AndreasGustavsson on ROS Answers with karma: 33 on 2019-01-23
Post score: 3

Original comments
Comment by gvdhoorn on 2019-01-23:
The design docs at least mention the words "thread safe" (here).

A:

It is safe and efficient to call any of the public API methods.  This is how it was designed.
It is highly recommended to only have one TransformListener, with multiple threads querying it. On most systems the largest overhead of the tf system is subscribing to the transform data and storing the data.
There are a few mutexes around iterable data structures to protect them from being corrupted by simultaneous operations. Queries are quite fast and will not sit and wait unless you ask for a timeout. But when they're in the timeout period they will not block other threads to have access.
However, from your description it sounds like you should rethink your design and not use waitForTransform. If you're going to be waiting on lots of data you should use a tf2::MessageFilter Here's a tutorial
If you want more details on the design and efficiency see the tf paper

Originally posted by tfoote with karma: 58457 on 2019-01-23
This answer was ACCEPTED on the original site
Post score: 5

Original comments
Comment by gvdhoorn on 2019-01-23:
+100 for tf2::MessageFilter.
Comment by AndreasGustavsson on 2019-02-05:
Thank you so much for the answer and tip, Tully (@tfoote). I have managed to redesigned the structure, which is now relying on tf2 and tf2::MessageFilter instead of tf. It's running great and the code actually looks much nicer!
Comment by M@t on 2020-08-05:
That tutorial link solved a huge number of timing issues for me, because I haven't found an example of how to set up the TF2 buffer as a member variable anywhere else.


Q:

A less-asyncronous way of using ROS2 action clients?

Hello, I am a little while into developing my first ROS2 project as someone totally new to ROS. My last couple of posts may provide some useful context of how I arrived at this issue but essentially my 'robot' has a set of actions and services for reading sensors or operating actuators, and then I use nodes without a real defined ROS type (such as client) which I have been calling 'drivers' to then put all the needed clients and subscribers needed to perform an operation into. I like this design because by just using some additional protocol within the server to identify the clients it is fairly easy to control access so that multiple drivers(clients) can use the same service or action in a coordinated manner as not to conflict. I am not sure if there's any issues with this approach, I would be happy to hear them, but it just seemed like the best approach I could come up with on my own.
This is working just fine when it comes to service clients in the 'drivers' but I am looking for a 'less-asynchronous' way of using the action clients than what the tutorial demonstrates, using something like the spin_until_future_complete method but I have not been successful in getting the response back.
The operation would look something like this:

move to position 1 (action)

read a set of 3 sensors and post to topics (services)

move to position 2 (action)

read sensors again, etc...

so I do not need to do anything in this node while the action is happening, just wait for it to finish. Using service clients it looks something like this:
    # set light level
def set_light(self, light_number, power_level):
    # create service request
    request = LightSet.Request()
    request.light_number = light_number
    request.power_level = power_level
    request.driver_status = self.driver_status

    # send request
    future = self.set_light_client.call_async(request)
    # recieve response
    rclpy.spin_until_future_complete(self.set_light_node, future)
    # processing
    if(future.result() is not None):
        result: LightSet.Response = future.result()
        if(result.success):
            self.get_logger().info('light {} set to {}'.format(light_number, result.confirm_level))
        else:
            self.get_logger().error('light setting failed')
    else:
        self.get_logger().error('light service call failed: {}'.format(future.exception()))

and my interpretation of using action clients in this manner has looked something like this but it does not work as I can only seem get ClientGoalHandle objects back and not the actual response
    # move to target
def move_to_target(self, target):
    # send goal to move x action server
    # create goal
    goal_msg = AxisControl.Goal()
    goal_msg.driver_status = self.driver_status
    goal_msg.target = target
    # wait
    self.move_x_client.wait_for_server()
    # send request
    future = self.move_x_client.send_goal_async(goal_msg)
    # recieve response
    rclpy.spin_until_future_complete(self.move_x_node, future)
    # process response
    if future.result() is not None:
        # self.get_logger().info(future.result)
        result: AxisControl.Result() = future.result().result
        if(result.complete):
            self.get_logger().info('move finished')
            return True
        else:
            self.get_logger().info('move failed')
            return False

Using the callback based approach everything seems to work OK but I am just finding it to be much more of a pain to program a simple synchronous operation like this than it seems like it should be, perhaps I am just over thinking it. Is it possible to use action clients in this synchronous manner or do I need to use the callback approach? If it has to be callback could you maybe show/link an example of what a simple, multi step operation looks like with that?
Additionally, I attempted using the 'send_goal' method but all documentation suggests I should not be using these synchronous clients (why are they there?) but regardless, it did not get me the action response either.

Originally posted by masynthetic on ROS Answers with karma: 55 on 2021-04-28
Post score: 1

A:

I found the following way using asynchronous callbacks modified from the docs:
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node

from action_msgs.msg import GoalStatus
from action_tutorials_interfaces.action import Fibonacci

class FibonacciActionClient(Node):

    def __init__(self):
        super().__init__('fibonacci_action_client')
        self._action_client = ActionClient(self, Fibonacci, 'fibonacci')
        self.status = GoalStatus.STATUS_EXECUTING

    def send_goal(self, order):
        self.status = GoalStatus.STATUS_EXECUTING
        goal_msg = Fibonacci.Goal()
        goal_msg.order = order

        self._action_client.wait_for_server()

        self._send_goal_future = self._action_client.send_goal_async(goal_msg, feedback_callback=self.feedback_callback)

        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected :(')
            return

        self.get_logger().info('Goal accepted :)')

        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def get_result_callback(self, future):
        result = future.result().result
        self.get_logger().info('Result: {0}'.format(result.sequence))
        self.status = GoalStatus.STATUS_SUCCEEDED

    def feedback_callback(self, feedback_msg):
        feedback = feedback_msg.feedback
        self.get_logger().info('Received feedback: {0}'.format(feedback.partial_sequence))

def main(args=None):
    rclpy.init(args=args)
    action_client = FibonacciActionClient()
    action_client.send_goal(10)

    while action_client.status != GoalStatus.STATUS_SUCCEEDED:
        rclpy.spin_once(action_client)

    action_client.get_logger().info('All done!')
    action_client.destroy_node()

if __name__ == '__main__':
    main()

You can also use this method to make successive calls to action_client.send_goal() and it will wait until each goal is done before the next goal is called.  You just have to have the while loop inside the for loop, i.e:
def main(args=None):
    rclpy.init(args=args)
    action_client = FibonacciActionClient()

    goals = [10, 11, 12, 13, 14, 15]

    for goal in goals:
        
        action_client.send_goal(goal)

        while action_client.status != GoalStatus.STATUS_SUCCEEDED:
            rclpy.spin_once(action_client)

    action_client.get_logger().info('All done!')
    action_client.destroy_node()

Originally posted by synaptic with karma: 36 on 2021-05-03
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by masynthetic on 2021-05-03:
thanks a lot for your answer! I think this is exactly what I am looking for, I will work on integrating it


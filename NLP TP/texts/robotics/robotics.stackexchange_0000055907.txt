Q:

ROS Answers SE migration: Wall Follower

Hi, i am a really new in coding. I would like to code a wall follower so that my kobuki is able to move along the wall. When i try to run the code, kobuki is not moving. Can anyone help me out here please? Thanks alot.
#include "ros/ros.h"
#include "sensor_msgs/LaserScan.h"
#include "hokuyo/hokuyo.h"
#include "std_msgs/String.h"
#include <geometry_msgs/Twist.h>
#include <sstream>
using namespace std;
float range[555], hit[555];

int z = 0;
void scanCallback(const sensor_msgs::LaserScan::ConstPtr& scan_msg)
{ 
  cout << z; z++;
/** this is to verify whether i am able to obtain the data i need*/
  ROS_INFO("I see: %u", scan_msg->header.seq);
  ROS_INFO("I see: %f", scan_msg->angle_min);
  ROS_INFO("I see: %f", scan_msg->time_increment);
    for (int y=150; y<=155; y++)
        {
    ROS_INFO("I see: %f", scan_msg->ranges[y]); 
    }
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, "wall_listener");
  ros::NodeHandle n;

  ros::Subscriber sub = n.subscribe("scan", 1000, scanCallback);

  ros::Publisher cmd_vel = n.advertise<geometry_msgs::Twist>("cmd_vel", 1000);

    for (int y=150; y<=1406; y++)
        {
    geometry_msgs::Twist move_cmd;
        move_cmd.angular.z = 0.2;
    move_cmd.linear.x = 0.5;
    cmd_vel.publish(move_cmd);  
    }

  ros::spin();

  return 0;
}

Originally posted by chao on ROS Answers with karma: 153 on 2013-12-05
Post score: 0

A:

Hello chao,
I'm not 100% sure but my guess is that you get so many scan messages that you cannot publish anything (your node processes the callback function all the time).
To verify that you should use the command:
rostopic echo /cmd_vel

in your console. If you don't see any messages published to that topic, then it is obvious that you cannot publish. rostopic
Try doing this:
//#include ...    
ros::Publisher cmd_vel;
int z = 0;
void scanCallback(const sensor_msgs::LaserScan::ConstPtr& scan_msg)
{ 
    //cout << z; z++;
    /** this is to verify whether i am able to obtain the data i need*/
    ROS_INFO("I see: %u", scan_msg->header.seq);
    ROS_INFO("I see: %f", scan_msg->angle_min);
    ROS_INFO("I see: %f", scan_msg->time_increment);
    for (int y=150; y<=155; y++)
    {
    ROS_INFO("I see: %f", scan_msg->ranges[y]); 
    }

    for (int y=150; y<=1406; y++)
    {
        geometry_msgs::Twist move_cmd;
        move_cmd.angular.z = 0.2;
        move_cmd.linear.x = 0.5;
        cmd_vel.publish(move_cmd);
    }

}

int main(int argc, char **argv)
{
    ros::init(argc, argv, "wall_listener");
    ros::NodeHandle n;

    ros::Subscriber sub = n.subscribe("/scan", 1000, scanCallback);

    cmd_vel = n.advertise<geometry_msgs::Twist>("/cmd_vel", 1000);

    ros::spin();

    return 0;
}

This is not the best programming practice. Your code needs to be organized a lot, however; it makes more sense to me this way and hopefully, you can understand the logic more easily. Now it says in your callback function that if you get a message from your laser,if you see anything, then publish cmd_vel commands.

Originally posted by yigit with karma: 796 on 2013-12-05
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by chao on 2013-12-06:
Hi Yigit, it works i think. I have tried it on arbotix simulator and robot starts moving! Thanks alot :)
Comment by yigit on 2013-12-06:
You are welcome. Glad I could help.


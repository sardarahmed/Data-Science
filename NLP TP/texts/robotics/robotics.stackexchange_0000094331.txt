Q:

What happens if I use c++ 17 features in my ros nodes?

In the ROS manual/wiki you can see, that ROS is only made for C++11. But what exactly does that mean? What happens if I just put add_compile_options(-std=c++17) in the CMakeLists.txt of my ROS-package and use C++17-features anyway? Specifically: Is it possible to use parallel std::for_each from C++17 in my ROS-nodes?

Originally posted by max11gen on ROS Answers with karma: 164 on 2020-01-09
Post score: 2

Original comments
Comment by gvdhoorn on 2020-01-09:\

In the ROS manual/wiki you can see

please always link to pages you are referring to. Right now we don't know what you "see" exactly.
Comment by max11gen on 2020-01-09:
@gvdhoorn I know, sorry. The thing was just, that I couldn't actually find where exactly I had read that, but I rather just had it in the back of my head.

A:

ROS is only made for C++11

this is actually not really true.
For ROS 1: Melodic has lifted the max version to C++14 (see here).
For ROS 2: all ROS 2 versions target C++14 by default (see REP-2000, search for "Minimum language requirements").

What happens if I just put add_compile_options(-std=c++17) in the CMakeLists.txt of my ROS-package and use C++17-features anyway?

Nothing. It probably will just work, as long as your C++17 object code is ABI compatible with whatever libraries you are linking against.
In other words: you'll potentially run into the exact same problems you could have with ABI incompatibilities between libraries when not using ROS.

Originally posted by gvdhoorn with karma: 86574 on 2020-01-09
This answer was ACCEPTED on the original site
Post score: 6

Original comments
Comment by max11gen on 2020-01-09:
Thanks for your answer. But how can I find out, if the object code is ABI compatible after all? Will I get errors if the compatibility is not given, or can it happen that there will be just arbitrary, undefined behaviour occurring?
Comment by gvdhoorn on 2020-01-09:
Yes, could be linking errors, could also be SEGFAULTs. I can't give you a more definitive answer unfortunately.
As I wrote: there is nothing really ROS specific here. It's essentially plain C++.
From my own personal experience though: C++03 + C++11 was troublesome (std::string etc). C++11 and newer has not been a problem for me so far (ie: combining binary artefacts compiled with these different versions). But again: personal experience, so this is not a guarantee everything will work.
Comment by pavel92 on 2020-01-09:
In addition to above-mentioned, you can also use the set_properties macro in CMakeLists to set cpp standards for specific targets only (where you know you need c++17 for example) within a package instead for the whole package as it is done with add_compile_options. Here is an example which applies the c++17 standard for a defined executable:
set_property(TARGET my_executable PROPERTY CXX_STANDARD 17)
set_property(TARGET my_executable PROPERTY CXX_STANDARD_REQUIRED ON)

Comment by max11gen on 2020-01-09:
@gvdhoorn Alright, thanks for your help!
Comment by max11gen on 2020-01-09:
@pavel92 Great hint, thanks.
Comment by gvdhoorn on 2020-01-09:
I would use target_compile_features(..) with a meta-feature instead, but it depends on your CMake version whether that is available.
Comment by audrius on 2021-05-23:
We do not have any issues with linking our C++17 code to noetic. Everything builds and runs just fine, with all tests passing.
Comment by allsey87 on 2022-05-25:
It depends a bit on the compilers in use. For example, if you use one version of GCC to build everything then you are fine to link C++11, 14, and 17 code together (see https://stackoverflow.com/a/49119902/5164339)


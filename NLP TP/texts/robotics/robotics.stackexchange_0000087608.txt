Q:

Message Types Case Sensitve?

Are message types or names in ROS supposed to be case sensitive? That is, are uint64 and Uint64 the same or different? Are Std_Msgs and std_msgs the same or different? Thank you.

Originally posted by 3Towers International on ROS Answers with karma: 3 on 2018-06-29
Post score: 0

A:

Message types and package names are case sensitive in both C++ and Python in ROS, so each of the examples you give will be different. If you try to use different cases, you will get compile errors in C++ (saying it can't find the header file you're trying to include) and import errors in Python, so it won't let you get very far using a different case.
EDIT: As a summary of the comment thread, there is a difference between the message types (e.g. UInt64.msg) and the primitive types that define the data attributes on those messages (e.g. uint64). It is indicated on the documentation for the std_msgs package that those messages are not intended for long-term use, since they each name their data attributes "data", and that it is better to define your own with more descriptive names for the data stored on the message. It seems the std_msgs messages are more intended to show what primitive data types are available, and how to include them in your own message definitions.

Originally posted by adamconkey with karma: 642 on 2018-06-29
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by 3Towers International on 2018-06-29:
That was my first belief. And if we look at the package names, this may hold because all of them are in lowercase chars, such as geometry_msgs.However, while the msg files are in First letter cap, or camel case, the specification is all in lowercase. Example Uint64.msg but uint64 in format specs.
Comment by gvdhoorn on 2018-06-29:
The two types you mention (UInt64.msg and uint64) are not the same. One is a message, the other a primitive.
Comment by 3Towers International on 2018-06-29:
When will you use the UInt64.msg? All I have seen are uint64 declaring field types? Maybe, we could use the UInt64 msg directly in some connections. It just makes me wonder, and confused, that all packages I saw would still create a userMessage defining one field of primitive type, tho name not data
Comment by adamconkey on 2018-06-29:
It says in the documentation for std_msgs that those messages are not intended for long-term use. I suspect they are intended to show you which primitive types are available and how to build up your own messages from them.
Comment by 3Towers International on 2018-06-29:
Thanks everyone!
Comment by gvdhoorn on 2018-06-30:
@aconkey: std_msgs is not really 'an example'. You cannot publish primitive types, so they need to be wrapped in a msg. If you do that, you get std_msgs. The remark about it being better to design your own msgs is about semantics: if you see a topic that carries a UInt64, can you tell ..
Comment by gvdhoorn on 2018-06-30:
.. me what the data it carries means? I'm pretty sure your first question would be: "well, what does the uint64 encode?". And that is exactly the problem. Without asking the author, reading documentation or code, you wouldn't know.
Semantically meaningful msgs try to address this, as the ..
Comment by gvdhoorn on 2018-06-30:
.. msg itself contains msg fields with descriptive names that on their own give you enough information to be able to interpret it.
That is obviously the idea, whether it always works is something else, but you'll at least stand a better chance with a proper msg than with a UInt64.
Comment by adamconkey on 2018-06-30:
But when you are defining your own messages, you define them with primitive types, not std_msgs. It's possible on your msg to use std_msgs/String, but that seems to just complicate it when you can use primitive string.
Comment by gvdhoorn on 2018-06-30:\

But when you are defining your own messages, you define them with primitive types

true. But I don't really see how that relates to what I explained about std_msgs.
Comment by adamconkey on 2018-06-30:
I meant from a usage perspective it seems like a different sort of package, in that you're typically not using the msg types defined by the package directly. Of course, I realize now Header is in std_msgs, and that is used quite often. So you're right "example" is not the right way to talk about it.


Q:

GenericPublisher using ShapeShifter and SerializedMessage

Hi there,
I want to write a generic publisher that is able to publish ros-topics where each instance of this class publishes topics of different message types (e.g. pub_1 publishes std_msg::Int32, pub_2 publishes sensor_msgs::PointCloud2,...).
I work with serialized messages, i.e.:
ros::serialization::IStream i_stream((u_int8_t*) testArray.data(), m_genericRosTopic.SerializedMessageSize);

contains my serialized message which I want to publish. I also know the message type and the topic_name, that I want to publish on.
How can I do this in a generic way?
I saw that the ros::Publisher class has a publish() function that is able to publish a ros::SerializedMessage.
Thus, I made a SerializedMessage from the IStream:
boost::shared_array<uint8_t> buf(i_stream.getData());
ros::SerializedMessage msg(buf, i_stream.getLength());

My generic publisher class has a ros::Publisher as a member. For advertising, I found:
m_genericRosTopic_publisher = m_shapeShifter.advertise(n, m_genericRosTopic.TopicName, 10);

After that I would like to publish the topic somehow:
m_genericRosTopic_publisher.publish(msg);

Publishing like this doesn't work. I guess there is still something missing.
But it seems that everything I need is already there (somewhere in roscpp), but I am not able to put the puzzle together.
Can someone help me out here, by clarifying the correct usage of topic_tools::ShapeShifter, ros::SerializedMessage and ros::Publisher?
Thanks for your help!

Originally posted by Felix Messmer on ROS Answers with karma: 198 on 2011-12-11
Post score: 1

A:

I solved the problem:
The ByteArrayMessage::serialize function is called as soon as a subscriber subscribes to the topic published by the GenericPublisher. The publisher than has to write the data from buffer_ to the write_ptr given by the subscriber.
Thus the function looks like this:
const uint8_t* ByteArrayMessage::serialize(uint8_t *write_ptr, uint32_t seq) const
{
    ros::serialization::OStream stream(write_ptr, 1000000000);
    for (size_t i = 0; i < length_; i++) 
    {
      stream.next(buffer_[i]);
    }

    return stream.getData();
}

I don't need the Serializer struct.
Thanks for your help!

Originally posted by Felix Messmer with karma: 198 on 2011-12-19
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Felix Messmer on 2011-12-19:
Hmm. It works under electric! So what is the deprecated part? The functions of the Serializer are not used. What am I missing?
Comment by Lorenz on 2011-12-19:
Don't forget that the interface you are implementing is already deprecated. Your code will not work under electric and newer ROS releases.
Comment by Mehdi. on 2017-09-11:
Hey Lorenz, do you have that code anywhere? I couldn't find it on your Github


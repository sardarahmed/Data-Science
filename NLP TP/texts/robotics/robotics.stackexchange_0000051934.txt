Q:

ImportError with custom action in python

Ubuntu 12.04, Groovy, catkin build
I am trying to define a custom action for a rospy node.
my_foo.py starts with:
#!/usr/bin/env python

import actionlib
import rospy
from geometry_msgs.msg import Twist
from my_foo.msg import *

When I run the node with rosrun, it yields the error:
Traceback (most recent call last):
  File "/home/johndoe/groovy-workspace/src/dcslROS/my_package/src/my_package/my_foo.py", line 16, in <module>
    import my_foo.msg
  File "/home/johndoe/groovy-workspace/src/dcslROS/my_package/src/my_package/my_foo.py", line 16, in <module>
    import my_foo.msg
ImportError: No module named msg

I have tried renaming the python package to not match the ROS package name and changing the setup.py file accordingly but that yielded the same error. The message build files are generated into devel/lib/python2.7/dist-packages/my_foo/msg but are not being found at run time.
My file structure is:
/my_foo
  package.xml
  CMakeLists.txt
  setup.py
  /action
    CustomAction.action
  /src
    my_node1.cpp
    /my_foo
      my_foo.py
      __init__.py

Setup.py:
#!/usr/bin/env python

from distutils.core import setup
from catkin_pkg.python_setup import generate_distutils_setup

d = generate_distutils_setup(
    packages=['my_foo'],
    package_dir={'': 'src'}
)

setup(**d)

init.py is an empty file.
CustomAction.action contains:
# Determine whether to connect
bool connect # True = connect robot, False = Do nothing
---
# Determine if successfully connected
bool connected # True = Connected, False = Not connected
---
# Determine if robot is still connecting
bool in_progress # True = still connecting, False = finished

package.xml
<package>
  <name>my_foo</name>
  <version>0.1.0</version>
  <description>
    Description
  </description>
  <maintainer email="foo@aol.com">
    John Doe
  </maintainer>
  <license>BSD</license>

  <url type="website">http://ros.org/wiki/my_foo</url>
  <!-- <url type="bugtracker"></url> -->

  <author>John Doe</author>
  
  <buildtool_depend>catkin</buildtool_depend>

  <build_depend>std_msgs</build_depend>
  <build_depend>geometry_msgs</build_depend>
  <build_depend>rospy</build_depend>
  <build_depend>roscpp</build_depend>
  <build_depend>actionlib</build_depend>
  <build_depend>actionlib_msgs</build_depend>
  <build_depend>genmsg</build_depend>
  <!-- <build_depend>joy</build_depend> -->
  <!-- <build_depend>turtlebot_teleop</build_depend> -->
  <run_depend>std_msgs</run_depend>
  <run_depend>geometry_msgs</run_depend>
  <run_depend>rospy</run_depend>
  <run_depend>roscpp</run_depend>
  <run_depend>actionlib</run_depend>
  <run_depend>actionlib_msgs</run_depend>
  <run_depend>genmsg</run_depend>
  <run_depend>joy</run_depend>
  <run_depend>turtlebot_teleop</run_depend>
  <!-- <test_depend>std_msgs</test_depend> -->
  <!-- <test_depend>geometry_msgs</test_depend> -->
  <!-- <test_depend>rospy</test_depend> -->
  <!-- <test_depend>roscpp</test_depend> -->
  <!-- <test_depend>joy</test_depend> -->
  <!-- <test_depend>turtlebot_teleop</test_depend> -->

  <export>

  </export>
</package>

CMakeLists.txt
# http://ros.org/doc/groovy/api/catkin/html/user_guide/supposed.html
cmake_minimum_required(VERSION 2.8.3)
project(my_foo)

# Load catkin and all dependencies required for this package
set(CATKIN_DEPS std_msgs geometry_msgs rospy roscpp genmsg actionlib actionlib_msgs)
set(SYS_DEPS python-bluez python-sys)
find_package(catkin REQUIRED COMPONENTS ${CATKIN_DEPS})

# Set the build type.  Options are:
#  Coverage       : w/ debug symbols, w/o optimization, w/ code-coverage
#  Debug          : w/ debug symbols, w/o optimization
#  Release        : w/o debug symbols, w/ optimization
#  RelWithDebInfo : w/ debug symbols, w/ optimization
#  MinSizeRel     : w/o debug symbols, w/ optimization, stripped binaries
#set(ROS_BUILD_TYPE RelWithDebInfo)

# Add action files
add_action_files(
  DIRECTORY action
  FILES CustomAction.action
)

# Install python scripts using distutils
catkin_python_setup()

# Generate action messages
generate_messages(
  DEPENDENCIES actionlib_msgs
)

## DEPENDS: system dependencies of this project that dependent projects also need
## CATKIN_DEPENDS: catkin_packages dependent projects also need
## INCLUDE_DIRS: 
## LIBRARIES: libraries you create in this project that dependent projects also need
catkin_package(
    DEPENDS ${SYS_DEPS}
    CATKIN_DEPENDS ${CATKIN_DEPS}
    INCLUDE_DIRS
    LIBRARIES
)

include_directories(include ${catkin_INCLUDE_DIRS})

add_executable(my_node1 src/my_node1.cpp)
target_link_libraries(my_node1 ${catkin_LIBRARIES})

install(TARGETS my_node1
  ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
  LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
  RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})

install(PROGRAMS src/my_foo/my_foo.py
  DESTINATION ${CATKIN_PACKAGE_PYTHON_DESTINATION}
)

Originally posted by Brendan Andrade on ROS Answers with karma: 83 on 2013-06-12
Post score: 0

Original comments
Comment by Dirk Thomas on 2013-06-12:
Have you sourced the setup.bash file from the devel folder after build the workspace?
Comment by Brendan Andrade on 2013-06-13:
Yes, I have.
Comment by Dirk Thomas on 2013-06-13:
Just a guess but the node you invoke is my_node2.py. Is there a Python file in the same folder with the  same name as the package?
Comment by Brendan Andrade on 2013-06-13:
No there isn't. When I get a free moment, I'm going to investigate what the python path is when the node runs. Files are generating correctly in devel but then aren't found when the node runs. Could be b/c the python package within the package folder structure has the same name as the ros package?
Comment by Dirk Thomas on 2013-06-13:
It is very common that the Python package has the same name as the ROS package - actually recommended.
Comment by Dirk Thomas on 2013-06-13:
A good next step would be to put all the code in a repo (if not already) and post the link to the repo with the exact command sequence you execute.
Comment by Brendan Andrade on 2013-06-14:
My mistake, yes the the node file had the same name as the package. I'm sorry my question did not reflect that. Changing the name of the node solved the problem. Was python node names not matching package names a requirement added with groovy/catkin or was that required with rosbuild/fuerte too?
Comment by Brendan Andrade on 2013-06-14:
Thank you, Dirk, for your help! Would you prefer to answer to the question below or should I save you the time and write the answer myself?

A:

This issue is not even related to ROS but to how Python resolves imports.
The problem is that you can not import a package "my_foo" from with a Python file "my_foo.py". In your example the script imports 'itself' and does not find "msg" inside of it.
If the script itself is not on the sys.path you can work around the issue by using "from future import absolute_import" (http://www.python.org/dev/peps/pep-0328/). But in the case your script is part of sys.path (which is the case if you e.g. invoke it from within the same folder) you have to make both name different (usually by renaming the script).

Originally posted by Dirk Thomas with karma: 16276 on 2013-06-14
This answer was ACCEPTED on the original site
Post score: 2


Q:

Custom OpenCV with ROS Groovy

I have a project which requires OpenCV with cuda support, so I have a local version of OpenCV compiled with cuda support, and I want to use this in ROS.  In previous versions of ROS I achieved this by overlaying opencv2, which I made point to my custom OpenCV version.
Now I am trying to achieve this with CMake, with limited success.
I made a simple test package (using rosbuild), only depending on roscpp (no opencv, no cv_bridge)
The code looks like this:
#include <opencv2/core/core.hpp>
#include <iostream>

int main(int argc, char** argv)
{
  cv::Mat M(2,2, CV_8UC3, cv::Scalar(0,0,255));
  std::cout << "M = " << std::endl << " " << M << std::endl;
  return 0;
}

My CMakeLists.txt looks like this:
cmake_minimum_required(VERSION 2.4.6)
include($ENV{ROS_ROOT}/core/rosbuild/rosbuild.cmake)

# Set the build type.  Options are:
#  Coverage       : w/ debug symbols, w/o optimization, w/ code-coverage
#  Debug          : w/ debug symbols, w/o optimization
#  Release        : w/o debug symbols, w/ optimization
#  RelWithDebInfo : w/ debug symbols, w/ optimization
#  MinSizeRel     : w/o debug symbols, w/ optimization, stripped binaries
#set(ROS_BUILD_TYPE RelWithDebInfo)

rosbuild_init()

#set the default path for built executables to the "bin" directory
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)
#set the default path for built libraries to the "lib" directory
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)

### OpenCV #############################

FIND_PACKAGE(OpenCV REQUIRED NO_DEFAULT_PATH PATHS /home/kir1pal/svslocal)
INCLUDE_DIRECTORIES(${OpenCV_INCLUDE_DIRS})
MESSAGE("opencv incl " ${OpenCV_INCLUDE_DIRS})
MESSAGE("opencv lib " ${OpenCV_LIBS})

#uncomment if you have defined messages
#rosbuild_genmsg()
#uncomment if you have defined services
#rosbuild_gensrv()

#common commands for building c++ executables and libraries
#rosbuild_add_library(${PROJECT_NAME} src/example.cpp)
#target_link_libraries(${PROJECT_NAME} another_library)
#rosbuild_add_boost_directories()
#rosbuild_link_boost(${PROJECT_NAME} thread)
rosbuild_add_executable(main src/main.cpp)
target_link_libraries(main ${OpenCV_LIBS})

I verified that ${OpenCV_INCLUDE_DIRS} and ${OpenCV_LIBS} are pointing to the correct opencv (in my case ~/svslocal/include and ~/svslocal/lib)
I then compile my code and run it, no problems. However when I run ldd on the executable, it is using the ros opencv_core instead of my local one.
kir1pal@pal3ea910:~/ros_workspace/custom_opencv_test/bin$ ldd main 
linux-vdso.so.1 =>  (0x00007fff919ff000)
libopencv_core.so.2.4 => /opt/ros/groovy/lib/libopencv_core.so.2.4 (0x00007f90f16b9000)
libstdc++.so.6 => /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f90f1391000)
libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f90f117b000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f90f0dbc000)
libz.so.1 => /lib/x86_64-linux-gnu/libz.so.1 (0x00007f90f0ba4000)
libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f90f0987000)
librt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007f90f077f000)
libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f90f0482000)
/lib64/ld-linux-x86-64.so.2 (0x00007f90f1af9000)

This is pretty important because if I try it on my project with CUDA I get a runtime error telling me that the opencv library has been compiled without cuda.
My LD_LIBRARY_PATH:
/usr/local/cuda-5.5/lib64:/opt/ros/groovy/lib

I also tried adding /home/kir1pal/svslocal/lib to the front of the LD_LIBRARY_PATH, did not change anything
Any idea what is going wrong here?

Originally posted by RossK on ROS Answers with karma: 141 on 2013-09-04
Post score: 0

A:

So the workaround I found was to add
LINK_DIRECTORIES(/home/kir1pal/svslocal/lib)

BEFORE rosbuild_init() in my CMakeLists.txt
I found this out by first looking at my gcc line:
/usr/bin/c++   -O2 -g     -pthread CMakeFiles/main.dir/src/main.cpp.o  -o ../bin/main -rdynamic -L/home/kir1pal/svslocal/lib -L/opt/ros/groovy/lib -lroscpp -l:/usr/lib/libboost_signals-mt.so -l:/usr/lib/libboost_filesystem-mt.so -lrosconsole -l:/usr/lib/libboost_regex-mt.so -l:/usr/lib/liblog4cxx.so -lxmlrpcpp -lroscpp_serialization -lrostime -l:/usr/lib/libboost_date_time-mt.so -l:/usr/lib/libboost_system-mt.so -l:/usr/lib/libboost_thread-mt.so -lpthread -lcpp_common /home/kir1pal/svslocal/lib/libopencv_calib3d.so.2.4.6 /home/kir1pal/svslocal/lib/libopencv_contrib.so.2.4.6 /home/kir1pal/svslocal/lib/libopencv_core.so.2.4.6 /home/kir1pal/svslocal/lib/libopencv_features2d.so.2.4.6 /home/kir1pal/svslocal/lib/libopencv_flann.so.2.4.6 /home/kir1pal/svslocal/lib/libopencv_gpu.so.2.4.6 /home/kir1pal/svslocal/lib/libopencv_highgui.so.2.4.6 /home/kir1pal/svslocal/lib/libopencv_imgproc.so.2.4.6 /home/kir1pal/svslocal/lib/libopencv_legacy.so.2.4.6 /home/kir1pal/svslocal/lib/libopencv_ml.so.2.4.6 /home/kir1pal/svslocal/lib/libopencv_nonfree.so.2.4.6 /home/kir1pal/svslocal/lib/libopencv_objdetect.so.2.4.6 /home/kir1pal/svslocal/lib/libopencv_photo.so.2.4.6 /home/kir1pal/svslocal/lib/libopencv_stitching.so.2.4.6 /home/kir1pal/svslocal/lib/libopencv_superres.so.2.4.6 /home/kir1pal/svslocal/lib/libopencv_video.so.2.4.6 /home/kir1pal/svslocal/lib/libopencv_videostab.so.2.4.6 -Wl,-rpath,/opt/ros/groovy/lib

At the end is -rpath,/opt/ros/groovy/lib, which seems to be set by cmake macro LINK_DIRECTORIES.  This seemed the be the cause of the problem.  /opt/ros/groovy/lib is added to LINK_DIRECTORIES by rosbuild_init() and therefore by calling LINK_DIRECTORIES before rosbuild_init() puts my library path in front of it.
This is not an ideal solution.  If anyone has a better idea I would like to hear it

Originally posted by RossK with karma: 141 on 2013-09-04
This answer was ACCEPTED on the original site
Post score: 1


Q:

[SOLVED] Error compiling cv_bridge Fedora 33

I'm trying to install ROS melodic on Fedora 33.
I have the following error when compiling package cv_bridge:
    error: cannot convert ‘int*’ to ‘cv::UMatData*’ in assignment
  264 |         m.u = refcountFromPyObject(o);
      |               ~~~~~~~~~~~~~~~~~~~~^~~
      |                                   |
      |                                   int*

In function convert_to_CvMat2 of file module_opencv2.cpp:
int convert_to_CvMat2(const PyObject* o, cv::Mat& m)
{
// to avoid PyArray_Check() to crash even with valid array
do_numpy_import();
    if(!o || o == Py_None)
    {
        if( !m.data )
            m.allocator = &g_numpyAllocator;
        return true;
    }

    if( !PyArray_Check(o) )
    {
        failmsg("Not a numpy array");
        return false;
    }

    // NPY_LONG (64 bit) is converted to CV_32S (32 bit)
    int typenum = PyArray_TYPE((PyArrayObject*) o);
    int type = typenum == NPY_UBYTE ? CV_8U : typenum == NPY_BYTE ? CV_8S :
        typenum == NPY_USHORT ? CV_16U : typenum == NPY_SHORT ? CV_16S :
        typenum == NPY_INT || typenum == NPY_LONG ? CV_32S :
        typenum == NPY_FLOAT ? CV_32F :
        typenum == NPY_DOUBLE ? CV_64F : -1;

    if( type < 0 )
    {
        failmsg("data type = %d is not supported", typenum);
        return false;
    }

    int ndims = PyArray_NDIM((PyArrayObject*) o);
    if(ndims >= CV_MAX_DIM)
    {
        failmsg("dimensionality (=%d) is too high", ndims);
        return false;
    }

    int size[CV_MAX_DIM+1];
    size_t step[CV_MAX_DIM+1], elemsize = CV_ELEM_SIZE1(type);
    const npy_intp* _sizes = PyArray_DIMS((PyArrayObject*) o);
    const npy_intp* _strides = PyArray_STRIDES((PyArrayObject*) o);
    bool transposed = false;

    for(int i = 0; i < ndims; i++)
    {
        size[i] = (int)_sizes[i];
        step[i] = (size_t)_strides[i];
    }

    if( ndims == 0 || step[ndims-1] > elemsize ) {
        size[ndims] = 1;
        step[ndims] = elemsize;
        ndims++;
    }

    if( ndims >= 2 && step[0] < step[1] )
    {
        std::swap(size[0], size[1]);
        std::swap(step[0], step[1]);
        transposed = true;
    }

    if( ndims == 3 && size[2] <= CV_CN_MAX && step[1] == elemsize*size[2] )
    {
        ndims--;
        type |= CV_MAKETYPE(0, size[2]);
    }

    if( ndims > 2 )
    {
        failmsg("more than 2 dimensions");
        return false;
    }

    m = cv::Mat(ndims, size, type, PyArray_DATA((PyArrayObject*) o), step);

    if( m.data )
    {
        m.u = refcountFromPyObject(o);
        m.addref(); // protect the original numpy array from deallocation
        // (since Mat destructor will decrement the reference counter)
    };
    m.allocator = &g_numpyAllocator;

    if( transposed )
    {
        cv::Mat tmp;
        tmp.allocator = &g_numpyAllocator;
        transpose(m, tmp);
        m = tmp;
    }
    return true;
}

Any help is more than welcomed, if more info is needed let me know.

Originally posted by 0novanta on ROS Answers with karma: 18 on 2021-11-09
Post score: 0

Original comments
Comment by osilva on 2021-11-09:
Please take a look at this thread: https://github.com/iterait/hipipe/issues/22
Hope it helps.
Comment by 0novanta on 2021-11-10:
I have found that post while looking for a solution, unfortunately it didn't work for me.
Luckily I was able to find another solution that made me able to compile cv_bridge package, I'll post it as an answer.

A:

I was able to compile the package after substituting the cv_bridge package (downloaded following the ROS installation tutorial) with the cv_bridge package found here.
I found this GitHub page thanks to this question.

Originally posted by 0novanta with karma: 18 on 2021-11-10
This answer was ACCEPTED on the original site
Post score: 0


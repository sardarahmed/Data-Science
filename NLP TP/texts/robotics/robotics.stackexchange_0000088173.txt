Q:

rospy.ServiceProxy master port mismatch

On my dev machine I run ros master on default port 11311 via ROSLaunchParent as follows:
os.environ["ROS_IP"] = "<dev-machine-ip>"
os.environ["ROS_MASTER_URI"] = "http://<dev-machine-ip>:11311"
roslaunch = ROSLaunchParent('', [], is_core=True, port=11311)
roslaunch.start()

stdout states that the roslaunch server is running on port 43121 (changes randomly between starts of roslaunch):
started roslaunch server http://<dev-machine-ip>:43121/

The master seems to be started on port 11311:
auto-starting new master
process[master]: started with pid [15304]
ROS_MASTER_URI=http://<dev-machine-ip>:11311/

I use docker-py (dc is a client, di is an images instance, dn is a network) to run a ROS node <some-node> in a docker container which connects to the dev machines master.
dn = dc.networks.create(name='some_test', driver="bridge")
some_node = dc.containers.run(image=di[0].id, environment=["ROS_IP=<some-ip-in-the-dev-machine-subnet>", "ROS_MASTER_URI=http://<dev-machine-ip>:11311"], name='<some-node>', network='test', command=rosrun_command, detach=True, tty=True)

import rosnode; nodes = rosnode.get_node_names(); print(nodes) lists /<some-node> (and /rosout). some-node is (at least) discoverable in the network. So far so good.
If I send multiple service requests with
rc_itempick_start = rospy.ServiceProxy('/<some-node-namespace>/<some-service>', <service-type>)
rc_itempick_start()

a random port is used instead of 11311:
core.py    WARNING  Unknown error initiating TCP/IP socket to <some-ip-in-the-dev-machine-subnet>:35516 (rosrpc://<some-ip-in-the-dev-machine-subnet>:35516)
(...)
error: [Errno 113] No route to host
core.py    WARNING  Unknown error initiating TCP/IP socket to <some-ip-in-the-dev-machine-subnet>:60739 (rosrpc://<some-ip-in-the-dev-machine-subnet>:60739)
(...)
error: [Errno 113] No route to host
(etc.)

Can someone help out in cross-checking what I missed?

Originally posted by thinwybk on ROS Answers with karma: 468 on 2018-07-27
Post score: 0

Original comments
Comment by gvdhoorn on 2018-07-27:
The port in the rosrpc URIs is not 11311 (or the port of the roslaunch server) because those URIs are not pointing to the master (or the roslaunch server), but to the port the service server uses to accept an incoming service request.
Comment by gvdhoorn on 2018-07-27:
after your edit:

error: [Errno 113] No route to host

This points to your service server not having been configured with the correct value for either ROS_IP or ROS_HOSTNAME. Or if it is the correct IP, then the docker container can't reach it.
Comment by thinwybk on 2018-07-27:
Right. I am not sure what to look at else w.r.t. service server config. I am not sure what the default docker network behaviour is. probably good to continue debugging here...
Comment by gvdhoorn on 2018-07-27:
The Python stuff you show seems to setup a bridged network, so IPs in the dev-machine-subnet should probably work. Is some-ip-in-the-dev-machine-subnet in the rosrpc URI an expected value? Can you ping that IP from the container? If not, that would be the first thing to fix.
Comment by gvdhoorn on 2018-07-27:
Btw: I don't see you configuring the IP for the container to use. If the container uses a 'random' IP instead of the one you set in ROS_IP, then things probably won't work.
Edit: in fact, if the code sample you show is what you actually run I'm pretty sure that is the problem. The ..
Comment by gvdhoorn on 2018-07-27:
.. container must have the same IP as you pass in for ROS_IP. Even if test is a bridged network, handing out IPs from another subnet will most likely not work. You'll have to use IPs from the test network. Afaik, bridged for a Docker network is not like VMware's bridged (for example).
Comment by thinwybk on 2018-07-27:
Right, totally missed that. When using docker-py setting the ip of the container explicitly requires to configuring the network (subnets , etc.).

A:

I missed to configure the docker subnet configuration
ipam_pool = docker.types.IPAMPool(subnet='X.X.X.0/24')
ipam_config = docker.types.IPAMConfig(pool_configs=[ipam_pool])
dn = dc.networks.create(name='some_test', driver="bridge", ipam=ipam_config)

and a specific ip for the container
some_node = dc.containers.run(image=di[0].id, environment=["ROS_IP=<some-ip-in-the-dev-machine-subnet>", "ROS_MASTER_URI=http://<dev-machine-ip>:11311"], name='<some-node>', command=rosrun_command, detach=True, tty=True)
dn.connect(rc_itempick, ipv4_address='<some-ip-in-the-dev-machine-subnet>')

Have to do additional checks but seems to work now...

Originally posted by thinwybk with karma: 468 on 2018-07-27
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by gvdhoorn on 2018-07-29:
I'm surprised you can actually hand out IPs from a different subnet, but if it works for you ..
Comment by thinwybk on 2018-07-30:
The ips have to be in the same subnet. Which different subnets do you mean? Have I missed a typo above...?


Q:

ROS callbacks' scope and objects' lifecycles

I am quite new to C++. I know that callbacks with return type of ConstPtr& are of boost::shared_ptr<const MsgType> type.
Now, when dealing with callbacks, does one copy or initialize objects by reference? For example, I have a ROS msg with fields int x and int y[]. Within the callback, would I copy x and y or initialize references for both of them?
Another thing, how can I know which objects are being copied and which ones are being referenced? Let's say msg->x and msg->y are they copied or referenced?
I am not familiar with object lifecycle and RAII at this point, could someone please explain to me in Layman's terms what's going on within ROS callbacks when ConstPtr& is used?

Originally posted by Hypomania on ROS Answers with karma: 120 on 2019-01-19
Post score: 0

A:

Just to clarify something, callbacks don't have a return value they are void. You may mean they accept a parameter of type  ConstPtr&.
This parameter that is passed to the callback function is a reference to the actual message data stored by ROS message passing system. Creating references to this data is a bad idea since after the callback completes that data will probably stop existing so you'll have invalid pointers, bugs, segfaults and all the things we hate. For this reason your callback function should always make copies of data that you intend to use after the callback has finished.
Your other questions are more general C++ issues, but your question doesn't make any sense without the context of the code it's within. A direct copy, or pointer copy (reference) are always done with an assignment = statement, without an assignment statement we can't answer your question.
I would like to point out that C++ ROS is not a great place to be if you're new to C++. We use some very complex features of the language, I would recommend working through some dedicated C++ tutorials or courses outside of ROS to learn the language itself.

Originally posted by PeteBlackerThe3rd with karma: 9529 on 2019-01-19
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by Hypomania on 2019-01-20:
Thank you again for your excellent answer. I understand that C++ ROS is complex, I am coming from embedded C background so I do know some C style concepts.
Comment by Hypomania on 2019-01-20:
As to my second question, all I want to know for now is when objects, within callbacks are, copied. I remember you telling me that copying a vector is as simple as doing msg->vec, however with arrays it was completely different, there is no simple arrow operator assignment, why?
Comment by PeteBlackerThe3rd on 2019-01-20:
msg->vec doesn't copy anything. It's a statement which has the value of the vec member of a struct/class which is pointed to by a variable called msg.
The -> operator isn't an assignment it simply refers to a member of structure identified by a pointer.
Comment by Hypomania on 2019-01-21:
@PeteBlackerThe3rd, so I am assuming the way vec would be copied is by one of the operator overloads? I thought equating two vectors together is considered as a copy. msg->vec would mean you are equating a vector to another vector. For e.g.: = x = (*msg).vec, where vec and x are both vecs.
Comment by PeteBlackerThe3rd on 2019-01-21:
You're right x=(*msg)->vec will copy the vector using the overloaded = operator. Similarly std::vector<type> *x = &(*msg)->vec; will copy a pointer to the vector. The first makes a copy of the data while the second makes a reference to the original.
Comment by Hypomania on 2019-01-24:
@PeteBlackerThe3rd, crystal clear, thank you!


Q:

Starting a node in code which is not part of a package

I would like to write code for a class which includes a function which calls ros::init to start a ros process. Is it possible to do this in code which is not contained in a package?
My class works with sensor data and I would like it to be possible to read data from in a variety of methods depending on which function is chosen. For example, there may be a function which employs the sensor driver API and reads via network connection, or else there may be a function which is a wrapper to an external library which provides data read from the sensor in a different way.
I would like to give a function the ability to get data from ROS by starting a node which contains a subscriber to the appropriate sensor topic. However, since I do not want the class to be part of a ROS package (so that it is portable) I am wondering if it is possible to do do this?
I imagine that in operation, the function will have to be able to attempt to start the process using ros::init, but may fail if no master process actually exists at that time. Is this idea possible?

Originally posted by Abbi on ROS Answers with karma: 11 on 2014-07-28
Post score: 0

A:

In theory, this should be doable. In practice, there will be lots of caveats that make annoying to non-ros users.
If you compile your project with cmake, you should be able to compile against roscpp and sensor_msgs by doing something like this in your CMakeLists.txt:
find_package(roscpp REQUIRED)
find_package(sensor_msgs REQUIRED)

include_directories(${roscpp_INCLUDE_DIRS} ${sensor_msgs_INCLUDE_DIRS})

add_executable(my_program my_program.cpp)
target_link_libraries(my_program ${roscpp_LIBRARIES} ${sensor_msgs_LIBRARIES})

If you compile with something other than CMake, you can probably use pkgconfig to find the compile and link flags for roscpp. This is mostly beyond the scope of my experience, and is probably not well tested.
Caveats include, but may not be limited to:

You need to have ROS installed and sourced in order to build this, because it relies on the CMAKE_PREFIX_PATH set by the ROS setup in order to find the roscpp and sensor_msgs libraries
You need to have ROS installed and sourced in order to run the final executable, because your program will be dynamically linked against roscpp, and will require the LD_LIBRARY_PATH set by the ROS setup in order to find the dynamic library for ROS

You may be able to get around these with static linking, or by detecting when ROS is not found, and compiling without it.

Originally posted by ahendrix with karma: 47576 on 2014-07-29
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Abbi on 2014-07-30:
Thank you very much. Ive only just started thinking about this approach but I figured that the biggest challenges would be to deal with all the linking and registration. I just thought that it might be something someone had already done. If I get any further Ill update this question!


Q:

robot_localization IMU coordinate frame

My question is: When using the robot_localization package, should the IMU chirality obey the standard right hand rule, or left hand rule? I think there is a discrepancy in the docs.
From the docs of the robot_localization package  a section about IMU data states the following:

Adherence to specifications: As with odometry, be sure your data adheres to REP-103 and the sensor_msgs/Imu specification.

Acceleration: Be careful with acceleration data. The state estimation nodes in robot_localization assume that an IMU that is placed in its neutral right-side-up position on a flat surface will:

Measure +9.81 meters per second squared for the Z axis.

If the sensor is rolled +90 degrees (left side up), the acceleration should be +9.81 meters per second squared for the Y axis.

If the sensor is pitched +90 degrees (front side down), it should read -9.81 meters per second squared for the X axis.

Problem: this documentation says two things. It says the data should adhere to REP-103, which says "All systems are right handed. This means they comply with the right hand rule.". Then it describes an example that could only work on a left hand system. Am I missing something?

Originally posted by psammut on ROS Answers with karma: 258 on 2017-11-06
Post score: 0

A:

Imagine you are in a car, and you accelerate forwards. That is +X acceleration. When you drive forwards, you feel the force pushing you backwards, even though you are accelerating forwards.
When you are in, say, a flight simulator machine, and they want to simulate forward motion, they tilt the machine backwards, so that you are facing up to the sky. You feel the force pushing you backwards, but you are "accelerating" upwards, against the gravity vector.
Taking it a step further: if you really did lay on your back, you'd feel the force of gravity pushing against you. If you then managed to fly straight up in the air from that position (+Z motion/acceleration), you'd feel an increase in force pushing against you, because you are accelerating upwards.
Now imagine we are in a standard ENU right-handed coordinate frame. +X is straight ahead, +Y is left, and +Z is straight up in the air. We have an IMU in neutral position on a table. If I push that IMU forwards along the table, it will register +X acceleration, because I am pushing it in the +X direction. If I push it left on the table, it will experience +Y acceleration, because it is moving in the +Y direction. If I move it straight up in the air, it should read +Z acceleration, because I am moving it in the +Z direction. This would be in addition to acceleration due to gravity, so if I accelerated at 1 m/s^2 straight up, my IMU should read +10.81 m/s^2. If it didn't, that would mean if I could move the IMU straight up at 9.81 m/s^2, the IMU would read 0, which is clearly not the case.
The problem is that, even though they are right-handed, a lot of IMUs report in NED frame, not ENU. r_l assumes ENU-frame, so you need to swap the signs of the Z and Y axes for all the data coming off the device if it's reading NED.

Originally posted by Tom Moore with karma: 13689 on 2018-01-24
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by mewbot on 2018-04-03:
swapping signs is enough?
isnt it swap X and Y, swap sign of Z
Comment by Tom Moore on 2018-04-09:
To go from NED to ENU, I have always just swapped the signs of the Y and Z axes. X does not need to change.
Comment by mewbot on 2018-04-10:
how do you swap this? did you make a new node just for this ?
sorry for the dump question; i'm quite new to ros.
Comment by Tom Moore on 2018-04-12:
No worries! Did you write your IMU driver? This has to be done at the driver level.


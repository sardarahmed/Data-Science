Q:

Robot Localization Not Publishing odom->base_link

Hello,
I have been working through the Nav2 first-Time Robot Setup example (https://navigation.ros.org/setup_guides/index.html) and have run into an issue while implementing the code onto a physical diff drive platform in the "Setting Up Odometry" step.
The ekf publisher works fine when I am using the Gazebo simulation with plugins outlined in the tutorial, but when I try to use a similar process for the physical system (stripping out the gazebo simulation and replacing it with my own odometry publisher nodes), the odom-base_link transform stops being published by the robot localization EKF.
All necessary nodes show up fine in rqt_graph, and the odometry/filtered topic is being published.
I have searched around and all of the solutions that I can find online don't seem to lead me anywhere. Any advice is greatly appreciated.
Below is the EKF config file, and the launch file I'm using to launch the rviz + robot localization portion of the code (currently manually launching the nodes dealing with the physical hardware and reporting of odometry).
config file:
    ### ekf config file ###
ekf_filter_node:
    ros__parameters:
# The frequency, in Hz, at which the filter will output a position estimate. Note that the filter will not begin
# computation until it receives at least one message from one of theinputs. It will then run continuously at the
# frequency specified here, regardless of whether it receives more measurements. Defaults to 30 if unspecified.
        frequency: 30.0

# ekf_localization_node and ukf_localization_node both use a 3D omnidirectional motion model. If this parameter is
# set to true, no 3D information will be used in your state estimate. Use this if you are operating in a planar
# environment and want to ignore the effect of small variations in the ground plane that might otherwise be detected
# by, for example, an IMU. Defaults to false if unspecified.
        two_d_mode: true

# Whether to publish the acceleration state. Defaults to false if unspecified.
        publish_acceleration: true

# Whether to broadcast the transformation over the /tf topic. Defaultsto true if unspecified.
        publish_tf: true

# 1. Set the map_frame, odom_frame, and base_link frames to the appropriate frame names for your system.
#     1a. If your system does not have a map_frame, just remove it, and make sure "world_frame" is set to the value of odom_frame.
# 2. If you are fusing continuous position data such as wheel encoder odometry, visual odometry, or IMU data, set "world_frame"
#    to your odom_frame value. This is the default behavior for robot_localization's state estimation nodes.
# 3. If you are fusing global absolute position data that is subject to discrete jumps (e.g., GPS or position updates from landmark
#    observations) then:
#     3a. Set your "world_frame" to your map_frame value
#     3b. MAKE SURE something else is generating the odom->base_link transform. Note that this can even be another state estimation node
#         from robot_localization! However, that instance should *not* fuse the global data.
        map_frame: map              # Defaults to "map" if unspecified
        odom_frame: odom            # Defaults to "odom" if unspecified
        base_link_frame: base_link  # Defaults to "base_link" ifunspecified
        world_frame: odom           # Defaults to the value ofodom_frame if unspecified

        odom0: bot/odom
        odom0_config: [true,  true,  true,
                       false, false, false,
                       false, false, false,
                       false, false, true,
                       false, false, false]

Launch file
import launch
from launch.substitutions import Command, LaunchConfiguration
import launch_ros
import os

def generate_launch_description():
    pkg_share = launch_ros.substitutions.FindPackageShare(package='sam_bot_description').find('sam_bot_description')
    default_model_path = os.path.join(pkg_share, 'src/description/sam_bot_description.urdf')
    default_rviz_config_path = os.path.join(pkg_share, 'rviz/urdf_config.rviz')

    robot_state_publisher_node = launch_ros.actions.Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        parameters=[{'robot_description': Command(['xacro ', LaunchConfiguration('model')])}]
    )
    
    joint_state_publisher_node = launch_ros.actions.Node(
        package='joint_state_publisher',
        executable='joint_state_publisher',
        name='joint_state_publisher',
        condition=launch.conditions.UnlessCondition(LaunchConfiguration('gui'))
    )

    rviz_node = launch_ros.actions.Node(
        package='rviz2',
        executable='rviz2',
        name='rviz2',
        output='screen',
        arguments=['-d', LaunchConfiguration('rvizconfig')],
    )
    
    
    robot_localization_node = launch_ros.actions.Node(
       package='robot_localization',
       executable='ekf_node',
       name='ekf_filter_node',
       output='screen',
       parameters=[os.path.join(pkg_share, 'config/ekf.yaml'), {'use_sim_time': LaunchConfiguration('use_sim_time')}]
)

    world_path=os.path.join(pkg_share, 'world/my_world.sdf'),

    return launch.LaunchDescription([
        launch.actions.DeclareLaunchArgument(name='gui', default_value='True',
                                            description='Flag to enable joint_state_publisher_gui'),
        launch.actions.DeclareLaunchArgument(name='model', default_value=default_model_path,
                                            description='Absolute path to robot urdf file'),
        launch.actions.DeclareLaunchArgument(name='rvizconfig', default_value=default_rviz_config_path,
                                            description='Absolute path to rviz config file'),
                                            
        launch.actions.DeclareLaunchArgument(name='use_sim_time', default_value='False',
                                            description='Flag to enable use_sim_time'),                                    
                                                                             
        joint_state_publisher_node,
        robot_state_publisher_node,
        robot_localization_node,
        rviz_node,
])

Originally posted by ahnikom on ROS Answers with karma: 36 on 2022-04-13
Post score: 1

A:

The mistake was on my end while handling the header timestamp for the /bot/odom message.
In the node that generates the timestamped odom message, I had accidentally left the assignment of the header timestamp value commented out after I had been working to sort out a problem with timestamps and clock usage. I.E. the header was constantly timestamped at 0s 0ns. breaking the EKF node.
Thank you everyone who looked at this! Sorry that the issue was located squarely between the chair and the keyboard.

Originally posted by ahnikom with karma: 36 on 2022-04-15
This answer was ACCEPTED on the original site
Post score: 1


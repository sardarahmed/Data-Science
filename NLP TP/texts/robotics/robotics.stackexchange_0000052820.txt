Q:

ROS Qt Interrupted System Call On Plugin Startup

I've recently been working on a python widget for rqt that creates a separate thread to read joystick data in from a pipe. I've tested it as a standalone python program and confirmed that it's getting valid data. However, when I put it into a python plugin for rqt that I've already created and tested, it crashes. After some tweaking of the code, it looks like it crashes at the end of the __init__ function in the plugin with IOError: [Errno 4] Interrupted system call  when the pipe read is interrupted.
The initialization is basically:

Create a joystick object that creates a thread to endlessly read in data from /dev/input/js0; start running it
Create thread to endlessly check the Joystick object containing this other thread to look for new data; start running it
Wait 5 seconds, during which joystick data prints out fine as I would expect
The 5 Second wait ends, IOError: [Errno 4] Interrupted system call is thrown, and rqt loads as normal

A snippet of the plugin code is below. The Joystick class being referenced creates a thread in the same manner, opens a pipe using self._pipe = open('/dev/local/js0', 'r'), then reads in raw data for parsing using for character in self._pipe.read(1):
    class Joystick(Plugin):
      # Variables...
      def __init__(self, context):
          # Some initialization code here...
          #...
          # Create the joystick object and run its thread
          self._joystick_reader = LinuxJoystickReader()
          self._joystick_reader.initialize('/dev/input/js0')
          self._joystick_reader.start()
          # Create a local thread and run it to print the joystick data
          self._joystick_thread_run = True
          self._joystick_read_thread = Thread(target=self.pub_joystick, args=())
          self._joystick_read_thread.start()
          # Sleep, during which the data prints out fine
          time.sleep(5)
          # -- ERROR --
          # File "joystick_class.py" line 35, in read_pipe
          # for character in self._pipe.read(1):
          # IOError: [Errno 4] Interrupted system call

       def pub_joystick(self):
         while self._joystick_thread_run:
           if self._joystick_reader.has_new_data():
             pub_str = str(self._joystick_reader.get_data_array()[0]) + ", " + str(self._joystick_reader.get_data_array()[1])
             print pub_str
         self._joystick_reader.stop()

Originally posted by jker on ROS Answers with karma: 115 on 2013-07-16
Post score: 1

Original comments
Comment by Dirk Thomas on 2013-07-17:
Btw you should never sleep during construction but I guess this is just part of your debugging code. Even any long running other operation should be deferred or be performed in a separate thread.
Comment by jker on 2013-07-18:
Yes, the sleep is just for debugging purposes (a shot in the dark that paid off), I'm trying to get the separate threads to run on their own without crashing :)

A:

It seems like something in Qt or one of the plugins was interrupting the system call I was making to read the joystick input. Adding additional try/catch code to my joystick implementation solved the problem for me, since it can just continue reading input even if it is interrupted. I was also able to get my plugin working without crashing and without the additional try/catch code by adding my plugin to the GUI last, after all the other plugins were loaded and running.
Got the idea from this StackOverflow thread. I'm still not sure what part interrupted my system call, why it did that, or if it's intentional, but the solution seems to be robust to random interruptions on startup.

Originally posted by jker with karma: 115 on 2013-07-18
This answer was ACCEPTED on the original site
Post score: 1


Q:

The result of the extract of color varies depending on the camera and Image's topic

I am using two cameras to extract of the cloth's color.
first camera webcam  and
second camera Xtion or orbbec
my code can't extract the color at same values (RGB)
when I watch the video I think that the webcam is better than others(RGBD). it is near from fact (the color similar what my eyes see)
the webcam is using rosrun usb_cam usb_cam_node _pixel_format:=yuyv  whereas others  roslaunch astra_camera astra.launch
this means different Format see here
my issue is the robot loses the target more with RGBD when a happening simple change in an environment not severe illumination. meanwhile, I need it because of the depth camera.
this my full code to compare them:
import rospy
import cv2
import numpy as np
from sensor_msgs.msg import Image, CameraInfo
from cv_bridge import CvBridge, CvBridgeError

class CVControl:
    def __init__(self):
        self.bridge = CvBridge()
        self.image_sub = rospy.Subscriber('/usb_cam/image_raw', Image, self.usb_cam)
        self.image_sub = rospy.Subscriber("/camera/rgb/image_raw", Image, self.img_callback)

    def usb_cam(self, data):
        try:
            cv_image = self.bridge.imgmsg_to_cv2(data, "bgr8")
        except CvBridgeError as e:
            print e
        img = cv_image
        hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
        red_lower = np.array([106, 48, 26], np.uint8)
        red_upper = np.array([126, 68, 106], np.uint8)
        red = cv2.inRange(hsv, red_lower, red_upper)
        # kernal = np.ones((5, 5), "uint8")        #
        # red = cv2.dilate(red, kernal)
        res_red = cv2.bitwise_and(img, img, mask=red)

        mask = cv2.morphologyEx(red, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (2, 2)))
        mask = cv2.Canny(mask, 50, 100)
        mask = cv2.GaussianBlur(mask, (13, 13), 0)
        mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (2, 2)))

        (_, contours, hierarchy) = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
        for pic, contour in enumerate(contours):
            area = cv2.contourArea(contour)
            if (area > 10000):
                x, y, w, h = cv2.boundingRect(contour)
                img = cv2.rectangle(img, (x, y), (x + w, y + h), (0, 0, 255), 2)
                cv2.putText(img, "Red Colour", (x, y), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255))

        cv2.imshow("usb_cam", img)
        cv2.waitKey(3)
    def img_callback(self, data):
        try:
            cv_image = self.bridge.imgmsg_to_cv2(data, "bgr8")
        except CvBridgeError as e:
            print e

        img = cv_image
        hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
        red_lower = np.array([106, 48, 26], np.uint8)
        red_upper = np.array([126, 68, 106], np.uint8)
        red = cv2.inRange(hsv, red_lower, red_upper)

        # kernal = np.ones((5, 5), "uint8")
        #
        # red = cv2.dilate(red, kernal)
        res_red = cv2.bitwise_and(img, img, mask=red)

        mask = cv2.morphologyEx(red, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (2, 2)))
        mask = cv2.Canny(mask, 50, 100)
        mask = cv2.GaussianBlur(mask, (13, 13), 0)
        mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (2, 2)))

        (_, contours, hierarchy) = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
        for pic, contour in enumerate(contours):
            area = cv2.contourArea(contour)
            if (area > 10000):
                x, y, w, h = cv2.boundingRect(contour)
                img = cv2.rectangle(img, (x, y), (x + w, y + h), (0, 0, 255), 2)
                cv2.putText(img, "Red Colour", (x, y), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255))
        cv2.imshow("Image window", img)
        cv2.waitKey(3)

def main():
    rospy.init_node('image_converter')
    try:
        ctrl = CVControl()
        rospy.spin()

    except KeyboardInterrupt:
        print "Shutting down"
        cv2.destroyAllWindows()

if __name__ == '__main__':
    main()

Regardless of the color of the box, this is output:

will I need to change the topic or something else?
please your advisees

Originally posted by Redhwan on ROS Answers with karma: 73 on 2019-12-05
Post score: 0

Original comments
Comment by ct2034 on 2019-12-05:
Thanks for your question. Could you please clarify, what your exact problem is: What behaviour do you expect, and what is happening instead? And could you please shorten your code to the relevant sections (if any) or use something like http://gist.github.com/ To make it more readable
Comment by Redhwan on 2019-12-05:
Thanks for your help.
I didn't upload it in any websites, I still improve it until submitting a paper.
I would that the robot follows me base on the color of clothes without loses me.

A:

This is a pretty common behavior with cameras. Different cameras respond to color slightly differently, and the automatic gain and white balance functions of the camera will affect the numeric and perceived color even more.
There is an entire field of study devoted to this topic: Color Theory
I suggest that you do some research into different color spaces (look at HSV for example) and maybe try to find and read a few papers about color tracking in computer vision. Most papers will discuss the techniques that they use to be robust to lighting and other changes in color.

Originally posted by ahendrix with karma: 47576 on 2019-12-05
This answer was ACCEPTED on the original site
Post score: 1


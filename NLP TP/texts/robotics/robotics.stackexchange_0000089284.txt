Q:

Image overlay with transparency (sensors_msg/Image) on mapviz

Hi everyone,
I've written a simple node which reads in a png file with transparency and publishes it to a certain topic. The topic is then subscribed by mapviz to display the image as an overlay. While the image is shown, the background isn't shown as transparent despite setting CvImage's encoding to "bgra8" (http://docs.ros.org/kinetic/api/cv_bridge/html/c++/classcv__bridge_1_1CvImage.html).

Is there a reason why this is not working as intended? Perhaps, I am missing something? I tried searching for a solution for hours but to no avail. Any help will be greatly appreciated. Thank you!
The test image I used is from here: https://commons.wikimedia.org/wiki/File:Test.png
The code of the node is as follows:
#include <ros/ros.h>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>
#include <image_transport/image_transport.h>

int main(int argc, char** argv)
{
  ros::init(argc, argv, "image_publisher");
  ros::NodeHandle nh;

  // cv_bridge::CvImage cv_image()
  // image_transport::ImageTransport it(nh);

  cv_bridge::CvImage cv_image;
  cv_image.image = cv::imread(<png file here>,cv::IMREAD_UNCHANGED);
  cv_image.encoding = "bgra8";
  sensor_msgs::Image ros_image;
  sensor_msgs::CompressedImage compressed_ros_image;
  cv_image.toImageMsg(ros_image);
  cv_image.toCompressedImageMsg(compressed_ros_image, cv_bridge::PNG);

  ROS_INFO_STREAM(cv_image.image);

  ros::Publisher pub = nh.advertise<sensor_msgs::Image>("/test_image", 5, true);
  ros::Publisher compressed_pub = nh.advertise<sensor_msgs::CompressedImage>("/test_image/compressed", 5, true);
  // ros::Publisher pub = nh.advertise<sensor_msgs::Image>("/test_image", 5, true);
  ros::Rate loop_rate(5);

  ros::Duration(1.0).sleep();

  pub.publish(ros_image);
  compressed_pub.publish(compressed_ros_image);

  while (nh.ok())
  {
    // pub.publish(ros_image);
    loop_rate.sleep();
  }
}

Updated:
Here is a snippet of rostopic echo /test_image:
header:
  seq: 0
  stamp:
    secs: 0
    nsecs:         0
  frame_id: ''
height: 983
width: 3050
encoding: "bgra8"
is_bigendian: 0
step: 12200
data: [255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, ...

As you can see, it appears that the received image data has some of the first few pixels' alpha channel value set to 0.

Originally posted by rwong on ROS Answers with karma: 13 on 2018-10-15
Post score: 0

Original comments
Comment by PeteBlackerThe3rd on 2018-10-15:
Have you checked if the problem is with the image transport or the rendering. Can you print some debug values so you can see if the received image contains the alpha information or not.
Comment by rwong on 2018-10-15:
Hi PeteBlackerThe3rd. I have updated my post. It appears that the received image data contains alpha information. Could it be that mapviz doesn't support colour blending using the alpha information?

A:

I've just had a look at the source code for the mapviz image plugin and you're right, you can see here that it doesn't currently support RGBA image rendering. There are two parts which will need to be modified in order to get this working if you want to adapt it.
Firstly the image callback function here will need to detect and handle images with transparency as well as normal BGR images.
Secondly the DrawIplImage function here will need modifiying so that it detects images with transparency and uses the GL_RGBA format as described in the OpenGL documention here.
If you're up for modifying this plugin it doesn't seem like that much work to get it to support images with alpha channels. Let me know if you have any other questions about getting this working.

Originally posted by PeteBlackerThe3rd with karma: 9529 on 2018-10-16
This answer was ACCEPTED on the original site
Post score: 0


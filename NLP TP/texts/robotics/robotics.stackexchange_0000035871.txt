Q:

how to save an sensor_msgs/Image to a file?

Hi all. I am trying to pass an image from a Ros node(C++) to a ROSjava node. I managed to make the rosjava node to subscribe to the others topic. The C++ is publishing an image topic and the Rosjava i supposed to write the image in a file.
The problem is that I cannot find an equivalent on Rosjava for the CVBridge that is used in C++ to make the image message a Iplimage file and save it.
What I currently do is try to put the message in a byte[] and then read it in a file. But the result is an jpg file 4 times bigger that the one sent and unreadable.
Here is the code I use for the C++ node:
int main(int argc, char **argv)

{    
  ros::init(argc, argv, "imagesender");    
  ros::NodeHandle n;    
  ros::Publisher image_pub = n.advertise<sensor_msgs::Image>("image/mysender", 1);

  printf("Loading image...\n");
  IplImage* imgsrc = cvLoadImage( "/home/spagi/ros_workspace/jpgtransfer/src/testimage.jpg" );
  if(!imgsrc){ printf("Could not load image file\n");}
  else{printf("Image Loaded Sucessfully\n");}
  
  sensor_msgs::ImagePtr imgmsg = sensor_msgs::CvBridge::cvToImgMsg(imgsrc, "bgr8");

  ros::Rate loop_rate(1);
  while (ros::ok())
  {  
    image_pub.publish(imgmsg);  
    ros::spinOnce();
    loop_rate.sleep();
  }    
  return 0;
}

And here the code for the Rosjava node:
 @Override
  public void main(Node node) {
      
      final FileInputStream fileInputStream=null;
      
    Preconditions.checkState(this.node == null);
    this.node = node;
    try {
      //final Log log = node.getLog();
      System.out.println("Started main node");
      node.newSubscriber("image/mysender", "sensor_msgs/Image",
          new MessageListener<org.ros.message.sensor_msgs.Image>() {
            @Override
            public void onNewMessage(org.ros.message.sensor_msgs.Image message) {
                System.out.println("Got a new Image message");
                if(x==0){
                    x++;                    
                byte[] byteArray = message.data;
                try {
                        
                //convert array of bytes into file
                FileOutputStream fileOuputStream = 
                          new FileOutputStream("/home/spagi/Desktop/javaccimage.jpg"); 
                fileOuputStream.write(byteArray);
                fileOuputStream.close();            
                System.out.println("Done");                 
                }catch(Exception e){
                    e.printStackTrace();
                }
                }                   
            }
            
          });
    } catch (Exception e) {
      if (node != null) {
        node.getLog().fatal(e);
      } else {
        e.printStackTrace();
      }
    }
  }

So again my problem is what to do with that message object and how can I make it a file. I dont know if there is an alternative for the publisher on the :
sensor_msgs::CvBridge::cvToImgMsg(imgsrc, "bgr8"); 

Originally posted by spagi on ROS Answers with karma: 33 on 2011-11-21
Post score: 1

A:

The ROS image message isn't a jpeg as a byte array; it's just values as a byte array. There's no compression done automatically (and therefore ROSJava will see just plain data, not compressed data).
Why are you using ROSJava to save the image? If all you want to do is turn Image messages into files, you can do that easily with cv_bridge in python or c++.
This sounds like an XY Problem. What's X?

Originally posted by Mac with karma: 4119 on 2011-11-21
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by spagi on 2011-11-22:
Basically I need the C++ node to get the image from the kinect and then the rest of my code runs on RosJava because I use the image to query google and do lexical analysis to the results. But I think that I might skip the whole image transfer thing and just store it and ready it a a file in rosjava
Comment by Mac on 2012-03-26:
Touching the filesystem will hurt you. Each element of the Image message data array is one of r, g, or b (as a byte) of the RGB image (assuming it's RGB). Reading that into your Java data structure is just a  for loop.


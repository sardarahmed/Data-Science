Q:

robot_localization: Strange frequency of odometry message output

Hello,
I'm using the robot_localization package on ROS noetic, on an Ubuntu 20.04LTS system with a 4 Core i5.
I am running an EKF node, and trying to get the odometry/filtered message output at a fairly high frequency (~200Hz)
I am running into some strange behavior when increasing the frequency configuration parameter for the filter.
If the frequency parameter is set to ~30Hz or less, each odometry/filtered message is output at the expected frequency, and the delta between each message is evenly distributed. (i.e. at 20Hz, 20 odometry messages are received in a second, and they are each 50ms apart)
As soon as the frequency is increased to 40Hz, something strange happens. Several odometry messages are sent with very high frequency (~10 microseconds between each message), followed by a 50 millisecond gap. This behavior is consistent increasing the frequency up to 200Hz.
Even at 200Hz, the filter does output an odometry message 200 times in a second. However, the timing between each message is not evenly distributed at all.
I have reduced the number of sensors to 1, a simple odometry source from wheel encoders. This message is published at 200Hz.
I have tried modulating the frequency at which this odometry message is published, as well as adjusting the queue sizes for the message.
Has anyone else experienced this? Is this the expected behavior for the filter?
Following section 1.3 of the troubleshooting guide, below is an output of the odom message:
header: 
  seq: 1942
  stamp: 
    secs: 1636049205
    nsecs: 696457465
  frame_id: "odom"
child_frame_id: "base_link"
pose: 
  pose: 
    position: 
      x: 0.0
      y: 0.0
      z: 0.0
    orientation: 
      x: 0.0
      y: 0.0
      z: 0.0
      w: 0.0
  covariance: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
twist: 
  twist: 
    linear: 
      x: 0.01
      y: 0.0
      z: 0.0
    angular: 
      x: 0.0
      y: 0.0
      z: 0.0
  covariance: [1e-06, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0001]

I am just hard-setting the X velocity to 0.01 for testing purposes.
Also, here is my configuration file:
frequency: 40

silent_tf_failure: false

sensor_timeout: 0.1

two_d_mode: false

transform_time_offset: 0.0

transform_timeout: 0.0

print_diagnostics: true

debug: false

publish_tf: true

publish_acceleration: false

permit_corrected_publication: false

smooth_lagged_data: false

map_frame: map              # Defaults to "map" if unspecified
odom_frame: odom            # Defaults to "odom" if unspecified
base_link_frame: base_link  # Defaults to "base_link" if unspecified
world_frame: odom           # Defaults to the value of odom_frame if unspecified

odom0: sensor_data/odom

odom0_config: [false,  false,  false,
               false, false, false,
               true, true, true,
               false, false, true,
               false, false, false]

odom0_queue_size: 100

odom0_nodelay: true

odom0_differential: false

odom0_relative: false

To be clear: The output of rostopic hz /odometry/filtered eventually reaches the frequency configuration value. That is not the issue. If I run a node that subscribes to the /odometry/filtered topic, and measure the delta/frequency between receipt of the message, I am seeing some wild variations. I would like to get to the bottom of this behavior specifically.
Last Note: The CPU usage of the ekf node is quite low, around 6%. The 50ms pause does not seem to be CPU related.
My first instinct was that perhaps I was seeing several ticks where the message queue was empty, followed by a tick where several messages were entered into the queue. However, adjusting the odom0_queue_size to 1 does not change the behavior.
Any advice would be greatly appreciated. I am happy to provide any more information/console output if that's helpful.

Originally posted by nparker2020 on ROS Answers with karma: 16 on 2021-11-04
Post score: 0

Original comments
Comment by gvdhoorn on 2021-11-04:
Odom is not a small message, but perhaps you're seeing Nagel's algorithm at work.

However, the timing between each message is not evenly distributed at all.

how did you measure dT? By looking at message arrival times, or the stamps?
Comment by nparker2020 on 2021-11-04:
Thanks for the reply. Yes, I assumed originally that Nagel's could be at work. I set the odom0_nodelay value to true in an effort the address that.
I was calculating dT upon receipt (arrival time). I see now that the stamps might tell another story. I will run a test looking at the stamps and reply back.
Comment by nparker2020 on 2021-11-04:
Wow. OK. Comparing the stamps in the header yields exactly what I would expect. Each odometry message is delivered in 1/freq. increments. Any advice in addressing this massive delay in message delivery?
EDIT: After looking over the docs and other forum threads, I added a TransportHints with tcpNoDelay() set to the subscribe call for the /odometry/filtered message. This completely resolved my issue. Thank you!
Comment by gvdhoorn on 2021-11-04:
Good to hear you got it resolved.

A:

ANSWER:
The answer to this issue, provided by gvdhoorn (Thanks again!), was to disable Nagel's algorithm for the /odometry/filtered topic.
In order to do this, I added a ros::TransportHints to the subscribe call on the /odometry/filtered topic:
ros::TransportHints transportConfig;
  transportConfig.tcpNoDelay();
  ros::Subscriber sub = n.subscribe("/odometry/filtered", 1000, <callback>, transportConfig);

Originally posted by nparker2020 with karma: 16 on 2021-11-04
This answer was ACCEPTED on the original site
Post score: 0


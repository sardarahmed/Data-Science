Q:

ROSActivity shutting down upon launching MasterChooser

Hi I've been on this one for a while.
using the android_tutorial_pubsub as a guide I've adjusted it to run my own NodeMains. They initially ran well with feeds showing up in LOGCAT every time they failed to connect to my ROS_MASTER (separate issue). However afterward, eclipse drastically changed after updating, and after much frustration, i'm back to the command line environment.
During this time, my NodeMains are failing to run, as I start my program, the MasterChooser interface runs with a toast "Tutorial_PubSub" Shutting down. Even going back to the unchanged tutorial code this issue is happening.
Using some util.log messages, ive realised this issue belongs inside ROSActivity as the log messages don't even get called. Perhaps I'm missing something from the AndroidManifest file.
Heres my code (Please disregard my newPrivate() on the NodeConfiguration it doesn't change anyting.
package org.ros.android.android_tutorial_pubsub;

import java.net.URI;
import java.net.URISyntaxException;

import android.os.Bundle;
import android.util.Log;
import au.net.qfr.hmmcontrollernode.controller_node;

import org.ros.address.InetAddressFactory;
import org.ros.android.MessageCallable;
import org.ros.android.RosActivity;
import org.ros.android.view.RosTextView;
import org.ros.node.NodeConfiguration;
import org.ros.node.NodeMainExecutor;
import org.ros.rosjava_tutorial_pubsub.Talker;

/**
 * @author damonkohler@google.com (Damon Kohler)
 */
public class MainActivity extends RosActivity {

  private RosTextView<std_msgs.String> rosTextView;
  private controller_node controlnode;
  
  private Talker talker;

  public MainActivity() {
    // The RosActivity constructor configures the notification title and ticker
    // messages.
     
     super("HMMController", "HMMController");
     Log.d("Main Activity", "In init nodemain executer method");
  }

  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);
    rosTextView = (RosTextView<std_msgs.String>) findViewById(R.id.text);
    rosTextView.setTopicName("valve_signals");
    rosTextView.setMessageType(std_msgs.String._TYPE);
    rosTextView.setMessageToStringCallable(new MessageCallable<String, std_msgs.String>() {
      @Override
     public String call(std_msgs.String message) {
        return message.getData();
      }
   });
  }
  
 

  @Override
  protected void init(NodeMainExecutor nodeMainExecutor) {
    controlnode = new controller_node();
    talker = new Talker();
    Log.d("Main Activity", "In init nodemain executer method");
    //RosTextView= new rosTextView();
    //URI master_uri=null;
    
        //master_uri = new URI("http://192.168.1.2:11311");
    
    NodeConfiguration nodeConfiguration = NodeConfiguration.newPrivate();
   // NodeConfiguration nodeConfiguration = NodeConfiguration.newPublic(InetAddressFactory.newNonLoopback().getHostAddress().toString());
    // At this point, the user has already been prompted to either enter the URI
    // of a master to use or to start a master locally.
    nodeConfiguration.setMasterUri(getMasterUri());
    //nodeMainExecutor.execute(controlnode, nodeConfiguration);
    nodeMainExecutor.execute(talker, nodeConfiguration);
    // The RosTextView is also a NodeMain that must be executed in order to
    // start displaying incoming messages.
    nodeMainExecutor.execute(rosTextView, nodeConfiguration);
  }
}

and here is my manifest file:
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="org.ros.android.android_tutorial_pubsub"
    android:versionCode="1"
    android:versionName="1.0" >

    <uses-sdk android:minSdkVersion="10" />

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />

    <application
        
        android:label="@string/app_name" >
        <activity
            android:name="org.ros.android.android_tutorial_pubsub.MainActivity"
            android:label="@string/app_name" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity android:name="org.ros.android.MasterChooser" />

        <service android:name="org.ros.android.NodeMainExecutorService" />
    </application>

</manifest>

Originally posted by PeterMilani on ROS Answers with karma: 1493 on 2012-11-27
Post score: 0

A:

Well I turned off my developer debug settings on the android device and the applications worked! Can connect to a remote host etc. Now went back into developer settings and only enabled usb debugging so that the apps could be installed.
Now the settings I had on that appeared to conflict with the applications were:
Stay awake -- Screen will never sleep while charging. Not sure why this would interfere with the application.
I guess as a start you should reset your developer settings if having this problem.

Originally posted by PeterMilani with karma: 1493 on 2012-11-27
This answer was ACCEPTED on the original site
Post score: 0


Q:

Closest point to a fixed frame

Hello
Im trying to write a node that gives me the distance to a fixed frame of some object in my map. So for example a door. So I just want to analyse the position of the robot (based on laser scan) in the relation to this object. So I passed the TF tutorial. But not sure if the code is Ok. Any help?
So this is my code
#include <ros/ros.h>
#include <tf/transform_listener.h>

int main(int argc, char** argv){
  ros::init(argc, argv, "my_tf_listener");

  ros::NodeHandle node;
  tf::TransformListener listener;

  ros::Rate rate(10.0);
  while (node.ok()){
    tf::StampedTransform transform;
    try{
      listener.lookupTransform("/base_link", "/door1",  
                               ros::Time(0), transform);
    }
    catch (tf::TransformException ex){
      ROS_ERROR("%s",ex.what());
    }

    double x = transform.getOrigin().x();
        double y = transform.getOrigin().y();
    double dist = sqrt(x*x + y*y);
    ROS_INFO("%f", dist);

    rate.sleep();
  }
  return 0;
};

And just labelled the door on my launch file like this
<node pkg="tf" type="static_transform_publisher" name="door1" args="1 0 0 0 0 0 /odom /door1 10"/>

So I think this part of the code give me the the distance to the door. Cause my laser is placed on the base_link. So it give me the distance between the door and the base link in every time step
while (node.ok()){
    tf::StampedTransform transform;
    try{
      listener.lookupTransform("/base_link", "/door1",  
                               ros::Time(0), transform);
    }
    catch (tf::TransformException ex){
      ROS_ERROR("%s",ex.what());
    }

    double x = transform.getOrigin().x();
        double y = transform.getOrigin().y();
    double dist = sqrt(x*x + y*y);
    ROS_INFO("%f", dist);

    rate.sleep();

Yes???
This is the visualisation code
#include "ros/ros.h"
#include "std_msgs/String.h"
#include "geometry_msgs/Pose.h"
#include "geometry_msgs/PoseWithCovarianceStamped.h"
#include "tf/message_filter.h"
#include "message_filters/subscriber.h"
#include "visualization_msgs/Marker.h"
/**
 * This tutorial demonstrates simple receipt of messages over the ROS system.
 */

class amcl_pose_listener {
  
public:
    
  ros::NodeHandle n_;
  
  //Message filters for subscribed sensor msgs

  message_filters::Subscriber<geometry_msgs::PoseWithCovarianceStamped> pose_sub_;  //Subscriber to a published pose msg (from a localiser such as AMCL, etc)
   
  ros::Publisher traj_pub_, line_to_door_pub_;  //Publish an trajectory
  
  //The trajectory
  visualization_msgs::Marker trajectory_points_, line_to_door_points_;
    
  amcl_pose_listener(ros::NodeHandle n): 

  pose_sub_(n_, "amcl_pose", 100)       //Subscriber to a pose msg "amcl_pose" (from AMCL)
  {    
    //Set call back function for pose data
    pose_sub_.registerCallback(boost::bind(&amcl_pose_listener::poseCallBack, this, _1));
    
    //Publish a trajectory
    traj_pub_ = n.advertise<visualization_msgs::Marker>("robot_fixed_pose_trajectory", 100);
    line_to_door_pub_ = n.advertise<visualization_msgs::Marker>("wheelchair_to_door_trajectory", 100);

    line_to_door_points_.points.resize(2);
    
  }
  
  //Pose data callback
  void poseCallBack(const geometry_msgs::PoseWithCovarianceStampedConstPtr& data_in)
  {
    //Init the trajectory history
    trajectory_points_.header.frame_id = "map";
    trajectory_points_.header.stamp = ros::Time::now();
    trajectory_points_.ns = "robot_fixed_pose_trajectory";
    trajectory_points_.type = visualization_msgs::Marker::LINE_STRIP;
    trajectory_points_.action = visualization_msgs::Marker::ADD;
    trajectory_points_.id = 0;
    //Green colour
    trajectory_points_.color.g = 1.0f;
    trajectory_points_.color.a = 1.0;
    trajectory_points_.scale.x = 0.1;   //Sets the width of the LINE_STRIP
    trajectory_points_.scale.y = 0.1;   //Ignored if marker type is LINE_STRIP

    //Init the trajectory history
    line_to_door_points_.header.frame_id = "map";
    line_to_door_points_.header.stamp = ros::Time::now();
    line_to_door_points_.ns = "line_to_door";
    line_to_door_points_.type = visualization_msgs::Marker::LINE_STRIP;
    line_to_door_points_.action = visualization_msgs::Marker::MODIFY;
    line_to_door_points_.id = 0;
    //Red colour
    line_to_door_points_.color.r = 1.0f;
    line_to_door_points_.color.a = 1.0;
    line_to_door_points_.scale.x = 0.1; //Sets the width of the LINE_STRIP
    line_to_door_points_.scale.y = 0.1; //Ignored if marker type is LINE_STRIP
           
    geometry_msgs::Point p;
    p.x = data_in->pose.pose.position.x;
    p.y = data_in->pose.pose.position.y;
    p.z = data_in->pose.pose.position.z;

    line_to_door_points_.points[0].x = 1; // set x co ord of door
    line_to_door_points_.points[0].y = 0; // set y co ord of door
    line_to_door_points_.points[1].x = p.x; // set x co ord of wheelchair
    line_to_door_points_.points[1].y = p.y; // set y co ord of wheelchair
    
    //ROS_INFO("POSE RECEIVED\n POSE RECEIVED, seq = %d", trajectory_points_.header.seq);
    //ROS_INFO("POSE INIT: %f, %f, %f\n", trajectory_points_.pose.position.x, trajectory_points_.pose.position.y, trajectory_points_.pose.position.z);
    
    trajectory_points_.header.seq++;
    
    trajectory_points_.points.push_back(p); //Add the point

    traj_pub_.publish(trajectory_points_);  // Publish the trajectory
      line_to_door_pub_.publish(line_to_door_points_); //publish line to door
  }

};

int main(int argc, char** argv)
{
  ros::init(argc, argv, "amcl_pose_listener");
  
  ros::NodeHandle n;
  amcl_pose_listener lstopc(n);
    
  ros::spin();
  
  return 0;
}

And this is the launch file
<!--
    Perform AMCL localisation: runs several nodes to generate odometry from laser scans (ICP) & IMU, loads a map of the POW assessment area, runs AMCL, plays back a dataset for localisation, and runs the visualiser with the correct visualisation parameters configured.
-->

<launch>
    <param name="/use_sim_time" value="true"/>

    <node name="rosplay" pkg="rosbag" type="play" args="/home/Desktop/PowRos/Data/user2/pow.bag --loop  --clock"/>
    
    <node pkg="tf" type="static_transform_publisher" name="baselink_laser" args="0 0 0 0 0 0 /base_link /laser 10"/>
    <node pkg="tf" type="static_transform_publisher" name="laser_imu" args="0 0 0 0 0 0 /laser /base_imu 10"/>
    <node pkg="tf" type="static_transform_publisher" name="baselink_camera" args="0 0 0 0 0 0 /base_link /camera 10"/>

    <node pkg="tf" type="static_transform_publisher" name="door1" args="1 0 0 0 0 0 /odom/door1 10"/>
    
    <!-- Start the map server node and specify the map file (*.pgm) and the map resolution in metres/pixel -->
    <node name="map_server" pkg="map_server" type="map_server" args="$(find amcl_listener)/maps/pow_real_time.yaml"         output="screen"/>
    
    <!--Start the Laser_scan_matcher package, to provide odometry from laser data (ICP)-->
    <node pkg="laser_scan_matcher" type="laser_scan_matcher_node" 
        name="laser_scan_matcher_node" output="screen">
        <param name="use_alpha_beta" value="true"/>
        <param name="max_iterations" value="10"/>
    </node>

    <!-- Start the gmapping node -->
    <!--node pkg="gmapping" type="slam_gmapping" name="slam_gmapping" output="screen"/-->

    <node pkg="amcl" type="amcl" name="amcl" respawn="true" output="screen">
        <param name="base_frame_id" value="base_link"/>
        <param name="odom_frame_id" value="world"/>
        <param name="global_frame_id" value="map"/>
        <param name="update_min_d" value="0.09"/>   
        <param name="update_min_a" value="0.09"/> 
        <param name="initial_pose_x" value="-1"/>
        <param name="initial_pose_y" value="0"/>
        <param name="initial_pose_a" value="-0.1"/>
        <param name="min_particles" value="6000"/> 
        <param name="max_particles" value="8000"/>
        <param name="odom_model_type" value="diff"/>
        <param name="kld_err" value="0.1"/> 
        <param name="resample_interval" value="1"/>
        <param name="odom_alpha1" value="0.2"/>   
        <param name="odom_alpha2" value="0.2"/>
        <param name="odom_alpha3" value="0.5"/>
        <param name="odom_alpha4" value="0.5"/>
        <param name="laser_max_beams" value="30"/>
    </node>

    <!--Start the "analyzer_packages"-->
    <!-- acml_listener broadcasts markers for the position of the wheelchair, to visualize in Rviz-->
    <node pkg="amcl_listener" type="amcl_pose_listener" name="amcl_listener" output="screen"/>
    
    <!-- Start an rviz node with a custom configuration for the viewpoint, map_server, trajectory, laser scans, etc -->
    <node pkg="rviz" type="rviz" output="screen" name="rviz" args="-d $(find pow_analyzer)/launch/pow_rviz.vcg"/> 

</launch>

Sorry. I do not understand what Dornhage done with the code. Why is said code formatted?

Originally posted by Astronaut on ROS Answers with karma: 330 on 2012-08-16
Post score: 0

Original comments
Comment by dornhege on 2012-08-17:
You didn't use the "code"-button (the one with the 10101) or indent your code, so it was not displayed correctly and unreadable. I fixed that.
Comment by Astronaut on 2012-08-17:
" code button"?? When I edit the code you mean? Any comment to my code??
Comment by dornhege on 2012-08-17:
Yes, during editing there is a button with something like 101010 on it that will format your posted code to be readable.
Comment by Astronaut on 2012-08-17:
Ok. Thanks. But I think my code is ok, and doing what I want. I do not understand the comment of michikarg. Why my code is wrong?
Comment by dornhege on 2012-08-17:
I only changed the display of your code. I have not reviewed the contents.
Comment by Astronaut on 2012-08-17:
AAh ok. Can you give me some advice or help about the content? Cause I think that my code is ok

A:

You are posting the position of the door in reference to the /odom-frame which ist NOT the position of the robot but the place where the robot started. You should read through the ROS navigation pages where also the frames used for localization and navigation are explained ( http://ros.org/wiki/navigation/ ). Usually you should post the position of the door in reference to the /map-frame and then ask for the transformation between you robot base_link or base-footprint-frame (which you basically did) given your robot's base-frame is /base_link.

Originally posted by michikarg with karma: 2108 on 2012-08-16
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Astronaut on 2012-08-16:
So the  the robot start in some point of the map environment. And start moving. I just want to know the distance of the robot in every moment of time ( while he is moving in the map) to that door. I think that what my code is doing, Correct?So what should I change, which part of the code?
Comment by Astronaut on 2012-08-16:
So I change this line in my launch  file. <node pkg="tf" type="static_transform_publisher" name="door1" args="1 0 0 0 0 0 /world /door1 .  No now the door frame is fixed on the world map frame . So base_link and world (map frame ) are the same now and can be related to some function like distance.
Comment by michikarg on 2012-08-16:
base_link and the map-frame should NOT be the same... the base_link frame is usually generated by your localization and represents the pose of your robot in the map. The map-frame is generated by your map server and is the origin of your map... Did you read through http://ros.org/wiki/navigation?
Comment by Astronaut on 2012-08-16:
cause of that I change the code.  <node pkg="tf" type="static_transform_publisher" name="door1" args="1 0 0 0 0 0 /world /door1
Comment by Astronaut on 2012-08-16:
cause of that I change the code.  <node pkg="tf" type="static_transform_publisher" name="door1" args="1 0 0 0 0 0 /world /door1
Comment by Astronaut on 2012-08-16:
So I think this part of the code give me the the distance to the door. Cause my laser is placed on the base_link. So it give me the distance between the door and the base link in every time step
while (node.ok()){ tf::StampedTransform transform; try{ listener.lookupTransform("/base_link", "/door1",
Comment by Astronaut on 2012-08-16:
I dont see what is wrong. Can you point which part of the code is not correct?
Comment by michikarg on 2012-08-16:
It seems to me that you are still not familiar with the basics of navigation and tf. While ROS answers is meant to help you, you will still have to understand the concepts and debug your code yourself...
Comment by Astronaut on 2012-08-16:
I understand the concept and also compiled and run my code too. It works fine. I can show you the code with visualisation. Than visualize that distance between the door and the robot position. I just edit that code
Comment by Astronaut on 2012-08-17:
Sorry. I do not understand what Dornhage done with the code. Why is said code formatted? I can not see his answers/ comment. Why?


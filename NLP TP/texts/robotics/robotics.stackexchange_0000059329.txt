Q:

Build packages with more than one .cpp

I have received some packages from Fuerte which I need to compile in Hydro with catkin.
Each package has more than one source file .cpp
In rosbuild, there was:
rosbuild_add_executable([file1])
rosbuild_add_executable([file2])
In catkin I did the same but with add_executable
The problem is that if I add both files (with different names of executables of course) the program doesn't compile
If I omit one of them, everything works properly, but I need both.
I don't know if the solution is to create two packages or I need to add anything to CMakeLists.txt
    cmake_minimum_required(VERSION 2.8.3)
    project(test_imu)
    
    ## Find catkin macros and libraries
    ## if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz)
    ## is used, also find other catkin packages
    find_package(catkin REQUIRED COMPONENTS
        message_generation
        nav_msgs 
        robotnik_msgs
        roscpp 
        sensor_msgs 
        geometry_msgs
        )
    
    ## System dependencies are found with CMake's conventions
    # find_package(Boost REQUIRED COMPONENTS system)
    find_package(MRPT REQUIRED 
        gui
        slam
        )
    find_package(gazebo REQUIRED)
    include_directories(include ${catkin_INCLUDE_DIRS} ${GAZEBO_INCLUDE_DIRS} ${SDFormat_INCLUDE_DIRS})
    include_directories("/home/summitxl/catkin_ws/src/Ensayos/test_imu/include")
    
    
    ## Uncomment this if the package has a setup.py. This macro ensures
    ## modules and global scripts declared therein get installed
    ## See http://ros.org/doc/api/catkin/html/user_guide/setup_dot_py.html
    # catkin_python_setup()
    
    ################################################
    ## Declare ROS messages, services and actions ##
    ################################################
    
    ## To declare and build messages, services or actions from within this
    ## package, follow these steps:
    ## * Let MSG_DEP_SET be the set of packages whose message types you use in
    ##   your messages/services/actions (e.g. std_msgs, actionlib_msgs, ...).
    ## * In the file package.xml:
    ##   * add a build_depend and a run_depend tag for each package in MSG_DEP_SET
    ##   * If MSG_DEP_SET isn't empty the following dependencies might have been
    ##     pulled in transitively but can be declared for certainty nonetheless:
    ##     * add a build_depend tag for "message_generation"
    ##     * add a run_depend tag for "message_runtime"
    ## * In this file (CMakeLists.txt):
    ##   * add "message_generation" and every package in MSG_DEP_SET to
    ##     find_package(catkin REQUIRED COMPONENTS ...)
    ##   * add "message_runtime" and every package in MSG_DEP_SET to
    ##     catkin_package(CATKIN_DEPENDS ...)
    ##   * uncomment the add_*_files sections below as needed
    ##     and list every .msg/.srv/.action file to be processed
    ##   * uncomment the generate_messages entry below
    ##   * add every package in MSG_DEP_SET to generate_messages(DEPENDENCIES ...)
    
    ## Generate messages in the 'msg' folder
    # add_message_files(
    #   FILES
    #   Message1.msg
    #   Message2.msg
    # )
## Generate services in the 'srv' folder
# add_service_files(
#   FILES
#   Service1.srv
#   Service2.srv
# )

## Generate actions in the 'action' folder
# add_action_files(
#   FILES
#   Action1.action
#   Action2.action
# )

## Generate added messages and services with any dependencies listed here
# generate_messages(
#   DEPENDENCIES
#   std_msgs  # Or other packages containing msgs
# )

###################################
## catkin specific configuration ##
###################################
## The catkin_package macro generates cmake config files for your package
## Declare things to be passed to dependent projects
## INCLUDE_DIRS: uncomment this if you package contains header files
## LIBRARIES: libraries you create in this project that dependent projects also need
## CATKIN_DEPENDS: catkin_packages dependent projects also need
## DEPENDS: system dependencies of this project that dependent projects also need
catkin_package(
#  INCLUDE_DIRS include
#  LIBRARIES test_imu
#  CATKIN_DEPENDS other_catkin_pkg
   DEPENDS gazebo_ros
)

###########
## Build ##
###########

## Specify additional locations of header files
## Your package locations should be listed before other locations

## Declare a cpp library
# add_library(test_imu
#   src/${PROJECT_NAME}/test_imu.cpp
# )

## Declare a cpp executable
#add_executable(test_imu_node src/test_imu_node.cpp)
add_executable(test_imu src/test_imu.cpp)
#add_executable(test_imu_results src/test_imu_results.cpp)

## Add cmake target dependencies of the executable/library
## as an example, message headers may need to be generated before nodes
# add_dependencies(test_imu_node test_imu_generate_messages_cpp)

## Specify libraries to link a library or executable target against
# target_link_libraries(test_imu_node
#   ${catkin_LIBRARIES
target_link_libraries(test_imu
   ${catkin_LIBRARIES}
 )
# )

#############
## Install ##
#############

# all install targets should use catkin DESTINATION variables
# See http://ros.org/doc/api/catkin/html/adv_user_guide/variables.html

## Mark executable scripts (Python etc.) for installation
## in contrast to setup.py, you can choose the destination
# install(PROGRAMS
#   scripts/my_python_script
#   DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
# )

## Mark executables and/or libraries for installation
# install(TARGETS test_imu test_imu_node
#   ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
#   LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
#   RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
# )

## Mark cpp header files for installation
# install(DIRECTORY include/${PROJECT_NAME}/
#   DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}
#   FILES_MATCHING PATTERN "*.h"
#   PATTERN ".svn" EXCLUDE
# )

## Mark other files for installation (e.g. launch and bag files, etc.)
# install(FILES
#   # myfile1
#   # myfile2
#   DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}
# )

#############
## Testing ##
#############

## Add gtest based cpp test target and link libraries
# catkin_add_gtest(${PROJECT_NAME}-test test/test_test_imu.cpp)
# if(TARGET ${PROJECT_NAME}-test)
#   target_link_libraries(${PROJECT_NAME}-test ${PROJECT_NAME})
# endif()

## Add folders to be run by python nosetests
# catkin_add_nosetests(test)

Originally posted by arenillas on ROS Answers with karma: 223 on 2014-05-13
Post score: 2

Original comments
Comment by Tirjen on 2014-05-13:
Can you please edit your question adding your CMakeLists.txt?
Comment by arenillas on 2014-05-13:
here it is
Comment by Tirjen on 2014-05-13:
I suppose you get the error when the add_executable and the target_link_libraries for the test_imu_node are not commented. There is a missing closed bracket in the target_link_libraries for the test_imu_node. I don't know if this is the problem, can you please say otherwise which error gives you the compiler?
Comment by sterlingm on 2014-05-13:
Are you trying to make 3 different executables with 1 source file each or 1 executable with 3 source files? Can you post the error message?
Comment by arenillas on 2014-05-13:
2 different executables with two different source files.
Comment by sterlingm on 2014-05-13:
Your add_executable calls only have 1 source file. You need to add more source files. I added it as an answer.

A:

You need to add all of source files that will build an executable to the add_executable command.
## Declare a cpp executable
add_executable(executable_one src/source_one.cpp src/source_two.cpp ... src/source_n.cpp) 

To create multiple executables, you just add multiple instances of that line:
## Declare a cpp executable
add_executable(executable_one src/source_one.cpp src/source_two.cpp ... src/source_n.cpp) 
add_executable(executable_two src/source_one.cpp src/source_two.cpp ... src/source_n.cpp) 
add_executable(executable_three src/source_one.cpp src/source_two.cpp ... src/source_n.cpp) 

Each add_executable is self-contained so it will only use the files you list to build the executable. So make sure you list all source files needed, even they are also used for a different executable. Also, make sure you have the target_link_library(executable ${catkin_LIBRARIES}) for each executable.

Originally posted by sterlingm with karma: 380 on 2014-05-13
This answer was ACCEPTED on the original site
Post score: 5


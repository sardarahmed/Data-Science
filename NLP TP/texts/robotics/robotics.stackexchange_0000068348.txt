Q:

Add a new ROS publisher node to a QTcreator project which already contains a ROS subscriber node

Hi guys,
I've used QT to create a package with GUI and a ROS node (subscriber), and every thing works as I expected. Now I need to add a new publisher node to my QT. Please help me to do this if you have any idea.
Thanks
my whole code is here
Main.cpp
#include "ros/ros.h"

#include "std_msgs/String.h"
#include "mainwindow.h"
#include 
#include <boost/thread.hpp>
#include 
#include <string.h>
#include 
#include 
#include 
#include 
#include 
#include "newwindow.h"
#include 
#include 
#include "gui_sub/Position.h"
using namespace std;
MainWindow* mainWin;
void infoCallback(const std_msgs::String::ConstPtr& msg)
{
// ROS_INFO("The New module is: [%s]", msg->data.c_str());
std::string str = msg->data;
//The Name of Raspberry Pi
std::string str_name = str.substr (14,19);
// List of Servo motors
std::string str_servo_1 = str.substr (55,23);
std::string str_servo_2 = str.substr (82,23);
std::string str_servo_3 = str.substr (109,23);
std::string str_servo_4 = str.substr (136,23);
// List of Brushless motors
std::string str_brushless_1 = str.substr (163,25);
std::string str_brushless_2 = str.substr (192,25);
std::string str_brushless_3 = str.substr (221,25);
std::string str_brushless_4 = str.substr (250,25);
//Converting the STD Strings to QStrings
QString qstr = QString::fromStdString(str);
QString qstr_name = QString::fromStdString(str_name);

QString qstr_servo_1 = QString::fromStdString(str_servo_1);
QString qstr_servo_2 = QString::fromStdString(str_servo_2);
QString qstr_servo_3 = QString::fromStdString(str_servo_3);
QString qstr_servo_4 = QString::fromStdString(str_servo_4);

QString qstr_brushless_1 = QString::fromStdString(str_brushless_1);
QString qstr_brushless_2 = QString::fromStdString(str_brushless_2);
QString qstr_brushless_3 = QString::fromStdString(str_brushless_3);
QString qstr_brushless_4 = QString::fromStdString(str_brushless_4);

// Using the new strings to create our lists via signal and slot methods
mainWin->updatemethod_info(qstr);
mainWin->updatemethod_name(qstr_name);

mainWin->updatemethod_servo_1(qstr_servo_1);
mainWin->updatemethod_servo_2(qstr_servo_2);
mainWin->updatemethod_servo_3(qstr_servo_3);
mainWin->updatemethod_servo_4(qstr_servo_4);

mainWin->updatemethod_brush_1(qstr_brushless_1);
mainWin->updatemethod_brush_2(qstr_brushless_2);
mainWin->updatemethod_brush_3(qstr_brushless_3);
mainWin->updatemethod_brush_4(qstr_brushless_4);

}
void callbackmethods()
{
ros::NodeHandle n;
ros::Subscriber sub = n.subscribe("/info", 1000, infoCallback);
ros::Rate rate(30);
while (ros::ok()){
ros::spinOnce();
rate.sleep();
}
}
int main(int argc, char **argv)
{
ros::init(argc, argv, "gui_sub");
QApplication app(argc, argv);
app.setOrganizationName("Trolltech");
app.setApplicationName("Application");

mainWin = new MainWindow();
mainWin->show();

//boost::thread thread_spin( boost::bind( ros::spin ));
boost::thread thread_spin( boost::bind( callbackmethods ));
ros::init(argc, argv, "servoinput");
ros::NodeHandle nt;
ros::Publisher position_pub;
position_pub=nt.advertise<gui_sub::Position>("position", 1000);
std::string di;
gui_sub::Position msg;
std::cout << "I am here  ";
std::cin>>di;
msg.position = atof(di.c_str());
position_pub.publish(msg);
return app.exec();
}

Originally posted by Saeid on ROS Answers with karma: 3 on 2015-06-29
Post score: 0

A:

Create another publisher (class) inside the node like in the C++ tutorial for creating nodes?
Should be something like this:
ros::Publisher pub; //When in class this is the member in class definition
pub = nh.advertise<pkg::TopicType>("awesome_topic", 1000 /*Queue*/); //This goes to Constructor 

//Maybe your main loop

ros::Rate rate(10);
while(ros:ok())
{
  pkg::TopicType msg; 
  /*add data to your msg here*/
  msg.field="some data";
  pub.publish(msg); //Publish it
  
  ros::spinOnce();
  rate.sleep(); //limit loop rate
}

See here: http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28c%2B%2B%29

Originally posted by cyborg-x1 with karma: 1376 on 2015-06-29
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Saeid on 2015-06-30:
Many thanks for your interest to answer my question.
I tried to do what you mentioned by adding this lines to my Main.cpp : (NEXT COOMENT)
Comment by Saeid on 2015-06-30:
ros::Publisher position_pub;
ros::NodeHandle nt;
position_pub=nt.advertise<beginner_tutorials::Position>("position", 1);
std::string di="1.5";
beginner_tutorials::Position msg;
msg.position = atof(di.c_str());
position_pub.publish(msg);
Comment by Saeid on 2015-06-30:
But unfortunately it's not publishing .
Comment by cyborg-x1 on 2015-06-30:
Could you please paste the whole code? Maybe edit your answer and add it.
Comment by cyborg-x1 on 2015-06-30:
Probably in qt you will have your main "ros" loop in a second thread.
Comment by cyborg-x1 on 2015-06-30:
Ahh now I see you problem.
 position_pub=nt.advertise<gui_sub::position>("position", 1000); 

must go into a function you call. I did not think of the main function of the Qt project, just put it somewhere shortly after where you set the values of the message.
Comment by cyborg-x1 on 2015-06-30:
normally when using Qt you put the while(ros::ok()) loop inside a function of a seperate thread. You are executing ros::spin() as thread, it does take care of the incomming messages and calls the callback functions. publish(msg) should be able to be called anywhere.
Comment by Saeid on 2015-06-30:
Thank you man, It works now, thanks a lot for your help man
Comment by cyborg-x1 on 2015-06-30:
You're welcome ;-)


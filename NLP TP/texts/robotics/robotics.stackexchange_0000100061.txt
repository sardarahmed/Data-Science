Q:

How to check callback queue?

Hello,
I have a node that subscribes to 3 topics that are being published by individual nodes. In the subscriber node, I have 3 callbacks, one for each. I would like to know if it is possible to know whether there are messages in callback queue. What I am trying to do is to avoid that the same topic triggers its callback twice in a row if there are messages from the other 2 topics available in the callback queue.
This is the code I have now:
#include "ros/ros.h"
#include "sensor_msgs/Image.h"
#include "sensor_msgs/LaserScan.h"
#include "geometry_msgs/TwistStamped.h"

// Callbacks
void pc_pub_img_callback(const sensor_msgs::Image::ConstPtr& msg){
      //ROS_INFO("Received from pc_pub_img");
      ROS_INFO("Img:Callback(%d)", msg->header.seq);
      ros::Duration(0.2).sleep();
      // Serialization
      sensor_msgs::Image Image;
      uint32_t serial_size = ros::serialization::serializationLength(*msg);
      boost::shared_array<uint8_t> buffer(new uint8_t[serial_size]);
      ROS_INFO("Img:Serialized");
}

void pc_pub_laser_callback(const sensor_msgs::LaserScan::ConstPtr& msg){
      //ROS_INFO("Received from pc_pub_laser");
      ROS_INFO("Laser:Callback(%d)", msg->header.seq);

      // Serialization
      sensor_msgs::Image LaserScan;
      uint32_t serial_size = ros::serialization::serializationLength(*msg);
      boost::shared_array<uint8_t> buffer(new uint8_t[serial_size]);
      ROS_INFO("Laser:Serialized");
}

void pc_pub_twist_callback(const geometry_msgs::TwistStamped::ConstPtr& msg){
      //ROS_INFO("Received from pc_pub_img");
      ROS_INFO("Twist:Callback(%d)", msg->header.seq);

      // Serialization
      geometry_msgs::Twist Twist;
      uint32_t serial_size = ros::serialization::serializationLength(*msg);
      boost::shared_array<uint8_t> buffer(new uint8_t[serial_size]);
      ROS_INFO("Twist:Serialized");
}

int main(int argc, char **argv)
{

    ros::init(argc, argv, "arm_to_fpga");
    ros::NodeHandle n;
    
    ros::Subscriber sub_img = n.subscribe("/pc_pub_img", 1000, pc_pub_img_callback);
    ros::Subscriber sub_laser = n.subscribe("/pc_pub_laser", 1000, pc_pub_laser_callback);
    ros::Subscriber sub_twist = n.subscribe("/pc_pub_twist", 1000, pc_pub_twist_callback);

    ros::spin();

    return 0;
}

Thanks.
EDIT: I've changed the frequencies for the 3 publishers at 30, 60 and 60 respectively and removed the serialization part to make the output simpler. Then, I got the following:
[ INFO] [1632761598.718118783]: Twist:Callback
[ INFO] [1632761598.720308913]: Laser:Callback
[ INFO] [1632761598.735116602]: Img:Callback
[ INFO] [1632761598.736248825]: Twist:Callback
[ INFO] [1632761598.736324787]: Laser:Callback
[ INFO] [1632761598.750847497]: Twist:Callback
[ INFO] [1632761598.753741510]: Laser:Callback
[ INFO] [1632761598.762706367]: Img:Callback
[ INFO] [1632761598.764424037]: Twist:Callback
[ INFO] [1632761598.766623670]: Laser:Callback
[ INFO] [1632761598.778012548]: Img:Callback
[ INFO] [1632761598.781003259]: Twist:Callback
[ INFO] [1632761598.783278070]: Laser:Callback
[ INFO] [1632761598.798151580]: Twist:Callback
[ INFO] [1632761598.800334432]: Laser:Callback
[ INFO] [1632761598.817158784]: Img:Callback
[ INFO] [1632761598.817276101]: Twist:Callback
[ INFO] [1632761598.817368705]: Laser:Callback
[ INFO] [1632761598.831502251]: Twist:Callback
[ INFO] [1632761598.833594552]: Laser:Callback
[ INFO] [1632761598.848181492]: Twist:Callback
[ INFO] [1632761598.850259481]: Laser:Callback
[ INFO] [1632761598.853909133]: Img:Callback
[ INFO] [1632761598.864712495]: Twist:Callback
[ INFO] [1632761598.866926431]: Laser:Callback
[ INFO] [1632761598.881360624]: Twist:Callback
[ INFO] [1632761598.885404560]: Img:Callback
[ INFO] [1632761598.885498932]: Laser:Callback
[ INFO] [1632761598.898164827]: Twist:Callback
[ INFO] [1632761598.900324819]: Laser:Callback
[ INFO] [1632761598.914681449]: Twist:Callback
[ INFO] [1632761598.918684480]: Img:Callback
[ INFO] [1632761598.918797223]: Laser:Callback
[ INFO] [1632761598.931412780]: Twist:Callback
[ INFO] [1632761598.953476288]: Img:Callback
[ INFO] [1632761598.953735208]: Twist:Callback
[ INFO] [1632761598.960459469]: Laser:Callback
[ INFO] [1632761598.960576034]: Laser:Callback
[ INFO] [1632761598.965029298]: Twist:Callback
[ INFO] [1632761598.980162791]: Img:Callback
[ INFO] [1632761598.981067892]: Twist:Callback
[ INFO] [1632761598.997919124]: Twist:Callback
[ INFO] [1632761599.004356246]: Laser:Callback
[ INFO] [1632761599.004398225]: Laser:Callback
[ INFO] [1632761599.004415405]: Laser:Callback
[ INFO] [1632761599.011760336]: Img:Callback
[ INFO] [1632761599.014376088]: Twist:Callback
[ INFO] [1632761599.031260034]: Twist:Callback
[ INFO] [1632761599.049056928]: Img:Callback
[ INFO] [1632761599.049138806]: Twist:Callback
[ INFO] [1632761599.049186088]: Laser:Callback
[ INFO] [1632761599.049257241]: Laser:Callback
[ INFO] [1632761599.050256653]: Laser:Callback

I want to know when the same callback is triggered multiple times in a row, whether there are messages for the other callbacks already in the queue. Hence, check before the callback is triggered to avoid triggering the same callback multiple times in a row when there is a message available for another callback to be triggered.

Originally posted by Ariel on ROS Answers with karma: 65 on 2021-09-10
Post score: 1

Original comments
Comment by Jaron on 2021-09-11:
I think you'll need to write your own CallbackQueue and spinner like mentioned here. Unfortunately, I haven't done that in ROS 1 so I can't provide more help than that but I thought I'd mention it.
Comment by Ariel on 2021-09-27:
it seems this is the way to go. Unfortunately I haven't found any example that shows how to check which queue for the messages has data available. I would assume that at some point, all queues for the 3 messages have received at least one and I would like to know at a given frequency, which ones has something in their queue. I found something similar here but that only gives priority to one node. I would first like to know whether there is a message in each callback queue and then decide myself from which queue to read first.

A:

According to the documentation (as suggested by @gvdhoorn) the code should look something like this:
#include "ros/ros.h"
#include "ros/callback_queue.h"
#include "sensor_msgs/Image.h"
#include "sensor_msgs/LaserScan.h"
#include "geometry_msgs/TwistStamped.h"

// Callbacks
void pc_pub_img_callback(const sensor_msgs::Image::ConstPtr& msg){
      ROS_INFO("Img:Callback");
}

void pc_pub_laser_callback(const sensor_msgs::LaserScan::ConstPtr& msg){
      ROS_INFO("Laser:Callback");
}

void pc_pub_twist_callback(const geometry_msgs::TwistStamped::ConstPtr& msg){
      ROS_INFO("Twist:Callback");
}

int main(int argn, char* args[])
{
  ros::init(argn, args, "arm_to_fpga");
  ros::NodeHandle n_img;
  ros::NodeHandle n_laser;
  ros::NodeHandle n_twist;

  ros::CallbackQueue Queue_img;
  ros::CallbackQueue Queue_laser;
  ros::CallbackQueue Queue_twist;

  n_img.setCallbackQueue(&Queue_img);
  n_laser.setCallbackQueue(&Queue_laser);
  n_twist.setCallbackQueue(&Queue_twist);

  ros::Subscriber s_img = n_img.subscribe("/FPGA_ROS_Scheduler/pc_pub_img", 1, pc_pub_img_callback);
  ros::Subscriber s_laser = n_laser.subscribe("/FPGA_ROS_Scheduler/pc_pub_laser", 1, pc_pub_laser_callback);
  ros::Subscriber s_twist = n_twist.subscribe("/FPGA_ROS_Scheduler/pc_pub_twist", 1, pc_pub_twist_callback);

  while(ros::ok())
  {
    if(!Queue_img.isEmpty() && !Queue_laser.isEmpty() && !Queue_twist.isEmpty())
    {
      Queue_img.callOne(ros::WallDuration(1.0));
      Queue_laser.callOne(ros::WallDuration(1.0));
      Queue_twist.callOne(ros::WallDuration(1.0));
    }
    ros::spinOnce();
  }    
  return 0;
}

EDIT: Here is the working example. It waits until all 3 queues have at least one message to invoke the callbacks.

Originally posted by Ariel with karma: 65 on 2021-09-29
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by gvdhoorn on 2021-09-29:
This is not an answer I believe, as you report yourself it doesn't seem to work.
Comment by Ariel on 2021-09-29:
True, it is not fully working like posted there, but seems to be the way to go with respect to the queues. I believe the issue is how to spin. That's why I posted it as an answer rather than editing the original question. Should I do that and delete this question?
EDIT: I got it working and edited the answer.
Comment by Mike Scheutzow on 2021-09-30:
I am skeptical that the code shown works well, because I see no ros::spinOnce() in there, and no rate limiting in the main loop. Also, the code does not implement a solution for the problem that is described.
A far simpler soultion is: If you don't want messages going out close together in time, then use a global variable to store the time-of-day you last published a message, then discard any new messages that arrive shortly after that. However, this approach has its own problems: it assumes you are willing to ignore the effect of message delivery delays, and to ignore the header.stamp in the arriving messages.
Comment by Ariel on 2021-09-30:
Removing the commented things during tested I deleted the ros::spinOnce(); (edited). The code now implements a solution to check callback queues individually which was my main question.


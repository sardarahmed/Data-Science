Q:

Creating a hardware interface for a physical sensor

I wish to use ros2_control to create interfaces with my robot.
I have replicated the rrbot_system_with_sensor example in ros-controls/ros2_control_demos.
I have created a subclass of hardware_interface::SystemInterface, and can see that my code is getting loaded and executed. I can see the sensor and command interfaces in list_hardware_interfaces, but its all just fake data. This is a good start, but I am stumped on how to create the actual hardware interface wrapper.
For context, our sensors and multiple of our motor drivers are connected to the RaspberryPi as Serial devices (USB/USART) and have custom protocols. I can write the logic layer, but I do not know how to implement the transport layer compatable with ros2_control.
So I have two primary questions:
Am I on the right track to subclass hardware_interface::SystemInterface?
More importantly, how do I actually communicate with the hardware in a realtime-safe fashion?

Originally posted by theunkn0wn1 on ROS Answers with karma: 3 on 2021-09-19
Post score: 0

Original comments
Comment by Mike Scheutzow on 2021-09-19:
Have you read this: https://ros-controls.github.io/control.ros.org/getting_started.html
Comment by theunkn0wn1 on 2021-09-19:
I have. All of that documentation is abstract and doesn't appear to clearly convey how a user would actually implement these concepts in software.

A:

If you're still looking for an answer I can try to help out. Although it would be a bit easier if you could share some code.
If I understand correctly, you created a class derived from SystemInterface, and you're looking for where to put the code which will actually communicate with hardware, fill states with real data from some sensors, and to pass on commands to an actuator?
You can take a look here for a couple of implementations: https://github.com/dignakov/ros2_control_demo_drivers. I haven't updated this repo in a while, so it doesn't match the latest ros2_control master branch so you should still follow the examples there if something doesn't agree, but it should give you an idea of how to set this up (I will update everything at some point soon...)
You can (or at least this is how I did it):
(1) Put put all of the variables/classes/structs you need to talk to your hardware as private members of your class.
(2) Configure them (along with getting parameters and everything else) in configure()
(3) Initialize the communication in start() and make sure you're getting data from the robot that makes sense.
(4) Fill in the read() and write() functions to read data from your sensor and fill in the state, and fill in commands which will be forwarded to the hardware.
(5) stop() can also be important to get your hardware into some reasonable state.
Take a look here, the Kuka version is probably a bit closer to what you're doing:
https://github.com/dignakov/ros2_control_demo_drivers/blob/master/ros2_control_kuka_demo_driver/src/kuka_system_position_only.cpp

Originally posted by EvilPictureBook with karma: 66 on 2021-09-26
This answer was ACCEPTED on the original site
Post score: 4

Original comments
Comment by theunkn0wn1 on 2021-09-30:
This helped me greatly, thank you!
Comment by bmagyar on 2021-11-29:
Don't forget to mark the answer correct to show others you are happy with it


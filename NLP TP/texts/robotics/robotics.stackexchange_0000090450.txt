Q:

Error using member function as callback for `setFromIK` on `RobotState` class

Good day,
I am trying to use the function setFromIK defined on moveit::core::RobotState.
This function admits a callable parameter named  GroupStateValidityCallbackFn with type (function signature):
typedef boost::function<bool(RobotState* robot_state, const JointModelGroup* joint_group, const double* joint_group_variable_values)>
The problem arises because I am trying to pass a member class functions to this parameter (because I need come class instance member fields in the processing), and then the binding process goes to hell.
My class look like this:
class CSDA10F{
    public:
       bool validateIKSolution( robot_state::RobotState* robot_state, 
                                        const robot_state::JointModelGroup* joint_group, 
                                        const double* joint_group_variable_value){
              [...]
              // some code here
              [...]
       }

       bool planCartesianMotionTask(MoveGroupInterface* move_group, 
                                                    geometry_msgs::Pose initial_pose, 
                                                    geometry_msgs::Pose final_pose,
                                                    std::vector<MoveGroupInterface::Plan> motion_plans,
                                                    uint max_configurations = 10) {
       [...] // Here I make the call!!!.
            auto ik_check_callback = std::bind(&CSDA10F::validateIKSolution, this, _1, _2, _3);
            ik_solution_found = start_state.setFromIK( joint_model_group, initial_pose, 10, 0.01, ik_check_callback);
       [...]
       }

I use 3 placeholders for the 3 arguments from the function, but then the compiler just failes with an error that I simply dont understand.
In file included from /usr/include/boost/function/detail/maybe_include.hpp:28:0,
                 from /usr/include/boost/function/detail/function_iterate.hpp:14,
                 from /usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp:62,
                 from /usr/include/boost/function.hpp:64,
                 from /opt/ros/kinetic/include/ros/forwards.h:40,
                 from /opt/ros/kinetic/include/ros/common.h:37,
                 from /opt/ros/kinetic/include/ros/ros.h:43,
                 from /home/invite/catkin_ws/src/[...].cpp:1:
/usr/include/boost/function/function_template.hpp: In instantiation of ‘static R boost::detail::function::function_obj_invoker3<FunctionObj, R, T0, T1, T2>::invoke(boost::detail::function::function_buffer&, T0, T1, T2) [with FunctionObj = std::_Bind<std::_Mem_fn<bool (invite_utils::CSDA10F::*)(moveit::core::RobotState*, const moveit::core::JointModelGroup*, const double*)>(invite_utils::CSDA10F, boost::arg<1>, boost::arg<2>, boost::arg<3>)>; R = bool; T0 = moveit::core::RobotState*; T1 = const moveit::core::JointModelGroup*; T2 = const double*]’:
/usr/include/boost/function/function_template.hpp:940:38:   required from ‘void boost::function3<R, T1, T2, T3>::assign_to(Functor) [with Functor = std::_Bind<std::_Mem_fn<bool (invite_utils::CSDA10F::*)(moveit::core::RobotState*, const moveit::core::JointModelGroup*, const double*)>(invite_utils::CSDA10F, boost::arg<1>, boost::arg<2>, boost::arg<3>)>; R = bool; T0 = moveit::core::RobotState*; T1 = const moveit::core::JointModelGroup*; T2 = const double*]’
/usr/include/boost/function/function_template.hpp:728:7:   required from ‘boost::function3<R, T1, T2, T3>::function3(Functor, typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type) [with Functor = std::_Bind<std::_Mem_fn<bool (invite_utils::CSDA10F::*)(moveit::core::RobotState*, const moveit::core::JointModelGroup*, const double*)>(invite_utils::CSDA10F, boost::arg<1>, boost::arg<2>, boost::arg<3>)>; R = bool; T0 = moveit::core::RobotState*; T1 = const moveit::core::JointModelGroup*; T2 = const double*; typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type = int]’
/usr/include/boost/function/function_template.hpp:1077:16:   required from ‘boost::function<R(T0, T1, T2)>::function(Functor, typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type) [with Functor = std::_Bind<std::_Mem_fn<bool (invite_utils::CSDA10F::*)(moveit::core::RobotState*, const moveit::core::JointModelGroup*, const double*)>(invite_utils::CSDA10F, boost::arg<1>, boost::arg<2>, boost::arg<3>)>; R = bool; T0 = moveit::core::RobotState*; T1 = const moveit::core::JointModelGroup*; T2 = const double*; typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type = int]’
/home/invite/catkin_ws/src/invite-robotics/invite_utils/include/invite_utils/csda10f_interface.h:202:116:   required from here
/usr/include/boost/function/function_template.hpp:138:22: error: no match for call to ‘(std::_Bind<std::_Mem_fn<bool (invite_utils::CSDA10F::*)(moveit::core::RobotState*, const moveit::core::JointModelGroup*, const double*)>(invite_utils::CSDA10F, boost::arg<1>, boost::arg<2>, boost::arg<3>)>) (moveit::core::RobotState*, const moveit::core::JointModelGroup*, const double*)’
           return (*f)(BOOST_FUNCTION_ARGS);

Does the declaration on the RobotState does not allow for member functions (I dont see why not)?, I believe I am making a mistake with std::bind but I cannot seem to find an answer of what it is.
What do I know:

I am using the correct argument types in the function to be bind
I have the correct number of arguments (3)

Any ideas what is the problem?

Originally posted by Danfoa on ROS Answers with karma: 47 on 2019-02-08
Post score: 0

A:

Seems like the compiler wants to use the boost:: placeholders instead of the std:: ones despite you using std::bind. You could change _1, ... with std::placeholders::_1, ... or, maybe a little less verbose, use a local using declaration for the correct namespace i.e. using namespace std::placeholders; to import the names for resolution.
If you're using at least C++11, you can avoid bind (boost's or std's) with a lambda:
new_robot_state.setFromIK(
    joint_model_group,
    target_pose,
    ATTEMPTS,
    TIMEOUT,
    [/* anything else you might need in your callback */](
        moveit::core::RobotState* robot_state,
        const moveit::core::JointModelGroup* joint_group,
        const double* joint_group_variable_values)
    {
      return validateIKSolution(/* anything else you might need in your callback, */
                                robot_state,
                                joint_group,
                                joint_group_variable_values);
    });

Originally posted by aPonza with karma: 589 on 2019-02-14
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Danfoa on 2019-02-15:
Thank you, the solution was also mentioned here, but I forgot to upload ROS answers.


Q:

template instantiation problems with new point types

Hi,
I added a new point type to maintain extra information with each point type. I can use the new point type with all the inline methods of existing templated classes of pcl(eg pcl::PCDWriter.write). But I cant use them with the methods of these templated classes which  are defined outside header files in respective cpp files(eg pcl::ExtractFilter.applyFilter).
The linker complains of undefined reference:

CMakeFiles/combineNearestCam.dir/src/NearestCamMerge.o:(.rodata._ZTVN3pcl14ExtractIndicesIN16scene_processing14PointXYGRGBCamEEE[vtable for pcl::ExtractIndices<scene_processing::PointXYGRGBCam>]+0x18): undefined reference to `pcl::ExtractIndices<scene_processing::PointXYGRGBCam>::applyFilter(pcl::PointCloud<scene_processing::PointXYGRGBCam>&)'

Is there a way to easily add explicit template instantiations of all classes of pcl for the newly defined point type?
code for new point type:
namespace scene_processing
{
    struct PointXYGRGBCam
    {
       float x;
       float y;
       float z;
       float rgb;
       uint32_t cameraIndex;
    };
} 

POINT_CLOUD_REGISTER_POINT_STRUCT(
      scene_processing::PointXYGRGBCam,
      (float, x, x)
      (float, y, y)
      (float, z, z)
      (float, rgb, rgb)
      (uint32_t, cameraIndex, cameraIndex)
      );

Regards
Abhishek

Originally posted by aa755 on ROS Answers with karma: 61 on 2011-03-16
Post score: 0

A:

This problem was solved when I dectared the new point type in point_types.hpp and point_types.h
exactly following the convention of the pre-existing types. In addition to this,in point_types.hpp, I had to add this new type to PCL_POINT_TYPES  to make it work with kdtree and to PCL_XYZ_POINT_TYPES  to make it work with ExtractIndices filter
#define PCL_POINT_TYPES       
(pcl::PointXYZ)             
(pcl::PointXYZI)            
(pcl::PointXYZRGBA)         
(pcl::PointXYZRGB)          
(pcl::PointXY)              
(pcl::InterestPoint)        
(pcl::Normal)               
(pcl::PointNormal)          
(pcl::PointXYZRGBNormal)    
(pcl::PointXYZINormal)      
(pcl::PointWithRange)       
(pcl::PointWithViewpoint)   
(pcl::MomentInvariants)     
(pcl::PrincipalRadiiRSD)    
(pcl::Boundary)             
(pcl::PrincipalCurvatures)  
(pcl::PFHSignature125)      
(pcl::FPFHSignature33)      
(pcl::VFHSignature308)      
(pcl::Narf36)               
(pcl::BorderDescription)    
(pcl::IntensityGradient)    
(pcl::Histogram<2>)         
(pcl::PointWithScale)         
(pcl::PointXYGRGBCam)
// Define all point types that include XYZ data
#define PCL_XYZ_POINT_TYPES   
(pcl::PointXYZ)             
(pcl::PointXYZI)            
(pcl::PointXYZRGBA)         
(pcl::PointXYZRGB)          
(pcl::InterestPoint)        
(pcl::PointNormal)          
(pcl::PointXYZRGBNormal)    
(pcl::PointXYZINormal)      
(pcl::PointWithRange)       
(pcl::PointWithViewpoint)   
(pcl::PointWithScale)         
(pcl::PointXYGRGBCam)

Originally posted by aa755 with karma: 61 on 2011-03-17
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by aa755 on 2011-11-06:
this is not a good solution because it changes code of core ros libraries ... which would be overwritten on update ... also, distributing code will be difficult. A better solution is to create these point types in your own code and include the .hpp files for the modules you need


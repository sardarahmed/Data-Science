Q:

Gracefully stopping robot & roslaunch

Hi!
I am writing a ROS node that takes control of the NAO, and upon receiving a Ctrl+C (or rosnode kill) signal, puts the NAO back to its original position.
In order to do that nao_driver/nao_controller.py (another ROS node) must be running in the background.
The problem crops up when I put both my node and nao_controller in the same roslaunch file. Roslaunch immediately stops nao_controller and my node never has the opportunity of stopping gracefully (ie. going back to the original position).
I've checked the wiki and roslaunch does not seem to have any support for adding node dependencies.
I reckon this must be a fairly common issue (shutdown ordering) and that there must be some guidelines and best practices that I am not following.
Can anyone help?
Thanks!

Originally posted by Miguel S. on ROS Answers with karma: 1114 on 2012-11-22
Post score: 1

A:

The best practice is that each node should be able to properly shutdown itself. As far as I know node orderings for shutdown (and bringup) are not supported by design.
You could circumvent this by (at least in c++) removing the SIGINT handler in ros::init and then doing your own shutdown procedure. But this needs to happen in all nodes involved.

Originally posted by dornhege with karma: 31395 on 2012-11-22
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Miguel S. on 2012-11-22:
I override SIGINT; and the node gives up after a while trying to get the NAO back to its original position. I think it'd be too messy to modify all the nodes involved. Instead I will create a service call to restore NAO to its original position which will be called before (normal) shutdown. Thanks!


Q:

remote launch differences

When a launch file is launched on a remote machine, is anything different about that remote process? The tag allows you to set the user, so I would assume the groups and permissions are the same on the remote machine? But this does not match my experience. Does anything make the launch different than launching directly on the machine?
Case:

I have an executable to operate some hardware that was given by the manufacturer. They did not provide a library.
Since they did not provide a library, I am only able to execute the program on the command line or through system calls in my code. I have a node that executes the system call.
If I run the node or execute the command line program on Machine A as user x, everything works fine. If I run the node or execute the command line program on Machine B as user x, everything works fine.
However, if I remote launch the node on machine B from machine A, the program will not work on machine B. Both the user on machine A launching the launch file is user x and the user attribute in the machine tag is user x.

The program output is unhelpful.
launch file:
<launch>    
    <machine  name="machineB" address="machineB" default="true" env-loader="/home/x/ros_ws/devel/remoteEnv.sh" user="x"/>

    <node name="mynode" pkg="mynode" type="mynode" respawn="true"/>    
</launch>

remoteEnv.sh on machineB:
#!/usr/bin/env bash

source /home/x/ros_ws/devel/setup.bash
export ROSCONSOLE_FORMAT='${time}[${severity}] ${node}/${logger}: ${message}'
export ROS_IP=192.168.1.123
export ROS_MASTER_URI=http://machineA:11311
export ROS_NAMESPACE=machineB

exec "$@"

Originally posted by thebyohazard on ROS Answers with karma: 3562 on 2022-07-28
Post score: 0

A:

One thing that is different is that the process has no associated tty.
I noticed that when I ran my launch file in a script as a service through systemd, the program stopped working as well. Looking at the output of ps aux, I saw that the service has no tty. For some reason the manufacturer's program I am trying to use requires an associated tty in order to work properly.
Based on the top answer to this question, encapsulating my system call with
script --return --quiet -c "[mfg command that needs a tty]" /dev/null

makes it happy and everything works fine.

Originally posted by thebyohazard with karma: 3562 on 2022-08-12
This answer was ACCEPTED on the original site
Post score: 0


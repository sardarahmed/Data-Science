Q:

pthread-related crashes

Hi all,
I'm running ROS electric on a 24-core machine and having some issues with pthread under specific conditions. I use a class named ObjectTracker to handle ROS callbacks and sometimes use pthread to run some code in parallel without a problem. However, ObjectTracker includes instances of another class called Model, and Model includes functions that use pthread, as well. When Model tries to use pthread, the code usually crashes. I've tried using spin, multithreadspinner, and asyncspinner in ObjectTracker, and I still get the crashes. I'm also not trying to use more than 24 cores when it crashes. Even if I'm only trying to use on thread, but as long as it's created with pthread within Model and not ObjectTracker, it's a problem. Here's the specific code that is problematic:
// create threads
pthread_attr_t attr;
int rc;
void* status;

int count_thread = 0;
while(count_thread<num_threads)
{
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
    for(int i=count_thread;i<min(count_thread+simultaneous_threads,num_threads);i++)
    {
        pthread_create(&threads[i], &attr, thread_align_cloud_init, (void *) &aligndata[i]);
    }

    // wait for the threads to execute
    pthread_attr_destroy(&attr);
    for(int i=count_thread;i<min(count_thread+simultaneous_threads,num_threads);i++)
        rc = pthread_join(threads[i], &status);

    count_thread+=simultaneous_threads;
}

Any help would be appreciated!!

Originally posted by Robin on ROS Answers with karma: 87 on 2012-02-16
Post score: 0

A:

Issues with multi-threaded programs are usually caused by parallel accesses to shared data structures. Especially STL containers will die in a horrible way if two threads modify them simultaneously, or if a thread accesses them while another thread is writing to them.
Your code looks fine to me (provided the threads array is large enough to hold all handles) and is probably not the source of your problem. Off the top of my head, I'd suggest you take a look at thread_align_cloud_init and verify that anything that is not a local variable is either protected by a mutex or never accessed by two different threads. If other functions are called, the same rule applies to them as well.

Originally posted by roehling with karma: 1951 on 2012-02-17
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Robin on 2012-02-22:
I think the problem was that both threads were reading from the same point clouds. Even though they weren't editing the clouds, that was enough to cause some access issues. Thanks for pointing me in the right direction.


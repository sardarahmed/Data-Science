Q:

subscription callback types ROS1 vs. ROS2

Hi everyone
I've been creating some subscriptions in ROS2 lately, and had a question regarding the callback signature of any subscription or service creation. In ROS1, the callback signature of any message type could've been any one of the MsgType, MsgTypePtr, MsgTypeConstPtr, and additional const qualification and references of all of the previous. However as far as I can tell in ROS2, there seems to only be a limited subset of the above which would constitute a compilable callback signature.
To give a couple of examples in ROS2:
create_subscription<std_msgs::msg::String>(
  "/foo", 5, [this](std_msgs::msg::String::ConstSharedPtr msg)  // this works
create_subscription<std_msgs::msg::String>(
  "/foo", 5, [this](std_msgs::msg::String::UniquePtr msg)  // also works
create_subscription<std_msgs::msg::String>(
  "/foo", 5, [this](const std_msgs::msg::String::ConstSharedPtr msg)  // doesn't seem to work
create_subscription<std_msgs::msg::String>(
  "/foo", 5, [this](std_msgs::msg::String::ConstSharedPtr& msg)  // doesn't work either
create_subscription<std_msgs::msg::String>(
  "/foo", 5, [this](std_msgs::msg::String::ConstUniquePtr msg)  // neither does this

It seems that the internal templates do not allow some of these patterns. Is it possible with the current design to perhaps extend subscription callback signatures so that it can accept some of the above signatures?

Originally posted by eric1221bday on ROS Answers with karma: 245 on 2019-09-19
Post score: 3

A:

At a high level there's two patterns that we want to support. Read only access and read+write access. If you want Read Only use a ConstSharedPtr, if you want to be able to modify the message use the UniquePtr to subscribe.
We could extend the API to cover more permutations, but keeping it simple will make users code more homogeneous and consequently more standardized which will make it both more readable and easier to audit.
This will also facilitate sharing of code if everything standardizes on using these two variations of the datatypes.
Specifically looking at the permutations you suggestion.

create_subscription<std_msgs::msg::String>(
"/foo", 5, [this](const std_msgs::msg::String::ConstSharedPtr msg)  // doesn't seem to work

This makes the shared pointer itself const, and you're getting it by value such that you'd be getting a copy and it consequently wouldn't be reference counted correctly.

create_subscription<std_msgs::msg::String>(
"/foo", 5, [this](std_msgs::msg::String::ConstSharedPtr& msg)  // doesn't work either

Keeping a reference to a shared pointer doesn't make much sense, you should have your own reference counted handle to the shared pointer so that it's known that you're using the contents and that you don't have to rely on someone else persisting the lifetime of the shared pointer.

create_subscription<std_msgs::msg::String>(
"/foo", 5, [this](std_msgs::msg::String::ConstUniquePtr msg)  // neither does this

You don't want to ask for a UniquePtr that's const. The reason to require a UniquePtr is so that you can know that you have full ownership of the message datatype to allow you to modify it. Under the hood if two subscribers request a UniquePtr datatype the subscription is required to make a copy of the message to give both subscribers unique pointers. If you just want const access to the message you should use the ConstSharedPtr and not force the subscriber to copy the data to give you a const instance if there might be other const subscribers.

Originally posted by tfoote with karma: 58457 on 2019-09-20
This answer was ACCEPTED on the original site
Post score: 5

Original comments
Comment by eric1221bday on 2019-09-20:
Hey, thanks for the answer, interestingly I also saw a slightly different pattern today in one of the demo nodes here
[this](const typename std_msgs::msg::String::SharedPtr msg) -> void

Which seems to be an attempt to get the shared_ptr to be const and have it compile. Would this then be an incorrect usage?


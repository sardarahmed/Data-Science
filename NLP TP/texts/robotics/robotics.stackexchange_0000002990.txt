Q:

innovation step ekf localization?

Let's say we have a bunch of observations $z^{i}$ from sensor and we have a map in which we can get the predicted measurements $\hat{z}^{i}$ for landmarks. In EKF localization in correction step, should we compare each observation $z^{i}$ with the entire predicted measurement $\hat{z}^{i}$?, so in this case we have two loops? Or we just compare each observation with each predicted measurement?, so in this case we have one loop. I assume the sensor can give all observations for all landmarks every scan.  The following picture depicts the scenario. Now every time I execute the EKF-Localization I get $z^{i} = \{ z^{1}, z^{2}, z^{3}, z^{4}\}$ and I have $m$, so I can get $\hat{z}^{i} = \{ \hat{z}^{1}, \hat{z}^{2}, \hat{z}^{3}, \hat{z}^{4}\}$. To get the innovation step, this is what I did 
$$
Z^{1} = z^{1} - \hat{z}^{1} \\
Z^{2} = z^{2} - \hat{z}^{2} \\
Z^{3} = z^{3} - \hat{z}^{3} \\
Z^{4} = z^{4} - \hat{z}^{4} \\
$$
where $Z$ is the innovation. For each iteration I get four innovations. Is this correct? I'm using EKF-Localization  in this book Probabilistic Robotics page 204. 
 

A:

Yes this is correct, given two assumptions:

Each measurement is independent (i.e., the (Gaussian) distribution of observation $z_i$ is uncorrelated with $z_j$). Usually this is a fair assumption (e.g., measuring the position of landmarks with a laser scanner).
Data association is known. In other words, you "just knew" that your first observation was in fact an observation of landmark 1. Therefore you can just compute the innovation with the predicted observation generated by landmark 1. Not knowing what landmark the observation belongs to is where the double loop comes in. In that case, you need to compare the observation with the predicted observations of all* the other landmarks, and choose the one that is most likely**, using a metric such as the Mahalanobis distance.

*You can probably speed this up by only comparing it to landmarks that are estimated to be in the field of view of the sensor.
**This is just one method of data association. Others (e.g., joint compatibility) exist.


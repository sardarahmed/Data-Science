Q:

PluginLib declaring template classes

Hi!
Using template classes with the PluginLib looks interesting. However I've found several problems when I tried it. Firstly the macro PLUGINLIB_DECLARE_CLASS does not look to work with template classes, even using the typical "parameter pareteses for macros" [See Code 1], it finally worked using typedefs [See Code 2]. I would like to automate this mechanism to easily generate plugin classes.
I would like to declare a plugin for each template class instantiation in the code. For that I though two alternatives:
- using the PLUGINLIB_DECLARE_CLASS in the class scope -> it didn't worked. The internal pocolib complains about it.
- using metaprograming to generate in the root scope all the possible combinations of template class instantiation. Any Idea?(I think PCL do things like that). Finally I think it would be necesary a macro for stringfy a template classname for the 2nd parameter of the PLUGINLIB_DECLARE_CLASS. Any Idea about how to do this?
CODE 1

 #include  
 //----- wrong plugin declaration --------
 PLUGINLIB_DECLARE_CLASS(rtcus_navigation, default_ds_twist,
(DefaultStateEstimation<DynamicState2D,Twist2D>),
(StateEstimtion<DynamicState2D,Twist2D>))

CODE 2

 //---- working template class plugin declaration -------- 
 typedef StateEstimtion<DynamicState2D,Twist2D> base;
 typedef DefaultStateEstimation<DynamicState2D,Twist2D> default_ds_twist;
 PLUGINLIB_DECLARE_CLASS(rtcus_navigation, default_DynamicState2D_Twist2D,default_ds_twist,base)

---

[Originally posted](https://answers.ros.org/question/44935/pluginlib-declaring-template-classes/) by [Pablo Iñigo Blasco](https://answers.ros.org/users/356/pablo-iñigo-blasco/) on ROS Answers with karma: 2982 on 2012-10-01

Post score: 1

A:

I have found a partial solution.
The plugin-base-class should inherit from an auxiliar-untemplated-base-class. After this you can use a dynamic_pointer_cast to the templated plugin-base-class. This is not bad given the dynamic load is itself dynamic, no additional and unexpected runtime errors should occur. given "NavigationNodeComponent" the auxiliar untemplated base class and state_estimator_name the name of the plugin we want to load.

pluginlib::ClassLoader loader("rtcus_navigation","rtcus_navigation::NavigationNodeComponent");
shared_ptr<StateEstimation<StateType, ActionType, TimeModel> > new_state_estimation = 
   dynamic_pointer_cast<rtcus_navigation::StateEstimation<StateType, ActionType, TimeModel> >( 
    loader.createInstance(state_estimator_name));

However this is only for the loading stage. How to declare plugin in a more automated way and not manually remains unsolved.

Originally posted by Pablo Iñigo Blasco with karma: 2982 on 2012-10-02
This answer was ACCEPTED on the original site
Post score: 0


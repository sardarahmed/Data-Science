Q:

Roslibjs don't get goal result on client

I have a simple ActionLib server, and a roslib js client very similar to the tutorials.
When I launch my client in chrome, I see printed in the console:
Connected to websocket server

I can also see in the terminal that I launched my cpp server in:
^CMacBook-Pro-2:ros_ws Fry$ rosrun cpp_action_server_pkg cmd_server
[ INFO] [1447742973.282337000]: cmd: Executing, creating fibonacci sequence of order 7 with seeds 0, 1
[ INFO] [1447742980.283698000]: cmd: Succeeded

So far so good. However, despite the "Suceeded", my js code
goal.on('result', function(result) {
             console.log('Final Result: ' + result.sequence);
           });

is apparently never called, as I never see 'Final Result:" in my (Chrome) browser console.
I see no errors printed out in  my roscore terminal, my actionlib server terminal, my rosbridge terminal, nor my browser console.
My full client page is:
 <!DOCTYPE html> <html> <head>
     <meta charset="utf-8" />
     <script type="text/javascript" src="http://cdn.robotwebtools.org/EventEmitter2/current/eventemitter2.js"></script>
     <script type="text/javascript" src="http://cdn.robotwebtools.org/roslibjs/current/roslib.js"></script>
 
     <script type="text/javascript" type="text/javascript">
       var ros = new ROSLIB.Ros({
             url : 'ws://localhost:9090'
        });
 
        var cmdClient = new ROSLIB.ActionClient({
              ros : ros,
              serverName : '/cmd',
              actionName : 'cpp_action_server_pkg/CmdAction'
        });
 
        var goal = new ROSLIB.Goal({
              actionClient : cmdClient,
              goalMessage  : { order : 7}
        });
 
        goal.on('feedback', function(feedback) {
              console.log('Feedback: ' + feedback.sequence);
            });
 
        goal.on('result', function(result) {
              console.log('Final Result: ' + result.sequence);
            });
 
        ros.on('connection', function() {
              console.log('Connected to websocket server.2');
            });

        ros.on('error', function(error) {
              console.log('Error connecting to websocket server: ', error);
            });
 
        ros.on('close', function() {
              console.log('Connection to websocket server closed.');
            });
 
        goal.send();
      </script>
      </head>
 
  <body>    <h1>Cmd ActionClient
 Example</h1>    <p>Check the Web
 Console for output</p>  </body>
 </html>

My full cpp server code is:
#include <ros/ros.h>
#include <actionlib/server/simple_action_server.h>
#include <cpp_action_server_pkg/CmdAction.h>

class CmdAction
{
protected:

  ros::NodeHandle nh_;
  actionlib::SimpleActionServer<cpp_action_server_pkg::CmdAction> as_; // NodeHandle instance must be created before this line. Otherwise strange error occurs.
  std::string action_name_;
  // create messages that are used to published feedback/result
  cpp_action_server_pkg::CmdFeedback feedback_;
  cpp_action_server_pkg::CmdResult result_;

public:

  CmdAction(std::string name) :
    as_(nh_, name, boost::bind(&CmdAction::executeCB, this, _1), false),
    action_name_(name)
  {
    as_.start();
  }

  ~CmdAction(void)
  {
  }

  void executeCB(const cpp_action_server_pkg::CmdGoalConstPtr &goal)
  {
    // helper variables
    ros::Rate r(1);
    bool success = true;

    // push_back the seeds for the fibonacci sequence
    feedback_.sequence.clear();
    feedback_.sequence.push_back(0);
    feedback_.sequence.push_back(1);

    // publish info to the console for the user
    ROS_INFO("%s: Executing, creating fibonacci sequence of order %i with seeds %i, %i", action_name_.c_str(), goal->order, feedback_.sequence[0], feedback_.sequence[1]);

    // start executing the action
    for(int i=1; i<=goal->order; i++)
    {
      // check that preempt has not been requested by the client
      if (as_.isPreemptRequested() || !ros::ok())
      {
        ROS_INFO("%s: Preempted", action_name_.c_str());
        // set the action state to preempted
        as_.setPreempted();
        success = false;
        break;
      }
      feedback_.sequence.push_back(feedback_.sequence[i] + feedback_.sequence[i-1]); //the 1 line of actual work!
      // publish the feedback
      as_.publishFeedback(feedback_);
      // this sleep is not necessary, the sequence is computed at 1 Hz for demonstration purposes
      r.sleep();
    }

    if(success)
    {
      result_.sequence = feedback_.sequence;
      ROS_INFO("%s: Succeeded", action_name_.c_str());
      // set the action state to succeeded
      as_.setSucceeded(result_);
    }
  }

};

int main(int argc, char** argv)
{
  ros::init(argc, argv, "cmd");

  CmdAction cmd("cmd");
  ros::spin();

  return 0;
}

Any debugging clues greatly appreciated!

Originally posted by Fry on ROS Answers with karma: 126 on 2015-11-17
Post score: 1

Original comments
Comment by BennyRe on 2015-11-17:
Hm. To me everything looks normal but I'm not a js expert. What comes in my mind is, that your objects get garbage collected after calling goal.send(); but this is just a wild guess.
Comment by rtoris288 on 2015-11-17:
If you rostopic echo /cmd/result does your result get printed out correctly?
Comment by lorepieri on 2021-06-29:
@Fry Did you solved this?

A:

Defective Comments only allow a few characters so I had to make my long-winded response to Benny Re and rtoris an answer.
BennyRe gets 2 points for thinking outside the box. However, GC in JS probably doesn't change much and presumably the implementors of ROSlibjs got it working at least at some point.
However, rtoris288 has a provocative clue. rostopic echo /cmd/result prints out nothing,
it just hangs until I control to get the prompt back.
More clues: rostopic list     prints out:
MacBook-Pro-2:ros_ws Fry$ rostopic list
/cmd/cancel
/cmd/feedback
/cmd/goal
/cmd/result
/cmd/status
/rosout
/rosout_agg

The arguments to rostopic echo that give me no printout and just hang are:
/cmd/cancel, /cmd/feedback, /cmd/goal, /cmd/result, /rosout_agg
The ones that give me information are:
/cmd/status
Lots of iterations of :
header:
seq: 4853
stamp:
secs: 1447793529
nsecs: 985096000
frame_id: ''
status_list:
goal_id: 
  stamp: 
    secs: 1447792658
    nsecs: 138962000
  id: goal_0.9185599682386965_1447792657624
status: 3
text: ''

/rosout :
header:
seq: 1
stamp:
secs: 1447792665
nsecs: 142908000
frame_id: ''
level: 2
name: /cmd
msg: cmd: Succeeded
file: /Users/Fry/ros_ws/src/cpp_action_server_pkg/src/cmd_server.cpp
function: executeCB
line: 65
topics: ['/rosout', '/cmd/result', '/cmd/feedback', '/cmd/status']
header:
seq: 2
stamp:
secs: 1447792579
nsecs: 366230010
frame_id: ''
level: 2
name: /rosapi
msg: Rosapi started
file: rosapi_node
function: 
line: 175
topics: ['/rosout']
header:
seq: 7
stamp:
secs: 1447793337
nsecs: 16545057
frame_id: ''
level: 4
name: /rosbridge_websocket
msg: Inbound TCP/IP connection failed: connection from sender terminated before handshake header received. 0 bytes were received. Please check sender for additional details.
file: tcpros_base.py
function: _tcp_server_callback
line: 351
topics: ['/cmd/result', '/rosout', '/cmd/goal', '/cmd/status', '/cmd/feedback', '/cmd/cancel']
So it looks like there is at least one problem that doesn't have to do with the browser.
PS:
^CMacBook-Pro-2:ros_ws Fry$ printenv | grep ROS
ROS_ROOT=/opt/ros/indigo/share/ros
ROS_PACKAGE_PATH=/Users/Fry/ros_ws/src:/opt/ros/indigo/share:/opt/ros/indigo/stacks
ROS_MASTER_URI=http://localhost:11311
ROSLISP_PACKAGE_DIRECTORIES=/Users/Fry/ros_ws/devel/share/common-lisp
ROS_DISTRO=indigo
ROS_ETC_DIR=/opt/ros/indigo/etc/ros
This is not an answer but more of a thickening of the plot :-(

Originally posted by Fry with karma: 126 on 2015-11-17
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by BennyRe on 2015-11-18:
Does your action server work with the axclient?
Comment by Fry on 2015-11-20:
Good idea! I just tried it. After some CMakeList.txt tweaking, I have a cpp client working, but the JS client still doesn't get the return value.


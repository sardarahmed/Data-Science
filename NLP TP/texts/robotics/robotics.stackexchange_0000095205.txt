Q:

What is the difference between nodes that publishes/subscribes to a ConstPtr and a nodelet that publishes/subscribes to a Const::Ptr?

My understanding is that nodelet's don't make an extra copy of data and therefore are more efficient, However if I am sending a ConstPtr between nodes I shouldn't generate an extra copy of the data the ptr points to as well correct?

Originally posted by Roozter on ROS Answers with karma: 3 on 2020-03-27
Post score: 0

A:

However if I am sending a ConstPtr between nodes I shouldn't generate an extra copy of the data the ptr points to as well correct?

If you're asking whether publishing a ConstPtr allows nodes to also benefit from zero-copy message exchange, then no, that's (unfortunately) not how it works.
nodelets can exchange messages without copying anything as they share the same memory address space. This allows them to (essentially) exchange pointers to messages, instead of (copies of) the messages themselves.
Nodes are run in separate processes, each with their own memory address space. Exchanging pointers would be meaningless, as objects will not "live" at the same addresses for these different processes.
So even though you're publish(..)ing a ConstPtr, the middleware will have to make a copy, as there is no other way to reliably exchange message data between nodes (ie: processes).
See #q346374 for another recent question about this.

Originally posted by gvdhoorn with karma: 86574 on 2020-03-27
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Roozter on 2020-03-27:
Thanks! I didn't know each process would have its own memory address space.
Comment by gvdhoorn on 2020-03-27:
It's one of the techniques used in process isolation.
Comment by gvdhoorn on 2020-03-27:
And for future readers: yes, shared memory could be used, and has been in the past. See ethzasl_message_transport and shm_transport for example (just two examples).
These have a nr of disadvantages. Just three would be:

they're not part of the main distribution, and maintenance depends on community contributions, leading to these plugins/extensions falling behind/becoming unmaintained
because they are not integrated completely, code changes are required to use them, leading to tight coupling between nodes and transports
exchanging pointers over shared memory immediately means publishers have to adhere to an (implied) contract, and so do subscribers. For instance: subscribers must not change messages as changes will automatically be visible to all other subscribers (use of ConstPtr definitely helps here)


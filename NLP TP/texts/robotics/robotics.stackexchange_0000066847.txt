Q:

SIGPIPE Conflict and Unmasking

I am trying to call roscpp within another program that uses SIGPIPE.
ROS is blocking this (in https://github.com/ros/ros_comm/blob/ros_comm-1.8.15/clients/cpp/roscpp/src/libros/init.cpp#L432) and this breaks things.
Why is SIGPIPE ignored here?  Presumably, this would be to prevent
the default handler from terminating the process when a socket is
disconnected.
My current workaround is to unmask SIGPIPE via sigprocmask() after the ROS libraries are
loaded.  This seems to be working fine in that I can communicate via
ROS and the rest of the program can use SIGPIPE as it needs to.  Are
there any potential subtle errors that could arise from this?
Ideally, it seems that there should be an option to prevent roscpp
from initially blocking SIGPIPE rather than it unconditionally
modifying the process-global state.

Originally posted by ntd on ROS Answers with karma: 36 on 2015-04-05
Post score: 0

A:

That code is pretty old, so it's hard to know, but I would guess that the purpose is to avoid the chance of receiving a SIGPIPE due to something bad happening to a socket, which could happen pretty often, given how many sockets we might be using and the variety of network conditions we're running in.  As you point out, the default behavior for SIGPIPE is to terminate the program, so if we expect to receive it, then we either need to ignore it or catch it.
I don't see a problem with your workaround of unmasking SIGPIPE and catching it yourself.  But you should know that you might get SIGPIPEs that are generated due to roscpp's sockets, as opposed to your own resources.

Originally posted by gerkey with karma: 1981 on 2015-04-17
This answer was ACCEPTED on the original site
Post score: 0


Q:

MD5Sum for custom native type

So I'm not sure if what I am trying to do is doable or not, but here it goes.
I want to be able to exchange serialized dotnet classes over ROS. (yes, you read it right :)
This is for a connector I am trying to build to make use of ROS over C# both on Windows and on OSX (roscs isn't enough because I don't have it in windows..)
So after the motivation, what I am trying to do is create my own native type in ros::std_msgs called Object, that would be able to carry a serialized class that I can later deserialize on reception (assuming both the sender and the receptor use the same class definition).
However, while trying to define this class, I see that I must define some values related to MD5 checksum.
More specifically:
struct MD5Sum< ::std_msgs::Object_<ContainerAllocator> >
{
  static const char* value()
  {
    return "d41d8cd98f00b204e9800998ecf8427e"; 
  }

  static const char* value(const ::std_msgs::Object_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xd41d8cd98f00b204ULL;
  static const uint64_t static_value2 = 0xe9800998ecf8427eULL;
};

Where do these values come from?
Is it possible for me to generate them for my class?
Thanks for any help!

Originally posted by TiagoRibeiro on ROS Answers with karma: 41 on 2012-11-07
Post score: 1

A:

The MD5 checksum is generated from the ROS message definition, i.e. from a file with ending .msg. It must stay constant for each message and is generated by the message generator, i.e. by the tool that translates .msg files in .h files or .py files. The MD5 sum is used to prevent the system from exchanging incompatible data which could lead to subtle bugs or severe errors.
Note that you shouldn't create your Object message inside std_msgs but create a new ROS package for your specific message. The reason is that you should not modify existing ROS packages that are installed from debian packages.
What exactly is the reason for using the ROS middleware for exchanging classes? In your specific case, if you do not need any other ROS features, might using a simple socket maybe be possible? If not, I suggest to define Object as a ROS message that maybe contains just a byte array. For instance, Object.msg could look like this:
byte[] blob

This will create an array undefined size. The serialized message will also be really simple. The layout will be:
<length of blob + 4> <length of blob> <byte1> <byte2> ...

Generally, the message first contains the number of bytes of the message. For dynamic arrays and strings, the first 32 bit specify the length and the rest is the data.

Originally posted by Lorenz with karma: 22731 on 2012-11-07
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by TiagoRibeiro on 2012-11-07:
Thank you very much!
The reason for using ROS is that we are developing mid/high-level AI control for characters (robotic or virtual) but would like to be able to interface with ROS in order to be able to share and colaborate with other people that use ROS. Thanks for your answer! Going to try it.


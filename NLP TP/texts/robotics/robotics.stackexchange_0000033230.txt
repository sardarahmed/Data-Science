Q:

"Assertion `!pthread_mutex_lock(&m)' failed." runtime error while working with custom message and kinect

Hi all,
I'm working with the Microsoft Kinect.
I'm using pointcloud_to_laserscan to retrieve a laserscan from kinect.
And there is another node which retrieves the rgb image from kinect for feature extraction and advertises the features using a custom ros message on a topic called "features".
Now I have another node. This node should subscribe to the pointcloud_to_laserscan and to the features topic using message_filters, because I need the laserscan and the features taken at the same time.
I tried to use the tutorial on http://www.ros.org/wiki/message_filters
I defined a sync policy:
typedef message_filters::sync_policies::ApproximateTime<sensor_msgs::LaserScan, myNode::myMsg> SyncLaserNodePolicy;

message_filters::Synchronizer<SyncLaserNodePolicy> sync2_;
message_filters::Subscriber<sensor_msgs::LaserScan> kinectLaser_sub;
message_filters::Subscriber<myNode::myMsg> feature_sub;

In the constructor of the node I initialize:
      kinectLaser_sub(n,"kinectLaser",1),
      feature_sub(n,"features",1),
      sync2_(SyncLaserNodePolicy(10),kinectLaser_sub,feature_sub),

My custom message is defined as:
Header header
surfKeyp2d[] keypoints2d
surfKeyp3d[] keypoints3d
surfDescMsg[] descriptors
uint32 number
sensor_msgs/Image image
geometry_msgs/TransformStamped trans

The code is compiling without errors, but when I try to run my node I get
the following error:
myNode: /usr/include/boost/thread/pthread/mutex.hpp:50: 
void boost::mutex::lock():     Assertion `!pthread_mutex_lock(&m)' failed.
Aborted

Anybody have an idea whats wrong?
Thanks a lot!

Originally posted by kluessi on ROS Answers with karma: 73 on 2011-07-25
Post score: 2

A:

Do you see any warnings while compiling this code? I would expect some warnings about the order in which you are initializing your class members.
In C++ member variables are initialized according the order of declaration, not the order you choose in the constructor. As you have declared the Sychronizer first, it's constructor will be called with uninitialized subscribers. That can cause all kind of nasticities, including the one you observed.
cheers
Dariush

Originally posted by Dariush with karma: 91 on 2011-07-26
This answer was ACCEPTED on the original site
Post score: 6


Q:

How to add a custom sensor plugin?

Currently I'm trying to write my own sensor plugin, based on the examples odometer and odometersystem from the git repository, but am failing to add the plugins to gazebo.
The system plugin OdometerSystem seems to be ok, but as soon as I add an instance of the sensor plugin Odometer, I get an undefined symbol error.
To make it very simple, I have written this basic code without doing anything but deriving from the sensor class:
MyClass.hh
#ifndef MYCLASS_HH_
#define MYCLASS_HH_

#include <gz/sensors/Sensor.hh>
#include <gz/sensors/SensorTypes.hh>
#include <gz/transport/Node.hh>

namespace myclass
{
    class MyClass : public gz::sensors::Sensor
    {
        /// \brief Load the sensor with SDF parameters.
        /// \param[in] _sdf SDF Sensor parameters.
        /// \return True if loading was successful
        public: virtual bool Load(const sdf::Sensor &_sdf) override;

        /// \brief Update the sensor and generate data
        /// \param[in] _now The current time
        /// \return True if the update was successfull
        public: virtual bool Update(const std::chrono::steady_clock::duration &_now) override;
    };
}
#endif

MyClass.cc
#include "MyClass.hh"

using namespace myclass;

bool MyClass::Load(const sdf::Sensor &_sdf)
{
    return true;   
}

bool MyClass::Update(const std::chrono::steady_clock::duration &_now)
{

    return true;
}

Adding an object of MyClass to my system plugin MyClassSystem:
void MyClassSystem::PreUpdate(const gz::sim::UpdateInfo &,
    gz::sim::EntityComponentManager &_ecm)
{
  ...

  myclass::MyClass myClass;

  return true;
}

Doing this results in this error while starting gazebo:
undefined symbol: _ZTVN7myclass7MyClassE
When I don't derive from gz::sensor::Sensor everything is fine.
This might be a very basic question, but what am I missing out here?
### Edit for additional information: ###
I registered the plugin MyClassSystem to gazebo like this:
GZ_ADD_PLUGIN(myclass::MyClassSystem, gz::sim::System,
              myclass::ISystemPreUpdate,
              myclass::ISystemPostUpdate
)

Modifying MyClass like following code is actually working:
MyClass.hh
#ifndef MYCLASS_HH_
#define MYCLASS_HH_

#include <gz/sensors/Sensor.hh>
#include <gz/sensors/SensorTypes.hh>
#include <gz/transport/Node.hh>

namespace myclass
{
    class MyClass
    {
        // Nothing done here
    };
}
#endif

MyClass.cc
#include "MyClass.hh"

using namespace myclass;

// Nothing to see here

### Edit2: CMake Test ###
I assume it's a problem with my CMakeLists.txt and simplified my code to test this theory. This is my code for now:
CMakeLists.txt
project(MyClassSystem)

find_package(gz-plugin2 REQUIRED COMPONENTS register)
set(GZ_PLUGIN_VER ${gz-plugin2_VERSION_MAJOR})

find_package(gz-sim8 REQUIRED)
set(GZ_SIM_VER ${gz-sim8_VERSION_MAJOR})

find_package(gz-sensors8 REQUIRED)
set(GZ_SENSORS_VER ${gz-sensors8_VERSION_MAJOR})

add_library(MyClassSystem SHARED MySuperClass.cc MyClass.cc MyClassSystem.cc ) 
set_property(TARGET MyClassSystem PROPERTY CXX_STANDARD 17)
target_link_libraries(MyClassSystem
  PRIVATE gz-plugin${GZ_PLUGIN_VER}::gz-plugin${GZ_PLUGIN_VER}
  PRIVATE gz-sim${GZ_SIM_VER}::gz-sim${GZ_SIM_VER}
  PRIVATE gz-sensors${GZ_SENSORS_VER}::gz-sensors${GZ_SENSORS_VER})

MyClassSystem.cc
#include <gz/msgs/double.pb.h>

#include <string>
#include <unordered_map>
#include <utility>

#include <gz/common/Profiler.hh>
#include <gz/plugin/Register.hh>
#include <gz/sensors/Noise.hh>
#include <gz/sensors/SensorFactory.hh>

#include <sdf/Sensor.hh>

#include <gz/sim/components/CustomSensor.hh>
#include <gz/sim/components/Name.hh>
#include <gz/sim/components/ParentEntity.hh>
#include <gz/sim/components/Sensor.hh>
#include <gz/sim/components/World.hh>
#include <gz/sim/EntityComponentManager.hh>
#include <gz/sim/Util.hh>

#include "MyClassSystem.hh"
#include "MyClass.hh"

GZ_ADD_PLUGIN(myclasssystem::MyClassSystem, gz::sim::System,
  myclasssystem::MyClassSystem::ISystemPreUpdate,
  myclasssystem::MyClassSystem::ISystemPostUpdate
)

using namespace myclasssystem;

//////////////////////////////////////////////////
void MyClassSystem::PreUpdate(const gz::sim::UpdateInfo &,
    gz::sim::EntityComponentManager &_ecm)
{
  myclass::MyClass myClass;
  myClass.Test(true);
}

//////////////////////////////////////////////////
void MyClassSystem::PostUpdate(const gz::sim::UpdateInfo &_info,
    const gz::sim::EntityComponentManager &_ecm)
{

}

MyClassSystem.hh
#ifndef MYCLASSSYSTEM_HH_
#define MYCLASSSYSTEM_HH_

#include <gz/sim/System.hh>
#include <gz/sensors/Sensor.hh>
#include <gz/transport/Node.hh>

namespace myclasssystem
{
  /// \brief Example showing how to tie a custom sensor, in this case an
  /// odometer, into simulation
  class MyClassSystem:
    public gz::sim::System,
    public gz::sim::ISystemPreUpdate,
    public gz::sim::ISystemPostUpdate
  {
    // Documentation inherited.
    // During PreUpdate, check for new sensors that were inserted
    // into simulation and create more components as needed.
    public: void PreUpdate(const gz::sim::UpdateInfo &_info,
        gz::sim::EntityComponentManager &_ecm) final;

    // Documentation inherited.
    // During PostUpdate, update the known sensors and publish their data.
    // Also remove sensors that have been deleted.
    public: void PostUpdate(const gz::sim::UpdateInfo &_info,
        const gz::sim::EntityComponentManager &_ecm) final;
  };
}
#endif

MySuperClass.cc
#include "MySuperClass.hh"

using namespace mysuperclass;

bool Test(bool param)
{
    return param;
}

MySuperClass.hh
#ifndef MYSUPERCLASS_HH_
#define MYSUPERCLASS_HH_

namespace mysuperclass
{
    class MySuperClass
    {
        public: MySuperClass() = default;
        public: virtual ~MySuperClass() = default;

        public: bool Test(bool param);
    };
}
#endif

MyClass.cc
#include "MyClass.hh"

using namespace myclass;

MyClass.hh
#ifndef MYCLASS_HH_
#define MYCLASS_HH_

#include <gz/sensors/Sensor.hh>
#include <gz/sensors/SensorTypes.hh>
#include <gz/transport/Node.hh>
#include "MySuperClass.hh"

namespace myclass
{
    class MyClass : public mysuperclass::MySuperClass
    {

    };
}
#endif

For simplification all files are flat in one and the same directory.
Error message is like this:

gz sim sensor_tutorial.sdf -v 3 -s: symbol lookup error: .../build/MyClassSystem/libMyClassSystem.so: undefined symbol: _ZN12mysuperclass12MySuperClass4TestEb

So i try to call the function Test(bool param) from the object myclass, while the function Test is only defined and implemented in the superclass MySuperClass. According to the error message here seems to be a misconfiguration that causes a problem within the linking process.
At this point it seems to be pretty obvious that it has nothing to do with gazebo itself. It's just my lack of understanding and experience how to include files and libs correctly with cmake.

A:

Finally I was able to copy the odometer example and run it in my gazebo instance. So this is what I did:

Created the classes MyOdometerSystem and MyOdometer according to the given examples OdometerSystem (gz-sim repo) and Odometer (gz-sensors repo)
Both classes are flat in one directory for simplification
Added my build directory to the GZ_SIM_SYSTEM_PLUGIN_PATH environment variable: export GZ_SIM_SYSTEM_PLUGIN_PATH=/[mydirectory]/build/MyOdometer/

Following code worked for me:
MyOdometer.hh
#ifndef MYODOMETER_HH_
#define MYODOMETER_HH_

#include <gz/sensors/Sensor.hh>
#include <gz/sensors/SensorTypes.hh>
#include <gz/transport/Node.hh>

namespace custom
{
  /// \brief Example sensor that publishes the total distance travelled by a
  /// robot, with noise.
  class MyOdometer : public gz::sensors::Sensor
  {
    /// \brief Load the sensor with SDF parameters.
    /// \param[in] _sdf SDF Sensor parameters.
    /// \return True if loading was successful
    public: virtual bool Load(const sdf::Sensor &_sdf) override;

    /// \brief Update the sensor and generate data
    /// \param[in] _now The current time
    /// \return True if the update was successfull
    public: virtual bool Update(
      const std::chrono::steady_clock::duration &_now) override;

    /// \brief Set the current postiion of the robot, so the odometer can
    /// calculate the distance travelled.
    /// \param[in] _pos Current position in world coordinates.
    public: void NewPosition(const gz::math::Vector3d &_pos);

    /// \brief Get the latest world postiion of the robot.
    /// \return The latest position given to the odometer.
    public: const gz::math::Vector3d &Position() const;

    /// \brief Previous position of the robot.
    private: gz::math::Vector3d prevPos{std::nan(""), std::nan(""),
        std::nan("")};

    /// \brief Latest total distance.
    private: double totalDistance{0.0};

    /// \brief Noise that will be applied to the sensor data
    private: gz::sensors::NoisePtr noise{nullptr};

    /// \brief Node for communication
    private: gz::transport::Node node;

    /// \brief Publishes sensor data
    private: gz::transport::Node::Publisher pub;
  };
}

#endif

MyOdometer.cc
#include <math.h>

#include <gz/msgs/double.pb.h>

#include <gz/common/Console.hh>
#include <gz/msgs/Utility.hh>
#include <gz/sensors/Noise.hh>
#include <gz/sensors/Util.hh>

#include "MyOdometer.hh"

using namespace custom;

//////////////////////////////////////////////////
bool MyOdometer::Load(const sdf::Sensor &_sdf)
{
  auto type = gz::sensors::customType(_sdf);
  if ("myodometer" != type)
  {
    gzerr << "Trying to load [myodometer] sensor, but got type ["
           << type << "] instead." << std::endl;
    return false;
  }

  // Load common sensor params
  gz::sensors::Sensor::Load(_sdf);

  // Advertise topic where data will be published
  this->pub = this->node.Advertise<gz::msgs::Double>(this->Topic());

  if (!_sdf.Element()->HasElement("gz:myodometer"))
  {
    gzdbg << "No custom configuration for [" << this->Topic() << "]"
           << std::endl;
    return true;
  }

  // Load custom sensor params
  auto customElem = _sdf.Element()->GetElement("gz:myodometer");

  if (!customElem->HasElement("noise"))
  {
    gzdbg << "No noise for [" << this->Topic() << "]" << std::endl;
    return true;
  }

  sdf::Noise noiseSdf;
  noiseSdf.Load(customElem->GetElement("noise"));
  this->noise = gz::sensors::NoiseFactory::NewNoiseModel(noiseSdf);
  if (nullptr == this->noise)
  {
    gzerr << "Failed to load noise." << std::endl;
    return false;
  }

  return true;
}

//////////////////////////////////////////////////
bool MyOdometer::Update(const std::chrono::steady_clock::duration &_now)
{
  gz::msgs::Double msg;
  *msg.mutable_header()->mutable_stamp() = gz::msgs::Convert(_now);
  auto frame = msg.mutable_header()->add_data();
  frame->set_key("frame_id");
  frame->add_value(this->Name());

  this->totalDistance = this->noise->Apply(this->totalDistance);

  msg.set_data(this->totalDistance);

  this->AddSequence(msg.mutable_header());
  this->pub.Publish(msg);

  return true;
}

//////////////////////////////////////////////////
void MyOdometer::NewPosition(const gz::math::Vector3d &_pos)
{
  if (!isnan(this->prevPos.X()))
  {
    this->totalDistance += this->prevPos.Distance(_pos);
  }
  this->prevPos = _pos;
}

//////////////////////////////////////////////////
const gz::math::Vector3d &MyOdometer::Position() const
{
  return this->prevPos;
}

MyOdometerSystem.hh
#ifndef MYODOMETERSYSTEM_HH_
#define MYODOMETERSYSTEM_HH_

#include <gz/sim/System.hh>
#include <gz/sensors/Sensor.hh>
#include <gz/transport/Node.hh>

namespace custom
{
  /// \brief Example showing how to tie a custom sensor, in this case an
  /// odometer, into simulation
  class MyOdometerSystem:
    public gz::sim::System,
    public gz::sim::ISystemPreUpdate,
    public gz::sim::ISystemPostUpdate
  {
    // Documentation inherited.
    // During PreUpdate, check for new sensors that were inserted
    // into simulation and create more components as needed.
    public: void PreUpdate(const gz::sim::UpdateInfo &_info,
        gz::sim::EntityComponentManager &_ecm) final;

    // Documentation inherited.
    // During PostUpdate, update the known sensors and publish their data.
    // Also remove sensors that have been deleted.
    public: void PostUpdate(const gz::sim::UpdateInfo &_info,
        const gz::sim::EntityComponentManager &_ecm) final;

    /// \brief Remove custom sensors if their entities have been removed from
    /// simulation.
    /// \param[in] _ecm Immutable reference to ECM.
    private: void RemoveSensorEntities(
        const gz::sim::EntityComponentManager &_ecm);

    /// \brief A map of custom entities to their sensors
    private: std::unordered_map<gz::sim::Entity,
        std::shared_ptr<MyOdometer>> entitySensorMap;
  };
}
#endif

MyOdometerSystem.cc
#include <gz/msgs/double.pb.h>

#include <string>
#include <unordered_map>
#include <utility>

#include <gz/common/Profiler.hh>
#include <gz/plugin/Register.hh>
#include <gz/sensors/Noise.hh>
#include <gz/sensors/SensorFactory.hh>

#include <sdf/Sensor.hh>

#include <gz/sim/components/CustomSensor.hh>
#include <gz/sim/components/Name.hh>
#include <gz/sim/components/ParentEntity.hh>
#include <gz/sim/components/Sensor.hh>
#include <gz/sim/components/World.hh>
#include <gz/sim/EntityComponentManager.hh>
#include <gz/sim/Util.hh>

#include "MyOdometer.hh"
#include "MyOdometerSystem.hh"

using namespace custom;

//////////////////////////////////////////////////
void MyOdometerSystem::PreUpdate(const gz::sim::UpdateInfo &,
    gz::sim::EntityComponentManager &_ecm)
{
  _ecm.EachNew<gz::sim::components::CustomSensor,
               gz::sim::components::ParentEntity>(
    [&](const gz::sim::Entity &_entity,
        const gz::sim::components::CustomSensor *_custom,
        const gz::sim::components::ParentEntity *_parent)->bool
      {
        // Get sensor's scoped name without the world
        auto sensorScopedName = gz::sim::removeParentScope(
            gz::sim::scopedName(_entity, _ecm, "::", false), "::");
        sdf::Sensor data = _custom->Data();
        data.SetName(sensorScopedName);

        // Default to scoped name as topic
        if (data.Topic().empty())
        {
          std::string topic = scopedName(_entity, _ecm) + "/myodometer";
          data.SetTopic(topic);
        }

        gz::sensors::SensorFactory sensorFactory;
        auto sensor = sensorFactory.CreateSensor<custom::MyOdometer>(data);
        if (nullptr == sensor)
        {
          gzerr << "Failed to create myodometer [" << sensorScopedName << "]"
                 << std::endl;
          return false;
        }

        // Set sensor parent
        auto parentName = _ecm.Component<gz::sim::components::Name>(
            _parent->Data())->Data();
        sensor->SetParent(parentName);

        // Set topic on Gazebo
        _ecm.CreateComponent(_entity,
            gz::sim::components::SensorTopic(sensor->Topic()));

        // Keep track of this sensor
        this->entitySensorMap.insert(std::make_pair(_entity,
            std::move(sensor)));

        return true;
      });
}

//////////////////////////////////////////////////
void MyOdometerSystem::PostUpdate(const gz::sim::UpdateInfo &_info,
    const gz::sim::EntityComponentManager &_ecm)
{
  // Only update and publish if not paused.
  if (!_info.paused)
  {
    for (auto &[entity, sensor] : this->entitySensorMap)
    {
      sensor->NewPosition(gz::sim::worldPose(entity, _ecm).Pos());
      sensor->Update(_info.simTime);
    }
  }

  this->RemoveSensorEntities(_ecm);
}

//////////////////////////////////////////////////
void MyOdometerSystem::RemoveSensorEntities(
    const gz::sim::EntityComponentManager &_ecm)
{
  _ecm.EachRemoved<gz::sim::components::CustomSensor>(
    [&](const gz::sim::Entity &_entity,
        const gz::sim::components::CustomSensor *)->bool
      {
        if (this->entitySensorMap.erase(_entity) == 0)
        {
          gzerr << "Internal error, missing myodometer for entity ["
                         << _entity << "]" << std::endl;
        }
        return true;
      });
}

GZ_ADD_PLUGIN(MyOdometerSystem, gz::sim::System,
  MyOdometerSystem::ISystemPreUpdate,
  MyOdometerSystem::ISystemPostUpdate
)

GZ_ADD_PLUGIN_ALIAS(MyOdometerSystem, "custom::MyOdometerSystem")

CMakeLists.txt
find_package(gz-cmake3 REQUIRED)

project(MyOdometerSystem)

find_package(gz-plugin2 REQUIRED COMPONENTS register)
set(GZ_PLUGIN_VER ${gz-plugin2_VERSION_MAJOR})

find_package(gz-sim8 REQUIRED)
set(GZ_SIM_VER ${gz-sim8_VERSION_MAJOR})

find_package(gz-sensors8 REQUIRED)
set(GZ_SENSORS_VER ${gz-sensors8_VERSION_MAJOR})

add_library(MyOdometerSystem SHARED MyOdometer.cc MyOdometerSystem.cc)
target_link_libraries(MyOdometerSystem
  PRIVATE gz-plugin${GZ_PLUGIN_VER}::gz-plugin${GZ_PLUGIN_VER}
  PRIVATE gz-sim${GZ_SIM_VER}::gz-sim${GZ_SIM_VER}
  PRIVATE gz-sensors${GZ_SENSORS_VER}::gz-sensors${GZ_SENSORS_VER})

MyOdometer.sdf
<?xml version="1.0" ?>
<sdf version="1.6">
  <world name="myodometer_world">
    <plugin
      filename="gz-sim-physics-system"
      name="gz::sim::systems::Physics">
    </plugin>
    <plugin
      filename="gz-sim-user-commands-system"
      name="gz::sim::systems::UserCommands">
    </plugin>
    <plugin
      filename="gz-sim-scene-broadcaster-system"
      name="gz::sim::systems::SceneBroadcaster">
    </plugin>
    <!-- The system is added to the world, so it handles all odometers in the world-->
    <plugin
      filename="MyOdometerSystem"
      name="custom::MyOdometerSystem">
    </plugin>

    <light type="directional" name="sun">
      <cast_shadows>true</cast_shadows>
      <pose>0 0 10 0 0 0</pose>
      <diffuse>0.8 0.8 0.8 1</diffuse>
      <specular>0.2 0.2 0.2 1</specular>
      <attenuation>
        <range>1000</range>
        <constant>0.9</constant>
        <linear>0.01</linear>
        <quadratic>0.001</quadratic>
      </attenuation>
      <direction>-0.5 0.1 -0.9</direction>
    </light>

    <model name="ground_plane">
      <static>true</static>
      <link name="link">
        <collision name="collision">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <material>
            <ambient>0.8 0.8 0.8 1</ambient>
            <diffuse>0.8 0.8 0.8 1</diffuse>
            <specular>0.8 0.8 0.8 1</specular>
          </material>
        </visual>
      </link>
    </model>

    <model name="model_with_sensor">
      <pose>0 0 0.05 0 0 0</pose>
      <link name="link">
        <inertial>
          <mass>0.1</mass>
          <inertia>
            <ixx>0.000166667</ixx>
            <iyy>0.000166667</iyy>
            <izz>0.000166667</izz>
          </inertia>
        </inertial>
        <collision name="collision">
          <geometry>
            <box>
              <size>0.1 0.1 0.1</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.1 0.1 0.1</size>
            </box>
          </geometry>
        </visual>
        <!-- Here's our custom sensor -->
        <sensor name="an_odometer" type="custom" gz:type="myodometer">
          <always_on>1</always_on>
          <update_rate>30</update_rate>
          <visualize>true</visualize>
          <gz:myodometer>
            <noise type="gaussian">
              <mean>0.00001</mean>
              <stddev>0.00001</stddev>
            </noise>
          </gz:myodometer>
        </sensor>
      </link>

      <!-- Use the velocity control plugin to give it some initial velocity -->
      <plugin
        filename="gz-sim-velocity-control-system"
        name="gz::sim::systems::VelocityControl">
        <initial_linear>0.2 0 0</initial_linear>
      </plugin>
    </model>

  </world>
</sdf>

How to run:

Run gz sim with myodometer.sdf: gz sim myodometer.sdf -v 3
Hit play to let the vehicle run
Listen to the topic myodometer in a different shell: gz topic -e -t /world/myodometer_world/model/model_with_sensor/link/link/sensor/an_odometer/myodometer

This example just integrates the system plugin and sensor plugin in one directory and can be used for your custom sensor plugins as a template.
At the end I don't know why it was causing me so much trouble to create this example, but special thanks to the user bcn for helping me to figure out severeal problems during this task.


Q:

ROS Answers SE migration: ROS Overview

I think I'm missing something obvious, but I'm having a hard time understanding the benefits of ROS.  I understand that it's a simulator, but I don't see the connection between the simulation and any of my robot projects. Obviously there is a connection as other people have robots using ROS, but I can't seem to connect the dots.
For example in the tutorials, we've got a turtle that we can move. OK so how to I map that onto an Arduino controlling a couple of motors?

Originally posted by cbruner on ROS Answers with karma: 13 on 2011-05-28
Post score: -4

A:

ROS is at its core a messaging system for distributed processing nodes. It defines a number of standard message formats for different types of commands and data that typically flow back and forth within a robot, but you are welcome to make up your own message formats if required. ROS does a great job of passing these messages around with very little programming overhead within a single computer or between networked computers.
Where ROS really starts to provide benefits is when you reuse functionality provided by the many other ROS users. Their code is supplied in repositories as "stacks". Other people have developed amazing capabilities for robots that have been "open-sourced" and are relatively easy to add incrementally using the ROS development environment. If you want an autonomous robot rather than a "remote control car" then being able to share other people's code is almost a necessity.
Visit http://www.ros.org/wiki/Robots for some inspiration or possibilities for purchasing a functional robot.
The hard part getting started is writing the interface code between ROS and your specific robot hardware if you are doing something unique. I discussed this in the recent "run erratic_navigation on my robot" question. I know I felt lost at this stage initially. I suggest patiently working through the many tutorials (22) available at ROS/tutorials. Be sure to stop by http://www.ros.org/wiki/AllTutorials for another couple of hundred available tutorials. Then experiment some more using the simulation environment, either Stage (2D)or Gazebo (3D). When you have a good idea of how the messaging system works and understand the most common message types required (cmd_vel, odom, tf, laser) you are ready to write the custom code to interface to your robot to ROS messages.
This takes a lot of patience and persistence to develop a custom robot with enough capability to do Kinect or laser guided navigation (one year of spare time for me). As I mentioned in an earlier posting if you really want to get going quickly, start with a pre-configured ROS robot like the Turtlebot or Erratic, or build something close to these so you can use the available open-source software for low-level interfacing. I didn't because I started my robot before these alternatives and ROS were available. I have had the satisfaction of doing it the hard way, but I don't necessarily recommend it as the best way to get started with ROS.
There may be some Arduino interfacing code already available that someone else can point to.
With further consideration I can add a few more points. Despite all of the tutorials I mentioned, none of them directly answer your question. There is not a simple path to controlling a few motors based on some simple sensor inputs like with Lego Mindstorms. ROS does offer the real possibility of developing a robot that can navigate to your fridge, get a beer and bring it back to you or fold your laundry, because these things are being done and the clever people that have done it are making their code base available to you.
ROS assumes that when you send out a command velocity (/cmd_vel) message that your robot starts moving in the indicated direction and speed. It then assumes that odometer messages (/odom) are regularly received indicating how far it has moved. It expects that when the various parts of your robot move relative to each other that a transform message (tf) is published by the robot. This is the hard part when getting started with custom robot hardware.
In the AllTutorials part of the wiki there are tutorials for using the Roomba, Erratic, P2OS, Nxt, Turtlebot. Software stacks are also available for these entry level robots that can be "reverse engineered" for a custom robot. There is an avr_bridge for Arduino stack that may be of assistance, but I haven't used it.
I expect that as more people hear about ROS they will drop by the ros.org/wiki and share your confusion. The home page has a very brief two sentence summary of what ROS is and a better summary in ROS/Introduction. Perhaps this should be expanded or linked more prominently to the home page.

Originally posted by Bart with karma: 856 on 2011-05-28
This answer was ACCEPTED on the original site
Post score: 15


Q:

How to have no-copy publishing over multiple cores?

I have 2 ROS Nodes each running on its own CPU core.
Is there a way I can publish a message in one node and have it be received by the other, without any copying occurring?
My ROS messages are larges images, so any copying of data would cause a large hit to performance.
As I understand it, the Publisher/Subscriber system only allows no-copy messages in a singe node process.
A nodelet is the usual workaround since that runs both the nodes in a single process.
Unfortunately, I need each of my ROS Nodes running on their own CPU, so I don't think I can do that as a solution.
I know I could create shared memory manually (either via a POSIX API or Boost) but would prefer if there was a solution using only the ROS APIs.

Originally posted by sergiom on ROS Answers with karma: 53 on 2015-05-07
Post score: 2

A:

Multiple threads within a single process do run on different cores of the CPU (http://stackoverflow.com/questions/2986931/the-way-cores-processes-and-threads-work-exactly). So nodelets are solving exactly your use case. That's why most of the image processing code is ROS package use nodelerts to implement the pipeline.

Originally posted by Dirk Thomas with karma: 16276 on 2015-05-07
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by sergiom on 2015-05-08:
So the first sentence in my question is more of a requirement than a detail.
I would like each node to only be executed in one core.
Does nodelet have a mechanism for specifying where it's executing threads will be run? Something like an OS-neutral set_affinity?
Comment by Dirk Thomas on 2015-05-08:
No, they don't have that feature atm. Also the worker threads in the nodelet manager have no fixed association to the callback of the nodelets which would also be required in order to handle all callback from a specific nodelet on a specific core.


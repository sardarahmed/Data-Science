Q:

Using the orocos/rtt rosparam service in c++

I'd like to use the rtt_ros_integration rosparam service from within one of my own components in c++. The only documentation I can find for accessing the interface of a service plugin through c++ requires that the service has a class declaration in some header that can be included: http://www.orocos.org/stable/documentation/rtt/v2.x/doc-xml/orocos-rtt-plugins.html#idp216560
Is there a way to do this by leveraging the rtt operations defined in rtt_rosparam_service.cpp?

Originally posted by jbohren on ROS Answers with karma: 5809 on 2012-04-18
Post score: 0

A:

What you need to do for this particular service is to first load the service:
// In your TaskContext subclass:
PluginLoader::Instance()->loadService("rosparam", this);

And then you could dynamic_cast the service pointer:
boost::shared_ptr<RosParam> rp = boost::dynamic_pointer_cast<RosParam>( this->provides("rosparam") );

rp->storeProperties(); // etc.

UNFORTUNATELY, this service was implemented fully in the .cpp file, so no header is available. What you can do, if you don't want to submit a patch which creates a nice hpp/cpp file and installs the hpp, you can write this as a workaround:
OperationCaller<bool(void)> storeProperties = this->provides("rosparam")->getOperation("storeProperties");

storeProperties(); // calls the Service's Operation.

Peter

Originally posted by psoetens with karma: 76 on 2012-04-18
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by jbohren on 2012-04-18:
Ahh! I see. After loading the plugin, I was trying this->requires("rosparam")->getOperation("storeProperties"). Thanks!


Q:

Convert Scan to PointCloud, use .h files, undefined reference

I follow the Laser Scanner data tutorial. I want to convert my Scan to a Point Cloud. Here are my files :
CmakeLists.txt :
cmake_minimum_required(VERSION 2.8.3)
project(laserprojection)
find_package(catkin REQUIRED COMPONENTS 
  roscpp
  rospy
  std_msgs
  laser_geometry
    geometry_msgs
  message_generation
    tf
)
find_package(Boost REQUIRED COMPONENTS system)
find_package(Eigen3 REQUIRED)
include_directories(${EIGEN3_INCLUDE_DIR} ${catkin_INCLUDE_DIRS} ${Boost_INCLUDE_DIRS})
add_executable(main test.cpp)
target_link_libraries(main ${Boost_SYSTEM_LIBRARY} ${catkin_LIBRARIES})

Test.cpp :
#include <stdio.h>
#include <ros/ros.h>
#include <tf/transform_listener.h>
#include <laser_geometry/laser_geometry.h>

#include "LaserScanToPointCloud.h"

int main(int argc, char** argv)
{
  ros::init(argc, argv, "Mapping1");
    ros::NodeHandle n;
  LaserScanToPointCloud lstopc(n);
  ros::spin();
  return 0;
}

My class.cpp :
#include "LaserScanToPointCloud.h"

  LaserScanToPointCloud(ros::NodeHandle n) : 
    n_(n),
    laser_sub_(n_, "base_scan", 10),
    laser_notifier_(laser_sub_,listener_, "base_link", 10)
  {
    laser_notifier_.registerCallback(
      boost::bind(&LaserScanToPointCloud::scanCallback, this, _1));
    laser_notifier_.setTolerance(ros::Duration(0.01));
    scan_pub_ = n_.advertise<sensor_msgs::PointCloud>("/my_cloud",1);
  }

  void scanCallback (const sensor_msgs::LaserScan::ConstPtr& scan_in)
  {
    sensor_msgs::PointCloud cloud;
    try
    {
        projector_.transformLaserScanToPointCloud(
          "base_link",*scan_in, cloud,listener_);
    }
    catch (tf::TransformException& e)
    {
        std::cout << e.what();
        return;
    }
    
    // Do something with cloud.

    scan_pub_.publish(cloud);

  }

My class.h :
#include "ros/ros.h"
#include "tf/transform_listener.h"
#include "sensor_msgs/PointCloud.h"
#include "tf/message_filter.h"
#include "message_filters/subscriber.h"
#include "laser_geometry/laser_geometry.h"

class LaserScanToPointCloud{

public:

  ros::NodeHandle n_;
  laser_geometry::LaserProjection projector_;
  tf::TransformListener listener_;
  message_filters::Subscriber<sensor_msgs::LaserScan> laser_sub_;
  tf::MessageFilter<sensor_msgs::LaserScan> laser_notifier_;
  ros::Publisher scan_pub_;

    //CONSTRUCTEUR
  LaserScanToPointCloud(ros::NodeHandle n);
    
    //METHODES
  void scanCallback (const sensor_msgs::LaserScan::ConstPtr& scan_in);

};

I have this undefined reference error :
test.cpp:(.text+0x154) : référence indéfinie vers « LaserScanToPointCloud::LaserScanToPointCloud(ros::NodeHandle) »

How can I use the class I created ? Should I change the Cmake ?

Originally posted by karl on ROS Answers with karma: 5 on 2019-02-12
Post score: 0

A:

Because your node contains elements from two different cpp files you need to let CMake know that they are both required. To do this you'll need to change the line:
add_executable(main test.cpp)

to
add_executable(main test.cpp class.cpp)

Hope this helps.

Originally posted by PeteBlackerThe3rd with karma: 9529 on 2019-02-12
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by karl on 2019-02-12:
It worked perfect when I merged my .h and .cpp class files in one file. Thank you very much :)


Q:

Can the repeatability of 10micrometers be accomplished?

Hi, I would like to ask if it is possible to accomplish the repeatability of 10 micrometers regarding robotic arms using Moveit, ros_control and tf for control. I need such precision for my project. I have tried to move an arm from theposition.x = -0.0528998 to the position.x = -0.0528999, although the move_group.getCurrentPose() and also the tf library provide me with the value of -0.0528155 for both positions. Is there a way how to improve the precision or is it something that cant be accomplished?

Originally posted by Zenzu on ROS Answers with karma: 28 on 2021-04-25
Post score: 0

Original comments
Comment by gvdhoorn on 2021-04-25:
Out of curiosity: could you describe the kind of hw you are using? Repeatability of 10 micrometres isn't really something a typical (industrial) robot is capable of achieving.
That makes it a bit of a moot point whether or not doubles / floats have the required number of significant digits to represent those distances.
Comment by Zenzu on 2021-04-25:
We are developing a small robotic arm for lab experiments that consists of handling samples of size under 1mm. But still, what is the maximum precision (maximum that you know) that can be accomplished using ROS toolbox?
Comment by gvdhoorn on 2021-04-25:
Ok, then the question does make sense.
I can't say I can answer this authoritatively (hence just a comment here), but doubles can encode about 15 to 16 significant digits (according to the IEEE 754 double-precision binary floating-point format page on Wikipedia (and other sources).
ROS uses metres for distances (such as transforms and geometry_msgs/Pose). Micrometres are 10e-6 metres, which would seem to fit easily in the range of a double (when 1.0 would be a metre).

the tf library provide me with the value of -0.0528155 for both positions

Without more information this is hard to say, but perhaps you've not configured the std::cout (or printf(..)) formatter to show you the required nr of digits?
Additionally: you mention a few components, each with their own configurations and characteristics. Are all using the same representation for distances and rotations?
Comment by gvdhoorn on 2021-04-26:
Additional comment: order of operations matters of course, especially with floating point numbers.
Even if double could achieve the required precision in the representation, each operation performed on them will/may/could add rounding errors. It could be your seeing that.
But without more testing I believe it will be difficult to be sure.
Comment by Zenzu on 2021-04-28:
I am sorry for late answer.. the problem was with setting the goal tolerance as well as with configuring std::cout precision. Thank you for your help, I am closing this issue since it seems that the precision of Moveit only depends on double's encoding

A:

The problem was with setting the goal tolerance as well as with configuring std::cout precision. It seems that the precision of Moveit only depends on double's encoding.

Originally posted by Zenzu with karma: 28 on 2021-04-28
This answer was ACCEPTED on the original site
Post score: 0


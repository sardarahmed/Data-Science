Q:

How to communicate with GZServer over a custom Socket-Client

Hi Gazebo Community,
I have to publish some gazebo data to a windows application. For that I wanted to establish a socket communication. I generated a model plugin that is publishing data of interest. The data I can readout through the gazebo gui. For the next step I wanted create a standalone socket client to read the data published by gazebo. As a starter for socket communication the result confuses me.
Code for Client:
using namespace std;

int main(int argc, char* argv[])
{
    int client;
    int portNum = 11345; // NOTE that the port number is same for both client and server
    bool isExit = false;
    int bufsize = 1024;
    char buffer[bufsize];
    char* ip = "127.0.0.1";

    struct sockaddr_in server_addr;

    /// \brief Creating a new Socketconnection
    /// \param[ARG 1] Adress Domain of the Socket
    /// \param[ARG 2] Type of the Socket. Continous TCP Stream
    /// \param[ARG 3] Protocol, choosen by the OS
    client = socket(AF_INET, SOCK_STREAM, 0);

    if(client < 0){
        cerr << "\nError establishing socket..." << endl;
        exit(1);
    }

    cout << "\n=> Client has been created..." << endl;

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(portNum);
    server_addr.sin_addr.s_addr = inet_addr(ip);

    // Connecto to the Socket-Server
    if( connect( client, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0 ){
        cerr << "\nError establishing connection to Server..." << endl;
        exit(1);
    }
    cout << "=> Awaiting confirmation from the server..." << endl;
    recv(client, buffer, bufsize, 0);
    cout << "=> Connection confirmed..." << endl;

    do {
        recv(client, buffer, bufsize, 0);
        cout << buffer << " ";
    } while (true);

    cout << endl;
    cout << "\n=> Connection terminated.\nGoodbye...\n";
    close(client);

    return 0;
}

And the output is the following:
=> Client has been created...
=> Awaiting confirmation from the server...
=> Connection confirmed...
00000048

����؁�:topic_namepaces_init#
default
/gazebo
velodyne_hdl-3200000990

�������:publishers_init�
K
/gazebo/default/pose/local/infogazebo.msgs.PosesStamped
10.12.0.62 ��
E
/gazebo/default/pose/infogazebo.msgs.PosesStamped
10.12.0.62 ��
6
/gazebo/default/guigazebo.msgs.GUI
10.12.0.62 ��
@
/gazebo/default/responsegazebo.msgs.Response
10.12.0.62 ��
J
/gazebo/default/world_statsgazebo.msgs.WorldStatistics
10.12.0.62 ��
?
/gazebo/default/model/infogazebo.msgs.Model
10.12.0.62 ��
A

I assumed a stream of data and not one single output. Is it right what I'm seeing? How can I access for example the custom topic: /gazebo/veldoyne/scan_pose?  Is that because I'm not encoding the ProtoBuf message in the right way and should I proceed with ign_transport lib to create a windows socket client for reading gazebo data?
Thanks for every advice.
Cheers, Rob

Originally posted by TwoBid on Gazebo Answers with karma: 35 on 2016-05-18
Post score: 1

A:

What you're seeing makes sense to me. You're probably observing the internal encoding of one or more Gazebo Transport messages, plus the internal encoding of a protobuf message. It would help if you post the publisher side too.
I'd suggest to create a subscriber on your Gazebo plugin and make sure that you get the data you're interested in your subscriber callback. Once you're sure that you're receiving the data correctly, you have to forward that data to your Windows process. I see two options:

You can create your custom protocol to send the data based on raw sockets. This is super flexible but probably more error-prone if you're not familiar with sockets. If you're using TCP, you have to make sure that the consumer process on your Windows machine knows the same protocol. Remember that TCP sockets don't preserve message boundaries. You could send two different messages on your Gazebo plugin and receive a single one on your Windows machine, for example. Alternatively, you can use UDP that doesn't have this "feature".

You can use a portable library. I'd recommend ZeroMQ if you still want to use a low level socket library. ZeroMQ solves the framing for you. Another approach would be to use Ignition Transport, a higher level approach that we're starting to use inside Gazebo.

Originally posted by Carlos Agüero with karma: 626 on 2016-05-24
This answer was ACCEPTED on the original site
Post score: 1


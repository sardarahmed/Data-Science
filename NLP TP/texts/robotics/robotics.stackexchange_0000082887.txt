Q:

How to best call catkin_add_gtest and add_rostest_gtest separately?

I'm trying to test ROS code at two different levels (calling catkin_add_gtest and add_rostest_gtest separately), and I haven't found documentation on exactly how to do what I'm hoping to do.
Essentially, I have src/library.cpp that I'd want to run gtest tests on through test/test_library.cpp. This should test low-level functionality - just the methods and functions defined in library.cpp, without any need of having a node running or publishing/subscribing.
I'd also like to run a full-fledged node-level test, running multiple nodes through rostest (defined in a test/test_node.test file), spun up through a gtest node defined in test/test_node.cpp.
The problem I'm facing is that if I run catkin run_tests package_name, this runs both the catkin_add_gtest and add_rostest_gtest targets. I'd like to use some command to run only one or the other, not both. How might I do that?
See example CMakeLists.txt below.
# CMakeLists.txt
...
add_library(library src/library.cpp )
target_link_libraries(library ${catkin_LIBRARIES})

if(CATKIN_ENABLE_TESTING)

  if(TARGET run_library_test) # can I do this?
    find_package(catkin REQUIRED rostest)
    catkin_add_gtest(test_library test/test_library.cpp)
    target_link_libraries(test_library library ${catkin_LIBRARIES})
  endif() # run_library_test

  if(TARGET run_node_test) # can I do this?
    find_package(catkin REQUIRED rostest)
    add_rostest_gtest(test_node test/test_node.test test/test_node.cpp)
    target_link_libraries(test_node library ${catkin_LIBRARIES})
  endif() # run_node_test

endif() # CATKIN_ENABLE_TESTING

Originally posted by nckswt on ROS Answers with karma: 539 on 2017-09-19
Post score: 3

A:

I had this problem as well and this was my solution
For reference, I refer to unit tests as the library tests (ie: no ROS environment) and integration tests as tests done with rostest
Add in two options in the top of your CMake (or your root CMake)
option(BUILD_UNIT_TESTS "Build the unit tests" OFF)
option(BUILD_INTEGRATION_TESTS "Build the integration tests" OFF)

Write your tests block similar to your above example
if(CATKIN_ENABLE_TESTING)
  if(BUILD_UNIT_TESTS)
    catkin_add_gtest(
      primary_controller_unit_tests
      test/unit_tests.cpp
    )
    if(TARGET primary_controller_unit_tests)
      target_link_libraries(
        primary_controller_unit_tests 
        ${catkin_LIBRARIES}
        ${PROJECT_NAME}
      )
    endif()
  endif(BUILD_UNIT_TESTS)

  if(BUILD_INTEGRATION_TESTS)
    add_rostest_gtest(
      primary_controller_integration_tests 
      test/integration_tests.test 
      test/integration_tests.cpp
    )
    if(TARGET primary_controller_integration_tests)
      target_link_libraries(
        primary_controller_integration_tests 
        ${catkin_LIBRARIES}
        ${PROJECT_NAME}
      )
    endif()
  endif(BUILD_INTEGRATION_TESTS)

endif(CATKIN_ENABLE_TESTING) 

Then when invoking catkin, use
catkin_make run_tests --cmake-args -DBUILD_UNIT_TESTS=OFF -DBUILD_INTEGRATION_TESTS=ON

I'm in the attempt of making a ROS template which will work with GitLab (this sort of functionality makes sense for a CI), if its of any use to anyone else see it here https://github.com/ALTinners/ros-gitlab-ci-example

Originally posted by ALTinners with karma: 26 on 2018-08-08
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Dirk Thomas on 2018-08-27:
Using a custom CMake option like BUILD_INTEGRATION_TESTS which defaults to OFF will prevent you from running these tests on e.g. the ROS buildfarm (since it doesn't know about the option and won't enable it).
Comment by ALTinners on 2018-08-28:
That was on purpose though - that particular project was intended to be run as a Build/Unit/Integration/Acceptance procedure, with early exit if a stage failed. You'd modify the catkin/cmake command you use based on the level of testing you wanted to perform, and change CMake defaults if needed.


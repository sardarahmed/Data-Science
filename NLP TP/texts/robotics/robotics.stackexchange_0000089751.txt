Q:

Error in template instantiation for ros::NodeHandle::param

I'm trying to get arm_id from the parameter server using function template<typename T>  T param(const std::string& param_name, const T& default_val) so as to initialize the variable in the initializer list. However, it seems the wrong template is getting picked for resolution. This is a MWCE (you would probably need to set some parameter first via launch file for this to actually work and not only compile):
class Foo
{
public:
  Foo();

private:
  static constexpr auto default_arm_id = "foo";
  ros::NodeHandle nh_;
  std::string arm_id_;
};

Foo::Foo()
    : nh_ {}
    , arm_id_ {nh_.param("/franka_state_controller/arm_id", default_arm_id)}
{
}

and the error I get is:
In file included from /home/(...)/foo.h:16:0,
                 from /home/(...)/foo.cpp:10:
/opt/ros/kinetic/include/ros/node_handle.h: In instantiation of ‘bool ros::NodeHandle::param(const string&, T&, const T&) const [with T = const char*; std::__cxx11::string = std::__cxx11::basic_string<char>]’:
/opt/ros/kinetic/include/ros/node_handle.h:2156:7:   required from ‘T ros::NodeHandle::param(const string&, const T&) [with T = const char*; std::__cxx11::string = std::__cxx11::basic_string<char>]’
/home/(...)/foo.cpp:56:72:   required from here
/opt/ros/kinetic/include/ros/node_handle.h:2124:7: error: invalid conversion from ‘const char*’ to ‘int’ [-fpermissive]
       if (getParam(param_name, param_val))
       ^
/opt/ros/kinetic/include/ros/node_handle.h:1705:8: note:   initializing argument 2 of ‘bool ros::NodeHandle::getParam(const string&, int&) const’
   bool getParam(const std::string& key, int& i) const;
        ^
/opt/ros/kinetic/include/ros/node_handle.h:2124:7: error: cannot bind rvalue ‘(int)((long int)param_val)’ to ‘int&’
       if (getParam(param_name, param_val))
       ^
make[2]: *** [CMakeFiles/foo.dir/src/foo.cpp.o] Error 1
make[1]: *** [CMakeFiles/foo.dir/all] Error 2
make: *** [all] Error 2

The same happens if I initialize in the body of the constructor, by the way.

Originally posted by aPonza on ROS Answers with karma: 589 on 2018-12-05
Post score: 0

A:

Try explictly specifying the template type when calling the function as below.
Foo::Foo()
    : nh_ {}
    , arm_id_ {nh_.param<std::string>("/franka_state_controller/arm_id", default_arm_id)}
{
}

With the auto declaration of the default value I don't think the compiler is able to resolve the type for the parameter. let us know if this fixes it.

Originally posted by PeteBlackerThe3rd with karma: 9529 on 2018-12-05
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by aPonza on 2018-12-05:
Yes, absolutely had not thought of that. Thanks!


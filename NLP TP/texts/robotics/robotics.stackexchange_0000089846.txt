Q:

ABB: S4C + IRB6650: How do I visualize an ABB robot's movements in Rviz

Forgive me, I am pretty new to ROS, so please excuse any gaps in my knowledge. I have a wireless ESP8266 microcontroller reading joint_state data from an ABB robot through serial connection and it is sending it directly to a remote ros server. I'm able to see the physical robot's live position by using 'rostopic echo joint_states' on the server, but I'm unable to visualize its movements in Rviz. I launched the demo of the Abb_irb6640_moveit_config package but I am confused on how to control it by reading joint_states. I am attempting to use Rviz in conjunction with rosserial's serial_node.py script.
UPDATE:
Thanks to @gdvhoorn ! I was finally able to get the visualization to work. I hadn't mentioned earlier that I was using the rosserial package to publish joint_state msgs using this arduino code https://github.com/mikevillan26/open_abb_serial_logger.git. I had to simply change the joint names I had declared in my code to reflect those of the abb_irb_6640 urdf. From there, I could launch the robot_state_visualize.launch file in the abb_irb6640_support pkg in conjunction with the rosserial_python/serial_node.py/tcp and the model would finally reflect the live movements of my robot.

Originally posted by mikevillan26 on ROS Answers with karma: 13 on 2018-12-14
Post score: 0

Original comments
Comment by gvdhoorn on 2018-12-14:\

I have a wireless ESP8266 microcontroller reading joint_state data from an ABB robot through serial connection

out of curiosity: what robot and controller is/are this? Seeing "serial" mentioned I'm guessing the controller doesn't have an ethernet connection available?
Comment by mikevillan26 on 2018-12-14:
Well it has an ethernet connection but I haven't tested it yet. It is an ABB irb6650s with an S4C+ controller, so socket connection is not an option. I've tested with the serial COM ports and I'm able to read joint data from the robot but I still cant send it commands.
Comment by mues on 2021-06-09:
is there any chance to get the open_abb_serial_logger because i cant find it anymore on on git

A:

I launched the demo of the Abb_irb6640_moveit_config package [..]

demo.launch is not a launch file you would use for controlling a real robot or for visualising a real robot's state.
It's -- as the name implies -- a demo setup that you may use to test MoveIt's functionality with a particular robot's (urdf) model.

[..] but I am confused on how to control it by reading joint_states.

I'm not sure what you mean by this. JointState messages are intended to be used to report joint state, not to command it.

Edit:

My aoplogies, I want to use the joint_state feedback data from the physical robot to move the robot model in RViz,simply as a way to visualize what is happening to the real robot.

Ok. That should not be too hard, seeing as you already are publishing JointState messages.
Components involved in visualising robot state:

RViz
robot_state_publisher
a JointState publisher
a urdf/xacro for the robot model (more of a passive component, but still)

You wrote #3, ROS provides #1 and #2, ros-industrial/abb provides #4.
Probably the quickest way to visualise current robot state would be to edit abb_irb6640_support/launch/robot_state_visualize_irb6640_185_280.launch and comment/remove the section that starts the $(find abb_driver)/launch/robot_interface.launch file. We don't need it, as your ESP8266 is already publishing JointState messages (so takes over half the role of abb_driver). Also comment/remove the line declaring the robot_ip argument, as you don't need it.
Now start your ESP8266 and then:
roslaunch abb_irb6640_support robot_state_visualize_irb6640_185_280.launch

RViz should come up and show you the current state of the robot (I don't know whether you have that particular variant of the IRB 6640, but that doesn't matter for now, you can fix that later).
NOTE: abb_driver decouples axes 2 and 3 (here). Without that, JointState messages won't be correct and the pose of the robot will be reported incorrectly. You'll probably have to do something similar in the code running on your ESP8266.

I have not been able to successfully write serial data to the robot controller, but for some reason I can receive data.

Depending on your ultimate goal, it may be an idea to take a look at ros-industrial/industrial_core#107: that issue asks for a serial transport for industrial_core. Provided the S4C+ supports sufficient Rapid and with appropriate changes to abb_driver (ie: make it support a serial connection) you may be able to use the regular infrastructure but then over a serial connection.
No guarantees of course, but if you'd be interested I'd be willing to help.

Edit 2:

Now when I run this in parallel with launching robot_state_visualize after doing what you told me, parts of the model are now white, [..] Looking at the RobotModel Display in Rviz, it tells me there is "No transform from [link_1] to [base_link]" for every link after the base frame.

Your description and screenshot suggest that there is a problem with TF. This is typically either because robot_state_publisher (RSP) is not running, or RSP is not receiving proper JointState messages for the URDF it has loaded.
In your case, it's most likely the latter. In the code on the ESP8266, I see this (from here):
char *j_name[] = {"J1", "J2", "J3", "J4", "J5", "J6"};

While those are perfectly valid joint names (although I would personally never use capitals in ROS names), they won't work for the URDF that you are loading, as there the names of the joints are: joint_1, joint_2, joint_3, joint_4, joint_5 and joint_6 (see here).
For RSP to be able to perform the correct forward kinematics, the incoming JointState messages must use the correct joint names, or it won't know which joint to use for which transform.
I expect things to start working once you use the correct joint names on the ESP8266 side.

Originally posted by gvdhoorn with karma: 86574 on 2018-12-14
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by mikevillan26 on 2018-12-14:
My aoplogies, I want to use the joint_state feedback data from the physical robot to move the robot model in RViz,simply as a way to visualize what is happening to the real robot. I have not been able to successfully write serial data to the robot controller, but for some reason I can receive data.
Comment by mikevillan26 on 2018-12-17:
So I forgot to mention that the ESP depends on running rosserial_python/serial_node.py/tcp meaning it will not publish joint _state data unless the node is running. Now when I run this in parallel with launching robot_state_visualize after doing what you told me, parts of the model are now white...
Comment by mikevillan26 on 2018-12-17:
The robot also appears to be driving into the floor and through itself like here
Comment by mikevillan26 on 2018-12-17:
Looking at the RobotModel Display in Rviz, it tells me there is "No transform from [link_1] to [base_link]" for every link after the base frame. Note that I have not yet changed anything about the decoupling of axes 2 & 3 as I was confused on how to do it for now so Im wondering if thats the reason
Comment by mikevillan26 on 2018-12-17:
Here is the arduino code I used for the ESP8266 to send wireless joint_state data to my ros server using the rosserial_python/serial_node/tcp https://github.com/mikevillan26/open_abb_serial_logger.git. I really appreciate all of your help
Comment by gvdhoorn on 2018-12-17:
Just an FYI: if industrial_core had a serial transport and abb_driver was updated to make use of that, your custom ESP8266 code + rosserial would not be needed. Unless you like the wireless aspect of it, of course (but even then: socat).
Comment by gvdhoorn on 2018-12-17:
Btw: could you please update your original question text with a new section (perhaps call it Edit) and then add the things you describe here in the comments in the edit section?
Also please attach your image to the question directly. I've given you sufficient karma for that.
Comment by mikevillan26 on 2018-12-17:
It worked!!! Thank you so much! I will look into industrial_core and see what if I can modify it for my needs!
Comment by gvdhoorn on 2018-12-17:
If you do add a serial transport there we would be very much interested in it. A PR would be very much appreciated.
Comment by gvdhoorn on 2018-12-17:\

I had to simply change the joint names I had declared in my code to reflect those of the abb_irb_6640 urdf.

perhaps the parameter support of rosserial could be used to avoid having to hardcode the joint names in your sketch.
Comment by mikevillan26 on 2018-12-18:
To be honest I would love some help figuring this issue out. Im sending string data (simple "Hello World") to the serial channel at the same baud rate, and having RAPID (ABB robot language) print the received string onto the pendant. Strange thing is it is returning a weird encoded message instead.
Comment by mikevillan26 on 2018-12-18:
It seems that RAPID is understanding the Python string differently, but data is somehow getting through. Also, it is coming in at a completely different rate. Here is the code for the robot controller as well as the ESP mcu here.
Comment by gvdhoorn on 2018-12-19:
I'd love to help, but am also rather busy at the moment. From your description your problem currently doesn't sound ROS related. Would it perhaps be an idea to ask this over at the RobotStudio forums? Or perhaps some other forum dedicated to ABB robots and RAPID programming?
Comment by gvdhoorn on 2018-12-19:
Getting garbled data would indicate an issue with baud rates, but you say you already checked that. It could also be an issue with serial port settings other than baud rate (bits-per-byte, etc).
But I'm not really an arduino/esp8266 expert, so I'm just guessing here.


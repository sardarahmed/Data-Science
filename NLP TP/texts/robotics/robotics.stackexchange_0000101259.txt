Q:

How are the "repos" yaml files generated?

The "building ROS2 from source" instructions at https://docs.ros.org/en/foxy/Installation/Ubuntu-Development-Setup.html use a "repos" file in yaml format: https://raw.githubusercontent.com/ros2/ros2/foxy/ros2.repos.
How is this file generated?
In ROS1, this kind of file was generated with the rosinstall_generator tool (http://wiki.ros.org/Installation/Source#noetic.2FInstallation.2FSource.Create_a_catkin_Workspace). Is there something similar for ROS2?
I am asking because I would like to build ROS2 from source with fewer irrelevant packages (e.g. without any of ros-visualization or without ros2/rviz). The only workarounds to prevent building irrelevant packages are 1) removing packages from the repos file manually, 2) deleting source folders after the complete checkout, or 3) by placing COLCON_IGNORE files.
But there surely must be a better way by just specifying the packages of interest and generating the "repos" file programmatically.

Originally posted by Christian Rauch on ROS Answers with karma: 214 on 2022-02-19
Post score: 0

A:

The "building ROS2 from source" instructions [..] use a "repos" file in yaml format. [..] How are the "repos" yaml files generated?

IIRC, that specific file is not generated by any tool. It's a manually managed file which was historically only used for CI purposes and for building ROS 2 from source by core developers. At some point it got repurposed to also be used by 'regular users' to build ROS 2 on their own machines.
That file does not contain "everything ROS 2", and for good reason: nightly builds of ROS 2 based on the contents of that file already sometimes time-out -- or at the very least take a (very) long time, as everything in there is built as part of a single build.
There have been quite a few PRs which wanted to add more packages to that file (and files similar to it) simply because such builds do not scale.
This comment by @clalancette highlights the difference between repos.yaml and whatever a tool like rosinstall_generator will generate:

Before we make changes here, I think it is worthwhile to define the target audience of the build-from-source instructions.
If the target audience is "people who can't use the binary packages, but just want to use ROS 2", then I agree that switching to rosinstall_generator is better. It will get them something closer to what the Debian packages are providing.
But if the target audience is "people who want to work on the core of ROS 2", the situation is murkier to me. The current instructions more-or-less follow how the CI jobs work (at least on Linux and macOS; Windows is now totally different). That means that if a user checks things out in that way, and runs the appropriate tests, there is a good chance that things will work on the CI job when they open a PR. If we switch to rosinstall_generator for the instructions, then that is further away from what CI does.
There is a way to resolve this discrepancy, which is to make the CI jobs use rosinstall_generator. That is one of the long-term goals I would like to get done for ROS 2, so maybe it is worthwhile addressing that first.

As you already noticed, rosinstall_generator will create an even larger .repos file for you. That's the discrepancy Chris refers to.

In ROS1, this kind of file was generated with the rosinstall_generator tool (http://wiki.ros.org/Installation/Source#noetic.2FInstallation.2FSource.Create_a_catkin_Workspace). Is there something similar for ROS2?

You can still use rosinstall_generator.
ROS 2 packages are still released using Bloom, which still pushes commits to ros/rosdistro. That information is the same as used by rosinstall_generator with ROS 1.
.repos files can be generated by dirk-thomas/vcstool, but vcs also supports the .rosinstall format. If you really want to have .repos files, append --format=repos to your rosinstall_generator command line.
A few older/related Q&As: #q378063, #q299473, #q339570, #q379624 (with linked Discourse discussion: Core, base and desktop releases), #q319587 and #q325245.

The only workarounds to prevent building irrelevant packages are 1) removing packages from the repos file manually, 2) deleting source folders after the complete checkout, or 3) by placing COLCON_IGNORE files.

Colcon actually supports quite extensive ways to select and/or ignore (sets of) packages, similar to how catkin_tools allowed you to build only subsets of a workspace (even as part of a profile). That's not the same as never checking out those sources, but since you suggested a few work-arounds which required changes to the artefacts in your workspace, I wanted to mention it.
See Colcon documentation: Package selection arguments:

--packages-up-to [PKG_NAME [PKG_NAME …]]

  Select the packages with the passed names as well as their recursive dependencies.

--packages-up-to-regex [PATTERN [PATTERN …]]

  Select the packages that match any of the passed patterns as well as their recursive dependencies.

--packages-above [PKG_NAME [PKG_NAME …]]

  Select the packages with the passed names as well as packages which recursively depend on them.

--packages-above-and-dependencies [PKG_NAME [PKG_NAME …]]

  Select the packages with the passed names, packages which recursively depend on them as well as their recursive dependencies.

--packages-above-depth DEPTH [PKG_NAME …]

  Select the packages with the passed names as well as packages which recursively depend on them up to the given depth.

--packages-select-by-dep [DEP_NAME [DEP_NAME …]]

  Select packages which (recursively) depend on the given packages.

--packages-skip-by-dep [DEP_NAME [DEP_NAME …]]

  Skip packages which (recursively) depend on the given packages.

--packages-skip-up-to [PKG_NAME [PKG_NAME …]]

  Skip the packages with the passed names as well as their recursive dependencies.

--packages-select-build-failed

  Select packages which have failed to build previously. Packages which have been aborted previously are not included.

--packages-skip-build-finished

  Skip packages which have finished to build previously.

--packages-select-test-failures

  Select packages which had test failures previously.

--packages-skip-test-passed

  Skip packages which had no test failures previously.

--packages-select [PKG_NAME [PKG_NAME …]]

  Select the packages with the passed names.

--packages-skip [PKG_NAME [PKG_NAME …]]

  Skip the packages with the passed names.

--packages-select-regex [PATTERN [PATTERN …]]

  Select the packages where any of the patterns match the package name.

--packages-skip-regex [PATTERN [PATTERN …]]

  Skip the packages where any of the patterns match the package name.

--packages-start PKG_NAME

  Skip packages before the given package name in flat topological ordering. This option only makes sense when using the sequential executor.

--packages-end PKG_NAME

  Skip packages after the given package name in flat topological ordering. This option only makes sense when using the sequential executor.

Originally posted by gvdhoorn with karma: 86574 on 2022-02-20
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Christian Rauch on 2022-02-20:
Thanks. While this certainly can reduce the number of downloaded source packages, I am still having trouble somehow replicating the repo file. Generating a minimal installation via rosinstall_generator ros_core --rosdistro galactic --deps --format=repos > base.repos still adds more repos (166 via cat base.repos | grep "type: git" | wc -l) than what is found in the "official" ros2.repos (102). This file may be generated manually, but do you manage to include all the visualization packages without the ros_core? I also noticed that the git repos are different.
Comment by gvdhoorn on 2022-02-21:
I'm not sure I understand what you're asking when you say:

This file may be generated manually, but do you manage to include all the visualization packages without the ros_core?

ros_core doesn't include any UI-based packages, and that's on purpose.
Or are you asking how to download the sources for all UI-based packages that are not in ros_core, but without also downloading ros_core packages?


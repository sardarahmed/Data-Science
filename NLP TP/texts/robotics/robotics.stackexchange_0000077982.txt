Q:

maybe error of cv_bridge (on kinect)

I made my ImageView program for kinect.
I can compile this program. But when I excute it, it happen core dump like this.
my_image_view_class: /usr/include/boost/smart_ptr/shared_ptr.hpp:653: typename boost::detail::sp_member_access<T>::type boost::shared_ptr<T>::operator->() const [with T = cv_bridge::CvImage; typename boost::detail::sp_member_access<T>::type = cv_bridge::CvImage*]: Assertion `px != 0' failed.

I am using ros indigo, ubuntu 14.04.
This is my code.
#include <ros/ros.h>
#include <sensor_msgs/Image.h>
#include <cv_bridge/cv_bridge.h>
#include <opencv2/opencv.hpp>
#include <string>

class MyImageView
{
    ros::NodeHandle nh;
    ros::Subscriber sub_color, sub_depth;

    cv_bridge::CvImagePtr cv_color_ptr, cv_depth_ptr;
    std::string sColorNode, sDepthNode;
    float **color_dimage, **depth_dimage;
    int size_rows, size_sols;
    
    void colorCallback(const sensor_msgs::ImageConstPtr& msg);
    void depthCallback(const sensor_msgs::ImageConstPtr& msg);

public:
    MyImageView();

    ~MyImageView();

    void colorImageShow(std::string window_name = "COLOR image");
    void colorImageShowTest(std::string window_name = "COLOR image");
    void depthImageShow(std::string window_name = "DEPTH image");

    void colorImageWrite(std::string filename);
    void depthImageWrite(std::string filename);

    double returnDepth();
};

MyImageView::MyImageView()
{
    sColorNode = "/camera/rgb/image_color";
    sDepthNode = "/camera/depth_registered/image_raw";
    sub_color = nh.subscribe<sensor_msgs::Image>(sColorNode, 1, &MyImageView::colorCallback, this);
    sub_depth = nh.subscribe<sensor_msgs::Image>(sDepthNode, 1, &MyImageView::depthCallback, this);
    size_rows = cv_depth_ptr->image.rows;
    size_sols = cv_depth_ptr->image.cols;
}

MyImageView::~MyImageView()
{

}

void MyImageView::colorCallback(const sensor_msgs::ImageConstPtr& msg)
{
    try
    {
        cv_color_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);
    }
    catch (cv_bridge::Exception& ex)
    {
        ROS_ERROR("error");
        exit(-1);
    }

    color_dimage = (float**)malloc(sizeof(float*) * cv_color_ptr->image.rows);
    for (int i = 0; i < cv_color_ptr->image.rows; ++i)
    {
        color_dimage[i] = (float*)malloc(sizeof(float) * cv_color_ptr->image.cols);
    }

    for(int i = 0; i < cv_color_ptr->image.rows;i++)
    {
        float* dimage = cv_color_ptr->image.ptr<float>(i);
        
        for(int j = 0 ; j < cv_color_ptr->image.cols; j++)
        {
            color_dimage[i][j] = dimage[j];
        }
    }
}

void MyImageView::depthCallback(const sensor_msgs::ImageConstPtr& msg)
{
    try
    {
        cv_depth_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::TYPE_32FC1);
    }
    catch (cv_bridge::Exception& ex)
    {
        ROS_ERROR("error");
        exit(-1);
    }

    depth_dimage = (float**)malloc(sizeof(float*) * cv_depth_ptr->image.rows);
    for (int i = 0; i < cv_depth_ptr->image.rows; ++i)
    {
        depth_dimage[i] = (float*)malloc(sizeof(float) * cv_depth_ptr->image.cols);
    }

    for(int i = 0; i < cv_depth_ptr->image.rows;i++)
    {
        float* dimage = cv_depth_ptr->image.ptr<float>(i);
        
        for(int j = 0 ; j < cv_depth_ptr->image.cols; j++)
        {
            depth_dimage[i][j] = dimage[j];
        }
    }
}

void MyImageView::colorImageShow(std::string window_name)
{
    cv::imshow(window_name, cv_color_ptr->image);
}

void MyImageView::colorImageShowTest(std::string window_name)
{
    cv_bridge::CvImagePtr show;
    show = cv_color_ptr;
    for(int i = 0; i < show->image.rows;i++)
    {
        cv::Vec3b* dimage = show->image.ptr<cv::Vec3b>(i);
        
        for(int j = 0 ; j < show->image.cols; j++)
        {
            if (depth_dimage[i][j] < 20)
            {
                dimage[j] = cv::Vec3b(255, 0, 0);
            }
        }
    }
    cv::imshow(window_name, show->image);
}

void MyImageView::depthImageShow(std::string window_name)
{
    cv::imshow(window_name, cv_depth_ptr->image);
}

void MyImageView::colorImageWrite(std::string filename)
{
    cv::imwrite(filename, cv_color_ptr->image);
}

void MyImageView::depthImageWrite(std::string filename)
{
    cv::imwrite(filename, cv_depth_ptr->image);
}

double MyImageView::returnDepth()
{
    double min = 1000.0;

    for(int i = 0; i < size_rows;i++)
    {
        float* dimage = cv_depth_ptr->image.ptr<float>(i);

        for(int j = 0 ; j < size_sols; j++)
        {
            if (dimage[j] < min && dimage[j] * 100 > 20)
            {
                min = dimage[j];
            }
        }
    }
    return min;
}

int main(int argc, char *argv[])
{
    ros::init(argc, argv, "my_image_view_class");

    MyImageView miv;

    miv.colorImageShow();
    // miv.colorImageShowTest();

    miv.colorImageWrite("color_result.jpg");

    miv.depthImageShow();

    miv.depthImageWrite("depth_result.jpg");

    std::cout << miv.returnDepth() << std::endl;

    cv::waitKey(10);

    ros::spin();
    return 0;
}

thanks.

Originally posted by sora on ROS Answers with karma: 63 on 2016-12-22
Post score: 1

A:

I solved myself.
After I changed constructor, the error was deleted.
(Actually, there are another error then)
New constructor is here.
MyImageView::MyImageView()
{
    sColorNode = "/camera/rgb/image_color";
    sDepthNode1 = "/camera/depth_registered/image_raw";
    sDepthNode2 = "/camera/depth/image";

    cv_color_ptr.reset (new cv_bridge::CvImage);
    cv_depth_ptr.reset (new cv_bridge::CvImage);

    sub_color = nh.subscribe<sensor_msgs::Image>(sColorNode, 1, &MyImageView::colorCallback, this);
    sub_depth_image = nh.subscribe<sensor_msgs::Image>(sDepthNode1, 1, &MyImageView::depthCallback, this);
}

Originally posted by sora with karma: 63 on 2016-12-22
This answer was ACCEPTED on the original site
Post score: 1


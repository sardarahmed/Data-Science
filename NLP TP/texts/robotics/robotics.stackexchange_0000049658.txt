Q:

ROS on Beaglebone

Hi,
I have referred to some posts regarding cross-compiling on the forum, but didn't find them specific enough. So here are my queries -

The most important one: How should I go about installing it on the Beaglebone?
Should the ROS version be taken into consideration?
Is it actually a good thing to have ROS installed onto the Beaglebone? I mean, would you say, based on the application, that there is an advantage? (I know it's kind of silly of me to ask this question 'cause different applications might have different effects.)
If anyone has worked on this before (or on something similar), does it create any "known" issues?
Will the speed/processing be limited as compared to running the same kind of "application" on a computer (with ROS)?
How much Memory/Size might it require to install and run ROS?

Any other information will also be appreciated! Thank you!

Originally posted by nemesis on ROS Answers with karma: 237 on 2013-03-22
Post score: 2

A:

1.I've just finished installing ROS Fuerte on a beaglebone running Ubuntu 12.04 LTS.
I followed clausq's tutorial. Note that he was using Debian as an operating system not ubuntu because at that time of his blog, ubuntu did not have PWM and otherperipheral support. This is no longer the case
and the peripherals can be
implemented as they would be in
angstrom.
Some key issues with installing that
differ from clausqr's blog are:

that you will need to implement a swap
file.
250 - 300Mb should be enough

you will have issues linking collada_urdf.cpp.
To solve this I installed libassim3
from its debian package as it is not
realised for 12.04 you cant use
apt-get directly.
Download
the .deb and unpack using the
command:
sudo dpkg -i
libassimp3_3.0~dfsg-1_armhf.deb
it will install this onto your
system.

additionally I also had to use a
patch suggested
here. It will not work directly as I
suspect that it was written for
Groovy. I ended up cutting and
pasting the code into my Collada_urdf.cpp
file so that the include statements
looked like this:
...
#include <assimp/IOSystem.h>

#  ifdef __arm__                 // fix for ARM build
#include <strings.h>
bool Assimp::IOSystem::ComparePaths(const char *p1, const char *p2) const
{
    return !::strcasecmp(p1, p2);
}
#  endif

#include <assimp/assimp.hpp>
#include <assimp/aiScene.h>
#include <assimp/aiPostProcess.h>
#include <assimp/IOStream.h>
...

and the make process completed.
2.Yes because it seems that it does make a difference in the
installation method. Additionally
you will need to consider the
Operating System on the Beaglebone
as that will change things too.
3.Unless I misunderstand your question, I would think yes that way
you have a direct link to your
hardware using a node that can use
the beaglebone IO and publish
immediately.
4.for install see 1. above.
5.Of course from a simple computation perspective it is slower
than a pc. However from an IO
perspective, the ubuntu kernel can
poll GPIO and read ADCs inherent in
the beaglebone much faster than if
it had to talk to a separate IO
board such as an IOIO or Arduino or
any other external controller via
RS232 or ethernet. It could
certainly be used as a cheap and fast
embedded controller that speaks on
ROS. Additionally it has the interfacing
potential of a pc without extra baggage such as video driving hardware. Typically with a pc you would require a separate IO/DAQ board.
6.To install I needed the full RAM plus the swap file got to about
260Mb. The core intallation and the
level 2 libraries have taken up
about 550Mb on the SD Card.

Originally posted by PeterMilani with karma: 1493 on 2013-03-24
This answer was ACCEPTED on the original site
Post score: 0


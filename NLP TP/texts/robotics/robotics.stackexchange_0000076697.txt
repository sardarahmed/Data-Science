Q:

Python smach userdata key not available

Hi, I am new to smach and I have some question about userdata in smach. This is my code:
def main():
rospy.init_node('smach_example_state_machine')

sm_top = smach.StateMachine(outcomes=['outcome4','outcome5'],
                          input_keys=['sm_input'],
                          output_keys=['sm_output'])
sm_top.userdata.sm_input=1
with sm_top:
 smach.StateMachine.add('FOO', Foo(),
                        transitions={'outcome1':'BAR',
                                     'outcome2':'outcome4'},
                        remapping={'foo_counter_in':'sm_input',
                                   'foo_counter_out':'sm_data'})
 print 'the number is:  '
 print sm_top.userdata.sm_input
 print 'the number is:  '
 print sm_top.userdata.sm_data

 time.sleep(5)
 smach.StateMachine.add('BAR', Bar(),
                        transitions={'outcome1':'FOO'},
                        remapping={'bar_counter_in':'sm_data',
                                   'bar_counter_out':'sm_output'})

# Execute SMACH plan
outcome = sm_top.execute()

When I tried to print sm_top.userdata.sm_data the program crashed and told me sm_data key is not available. However I can access this key in the state Boo. I understand this might have something to do with pointer.(I would like to know the detail too).
My question is: Is there anyway to access sm_top.userdata.sm_data in the main function?
Also, is there a way to remap the output of a state to the input of two other states(1 to N)?
Thanks!

Originally posted by orsonl on ROS Answers with karma: 54 on 2016-10-10
Post score: 0

Original comments
Comment by gvdhoorn on 2016-10-11:\

However I can access this key in the state Boo

Might not have had enough coffee, but I don't see a state Boo? Did you mean to write Foo?

A:

Userdata should only be accessed within states/containers which declare read (input key) or write (output key) access, although it is usually fine to initialize internal userdata keys on container construction.
Anyways, your example fails for the following reason: The key sm_data is only written by state Foo. Consequently, it only exists after the state returns with one of its outcomes (assuming the state declared foo_counter_out as output key). This won't happen before calling sm_top.execute(), which is after the print statement in your example. Before the very last line, you only construct the state machine, but do not execute it.
Yes, a userdata key can be passed to any amount of states. Consider it just as a variable to be updated during state machine execution.

Originally posted by Philipp Schillinger with karma: 321 on 2016-10-11
This answer was ACCEPTED on the original site
Post score: 0


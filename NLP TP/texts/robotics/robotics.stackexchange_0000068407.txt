Q:

CvBridge conversion problem: Asus Xtion depth image to OpenCV

Hi,
I have a Asus Xtion sensor being driven by the Openni2_launch package. I subscribe to the "/camera/depth/image" topic and attempt to convert the ImageConstPtr& data type to an OpenCV Mat in a callback function utilising the cv_bridge package. Visualising the "/camera/depth/image" ROS topic in RQT, I get a high quality depth image as expected:

However I can't seem to find an image type encoding (e.g. "8UC1") which OpenCV/cv_bridge accepts which results in an image similar to the one above. As an example, with the encoding "32FC1", this is the type of quality I get. I'm not entirely sure what I'm doing wrong!

And here's the source code
// Callback function for time-synchronised RGB and depth images
void sync_callback(const sensor_msgs::ImageConstPtr& rgb, const sensor_msgs::ImageConstPtr& depth)
{
    // Convert ROS images to OpenCV
    cv::Mat rgb_image;
    cv::Mat depth_image;

    try
    {
        rgb_image = cv_bridge::toCvShare(rgb, "mono8") -> image;
        depth_image = cv_bridge::toCvShare(depth, "32FC1") -> image;
    }
    catch (cv_bridge::Exception& e)
    {
        ROS_ERROR("Could not convert from ROS images to OpenCV type: %s", e.what());
    }

Thanks in advance!

Originally posted by WillAndrew on ROS Answers with karma: 20 on 2015-07-02
Post score: -1

A:

The output from openni2_camera is 32FC1, with measurements in meters. In the past I have converted to 32FC1, and then normalized in the range of ~0.5m to 5.5m. I haven't tried to compile my depth_viewer in a while, but it is probably a good starting spot.

Originally posted by fergs with karma: 13902 on 2015-07-04
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by WillAndrew on 2015-07-06:
Works really well, thanks!


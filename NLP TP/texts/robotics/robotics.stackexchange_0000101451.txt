Q:

Attaching an end-effector .stl or .xaml file with a .xacro Industrial Robot and loading on Gazebo via ROS

Hi there, I have build an end effector with the use of the Rhino, where the file can be saved as an .stl or as an .xaml. I would now like to attach the end effector to an Industrial Robot, particularly the ABB IRB-120 Robot, and load it onto Gazebo. I have also managed to install the robot itself via ROS and the arm_controllers file.
The next step would to load the robot with the end effector, where I am referencing to the following tutorial:
http://wiki.ros.org/Industrial/Tutorials/WorkingWithRosIndustrialRobotSupportPackages
However, I noticed that the end effector in this case is a .xacro file. Is it possible to load a .xacro robot and attach an end effector made using a .stl file or a .xaml file?
Thanks in advance,
Jacob

Originally posted by JCatania on ROS Answers with karma: 13 on 2022-04-01
Post score: 1

A:

Is it possible to load a .xacro robot and attach an end effector made using a .stl file or a .xaml file?

no, not directly. And .xaml files cannot be used at all I believe.
In a URDF (which a .xacro file in the end is turned in to), you define the kinematic structure of your robot + attach meshes to the link elements which are part of that structure. Those meshes can be .stls (or .dae, or anything supported by Assimp), but they can only be attached to link elements. You cannot just have a mesh element and attach it to the kinematic structure. That's not how URDF works (or: was designed to be used).
So in your case, where you have a .stl, you'd have to create a minimal .xacro which probably defines only a single link, the base_link (this name is arbitrary, you can use whatever you want, but base_link is a good ROS convention to follow). That base_link can then be used to attach your .stl to.
As an example:
<?xml version="1.0"?>
<robot xmlns:xacro="http://wiki.ros.org/xacro">
  <xacro:macro name="my_eef" params="prefix">

    <!-- this EEF model has only a single link: base_link, which is used
         to 'attach' the STL mesh to which fully represents the geometry
         of the real EEF.

         Note the use of both a visual (ie: detailed) quality mesh and
         a collision (ie: coarse) mesh. This is to facilitate tools like
         motion planners, which often use coarse models to speed up mesh
         to mesh collision checking.
    -->
    <link name="${prefix}base_link">
      <visual>
        <origin xyz="0 0 0" rpy="0 0 0"/>
        <geometry>
          <mesh filename="package://my_eef_pkg/meshes/visual/base_link.stl"/>
        </geometry>
        <material name="grey">
          <color rgba="0.2 0.2 0.2 1.0"/>
        </material>
      </visual>
      <collision>
        <origin xyz="0 0 0" rpy="0 0 0"/>
        <geometry>
          <mesh filename="package://my_eef_pkg/meshes/collision/base_link.stl"/>
        </geometry>
      </collision>
    </link>

    <!-- a default tool frame (might be better to broadcast a static TF frame
         for this instead, but this is just an example).

         Note: this follows conventions of industrial robotics, and rotates the
         frame such that Z+ points forward, X+ points up.
    -->
    <link name="${prefix}tool_frame" />
    <joint name="${prefix}base_link-tool_frame" type="fixed">
      <origin xyz="0 0 0" rpy="${pi} ${-pi/2.0} 0" />
      <parent link="${prefix}base_link" />
      <child link="${prefix}tool_frame" />
    </joint>
  </xacro:macro>
</robot>

Put your EEF .xacro in its own package, and now you can follow the tutorial(s) you already linked/found.
Note that this defines a xacro:macro. So you'd have to instantiate it. You cannot use it directly.

Originally posted by gvdhoorn with karma: 86574 on 2022-04-02
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by JCatania on 2022-04-02:
Yes. it worked well. Thanks!
However, what I did is that I used the same .stl file instead of two separate files. Note that I created the file via Rhino.
Comment by gvdhoorn on 2022-04-03:\

However, what I did is that I used the same .stl file instead of two separate files.

that will prevent consumers of your .xacro from optimising their algorithms when working with mesh data. MoveIt for instance will have to collision check with the fully detailed mesh, instead of with a coarser approximation.
Using a suitably downsampled version of your .stl could have a significant positive effect on performance.

Note that I created the file via Rhino.

I'm not sure I understand what this implies.
Meshes generated by modelling tools tend to be overly detailed.
How big is the .stl (as in: in bytes)?
Comment by JCatania on 2022-04-03:
The file is 2.9 kB. It must have both visual and collision meshes, as when I loaded the end effector on Gazebo, it loaded correctly.
Comment by gvdhoorn on 2022-04-03:\

It must have both visual and collision meshes, as when I loaded the end effector on Gazebo, it loaded correctly.

No, that's not how it works.
Your .stl file contains a single shape. If you don't specify a different file, your "high quality" model will just be used for both purposes.

The file is 2.9 kB.

Then it's likely OK to reuse the same file for both purposes.


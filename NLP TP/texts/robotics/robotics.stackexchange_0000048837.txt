Q:

octomap, velodyne and clustering

I would like to know if it would be possible to process velodyne data with an octomap.
I am not interested in building a huge map of the environment, i.e. for SLAM. But I need to know my surrounding for immediate planning and obstacle avoidance, let say about 70m around the robot. That means the octomap would be a rolling map in a way. I would need a resolution of about 10-20cm if possible and an update rate close to real time (i.e 10Hz).
In particular I am really interested in the ray tracing ability of the octomap.
Besides, I want to be able to retrieve the obstacles from the map, so that I can track them and classify them (cars, pedestrians, bicycles, etc). This would require some sort of clustering technique, i.e. connected component analysis...
Also, my planner requires a list of obstacles coordinates, so I was wondering if I could query the map to return me all the voxels (at a certain resolution) that are occupied. I saw that the search function was taking a x,y,z coordinates, does it mean that I'd have to do a triple loop search on a volume of voxels and test for occupancy? I feel there could be a better approach...
If velodyne data is too much data, I guess I can consider downsampling (spatially and temporally)... So I'd like to know what others people here have tried before I get started.

Originally posted by brice rebsamen on ROS Answers with karma: 1001 on 2013-02-28
Post score: 3

Original comments
Comment by joq on 2013-02-28:
I have never tried it, but this sounds like a good idea.
Comment by AHornung on 2013-03-03:
By the way, for general OctoMap questions (not specific to ROS), we also have a mailing list: https://groups.google.com/group/octomap

A:

You can check our new paper about OctoMap (PDF preprint) for a detailed analysis of the performance.
Looking at our outdoor dataset (50m maxrange), it will take about 1.7 seconds to insert 700000 points into the map at 20cm resolution. Most of this time will be spent in the raycasting operation. So I would strongy suggest downsampling the initial clouds, e.g. with a PCL voxel grid first. Something below the OctoMap resolution (5-10cm) should be fine so you don't lose too much detail.
To obtain all obstacles in the map, simply traverse it with a leaf iterator:
http://octomap.github.com/octomap/doc/classleaf__iterator.html#details
This is the most efficient way, much faster than looping over all possible coordinates.
For finding connected components, best work on OcTreeKeys directly. You might find some code in the class "OcTreeLUT" useful for neighbor finding, but we're not really using that code anymore (consider it experimental and untested).

Originally posted by AHornung with karma: 5904 on 2013-02-28
This answer was ACCEPTED on the original site
Post score: 5


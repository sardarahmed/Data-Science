Q:

Crash when calling init_node while holding GIL

I'm getting a crash when trying to invoke rospy from within an embedded Python interpreter.
Ubuntu 14.04LTS
Python 2.7.6
rosdistro: jade
rosversion: 1.11.16
The following C/C++ file duplicates the problem:
#include <Python.h>

int main(int argc, char* argv[])
{
    Py_InitializeEx(0);
    PyEval_InitThreads();

    static const char *argv0 = "test";
    PySys_SetArgv(1, (char **) &argv0);

    PyEval_ReleaseLock();

    PyGILState_STATE gstate;
    gstate = PyGILState_Ensure();

    PyRun_SimpleString("import rospy");
    printf ("import rospy - successful\n");

    PyRun_SimpleString("rospy.init_node('OpenCog_Eva')");
    PyGILState_Release(gstate);

    Py_Finalize();
    printf ("finished\n");
    return 0;
}

The crashes are of the form:
Fatal Python error: ceval: tstate mix-up
Aborted

or
Segmentation fault

or
Fatal Python error: PyEval_SaveThread: NULL tstate
Aborted

or
Fatal Python error: GC object already tracked
Aborted

These are all problems that come about when the GIL locking isn't quite right.
Any ideas how to fix this crash?

Originally posted by inflector on ROS Answers with karma: 13 on 2016-02-26
Post score: 1

A:

Found it!! Use PyEval_SaveThread() instead of PyEval_ReleaseLock().  Several websites clearly state that PyEval_ReleaseLock() is to be used, but it seems they're wrong.  The official python documentation has a cryptic warning that suggests that using  PyEval_SaveThread() is preferred.  And indeed, that fixes the bug!

Originally posted by linas with karma: 26 on 2016-02-26
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by inflector on 2016-02-27:
Interesting, I tried that in the sample and it still crashed.
I needed to do two additional things for the sample:

Put a rospy.spin() in somewhere before releasing the GIL.

Swap back in the main thread's state with PyThreadState_Swap(thread_state) before Py_Finalize().


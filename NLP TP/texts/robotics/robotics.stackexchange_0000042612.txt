Q:

Can I call ROS “ros::init(…)” within the player (Player/Stage) driver?

I am trying to write a Player driver that will publish messages on ROS.
Player driver does not create an executable file and hence I am not sure how to call ROS initialize within the player driver.
The main function of player driver looks like this...
void PlayerDriver::Main() 
{

int argc; // Player Main() method does not take argument 
char **argv; // What to do with argc and argv??

geometry_msgs::Point commandInput;
ros::init(argc, argv, "Command");

ros::NodeHandle n;
ros::Publisher command_pub = n.advertise<geometry_msgs::Point>("servocommand", 1000);
ros::Rate loop_rate(1);

while (ros::ok())
{

ros::spinOnce();   

ProcessMessages();

//Do some stuff
commandInput.x = globalVel.v;
commandInput.y = globalVel.w;
commandInput.z = 0.0;
command_pub.publish(commandInput);

//Do some stuff

loop_rate.sleep();
}

}

The Player driver compiles and creates a shared library and I have a cfg file. It is called by "player playerdriver.cfg" and works fine, gets connected to a Player Client but it does not publish messages on ROS.
As the Player Main() method does not take arguments, I believe this is where I am doing some mistake. Any suggestions are welcome.

Originally posted by sks on ROS Answers with karma: 36 on 2012-07-24
Post score: 1

Original comments
Comment by sks on 2012-07-24:
Thanks @allenh1 for the reply. I saw your example, Robot class. I think here the Player is a client. I am trying to create a Player server. Do you think I can create a class as you have suggested? I have had no problem integrating a player client with ROS publisher/subscriber.
Comment by allenh1 on 2012-07-24:
Hm. When you say player server, what exactly do you mean?
Comment by sks on 2012-07-24:
Player server (also known as Player Plugin). Please see following link
http://psurobotics.org/wiki/index.php?title=Writing_a_Player_Plugin
Comment by allenh1 on 2012-07-24:
Oh. I think I see what you're doing now. You're writing a Player, ROS driver to publish ros messages into player, right?
Comment by sks on 2012-07-24:
What I am trying to write is this "Simulated Robot with Player driver" which will allow a player client to subscribe with Position2d. The client can send Position2d msgs to simulated robot. Now, I want to put ROS Publisher in this "simulated player robot". Hope I was able explained my problem.

A:

There are several approaches to using a player driver in ROS:

Wrapping the player library in a ROS node (like erratic_player does).

Converting the driver to ROS manually.

The first probably gets the job done quicker, but is harder to maintain. With a little practice, the second is relatively straightforward. I've done quite a few. If you have follow-up questions, feel free to ask.
When converting a player driver to a ROS node, the class inherited from the
player Driver class is no longer needed and just adds unnecessary
complexity.
Make a simple C++ main program, something like this:
int main(int argc, char** argv)
{
  ros::init(argc, argv, NODE);
  ros::NodeHandle node;

  // topics to read and write
  brake_cmd = node.subscribe("cmd", 10, ProcessCommand,
                             ros::TransportHints().tcpNoDelay(true));
  brake_state = node.advertise<art_brake::State>("state", 10);

  if (GetParameters() != 0)             // from the player constructor
    return 1;

  ros::Rate cycle(20.0);                // set driver cycle rate

  if (Setup() != 0)                     // from the player Setup()
    return 2;

  // Main loop; grab messages off our queue and republish them via ROS
  while(ros::ok())
    {
      ...                               // activities from player Main()
      cycle.sleep();                    // sleep until next cycle
    }

  Shutdown();

  return 0;
}

Originally posted by joq with karma: 25443 on 2012-07-24
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by sks on 2012-07-24:
Ok, what I am trying to do is exactly same as erratic_player ...however, at a smaller scale, as I have no sensors, just Position2d interface. An easier method will help but I am also looking at erratic_player.cpp to find solution.
Comment by sks on 2012-07-24:
The robot driver is in ROS but the client controller is written using player for an old robot. I am just taking a short-cut by not writing the client controller again using ROS. Instead I am writing this "erratic_Player" type driver to use position2dmsgs from player client and publish for ROS robot.
Comment by joq on 2012-07-24:
Why not just convert the client controller to ROS? Do you need to maintain both versions?
Comment by sks on 2012-07-24:
I might have to spend a lot of time to convert client controller to ROS. Initially I was trying the same, but its a large code written by someone else in my lab. I thought writing a player driver will be an easier task. Is there a way to email you my driver? Can you look at my code?
Comment by sks on 2012-07-24:
From your example, what i am getting is I can create an object of PlayerDriver class inside a small ros publisher subscriber program and call its methods in a sequence that Player will follow? Am I correct?
Comment by joq on 2012-08-03:
I think so, but that class would not be derived from PlayerDriver.


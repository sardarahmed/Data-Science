Q:

Reading data from different topics, using the same callback

I have to read data from topics having same name but different namespaces. e.g. node0/battery, node1/battery etc.
so, my code is:
f  = open("./Nodelist.txt", "r")
nlist = f.read().splitlines()
for self.x in nlist:
     battery_lvl_listener = self.create_subscription(Float64,'' + str(self.x) + '/battery_lvl', self.battery_listener_callback,10)

def battery_listener_callback(self, msg):
        print("data read from: %s", self.x)

The problem is that self.x is always the same.

Originally posted by adry on ROS Answers with karma: 3 on 2020-07-29
Post score: 0

A:

self.x is always the same because it is set for each round of the for loop, then remains at the value of the final round of the for loop. It won't be updated after that, not even when the callback is called.
You can have multiple subscriptions using a single callback, so long as that callback is re-entrant (safe to be called multiple times in parallel). I don't think there is any way to know which particular topic the message came from, however. The assumption in the design of ROS 1 is that you use one callback per subscription, therefore you know implicitly which topic the data came from in a callback.
If you want to use "one" callback for many topics and know which topic sent the message, you can do it using a closure. Something like this should work:
import rclpy
from rclpy.node import Node

from std_msgs.msg import String

class MinimalSubscriber(Node):

    def __init__(self):
        super().__init__('minimal_subscriber')
        self.subs = []
        with open('nodelist.txt', 'r') as f:
            nlist = f.read().splitlines()
            for x in nlist:
                self.subs.append(self.create_subscription(String, x + '/battery_lvl', self.make_callback(x), 10))

    def make_callback(self, x):
        def callback(msg):
            self.get_logger().info('data read from: ' + x)
        return callback

def main(args=None):
    rclpy.init(args=args)

    minimal_subscriber = MinimalSubscriber()

    rclpy.spin(minimal_subscriber)

    # Destroy the node explicitly
    # (optional - otherwise it will be done automatically
    # when the garbage collector destroys the node object)
    minimal_subscriber.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()

However it is important to remember that this is technically three different callbacks at run time. If you actually need one method that is called no matter the topic then you will need to make a separate method and call it from the closure.

Originally posted by Geoff with karma: 4203 on 2020-07-29
This answer was ACCEPTED on the original site
Post score: 2


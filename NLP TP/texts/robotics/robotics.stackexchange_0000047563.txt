Q:

Why is some rosserial code distributed only in header files?

I was always taught that code should be strictly organized into header and source files, with the declaration in headers and actual implementation in cpp source files (or compiled into object libraries.)
I'm working with the rosserial_client package. A lot of the code (e.g. node_handle.h) is contained entirely in the header files, and the tutorials for the package even suggest writing new implementations entirely in header files.
I'm no C++ expert, so I'm not saying this is wrong :) I'm just trying to learn best practices, so I'd like to understand why so much code is organized this way. Is it just lazy/quick coding, or is there a method to the madness?

Originally posted by danep on ROS Answers with karma: 197 on 2013-01-23
Post score: 3

A:

I have not looked at the rosserial code, but there are a couple of reasons why developers sometimes put implementation code within header files.

If you put definitions exclusively in header files, the library becomes a "header-only library" meaning that you don't have to actually link against the library. A copy of the code is pulled into your source via the #include directive. This wastes more space as there's a copy of the function in every compilation unit (i.e. .cpp file), but usually is not a problem. For exaple, the popular sqlite database gives you the choice of using sqlite as a header file with library you link against or you can just include one giant amalgamated .h file. Boost does this often as well. Developers often like this because they can just throw the headers into their source tree and not have to add additional dependencies.

Though it's not guaranteed, compilers often inline function definitions in the header file. Depending on how often the functions are used and their size, often it makes more sense to keep them in the header.

Laziness - A lot of methods/functions, especially getters/setters are one-liners are it's convenient to just throw them into the .h file and leave the meaty code in the source file.

Templates - templates MUST be defined in header files due to the nature of how C++ instantiates templates

In general, you should try to keep as much code as possible in the cpp files so that only a single compiled version of your functions/methods/classes decreasing compile time and the size of your executable targets. If inlining is required,  modern C++ compilers perform very aggressive inlining and in most cases will automatically inline functions better than you can. Also, this prevents users from having to recompile everything that touches your library if the implementation changes without the interface changing -- only a relink is required.
I also personally like keeping implementations out of header files as in C/C++ they are useful for referencing the API. Putting the code in header files can sometimes make them hard to read.

Originally posted by mirzashah with karma: 1209 on 2013-01-23
This answer was ACCEPTED on the original site
Post score: 4

Original comments
Comment by danep on 2013-01-24:
Thanks for the very thorough and helpful answer!
Comment by fergs on 2014-02-14:
In this particular case, we're dealing with primarily with templates.


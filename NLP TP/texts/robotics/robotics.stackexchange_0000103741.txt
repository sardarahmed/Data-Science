Q:

Nav2, controllers, and Twist commands for ackermann robots

So far, I have been always dealing with Ackermann-based robots and I have had good success using the Nav2 stack (thank you to all the contributors to this awesome stack).
I have always been using the Twist command to drive the robot and my hardware controller interprets twist.angular.z as a steering angle. This is conceptually wrong since, I think, the right way to use a Twist command for an Ackermann based robot would be to derive a steering angle from the angular.z  instead of just using it as a steering angle directly.
The problem with this approach is that, especially for non-zero turn radius robots, commands with twist.angular.z != 0 & twist.linear.x = 0 are not achievable.
What is the right way to control Ackermann-based robots within the Nav2 stack, using the currently available controllers?

A:

The angular.z field is the body-fixed frame angular velocity, not the steering angle / velocity wrt how Nav2 treats the Twist message. That is no different or unique from any other type of robot platform. It sounds like you need to shim the cmd_vel topic to the input of your hardware controller to convert body-fixed frame (e.g. base_link) to your steering angle knowing your robot's kinematics.
That's more or less what any and all robots have to do in this case. Its just that differential / omnidirectional kinematics are more trivial. You need to convert the base_link motion into something your motors / motor controllers can understand (e.g. spin at this velocity with this angle).


Q:

Correct usage of socketcan_interface - hex2dec

I've recently started using the socketCAN_interface component of ros_canopen to get data from a Kuebler encoder.
My code is relatively straight forward, I receive messages on a particular CAN-ID using the following:
    can::CommInterface::FrameListener::Ptr one_frame = driver.createMsgListener(can::MsgHeader(0x101), handleFrame101);

Which calls the following method, writing data to a float which is a global variable:
void handleFrame101(const can::Frame &f){
        // handle specific frame
        std::string frame = can::tostring(f, true); //Break frame into string to extract data
        std::string data = frame.substr(frame.find("#")+1);
        //Check if data matches expected data length from frame, length/2 as dlc is hex (2 bytes per char)
        if( (data.length()/2) == int(f.dlc) ){
            uint64_t output;
            std::stringstream ss;
            ss << std::hex << data;
            ss >> output;
            extension = output;
        }else{
            extension = 0;
        }
    }

I'm wondering if there's a better way to do this, it seems ridiculous to decode the hex myself when there's an inbuilt function in socketcan_interface to do so. However, I was never able to get it to take f.data and compile successfully. Is it an internal only function? I'm not very familiar with C++ so the documentation wasn't clear.
I'm running ubuntu 14.04 and Indigo.

Originally posted by rmck on ROS Answers with karma: 147 on 2017-04-07
Post score: 0

A:

You can probably just use Frame::data directly rather that converting to a printable text string representation, it's an array of 8-bit bytes.  Find documentation for boost::array to find out how to get the data out. (e.g. I think boost::array::data() is just a pointer to the internal storage which is a C array, which can be statically recast to other data types such as uint64_t if you are sure it has at least 8 bytes.)     Or you can iterate over the data array and assemble your 64-bit number.

Originally posted by ReedHedges with karma: 821 on 2017-04-07
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Mathias LÃ¼dtke on 2017-04-08:
Exactly! Frame::data can be used like regular arrays, e.g. f.data[i]
boost:array is used to get proper bounds checking.
Comment by rmck on 2017-04-09:
So if I want to translate the hex array to a float or uint I should just iterate over it and recast it?


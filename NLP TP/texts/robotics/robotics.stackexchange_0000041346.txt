Q:

How to use initialpose orientation

i am still in the process of learning ros and i need some help. I have a task where i need to detect a obstacle(based on the obstacle color) from the pointcloud  and move the turtlebot around the obstacle (also based on the color). The obstacles is a cylinder of a fixed radius (0.3m).
To acomplish this i have made one node which process the color and one which handles the navigation. When i detect a obstacle in the point cloud i convert the closest point into the map frame using a transform listener (this works). Then i use MoveBaseClient to send goals to the turtlebot.
The problem here is that i need to know where is the front and the back of the obstacle (so the turtlebot doesnt spin around the same obstacle). My solution to this problem is to set the initialPose (in rviz) which has the orientation perpendicular to the obstacle. This way i can compute 3 points: one in front of the obstacle, one on the left or on the right of the obstacle and one behind the obstacle. The problem is that this doesnt work as i planed and the points are not properly computed.
The first problem is that the orientation i get is in form: x,y,z and only z is set. And also when i normalize the vector i lose the correct orientation (which is clearly seen below in the output). How can i construct a vector with the same direction as the orientation but of length of obstacle radius? The other thing is that the map itself has its own orientation.. do i have to consider that also? If someone could be so kind to help me understand what i am doing wrong. I have spent weeks on getting this to work.
The code for computing the points:
    // vector of the obstacles center (coordinates are in map frame)
    tf::Vector3 vec(ob->position.x, ob->position.y, 0);
    // vector of the initialPose orientation
    tf::Vector3 vec2(initialPose.orientation.x, initialPose.orientation.z, 0);
    // normalize the orientation vector
    vec2.normalize();
    tf::Vector3 res;
    // multiply the orientation vector with the obstacle radius
    vec2 = vec2 * (ob->radius);
    float angle,px,py; px = py = angle = 0;
    switch (pointIndex) {
       case 0: // point in front of the obstacle 
            // position + orientation
            res = vec - vec2;
          break;
        case 1: // point on the left/right of the obstacle
            if (ob->color == 2) {
                angle = 1.57079633f; // 90 degrees
             } else {
                angle = -1.57079633f; // - 90 degrees
             }
            // rotate the vector
            px = cos(angle) * vec2.getX() - sin(angle) * vec2.getY();
            py = sin(angle) * vec2.getX() + cos(angle) * vec2.getY();
            vec2.setX(px); vec2.setY(py);
            // position + orientation
            res = vec + vec2;
            break;
        case 2: // point behind the obstacle              
            // position + orientation
            res = vec + vec2;
            break;
    }
    // set the goal
    setGoal(res);  

Output of the code:
    [ INFO] [1339592203.148984056]: new obstacle detected at X,Y,Z =                 
    [-2.574487,2.275727,0.000000] with color 2

    [ INFO] [1339592212.150162291]: Got orientation: 0.000000 0.000000 -0.376139 i
    in frame /map

    [ INFO] [1339592213.148978752]: Computing position in front of the obstacle         
    for obstacle at x,y,z = [-2.574487,2.275727,0.000000] result vector x,y,z= 
    [-2.574487,2.575727,0.000000] orientation vector [0.000000,-0.300000,0.000000] 

    [ INFO] [1339592213.149018613]:  setting goal x,y,z: -2.574487 2.575727 0.000000

Originally posted by ZeroCool on ROS Answers with karma: 151 on 2012-06-13
Post score: 2

A:

// vector of the initialPose orientation
    tf::Vector3 vec2(initialPose.orientation.x, initialPose.orientation.z, 0);

Not quite sure why you are setting the vector as such. The initialPose published by RViz is in geometry_msgs/PoseWithCovarianceStamped format. The orientation is in quarternion, so you cannot just take the x and z values if you intend to use the roll and yaw angles. (unless you are doing something else, so I could be wrong)

Originally posted by weiin with karma: 2268 on 2012-06-13
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by ZeroCool on 2012-06-14:
While searching through the documentation i realized i've totally misunderstood the quaternions. Now i have to figure out how to create a vector facing in the direction of the orientation. Do you happen to know how to do that?
Comment by weiin on 2012-06-14:
still not exactly sure what you are trying to achieve.... for quaternion to vector3 conversion. google gives some thoughts: http://www.google.com.sg/#hl=en&gs_nf=1&cp=18&gs_id=jx&xhr=t&q=quaternion+to+vector3&pf=p&sclient=psy-ab&oq=quaternion+to+vect&aq=0&aqi=g3g-K1&aql=&gs_l=&pbx=1&bav=on.2,or.r_g
Comment by weiin on 2012-06-14:
and a related question: http://answers.ros.org/question/36517/how-to-construct-a-vector-from-quaternion/


Q:

what is the reasoning behind current architecture of navigation stack (move_base), the way it is?

i was looking at how move_base and navigation stack works. somethings seems weird to me. nav_core package has BaseGlobalPlanner and BaseLocalPlanner interfaces, which is like general programming practice. navfn is a package that implements BaseGlobalPlanner. BaseGlobalPlanner interface has two methods to overwrite initialize and make_plan. it seems that the task of initialize method is to pass the global costmap to the planner. now, i think this can be achieved by same mechanism as ros messages or service. and task of make_plan can be also served by a ros service.
sometimes standard ros mechanisms (messages and services) used, as for costmap and recovery behaviours. however, sometimes general programming techniques (interfaces) are used, as for BaseGlobalPlanner and BaseLocalPlanner. so the question is why there is this kind of double practice? i would like to know the reasoning here, so i can make better decisions, as i will be working with the navigation stack for my project...

Originally posted by harmish on ROS Answers with karma: 111 on 2011-09-26
Post score: 5

A:

The nav_core package contains the BaseGlobalPlanner and BaseLocalPlanner interfaces so that various planners can be loaded in place of one another without modifying move_base. ROS does this using pluginlib.
Pluginlib is one of the reasons that the initialize method is required. Since plugins are loaded dynamically, one cannot instantiate an instance of a particular plugin (navfn, for example). move_base uses pluginlib's classLoader to load an instance of whatever planner is desired. It then calls the initialize method to set up all configurations, services, publishers, subscribers, etc. The initialize method does more than just pass the copy of the costmap. If you were to only try to use messages, you would not be able to dynamically load the planner (because it'd have to be pre-loaded to be able to subscribe to the topic and, thus, would not be dynamically loaded).
By enforcing the BaseGlobalPlanner and BaseLocalPlanner interfaces, move_base can always be sure that it has both planners at all times. If the planners ran standalone, move_base would have more difficulty controlling their operation, ensure that they're running, and creating/destroying instances of planners.
These are just my opinions on the matter, I'm sure it's not a comprehensive list, but I hope it helps.

Originally posted by DimitriProsser with karma: 11163 on 2011-09-27
This answer was ACCEPTED on the original site
Post score: 6

Original comments
Comment by dornhege on 2011-12-16:
One more aspect is to avoid any overhead from calling services/passing message over the network very often. Especially when passing data structures like maps around.


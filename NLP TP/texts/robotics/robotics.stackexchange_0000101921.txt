Q:

Actual, physical Implementation of a robot system using Ros

Hello, I am a beginner to Ros and trying to conceptualize how a physical robot system would work with Ros. To give a concrete example,  say you have a setup like this:
Arduino with an imu and motors, which connects to a raspberry pi that does SLAM and object detection. The idea is that the raspberry pi ultimately controls the motors to make them move in the direction of the target.
Nodes and topics:

motor (subscribes to Nav/actuators/motor)
LiDAR (publishes to mapping/LiDAR)
Imu (publishes to Nav/sensors/ imu)

I have 2 questions.

how do the motors publish? motors and sensors are dumb, in the sense that you can’t upload a Python / cpp rcl script to their firmware/ software to make them nodes.
if the motors are on the Arduino, then do i need  to have micro Ros installed on the Arduino ? Or can the pi control the motors using i2c / SPI ? Using this method:

are the motors no longer part of the Ros graph?
Is there a way to do keep them in the Ros graph ?

I really appreciate anyone’s input, I have been struggling to conceptualize how to actually implement  a physical  Robot system using Ros. I’ve done myriad tutorials but I am still struggling to make the connection to the real world application.

Originally posted by r_gerson on ROS Answers with karma: 36 on 2022-06-09
Post score: 0

A:

Yes, you'd need to connect the motors to an Arduino. The motors don't publish anything. You'd need encoders (and read them). That can be used to calculate the speed of the wheels.

then do i need to have micro Ros installed on the Arduino ? Or can the pi control the motors using i2c / SPI ?

Simple answer, you could do either. Note that micro-ros requires a 32bit controller. Your default Arduino uno/mega are 8bit, so you'd need to go the i2c/spi way.

are the motors no longer part of the Ros graph?

If I understand your question correctly, motors are never part of the ROS graph. Motor controllers on the other hand, they can be, but aren't required.
Simple example:
I've got an Arduino connected to my raspberry using I2C. I'm using ros2_control to control my robot. In my hardware_interface I've written the part to send the desired speeds over I2C to the Arduino and receive the actual speed (from the encoders). My hardware_interface is part of the ROS graph. My Arduino (the motor controller) isn't.
If I were to use micro-ros, I could publish the desired speed on a topic and have the Arduino subscribe to it and control the motors that way. In that case the Arduino (motor controller) is visible in the ROS graph. The motors are never part of the graph though (in the same way that your lidar technically isn't part of the ROS graph. Your lidar driver, on the other hand, is.
I do not fully understand, however, why that matters. Maybe I'm missing something you want to do.
ETA:
No, the hardware interface is a plugin. Basically, ros2_control doesn't know how to access your motors.
I've had a project where we had the motors hooked up to a PLC and we send the motor commands to the PLC over an ethernet cable. I've also had a project where we used a good old fashioned CAN bus. It would literally be impossible for ros2_control to write code that could interface with every type of hardware (see where the name comes from?). They solved this by creating the hardware_interface plugin.
ros2_control assumes that the plugin has some functions (read() and write() are 2 of them). It then simply calls those functions. You need to write the hardware_interface yourself, and make sure those functions do what you want them to do (communicate with your motors). You could compare it to a subscriber. You create the subscriber and say what the callback function is. ROS will then call that function for you every time there's a message. You need to be the one to actually program that the function does what you want it to do.
BTW, the documentation for ros2_control

Originally posted by Joe28965 with karma: 1124 on 2022-06-09
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by r_gerson on 2022-06-09:
Thanks Joe! So your hardware interface is a topic, which reads and writes data to the arduino over i2c?


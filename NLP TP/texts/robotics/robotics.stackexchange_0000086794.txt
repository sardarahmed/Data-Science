Q:

Approximate time sync callback delay issue

I have a ros bag with 6 pairs of stereo image. I can subscribe to two (left & right) image topics using approximate time sync policy. The unusual thing I noticed is that the last image pair is some how not reaching the call back function. Here is the brief code
  message_filters::Subscriber<Image> image1_sub(nh, "/cam0/image_raw", 100);
  message_filters::Subscriber<Image> image2_sub(nh, "/cam0/image_raw", 100);

  typedef sync_policies::ApproximateTime<Image, Image,> MySyncPolicy;
  Synchronizer<MySyncPolicy> sync(MySyncPolicy(1000), image1_sub, image2_sub);
  sync.registerCallback(boost::bind(&callback, _1, _2,));

//callback is below
inline void callback(const ImageConstPtr& image1, const ImageConstPtr& image2){ 
  ROS_INFO("Sync_Callback");  // I'm simply counting the print out to see how many times the call bask gets a hit
}

I've tried it with image_transport::SubscriberFilter with exact outcome.
Another unusual thing: while the node is still alive I played a different bag file and the image pair from previous bag (the last one) pops out. It seems as if it is somehow waiting for another message to arrive. This is different than my understanding of how callbacks work. I'm stuck and would appreciate any help

Originally posted by avcx on ROS Answers with karma: 26 on 2018-04-27
Post score: 1

A:

I think the approximate time synchronizer is waiting until the next image on either topic arrives before it determines that the current pair should be published: http://wiki.ros.org/message_filters/ApproximateTime
Note the description of Inter message lower bound

Inter message lower bound: if messages
of a particular topic cannot be closer
together than a known interval,
providing this lower bound will not
change the output but will allow the
algorithm to conclude earlier that a
given set is optimal, reducing delays.
With the default value of 0, for
messages spaced on average by a
duration T, the algorithm can
introduce a delay of about T. With
good bounds provided a set can often
be published as soon as the last
message of the set is received. An
incorrect bound will result in
suboptimal sets being selected. A
typical bound is, say, 1/2 the frame
rate of a camera.

Originally posted by ahendrix with karma: 47576 on 2018-04-29
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by lucasw on 2023-05-27:
Something like this may work depending on expected update rates and expected slop between the messages to be synchronized (both in their header stamps and in the actual arrival times at the sync subscriber):
  approx_sync.setMaxIntervalDuration(ros::Duration(max_interval));

  const float lower_bound = max_interval * 2.0;
  sync.setInterMessageLowerBound(0, ros::Duration(lower_bound));
  sync.setInterMessageLowerBound(1, ros::Duration(lower_bound));


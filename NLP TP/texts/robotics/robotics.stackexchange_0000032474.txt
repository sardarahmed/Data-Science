Q:

using basic ros headers, linking error

I am trying to set up a custom-built ogre application that requires ogre 1.7.3, and the ogre built into ros does not contain the definitions needed. So I have customized the CMakeLists.txt file of a package I am creating, and when trying to use the listener and talker functionality as mentioned in the tutorials, I get a bunch of compiling errors like this one (all 'undefined references'):
 /opt/ros/diamondback/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:208: undefined reference to ros::NodeHandle::advertise(ros::AdvertiseOptions&)'

which corresponds to this line of code:
`ros::Publisher chatter_pub = n.advertise("chatter",1000);`

And Here is my cmake file (sorry, not allowed to attach it)
cmake_minimum_required(VERSION 2.4.6)
include($ENV{ROS_ROOT}/core/rosbuild/rosbuild.cmake)
rosbuild_init()
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)
rosbuild_genmsg()
rosbuild_gensrv()

set(PROJECT_NAME Sim1)
set(CMAKE_MODULE_PATH "/usr/local/lib/OGRE/cmake/") 

find_package(OIS REQUIRED)
find_package(OGRE REQUIRED)
include_directories(${OIS_INCLUDE_DIRS})
include_directories(${OGRE_INCLUDE_DIRS})
message(STATUS "ROS LIBS: ${ROS_LIBRARIES}")
if (OGRE_Terrain_FOUND)
  set(OGRE_LIBRARIES ${OGRE_LIBRARIES} ${OGRE_Terrain_LIBRARIES})
  message(STATUS "Found OGRE_Terrain: ${OGRE_Terrain_LIBRARIES}")
else (OGRE_Terrain_FOUND)
  message(SEND_ERROR "OgreTerrain Library not found.")
endif(OGRE_Terrain_FOUND)

set(LIBS ${LIBS} ${OIS_LIBRARIES} ${OGRE_LIBRARIES} ${OGRE_TERRAIN_LIBRARIES})
set(SRCS 
  ./src/BaseApplication.cpp
  ./src/sim1.cpp)

set(HDRS
  ./src/BaseApplication.h
  ./src/sim1.h)

file(MAKE_DIRECTORY ./bin)
file(MAKE_DIRECTORY ./media)

set(Boost_ADDITIONAL_VERSIONS "1.44" "1.44.0" "1.42" "1.42.0" "1.41.0" "1.41" "1.40.0" "1.40" 
"1.39.0" "1.39" "1.38.0" "1.38" "1.37.0" "1.37" )

set(OGRE_BOOST_COMPONENTS thread date_time)
find_package(Boost COMPONENTS ${OGRE_BOOST_COMPONENTS} QUIET)
include_directories(${Boost_INCLUDE_DIR})
add_definitions(-DBOOST_ALL_NO_LIB)
set(OGRE_LIBRARIES ${OGRE_LIBRARIES} ${Boost_LIBRARIES})
rosbuild_add_library(${PROJECT_NAME} ./src/sim1.cpp)
rosbuild_add_library(${PROJECT_NAME} ./src/BaseApplication.cpp)
target_link_libraries(${PROJECT_NAME} ${LIBS})
rosbuild_add_executable(${PROJECT_NAME} ${HDRS} ${SRCS}) 
Here is the specific compilation command of running rosmake verbosely
   /usr/bin/cmake -E cmake_link_script CMakeFiles/Sim1.dir/link.txt --verbose=1
    /usr/bin/c++   -O2 -g  -pthread -pthread -pthread CMakeFiles/Sim1.dir/src/sim1.o CMakeFiles/Sim1.dir/src/BaseApplication.o  -o bin/Sim1 -rdynamic -L/opt/ros/diamondback/stacks/ros_comm/clients/cpp/roscpp/lib -L/opt/ros/diamondback/stacks/ros_comm/clients/cpp/roscpp_serialization/lib -L/opt/ros/diamondback/stacks/ros_comm/utilities/xmlrpcpp/lib -L/opt/ros/diamondback/stacks/ros_comm/tools/rosconsole/lib -L/opt/ros/diamondback/stacks/ros_comm/utilities/rostime/lib -L/opt/ros/diamondback/stacks/ros_comm/utilities/cpp_common/lib -L/opt/ros/diamondback/ros/core/roslib/lib -L/opt/ros/diamondback/ros/tools/rospack/lib -lOIS /usr/local/lib/libOgreMain.so /usr/local/lib/libOgreTerrain.so -lboost_thread-mt ...continued(these next lines are all one line)
-Wl,-rpath,/opt/ros/diamondback/stacks/ros_comm/clients/cpp/roscpp/lib:
/opt/ros/diamondback/stacks/ros_comm/clients/cpp/roscpp_serialization/lib:
/opt/ros/diamondback/stacks/ros_comm/utilities/xmlrpcpp/lib:
/opt/ros/diamondback/stacks/ros_comm/tools/rosconsole/lib:
/opt/ros/diamondback/stacks/ros_comm/utilities/rostime/lib:
/opt/ros/diamondback/stacks/ros_comm/utilities/cpp_common/lib:
/opt/ros/diamondback/ros/core/roslib/lib:/opt/ros/diamondback/ros/tools/rospack/lib:
/usr/local/lib
Solved: I took the advice of starting from scratch and building my CMakeLists.txt starting with the ROS messaging services.  Here is my final CMakeLists.txt file if anyone has a similar problem

cmake_minimum_required(VERSION 2.4.6)
include($ENV{ROS_ROOT}/core/rosbuild/rosbuild.cmake)

rosbuild_init()

set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)

rosbuild_genmsg()
rosbuild_gensrv()

set(CMAKE_MODULE_PATH "/usr/local/lib/OGRE/cmake/") 
find_package(OIS REQUIRED)
find_package(OGRE REQUIRED)
include_directories(${OIS_INCLUDE_DIRS})
include_directories(${OGRE_INCLUDE_DIRS})
set(OGRE_LIBRARIES ${OGRE_LIBRARIES} ${OGRE_Terrain_LIBRARIES})
set(LIBS ${LIBS} ${OIS_LIBRARIES} ${OGRE_LIBRARIES} ${OGRE_TERRAIN_LIBRARIES})

set(Sim1Sources ./src/sim1.cpp ./src/BaseApplication.cpp)
set(Sim1Headers ./src/sim1.h ./src/BaseApplication.h)

rosbuild_add_executable(talker src/talker.cpp)
rosbuild_add_executable(listener src/listener.cpp)
rosbuild_add_executable(Sim1 ${Sim1Sources} ${Sim1Headers})
target_link_libraries(Sim1 ${LIBS})

Originally posted by eqzx on ROS Answers with karma: 13 on 2011-06-22
Post score: 1

Original comments
Comment by Asomerville on 2011-06-22:
Try formatting your Cmakefile using the code tag. That will make it much more readable.

A:

An undefined reference is almost always a missing library in the link step. Just shooting in the dark, I would guess you're missing a dependency on "roscpp" in your manifest.xml
running rosmake with:
VERBOSE=1 rosmake -v 

Will print the exact lines used to compile and link. You could then verify one way or another that the library was linked in. In some way or another, roslib is not being linked in.
Your CMakeLists.txt is way more complicated than it probably should be. Some of the default ros stuff is probably getting undone in one of your sets. Try simplifying.

Originally posted by Asomerville with karma: 2743 on 2011-06-22
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by eqzx on 2011-06-23:
thank you guys. i took your advice dornhege, finally compiles now.
Comment by dornhege on 2011-06-22:
I would agree with that suspicion. I think its best to approach from the other side: Create a package with standard ros tools and write a working listener/publisher - then add the OGRE stuff
Comment by Asomerville on 2011-06-22:
Your CmakeLists.txt is way more complicated than any I've created. I suspect you're borking the default ros stuff somewehere in there with one or more of your sets
Comment by eqzx on 2011-06-22:
I added that to the manifest as well, still didn't help. the compilation for the tutorial gives the impression that linking with ros is a few short lines...
Comment by Asomerville on 2011-06-22:
I see the directory, but not the lib itself. It looks like you're missing '-lroslib' at the very least.
Comment by eqzx on 2011-06-22:
okay. roscpp looks like it's in there...I updated the question with the output
Comment by Asomerville on 2011-06-22:
try with verbose to show compile commands
Comment by eqzx on 2011-06-22:
unfortunately, I tried that already


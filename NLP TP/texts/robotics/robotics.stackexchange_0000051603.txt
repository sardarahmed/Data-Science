Q:

confusing about simple ros c++ code

Hi,
I have a simple question about c++ pointer. This is the main.
int main(int argc, char** argv)
{
  ros::init(argc, argv, "joint_trajectory_action_node");
  ros::NodeHandle node;//("~");
  JointTrajectoryExecuter jte(node);

  ros::spin();

  return 0;
}

And this is part of the constructor of JointTrajectoryExecuter
public:
  JointTrajectoryExecuter(ros::NodeHandle &n) :
    node_(n),
    action_server_(node_, "joint_trajectory_action",
                   boost::bind(&JointTrajectoryExecuter::goalCB, this, _1),
                   boost::bind(&JointTrajectoryExecuter::cancelCB, this, _1),
                   false),
    has_active_goal_(false)

node_ is defined as ros::NodeHandle node_;
I don't understand "node_(n)".
Can anyone give me any hint?
Thanks!

Originally posted by AdrianPeng on ROS Answers with karma: 441 on 2013-05-31
Post score: 0

Original comments
Comment by mortonjt on 2013-05-31:
I think you may be referring to a initialization list

A:

If you look at the ros::NodeHandle documentation, you can find a copy constructor that matches that signature:
ros::NodeHandle::NodeHandle(const NodeHandle &rhs)

Essentially, this creates a new NodeHandle instance that inherits a copy of all the parameters from the original NodeHandle.  In the JointTrajectoryExecuter class you reference, this creates a local NodeHandle variable within the class that is a a copy of the NodeHandle created when the node is first initialized.  The class can then use this local copy for handling actions, messages, etc.
In general, this isn't necessary, as all NodeHandle objects in a given node point to the same underlying object.  But this version does allow the new NodeHandle to inherit the namespace of the original NodeHandle, if one was specified.

Originally posted by Jeremy Zoss with karma: 4976 on 2013-05-31
This answer was ACCEPTED on the original site
Post score: 2


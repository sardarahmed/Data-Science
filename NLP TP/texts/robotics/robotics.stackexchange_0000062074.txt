Q:

access message filters cache data in python

Hi all
I am suing message filters cache in my little python code but I couldn't figure out to access the cache data. It seems the python version has not function  cache.getInterval(start, end).
in tutorial there is only   c++ example seems to have the function but the python version  doesn't.
Could anyone please tell me how can I possibly access the cache data.
Here is the is my code

class EegListener(object):

 def __init__(self):

     rospy.init_node('eeg_listener')
     self.eeg_subscriber = message_filters.Subscriber("/eeg_signal_packet", EegPacket)
             # the topick contains Header type and float64[] type
     self.eeg_cache = message_filters.Cache(self.eeg_subscriber, 1280)
              
 def callback(self,eeg_msg):                 
             print eeg_msg.header 
 def listener(self):
     self.eeg_cache.registerCallback(self.callback)
             #  self.eeg_cache.getInterval(rospy.get_rostime(),rospy.get_rostime()) does not exists !?
         rospy.spin()

Originally posted by raminzohouri on ROS Answers with karma: 26 on 2014-08-23
Post score: 1

A:

Yes, this appears to be broken.
The current version of the Cache synchronizer has a TODO instead of actually maintaining a cache: message_filters/__init__.py
You should probably file this as a bug against ros_comm: https://github.com/ros/ros_comm/issues

Originally posted by ahendrix with karma: 47576 on 2014-08-23
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by raminzohouri on 2014-08-24:
Hey Austin
Thank you very much for your reply. I will report the issue for sure. At the mean time I have implemented the C++ version of the message filters cache. it looks find except that I have some packet lost in between.
I am publishing a message with header and there I have 128Hz frequency but when I am reading cache with :

start_time = ros::Time::now();
cache.getInterval(start_time - ros::Duration(1), start_time).size()

The vector has size of 107-115.  When I only subscribe and print it also seems fine. Are there any packet lost of I just need to increase the duration to get full cycle that i publish ?
Comment by ahendrix on 2014-08-24:
ROS is designed to drop packets when a topic is saturated, so it's quite possible that it's losing a few. The only way to really know is to analyze the message sequence numbers to see if any messages are missing.
Comment by raminzohouri on 2014-08-24:
I did so and it keep losing around 20 packets that are important for me.. actually  I am trying to make emokit signals in available in ros... I can publish the message but the points is each message contains one packet and the sampling frequency for the device is 128Hz. Publisher does not lose any packet, also the subscriber.
But i need to queue 10 second of these packets and lose a service ros service to access the desired interval. Do you have any suggestion about how to do this ?
Boost::circularBuffer is the thing i am trying to use for queuing messages at moment .
Comment by ahendrix on 2014-08-24:
You may want to try increasing the publisher and subscriber queue sizes to see if that helps prevent dropping messages.
Comment by raminzohouri on 2014-08-24:
Thanks for the reply I did so and now I am publishing the packets getting them from cache ....
the code is looks like this now  and I am using a service to read from the new topic...
I hope this code is optimal ?
`
message_filters::Cache<bci_eeg_msgs::EegPacket>
eeg_packet_cache;
bci_eeg_msgs::EegPacketBuffer
eeg_packet_buffer; ros::Publisher
eeg_packet_buffer_pub ;

void some_function (const
bci_eeg_msgs::EegPacket::ConstPtr
&msg) {
    eeg_packet_cache.add(msg);

    std::vector<bci_eeg_msgs::EegPacket::ConstPtr>
eeg_cache_vector =
           eeg_packet_cache.getInterval(eeg_packet_cache.getOldestTime(),
eeg_packet_cache.getLatestTime());
       for(uint i = 0; i < eeg_cache_vector.size(); ++i){   
eeg_packet_buffer.data.push_back(*eeg_cache_vector[i]);
}   
eeg_packet_buffer_pub.publish(eeg_packet_buffer);
     }

int main(int argc, char **argv) {  
ros::init(argc, argv,
"caching_example");  
ros::NodeHandle nh;  
eeg_packet_cache.setCacheSize(128*5);
ros::Subscriber sub =
nh.subscribe("/eeg_signal_packet",
256 , some_function);  
eeg_packet_buffer_pub = 
      nh.advertise<bci_eeg_msgs::EegPacketBuffer>("/eeg_packet_buffer",1);
ros::spin();   return 0; }`

Comment by gvdhoorn on 2014-08-24:
@raminzohouri: I think it would be better if you update your original question. The comment area is just that: for short comments. Seeing as your original question was answered by @ahendrix though, you might want to create a new one (for your problem with msg loss).


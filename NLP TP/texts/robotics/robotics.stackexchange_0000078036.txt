Q:

How does rospy.Timer behave if it triggers while the previous callback is still busy?

I'm using a rospy.Timer (periodic, not one-shot) to handle a long-running process in a non-blocking way. I only want one instance of the process to be running at any one time. Therefore, I thought I would have to implement some sort of lock in order to prevent subsequent Timer callbacks from triggering new instances of the process.
However, it seems like I didn't have to! Subsequent callbacks are not called if the previous one is still working. Or are they added to a queue like subscriber callbacks? Either is a good thing in my use case, but where can I find out more about it? It's not mentioned in http://wiki.ros.org/rospy/Overview/Time#Timer from what I can tell.

Originally posted by spmaniato on ROS Answers with karma: 1788 on 2016-12-26
Post score: 3

A:

You could have a look at the code:
timer.py
The callback is directly executed (no thread) so if your function takes longer than your rate, it will be called as fast as possible (independent of your specified rate).

Originally posted by NEngelhard with karma: 3519 on 2016-12-26
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by spmaniato on 2016-12-26:
Thanks for the link! According to the source code, it looks like the callback should be getting called regardless of whether the previous one has returned. That's not what I observed though. Hmm. I'll take another look.
Comment by NEngelhard on 2016-12-26:
Why do you think so? The callback is called in line 223 in the main loop. So the execution waits there until your function finished.
Comment by spmaniato on 2016-12-26:
Oh, now I get it! The entire Timer / thread is getting blocked by the call to the long-running callback. Thanks again @NEngelhard :-)


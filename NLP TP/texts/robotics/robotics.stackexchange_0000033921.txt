Q:

Executing rosjava programs

Leaving android aside for the moment, what's the recommended way of executing a rosjava program buried in a main() in one of your classes?
Am asking because of the complexity of the CLASSPATH. This seems to be handled in the compilation, but I'm not sure how to bring it in when trying to run something.

Originally posted by Daniel Stonier on ROS Answers with karma: 3170 on 2011-08-26
Post score: 0

Original comments
Comment by Daniel Stonier on 2011-08-27:
Just noticed rosjava_bootstrap's run.py which will bootstrap the classpath for a NodeMain type class. Is there a way to do this for a generic class with a generic main?

A:

If you are implementing your own main(), I recommend looking at the rosjava_bootstrap run.py script and adapting it to your own needs.  The main thing of note is the Python routines for constructing the classpath.
Also of note is the RosRun.java, which shows the basic bootstrapping steps that you'll need for constructing a context.
All of this will get better over time -- we are evolving the toolchain to try and find the sweet spot of compatibility with the many different and varied frameworks that Java provides (e.g. Eclipse, ant, Maven, OSGI, Android, etc...).

Originally posted by kwc with karma: 12244 on 2011-08-27
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by kwc on 2011-08-28:
There is someone who is working on support for osgi containers and done several different deployment scenarios with it.  You should see the basic hooks in place for that, though it's not well documented.
Comment by Daniel Stonier on 2011-08-27:
Ended up doing exactly that (re-implementing my own run.py). Also found I could add ros.runtime.classpath from ros.properties directly into an osgi xxx.bnd file which gives it rpath like tracking across jars. That will do for now. So many frameworks :)


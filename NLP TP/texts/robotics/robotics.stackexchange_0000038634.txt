Q:

Filtering (more than once) a Pointcloud

Hello all, I've been trying to use the point cloud generated by a Kinect camera to fill an occupancy grid. To do so, I have used a passthrough filter (following the information provided in this answer), and the filter is working as expected using an adaptation of this code.
The thing is, in that sample of code both the input and the output cloud are of the same data type (pointcloud::ptr), so if I wanted to filter the same cloud more than once (on two different axis, for instance), there shouldn't be a problem. But when I try to do it with the output I'm getting from the camera, the compiler says I need a const pointer for the input, and a pointcloud for the output of the filter.
Things I've tried:

Using Pointcloud2Ptr as the data type (instead of just pointcloud2). The code compiles just fine, but the execution fails with an unhelpful error ("Assertion failed"). It appears to be a problem with how I've used the contructor, but since 2 out of 3 links for pointcloud2 404'd when I was looking for information, I'm not entirely sure what is the correct way to initialize the pointcloud pointers.

Various combinations of referencing/dereferencing both the pointclouds and the pointers. None of them seemed to be correct.

Converting the input cloud from pointcloud2 to pointcloud and using the same code linked above. This does in fact return the same error, assertion failed.

So, my question is: am I facing this problem correctly? Is there a way to use the same pointcloud as both the input and the output cloud of a passthrough filter?
I hope I didn't miss any important information.
Thanks in advance.

Originally posted by JoaquinV on ROS Answers with karma: 5 on 2012-03-12
Post score: 0

A:

In general, PCL filters are not meant to be used in-place; if that works, all that's happened is that you've gotten lucky.
And .makeShared() does, in fact, make a copy. In general, the way to use PCL is to do everything as a pointer explicitly; the correct construction is then
pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZRGB>());
which gets you a smart pointer for passing around (a boost::shared_ptr, behind the scenes).
I strongly recommend a typedef or three to make that less painful to type...

Originally posted by Mac with karma: 4119 on 2012-03-12
This answer was ACCEPTED on the original site
Post score: 4


Q:

Normal calculation and comparation of points, how to perform this?

I have a problem do you know how to estimate a normal for a single point using the function:
computePointNormal (const pcl::PointCloud &cloud, const std::vector &indices, Eigen::Vector4f &plane_parameters, float &curvature);
How can I fill the indices?
After the normal calculation how can I compare two normals of different points and check if their pointing directions?

Originally posted by Nxzx on ROS Answers with karma: 9 on 2016-01-15
Post score: 0

A:

This is more like a PCL question. Though I can give some insight.
As it is told in pcl tutorial Normal Estimation,

To compute a single point normal, use:
computePointNormal (const pcl::PointCloud<PointInT> &cloud, const std::vector<int> &indices, Eigen::Vector4f &plane_parameters, float &curvature);

Where cloud is the input point cloud
that contains the points, indices
represents the set of k-nearest
neighbors from cloud, and
plane_parameters and curvature
represent the output of the normal
estimation, with plane_parameters
holding the normal (nx, ny, nz) on the
first 3 coordinates, and the fourth
coordinate is D = nc . p_plane
(centroid here) + p.

To be able to estimate a normal for a single point you need to use neighbouring points to estimate a surface. Without those you can not have a normal for a point. For those neighbouring points you should use a method like kNN. In PCL we have kNN implementation with KdTree Class.
Depending on your application you can use KdTree to gather k-nearest neighbour points to your target point for normal estimation. Then, you should supply indices of those points to computePointNormal method. For usage of KdTree, you can check this tutorial.
Hope this helps. For further questions you can visit pcl-users.org.
Update
About your code in your answer,
computePointNormal waits const pcl::PointCloud<PointInT> &cloud as first argument, but you are passing point cloud pointer. Possibly it will be fine if you change it to this (Note the * );
computePointNormal(*filteredCloud1,pointIdxRadiusSearch,plane_parameters,curvature);

Originally posted by Akif with karma: 3561 on 2016-01-16
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by Nxzx on 2016-01-21:
Thank you! It is working now!
Comment by Akif on 2016-01-21:
Glad you made it! Then you can mark this answer as accepted so that future users will use the same solution with you.
Comment by thompson104 on 2018-08-08:
Sir, do you mind taking a look at this post? Thank you.
https://answers.ros.org/question/300085/camera-recommendation-used-for-depth-measurement/


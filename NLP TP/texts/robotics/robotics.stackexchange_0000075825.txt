Q:

Last node handle goes out of scope but callbacks still work. Why?

I thought I need to keep my node handle alive by storing it in my class member, but when I make it a local variable in my constructor and let it go out of scope, my callback still gets called.
Is this proper defined behavior?
#include <ros/ros.h>
#include <std_msgs/Int32.h>

class MyNode
{

public:

    MyNode()
    {
        ros::NodeHandle nh; // will go out of scope
        subscriber = nh.subscribe("topic_name", 10, &MyNode::callback, this);
    }

private:

    void callback(std_msgs::Int32ConstPtr const & msg)
    {
        ROS_ERROR_STREAM("Callback got called");
    }

    // I thought this was mandatory
    // ros::NodeHandle nh;

    ros::Subscriber subscriber;

};

int main(int argc, char ** argv)
{
    ros::init(argc, argv, "my_node");
    MyNode node;
    ros::spin();
    return 0;
}

UPDATE:
Here it says "when the last ros::NodeHandle is destroyed, it will call ros::shutdown()". Further down it is suggested, that ros::shutdown() will make ros::spin() return. So what's up with that?

Originally posted by Dimitri Schachmann on ROS Answers with karma: 789 on 2016-08-17
Post score: 1

A:

If you look at https://github.com/ros/ros_comm/blob/kinetic-devel/clients/roscpp/src/libros/subscriber.cpp#L66, the Subscriber keeps a copy/reference to the node handle. So as long as it exists, there is yet another referenced handle that will prevent the node to shut down.

Originally posted by dseifert with karma: 106 on 2016-08-18
This answer was ACCEPTED on the original site
Post score: 3


Q:

Build errors in eclipse

Using Ubuntu Precise 64 bit.
Successfully installed ROS Fuerte and did Beginner Tutorials.
Installed Java JRE 6
Installed Eclipse for C++ Developers (Juno)
Performed all instructions at http://www.ros.org/wiki/IDEs up to, but not including:
5. Running and debugging your executables within Eclipse
I had selected the Beginners_tutorials package (directory) as my project.
I selected talker.cpp in the Eclipse IDE to see the code and build it.
I got the following errors:
    Description Resource    Path    Location    Type
    Method 'sleep' could not be resolved    talker.cpp  /beginner_tutorials/src line 148    Semantic Error
    Field 'data' could not be resolved  talker.cpp  /beginner_tutorials/src line 122    Semantic Error
    Function 'ROS_INFO' could not be resolved   talker.cpp  /beginner_tutorials/src line 124    Semantic Error
    Function 'ok' could not be resolved talker.cpp  /beginner_tutorials/src line 109    Semantic Error
    Type 'std_msgs::String' could not be resolved   talker.cpp  /beginner_tutorials/src line 118    Semantic Error
    Method 'publish' could not be resolved  talker.cpp  /beginner_tutorials/src line 133    Semantic Error
    Function 'spinOnce' could not be resolved   talker.cpp  /beginner_tutorials/src line 142    Semantic Error
    Field 'data' could not be resolved  talker.cpp  /beginner_tutorials/src line 124    Semantic Error
    Method 'c_str' could not be resolved    talker.cpp  /beginner_tutorials/src line 124    Semantic Error
    Field 'advertise' could not be resolved talker.cpp  /beginner_tutorials/src line 80 Semantic Error
    Type 'ros::Publisher' could not be resolved talker.cpp  /beginner_tutorials/src line 80 Semantic Error
    Type 'ros::Rate' could not be resolved  talker.cpp  /beginner_tutorials/src line 89 Semantic Error
    Symbol 'String' could not be resolved   talker.cpp  /beginner_tutorials/src line 80 Semantic Error
    make: *** No rule to make target `/cmake.mk'.  Stop.    beginner_tutorials          C/C++ Problem
    Type 'ros::NodeHandle' could not be resolved    talker.cpp  /beginner_tutorials/src line 49 Semantic Error
    Function 'init' could not be resolved   talker.cpp  /beginner_tutorials/src line 39 Semantic Error
make: /cmake.mk: No such file or directory  Makefile    /beginner_tutorials line 1  C/C++ Problem

In the IDE I have 2 include directives at the top of the talker.cpp file that give the following message:
Unresolved inclusion: "ros/ros.h"
Unresolved inclusion: "std_msgs/String.h"

Here is the talker.cpp file:
#include "ros/ros.h"
#include "std_msgs/String.h"
#include <sstream>

/** include description
 *
 * ros/ros.h includes all headers necessary for most common public pieces of the ROS system
 * std_msgs/String.h includes the std_msgs/String message, which resides in the std_msgs package.
 * This is a header generated automatically from the String.msg file in that package. For more
 * information on message definitions, see the msg page.
 */
 
/** File flow description
 * This tutorial demonstrates simple sending of messages over the ROS system.
 * This is a Publisher Node
 * Here's the condensed version of what's going on:
 *
 * 1- Initialize the ROS system
 * 2- Advertise that we are going to be publishing std_msgs/String messages 
 *    on the chatter topic to the master
 * 3- Loop while publishing messages to chatter 10 times a second
 */
int main(int argc, char **argv)
{
  /** ros::init() function description
   * The ros::init() function needs to see argc and argv so that it can perform
   * any ROS arguments and name remapping that were provided at the command line. For programmatic
   * remappings you can use a different version of init() which takes remappings
   * directly, but for most command-line programs, passing argc and argv is the easiest
   * way to do it.  The third argument to init() is the name of the node.
   *
   * You must call one of the versions of ros::init() before using any other
   * part of the ROS system.
   * Initialize ROS. This allows ROS to do name remapping through the command line -- not important
   * for now. This is also where we specify the name of our node. Node names must be unique in a 
   * running system.
   * The name used here must be a base name, ie. it cannot have a / in it.
   */
  ros::init(argc, argv, "talker");  //name of node
   
  /** ros::NodeHandle description
   * NodeHandle is the main access point to communications with the ROS system.
   * The first NodeHandle constructed will fully initialize this node, and the last
   * NodeHandle destructed will close down the node.
   * Create a handle to this process' node. The first NodeHandle created will actually 
   * do the initialization of the node, and the last one destructed will cleanup any 
   * resources the node was using.
   */
  ros::NodeHandle n;
   
  /** advertise() function description
   * The advertise() function is how you tell ROS that you want to
   * publish on a given topic name. This invokes a call to the ROS
   * master node, which keeps a registry of who is publishing and who
   * is subscribing. After this advertise() call is made, the master
   * node will notify anyone who is trying to subscribe to this topic name,
   * and they will in turn negotiate a peer-to-peer connection with this
   * node.  advertise() returns a Publisher object which allows you to
   * publish messages on that topic through a call to publish().  Once
   * all copies of the returned Publisher object are destroyed, the topic
   * will be automatically unadvertised.
   *
   * The second parameter to advertise() is the size of the message queue
   * used for publishing messages.  If messages are published more quickly
   * than we can send them, the number here specifies how many messages to
   * buffer up before throwing some away.
   *
   * Tell the master that we are going to be publishing a message of type 
   * std_msgs/String on the topic chatter. This lets the master tell any 
   * nodes listening on chatter that we are going to publish data on that 
   * topic. The second argument is the size of our publishing queue. In 
   * this case if we are publishing too quickly it will buffer up a maximum 
   * of 1000 messages before beginning to throw away old ones.
   *
   * NodeHandle::advertise() returns a ros::Publisher object, which serves
   * two purposes: 1) it contains a publish() method that lets you publish
   * messages onto the topic it was created with, and 2) when it goes out 
   * of scope, it will automatically unadvertise.
   */
  ros::Publisher chatter_pub = n.advertise<std_msgs::String>("chatter", 1000);
   
  /** ros::Rate description
   * A ros::Rate object allows you to specify a frequency that you would 
   * like to loop at. It will keep track of how long it has been since the 
   * last call to Rate::sleep(), and sleep for the correct amount of time.
   *
   * In this case we tell it we want to run at 10hz.
   */
  ros::Rate loop_rate(10);
   
  /** count variable description
   * A count of how many messages we have sent. This is used to create
   * a unique string for each message.
   */
  int count = 0;

  /** ros::ok() description
   * By default roscpp will install a SIGINT handler which provides Ctrl-C 
   * handling which will cause ros::ok() to return false if that happens.
   *
   * ros::ok() will return false if:
   *
   * --a SIGINT is received (Ctrl-C)
   * --we have been kicked off the network by another node with the same name
   * --ros::shutdown() has been called by another part of the application.
   *
   * Once ros::ok() returns false, all ROS calls will fail.
   */
  while (ros::ok())
  {
    /** String msg description
     * This is a message object. You stuff it with data, and then publish it.
     * We broadcast a message on ROS using a message-adapted class, 
     * generally generated from a msg file. More complicated datatypes are 
     * possible, but for now we're going to use the standard String message, 
     * which has one member: "data".
     */
    std_msgs::String msg;
   
    std::stringstream ss;
    ss << "hello world " << count;
    msg.data = ss.str();
   
    ROS_INFO("%s", msg.data.c_str());
   
    /** publish() description
     * The publish() function is how you send messages. The parameter
     * is the message object. The type of this object must agree with the type
     * given as a template parameter to the advertise<>() call, as was done
     * in the constructor above.
     * Now we actually broadcast the message to anyone who is connected.
     */
    chatter_pub.publish(msg);
  
    /** ros::spinOnce() description
     * Calling ros::spinOnce() here is not necessary for this simple 
     * program, because we are not receiving any callbacks. However, if you
     * were to add a subscription into this application, and did not have
     * ros::spinOnce() here, your callbacks would never get called. So, add
     * it for good measure.
     */
    ros::spinOnce();
  
    /** ros::Rate description
     * Now we use the ros::Rate object to sleep for the time remaining to 
     * let us hit our 10hz publish rate.          
     */
    loop_rate.sleep(); 
    ++count;
  }

Please advise on how to correct this.

Originally posted by TurtleBot_Fan on ROS Answers with karma: 287 on 2012-09-29
Post score: 1

A:

So i assume that you started Eclipse from an Icon/GUI and not from the terminal. The Problem here is that the environment Variables of the .bashrc are not in use. Therefore you need to execute also Steep 5 or just start Eclipse from a Terminal instead. If you start it from terminal the environment Variables are in use and the packages can be found (of course assuming that your ROS_PACKAGE_PATH contains them, can be checked by roscd + A_PACKAGE or "echo $ROS_PACKAGE_PATH")

Originally posted by tlinder with karma: 663 on 2012-09-30
This answer was ACCEPTED on the original site
Post score: 2


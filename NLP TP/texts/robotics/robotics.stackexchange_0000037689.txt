Q:

Gazebo service through c++ code

I have created a server and client about set model state service of gazebo. This is the error I get when I run make:
/home/phadjic/ros_workspace/pool_party/src/client.cpp: In function ‘int main(int, char*)’: /home/phadjic/ros_workspace/pool_party/src/client.cpp:36:39: error: no match for ‘operator=’ in ‘setmodelstate.gazebo_msgs::SetModelState::request.gazebo_msgs::SetModelStateRequest_std::allocator<void >::model_state = modelstate’ /opt/ros/electric/stacks/simulator_gazebo/gazebo_msgs/msg_gen/cpp/include/gazebo_msgs/ModelState.h:23:20: note: candidate is: gazebo_msgs::ModelState_std::allocator<void >& gazebo_msgs::ModelState_std::allocator<void >::operator=(const gazebo_msgs::ModelState_std::allocator<void >&) /home/phadjic/ros_workspace/pool_party/src/client.cpp:39:22: error: ‘SetModelState’ was not declared in this scope /home/phadjic/ros_workspace/pool_party/src/client.cpp:42:8: error: no matching function for call to ‘print(int, log4cxx::Logger&, ros::console::Level&, const char [54], int, const char [22], double&)’ /opt/ros/electric/stacks/ros_comm/tools/rosconsole/include/ros/console.h:132:22: note: candidates are: void ros::console::print(ros::console::FilterBase, log4cxx::Logger, ros::console::Level, const char, int, const char, const char, ...) /opt/ros/electric/stacks/ros_comm/tools/rosconsole/include/ros/console.h:136:22: note: void ros::console::print(ros::console::FilterBase, log4cxx::Logger, ros::console::Level, const std::stringstream&, const char, int, const char*)
The lines of my client file mentioned above are:
ros::ServiceClient client = n.serviceClient<gazebo_msgs::setmodelstate("/gazebo_msgs/SetModelState"); 
gazebo_msgs::SetModelState setmodelstate;
setmodelstate.request.model_state=modelstate;
client.call(setmodelstate); 

if (client.call(setModelState))
{
   ROS_INFO("BRILLIANT!!!");
   ROS_INFO(start_pose.position.x);
}
else
{
   ROS_ERROR("Failed to call service ");
   return 1;
}

Originally posted by Penny on ROS Answers with karma: 41 on 2012-02-08
Post score: 0

Original comments
Comment by Abdulbaki on 2017-12-30:
Correction for the first line;
ros::ServiceClient client = n.serviceClient<gazebo_msgs::setmodelstate>("/gazebo_msgs/SetModelState");

A:

Here is a complete set of instructions to get things working,
Open a new terminal, start gazebo empty world, spawn an object:
source /opt/ros/electric/setup.bash
roslaunch gazebo_worlds empty_world.launch

Open yet another terminal, spawn a model:
source /opt/ros/electric/setup.bash
rosrun gazebo spawn_model -urdf -file `rospack find gazebo_worlds`/objects/14_4v_cordless_drill.urdf -model drill -z 1

Open a third terminal, setup ros and create a package named gazebo_test:
cd /tmp
source /opt/ros/electric/setup.bash
roscreate-pkg gazebo_test gazebo gazebo_msgs
cd gazebo_test
export ROS_PACKAGE_PATH=`pwd`:${ROS_PACKAGE_PATH}

edit CMakeLists.txt so it looks like this:
cmake_minimum_required(VERSION 2.4.6)
include($ENV{ROS_ROOT}/core/rosbuild/rosbuild.cmake)

# Set the build type.  Options are:
#  Coverage       : w/ debug symbols, w/o optimization, w/ code-coverage
#  Debug          : w/ debug symbols, w/o optimization
#  Release        : w/o debug symbols, w/ optimization
#  RelWithDebInfo : w/ debug symbols, w/ optimization
#  MinSizeRel     : w/o debug symbols, w/ optimization, stripped binaries
#set(ROS_BUILD_TYPE RelWithDebInfo)

rosbuild_init()

#set the default path for built executables to the "bin" directory
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)
#set the default path for built libraries to the "lib" directory
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)

rosbuild_add_executable(example src/example.cpp)

next, save following code to src/example.cpp:
#include <ros/ros.h>
#include <gazebo_msgs/SetModelState.h>
int main (int argc, char** argv)
{
  ros::init(argc,argv,"test_node");
  ros::NodeHandle n;
  ros::ServiceClient client = n.serviceClient<gazebo_msgs::SetModelState>("/gazebo/set_model_state"); 
  gazebo_msgs::SetModelState setmodelstate;
  gazebo_msgs::ModelState modelstate;
  modelstate.model_name = "drill";
  setmodelstate.request.model_state = modelstate;

  if (client.call(setmodelstate))
  {
    ROS_INFO("BRILLIANT!!!");
    ROS_INFO("%f",modelstate.pose.position.x);
  }
  else
  {
    ROS_ERROR("Failed to call service ");
    return 1;
  }
  return 0;
}

make and run:
make
./bin/example

Output:
$ ./bin/example 
[ INFO] [1329941615.597042253]: BRILLIANT!!!
[ INFO] [1329941615.597092973]: 0.000000

Originally posted by hsu with karma: 5780 on 2012-02-08
This answer was ACCEPTED on the original site
Post score: 6

Original comments
Comment by Penny on 2012-02-22:
Thank you a lot for the code above, now I have managed to make my package and create the server and client, but I have the following prob: "Failed to call service", do you now why this happens? should I change something else?
Comment by Penny on 2012-02-22:
i rosrun again my code, now "Failed to call service" does not appear, but neither "BRILLIANT" appears.
Comment by Penny on 2012-02-22:
i made roswtf and below i posted what i get:
Comment by hsu on 2012-02-22:
I just edited my post to a fully functional tutorial, you should be able to follow step by step and see the final output :)
Comment by Penny on 2012-02-25:
Thank you very much, really your post above solved my problem :)


Q:

Global Path Planner Plugin with Oscillating Husky and Flickering Path Issue

Hello,
I am trying to make a predefined path for my robot to follow.
From my question here, I was adviced to create a custom global planner plugin to define the path and allow the local planner to follow it. I have gone through the famous global planner plugin tutorial, and I am currently trying to implement the code that is posted as an answer to this question by @tianb03.
I am using the husky navigation package. When I give a final orientation in rviz, the path generated by me is visible but the husky seems to be stuck at its initial position. Once I give the husky a little push, it begins to follow the path towards the goal; however, this path quickly disappear and appear repeatedly, causing the husky to run around in circles...
Here is a link to a video illustrating my problem: https://www.youtube.com/watch?v=VvE5rAwMgoM&feature=youtu.be
I am wondering, why is this happening? How can I make the husky follow my predefined global path as close as possible before coming to a stop at the destination? (Do I always have to define the orientation? Can it just stop in its tracks as it nears the goal pose without correcting its orientation to a user defined input?)
Below is my implementation of the global planner plugin as suggested by @tianb03 (Based on the carrot planner cpp):
#include <carrot_planner/carrot_planner.h>
#include <pluginlib/class_list_macros.h>

//register this planner as a BaseGlobalPlanner plugin
PLUGINLIB_EXPORT_CLASS(carrot_planner::CarrotPlanner, nav_core::BaseGlobalPlanner)

namespace carrot_planner {

  CarrotPlanner::CarrotPlanner()
  : costmap_ros_(NULL), initialized_(false){}

  CarrotPlanner::CarrotPlanner(std::string name, costmap_2d::Costmap2DROS* costmap_ros)
  : costmap_ros_(NULL), initialized_(false){
    initialize(name, costmap_ros);
  }
 
  void CarrotPlanner::initialize(std::string name, costmap_2d::Costmap2DROS* costmap_ros){
    if(!initialized_){
      costmap_ros_ = costmap_ros;
      costmap_ = costmap_ros_->getCostmap();

      ros::NodeHandle private_nh("~/" + name);
      private_nh.param("step_size", step_size_, costmap_->getResolution());
      private_nh.param("min_dist_from_robot", min_dist_from_robot_, 0.10);
      world_model_ = new base_local_planner::CostmapModel(*costmap_); 

      initialized_ = true;
    }
    else
      ROS_WARN("This planner has already been initialized... doing nothing");
  }

  //we need to take the footprint of the robot into account when we calculate cost to obstacles
  double CarrotPlanner::footprintCost(double x_i, double y_i, double theta_i){
    if(!initialized_){
      ROS_ERROR("The planner has not been initialized, please call initialize() to use the planner");
      return -1.0;
    }

    std::vector<geometry_msgs::Point> footprint = costmap_ros_->getRobotFootprint();
    //if we have no footprint... do nothing
    if(footprint.size() < 3)
      return -1.0;

    //check if the footprint is legal
    double footprint_cost = world_model_->footprintCost(x_i, y_i, theta_i, footprint);
    return footprint_cost;
  }

  bool CarrotPlanner::makePlan(const geometry_msgs::PoseStamped& start, 
      const geometry_msgs::PoseStamped& goal, std::vector<geometry_msgs::PoseStamped>& plan){

    if(!initialized_){
      ROS_ERROR("The planner has not been initialized, please call initialize() to use the planner");
      return false;
    }

    ROS_DEBUG("Got a start: %.2f, %.2f, and a goal: %.2f, %.2f", start.pose.position.x, start.pose.position.y, goal.pose.position.x, goal.pose.position.y);

    plan.clear();
    costmap_ = costmap_ros_->getCostmap();

    if(goal.header.frame_id != costmap_ros_->getGlobalFrameID()){
      ROS_ERROR("This planner as configured will only accept goals in the %s frame, but a goal was sent in the %s frame.", 
          costmap_ros_->getGlobalFrameID().c_str(), goal.header.frame_id.c_str());
      return false;
    }

    bool done = false;

    int i,n;
    float *Coordinate_Array = NULL;
    float *array = NULL;
    char read[101];
    char* Filename;
    Filename = "/home/aaron/catkin_ws/src/carrot_planner/src/Coordinate.txt";
    FILE *fp = NULL;
    fp = fopen(Filename, "r"); //opens a file for reading

    if(fp == NULL)
       ROS_INFO("Error in reading file");

    fscanf(fp, "%d", &n); //reads formatted input from a stream, "%d" = double data type
    fgets(read, 100, fp); //reads a line from the specified stream and stores it to "read", 100 = maximum number of characterst to be read   

    array=(float*)calloc(2*n,sizeof(float));
    for(i = 0; i < n; i ++)
    {
       //get the value
       //"%s" = string data type
       fscanf(fp, "%s", &read); array[i*2] = (float)atof(read); //converts "read" to a floating point number (type float)
       fscanf(fp, "%s", &read); array[i*2+1] = (float)atof(read);

       //flush of comments
       fgets(read, 100, fp);
    }

    fclose(fp);

    Coordinate_Array = array;

    for (i=0; i<n; i++)
    {
        geometry_msgs::PoseStamped first_start = start;
        geometry_msgs::PoseStamped first_goal = goal;

        first_start.pose.position.x=Coordinate_Array[i*2]-Coordinate_Array[0];//offset
        first_start.pose.position.y=Coordinate_Array[i*2+1]-Coordinate_Array[1];

        first_goal.pose.position.x=Coordinate_Array[i*2+2]-Coordinate_Array[0];
        first_goal.pose.position.y=Coordinate_Array[i*2+3]-Coordinate_Array[1];

        plan.push_back(first_start);

        tf::Stamped<tf::Pose> goal_tf;
        tf::Stamped<tf::Pose> start_tf;

        poseStampedMsgToTF(first_goal,goal_tf);
        poseStampedMsgToTF(first_start,start_tf);

        double useless_pitch, useless_roll, goal_yaw, start_yaw;
        start_tf.getBasis().getEulerYPR(start_yaw, useless_pitch, useless_roll);
        goal_tf.getBasis().getEulerYPR(goal_yaw, useless_pitch, useless_roll);

        double goal_x = first_goal.pose.position.x;
        double goal_y = first_goal.pose.position.y;

        double target_x = goal_x;
        double target_y = goal_y;
        double target_yaw = goal_yaw;

        geometry_msgs::PoseStamped new_goal = first_goal;
        tf::Quaternion goal_quat = tf::createQuaternionFromYaw(target_yaw);

        new_goal.pose.position.x = target_x;
        new_goal.pose.position.y = target_y;

        new_goal.pose.orientation.x = goal_quat.x();
        new_goal.pose.orientation.y = goal_quat.y();
        new_goal.pose.orientation.z = goal_quat.z();
        new_goal.pose.orientation.w = goal_quat.w();

        plan.push_back(new_goal);

    }//end for i

    
    done = true;
   return (done);
  }//end of makePlan

};

My txt file that describes the coordinates are as shown below:
3
5 5
10 5
10 0

Originally posted by aarontan on ROS Answers with karma: 135 on 2018-07-02
Post score: 0

A:

I have discovered that the size of the local costmap and the distance between each way point impacts the global plan. In this case, the local costmap was too big which seems to include too many waypoints therefore confusing the robot. With that being said, I am still looking for an official answer if anyone knows something about this.
I have improved this to follow a circle and adjusted the local costmap size to something smaller and it solved the flickering path issue ... here is a video and a follow up question

Originally posted by aarontan with karma: 135 on 2018-07-04
This answer was ACCEPTED on the original site
Post score: 0


Q:

what is executors, and callbackgroup in ROS2?

I am learning ROS2 Humble and would like to learn more about executors, and callbackgroup.
my first question is:
"What if we use basic spin and executor? How would it affect things?"
example code snippet 1:
int main(int argc, char* argv[])
{
   // Some initialization.
   rclcpp::init(argc, argv);
   ...

   // Instantiate a node.
   rclcpp::Node::SharedPtr node = ...

   // Run the executor.
   rclcpp::spin(node);

   // Shutdown and exit.
   ...
   return 0;
}

and what is the difference between following code compared to above snippet?
example code snippet_2:
rclcpp::executors::SingleThreadedExecutor executor;
executor.add_node(node);
executor.spin();

My second question is regarding callback groups:
What does the following statement mean? In what scenario do we create the callback group (and not just callback function)?
"ROS 2 allows organizing the callbacks of a node in groups. In rclcpp, such a callback group can be created by the create_callback_group function of the Node class."
https://docs.ros.org/en/humble/Concepts/Intermediate/About-Executors.html#:~:text=ROS%202%20allows%20organizing%20the%20callbacks%20of%20a%20node%20in%20groups.%20In%20rclcpp%2C%20such%20a%20callback%20group%20can%20be%20created%20by%20the%20create_callback_group%20function%20of%20the%20Node%20class
I would appreciate the time and effort anyone put into answering this question, as I know it would be a long answer. Thank you!

A:

and what is the difference between following code compared to above snippet? example code snippet_2

As explained in the ROS 2 Documentation page, "The call to spin(node) basically expands to an instantiation and invocation of the Single-Threaded Executor, which is the simplest Executor." The example was provided to show that both the code snippets do the same thing under the hood. When you call the spin() function on a node, it creates a SingleThreadedExecutor, adds the node to the executor, and spins it. But, when you call rclcpp::spin(node), you are abstracted from this information, and you have a much simpler interface to deal with.
If you want to know more about scheduling in general, I will suggest that you read up on multi-threading in Operating Systems, and how task scheduling occurs. You will find that a lot of the design principles with use of executors will be clearer once you understand how an operating system manages multi tasking.
As a helpful resource focusing mainly on the ROS side of things, I point you to William Woodall's presentation on Execution in ROS 2.

My second question is regarding callback groups: What does the following statement mean? In what scenario do we create the callback group (and not just callback function)?

A callback function is more related to the data-exchange side of ROS 2. A callback function defines what is to be done when we receive data on a topic/we exhaust a timer, and so on. One can have multiple callback functions executing in one ROS 2 node. If you call rclcpp::spin(node), it is effectively expanded to creating a SingleThreadedExecutor, adding the node to it, and spinning the node. Think of it as you having only one process running on your computer.
When you are running a MultiThreaded Executor, e.g., a web app on one thread, and the corresponding ROS node on the other thread, you can choose to offload some processing of callbacks on the rather light web app thread, compared to the ROS node thread, which will likely be busier, and might not be able to process all callbacks in the given time. This also indirectly contributes to ROS 2 being able to run Real-Time Systems, where missing a deadline leads to system failure.


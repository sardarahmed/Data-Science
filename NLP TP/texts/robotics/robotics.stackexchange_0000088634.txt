Q:

Integrating ROS with an existing C++ code base

I have an existing C++ code base building  in Eclipse and running under Ubuntu 16.04 and I would like to incorporate some ROS (melodic) functionality (nodes, services, etc, for starters).  I've been reading the tutorials and documentation about catkin and such, and also done some searching, but I'm still unsure of the best way to make this happen.  For example, is there a way that I can add the ROS build constructs to the existing Eclipse project?  Or do I need to create a new project, and import the source?  In the latter case, do I need to add lines for all the cpp files to CMakeLists.txt manually?
I've also found this: http://wiki.ros.org/IDEs  , which is surely relevant, but doesn't quite describe my situation.
If someone could point me in the right direction, I'd appreciate it.
Thanks!

Originally posted by twink on ROS Answers with karma: 11 on 2018-08-21
Post score: 1

A:

Can you clarify what sort of integration you are looking for?
Best practice is to keep non-ROS code "non-ROS code" and to create separate, relatively small (or thin) wrappers that make use of functionality provided by libraries etc.
Doing it that way, there should be no need to import any sources or existing infrastructure into a ROS-aware IDE: just develop the non-ROS code as you always do, make sure the necessary parts can be found (by CMake) and keep the ROS adapters as ROS pkgs in a ROS workspace.
CMake has all the support for such a workflow (and Catkin too).

Edit:

it sounds like in the setup you're describing, the executables would end up being the ROS nodes, and other system code would be called via libraries. Yes?

that was my suggestion yes.

I was hoping there was a way to basically add some ROS functionality to our project, sort of like a 3rd party SDK, rather than essentially ROS-ifying our whole project. This is starting to look like a naive notion...

As to the type of integration you mention in your comment on @PeteBlackerThe3rd: see gerkey/ros1_external_use (this post talks a bit about it).
Note: this is not a typical workflow / setup, so you could run into some issues. There will also not be many people able to help you, as I believe 98% of ROS (1) users would be doing the regular Catkin based approach combined with my suggestion (calling into libraries from ROS nodes).
Another alternative way to integrate with ROS is to not integrate at all.
That may sound strange, but you could just use an IPC with rosbridge_suite on the ROS side, and some JSON parsing/emitting code on the other. Of course this could be done the other way around as well: write a ROS node that implements / uses the ROS API that you'd like to offer / consume and use any IPC system to communicate with your existing system (gRPC, etc).

This is a commercial product, not a research project, so I need to have a clean, maintainable design.

And personal perhaps, but please refrain from such comments. You're implying that all "research project" code is not clean or maintainable. I know that is a popular thing to claim, but it is far from true and not a very nice thing to say or write.

Originally posted by gvdhoorn with karma: 86574 on 2018-08-22
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by twink on 2018-08-22:
@gvdhoorn , thanks very much; your comments are very interesting, since that's actually what I would prefer to do.  This is a commercial product, not a research project, so I need to have a clean, maintainable design.  So we currently have an executable that spawns some subsystem threads.
Comment by twink on 2018-08-22:
My thought was to use create a ROS service out of one of those threads and a ROS service client out of another.  But it sounds like in the setup you're describing, the executables would end up being the ROS nodes, and other system code would be called via libraries.  Yes?
Comment by twink on 2018-08-22:
Or are you suggesting wrapping the ROS stuff somehow?  Thanks!
Comment by twink on 2018-08-22:
@gvdhoorn thanks again for the ideas, and especially for pointing me to that discussion  It gets exactly to the crux of my initial reaction to ROS and it's very good to hear folks talking and thinking about it.
Comment by twink on 2018-08-22:
Re commercial vs research use, please accept my apologies.  I didn't mean to imply that all research code is not maintainable, etc.  Just that some research-related code may have a relatively short life-span, and hence may not have maintainability as a priority or goal, understandably.


Q:

Does setModelState block such that the next sensor readings account for the modified scene?

I am running a simulation involving many different configurations of a large number of objects.  For each "cycle", I read the required object configuration and move the objects in the scene via the /setModelState ROS service.  I wait (using simulated time) for what is equivalent to the sensor's publish rate (to make sure I receive the sensor measurements after moving the objects)
I am trying to track down a bug where my sensors in the scene occasionally don't register the new object positions.  This does not happen every time, and the probability of it happening seems to decrease as I increase the wait time between moving the objects and getting the sensor readings.
To help narrow down the possibilities, I'd like to know if setModelState block (or stop time) until the next sensor readings.  I.e. once setModelState returns, is it guaranteed that the next reading returned by the sensor uses the updated scene?

Originally posted by wongrufus on Gazebo Answers with karma: 78 on 2020-12-11
Post score: 1

A:

This does not seem to be the case.  setModelState calls Entity::SetWorldPose which calls Entity::SetWorldPoseModel which calls Entity::PublishPose which calls World::PublishModelPose which only queues up the requested change in the model.
The actual change is applied in World::Step which calls World::ProcessMessages where the requested changes is propagated to the rendering scene via updateScenePose.
In my case, my sensor (Gpu Laser) uses the rendering Scene for updates.  Hence it cannot be guaranteed that the scene is updated when setModelState returns.  Instead, one needs to wait for the next World::Step call.  This may also explain why my waits seem to stop working when my computer is heavily loaded.

Originally posted by wongrufus with karma: 78 on 2021-01-04
This answer was ACCEPTED on the original site
Post score: 0


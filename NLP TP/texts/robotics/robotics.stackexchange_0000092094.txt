Q:

std_msgs/sensors_msgs does not name a type

Hi,
I have a project with 2 files a main .cpp and a .hpp. The .cpp includes
#include "sensor_msgs/msg/nav_sat_fix.h"

and declares a variable
sensor_msgs::msg::NavSatFix n;

and this works just fine.
When I try to do the same thing by including sensor message in the .hpp file I get a colcon message stating that sensor_msgs does not name a type, even though I declared it identically to the .cpp reference.
My package.xml depends on sensor_msgs and my CMakeLists.txt finds sensor_msgs is listed as one of the ament_target_dependencies. The same thing happens if I include a std_msg in the .hpp section so I assume its some path missing somewhere, but I'm not sure why it works for the .cpp and not the .hpp.
UPDATE:
Here is a simplified mini-project to show the issue I'm having
CMakeList.txt:
cmake_minimum_required(VERSION 3.5)
project(testing)

# Default to C++14
if(NOT CMAKE_CXX_STANDARD)
  set(CMAKE_CXX_STANDARD 14)
endif()

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(std_msgs REQUIRED)
find_package(sensor_msgs REQUIRED)

include_directories("../dependencies/")

add_executable(${PROJECT_NAME} a.cpp)
ament_target_dependencies(${PROJECT_NAME} rclcpp std_msgs sensor_msgs obstacle_msgs)

install(TARGETS
  ${PROJECT_NAME}
  DESTINATION lib/${PROJECT_NAME}
)

ament_package()

package.xml:
<?xml version="1.0"?>
<package format="2">
  <name>testing</name>
  <version>0.0.0</version>
  <description>blah blah blah</description>

  <maintainer email="paul@somewhere.com">Paul</maintainer>
  <license>TODO</license>
  <!-- <author email="paul">Paul</author> -->

  <buildtool_depend>ament_cmake</buildtool_depend>
  <depend>rclcpp</depend>
  <depend>std_msgs</depend>
  <depend>sensor_msgs</depend>
  
  <!-- The export tag contains other, unspecified, tags -->
  <export>
    <!-- Other tools can request additional information be placed here -->
    <build_type>ament_cmake</build_type>
  </export>
</package>

a.cpp:
#include "b.hpp"

int main()
{
    B *b = new B();

    return 0;
}

b.hpp:
#ifndef SRC_TEST_B_HPP_
#define SRC_TEST_B_HPP_

#include "sensor_msgs/msg/nav_sat_fix.h"

class B {
public:
    sensor_msgs::msg::NavSatFix getPoly() { return m_polygon; }
private:
    sensor_msgs::msg::NavSatFix m_polygon;
};

#endif /* SRC_TEST_B_HPP_ */

Compiling output:
In file included from /home/paul/code/eclipse_ws/ROS2/src/testing/a.cpp:1:0:
/home/paul/code/eclipse_ws/ROS2/src/testing/b.hpp:8:2: error: ‘sensor_msgs’ does not name a type
  sensor_msgs::msg::NavSatFix getPoly() { return m_polygon; }
  ^~~~~~~~~~~
/home/paul/code/eclipse_ws/ROS2/src/testing/b.hpp:10:2: error: ‘sensor_msgs’ does not name a type
  sensor_msgs::msg::NavSatFix m_polygon;

What simple thing am I missing?
Sincerely, Paul.

Originally posted by AwooOOoo on ROS Answers with karma: 117 on 2019-06-18
Post score: 1

Original comments
Comment by gvdhoorn on 2019-06-18:
Pedantic, but:

I get a colcon message

it's actually the compiler (probably GCC if compiling on Linux) tells you that it can't find the type. Colcon is not the compiler.

Edit: please show (the relevant parts) of your CMakeLists.txt.

A:

You seem to be importing a C header and use it as if it was containing C++ classes.
Did you try importing the C++ version of the message instead?
#include "sensor_msgs/msg/nav_sat_fix.hpp"

If you are porting packages from ROS 1, you can refer to this documentation page that provides useful tips for how to update package.xml, header inclusion etc

Originally posted by marguedas with karma: 3606 on 2019-06-18
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by AwooOOoo on 2019-06-18:
I can't believe it was that simple.... Thank you =)


Q:

[rosmake] how to configure your own packages

Many packages I download in source form are able to be built via a simple
$rosmake <package>

This seems to imply the build system for those packages is already configured.
My packages on the contrary need to expressly launch cmake first otherwise there is no makefile.
The generated makefile then is not portable in that cmake creates machine specific paths.
So how do I make my packages portable like the others?
I want my packages to "just work" once downloaded.
I should also note that I've moved to a stack and that packages within are correctly built in the right dependency sequence, but if there is no makefile already, rosmake would fail.
Rosmake appears unable to generate the Makefile from CMakeLists.txt by itself requiring an explicit cmake before.
I've been requested to post the code, I guess that's the CMakeLists code.
Here it is
cmake_minimum_required(VERSION 2.4.6)
include($ENV{ROS_ROOT}/core/rosbuild/rosbuild.cmake)

# Set the build type.  Options are:
#  Coverage       : w/ debug symbols, w/o optimization, w/ code-coverage
#  Debug          : w/ debug symbols, w/o optimization
#  Release        : w/o debug symbols, w/ optimization
#  RelWithDebInfo : w/ debug symbols, w/ optimization
#  MinSizeRel     : w/o debug symbols, w/ optimization, stripped binaries
set(coverage RelWithDebInfo)
set(CMAKE_CXX_FLAGS "-std=c++0x")

rosbuild_init()
rosbuild_find_ros_package(saetta_msgs REQUIRED)
rosbuild_add_boost_directories()
find_package(PkgConfig REQUIRED)
pkg_check_modules(OpenCV REQUIRED opencv)
pkg_check_modules(gtk+ REQUIRED gtk+-2.0)

#set paths
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)
set(PATH_SRC ${PROJECT_SOURCE_DIR}/src)
set(PATH_CVBLOBS ${PATH_SRC}/cvblobs8.3_linux)
set(PATH_INC ${PROJECT_SOURCE_DIR}/include)
set(INCLUDE_PATHS ${PATH_INC} ${PATH_CVBLOBS} ${OpenCV_CFLAGS} ${gtk+_CFLAGS})
link_directories(${LIBRARY_OUTPUT_PATH})

# Set the directories where include files can be found.
include_directories (include)
include_directories (${INCLUDE_PATHS})
include_directories (${gtk+_INCLUDE_DIRS})
include_directories (${OpenCV_INCLUDE_DIRS})
include_directories (${saetta_msgs_PACKAGE_PATH}/msg_gen/cpp/include)

# Add dynamic reconfigure API.
#rosbuild_find_ros_package (dynamic_reconfigure)
#include (${dynamic_reconfigure_PACKAGE_PATH}/cmake/cfgbuild.cmake)
#gencfg ()

#common commands for building c++ executables and libraries
rosbuild_add_library(vision ${PATH_SRC}/Vision.cpp)
# add imported target
add_library(blobs STATIC IMPORTED)
# point the imported target at the real file
set_property(TARGET blobs PROPERTY IMPORTED_LOCATION ${PATH_CVBLOBS}/libblob.a)
target_link_libraries(vision ${OpenCV_LIBRARIES} ${PATH_CVBLOBS}/libblob.a)
rosbuild_add_executable(vispos ${PATH_SRC}/main.cpp)
target_link_libraries(vispos vision)
rosbuild_link_boost(vispos system)

And here is the Manifest
<package>
  <description brief="saetta_vision">
Saetta vision  </description>
  <author>Claudio Carbone</author>
  <license>BSD</license>
  <review status="unreviewed" notes=""/>
  <url></url>
  <depend package="rospy"/>
  <depend package="roscpp"/>
  <rosdep name="OpenCV 2.4.0"/>
  <depend package="saetta_msgs" />

</package>

Here is the build command
me@mycomputer:~/Apps/ROS/Saetta/saetta_vision$ rosmake Saetta
[ rosmake ] rosmake starting...                                                 
[ rosmake ] Packages requested are: ['Saetta']                                  
[ rosmake ] Logging to directory /home/me/.ros/rosmake/rosmake_output-20130220-113614
[ rosmake ] Expanded args ['Saetta'] to:
['saetta_base', 'saetta_vision', 'saetta_msgs']
[...]    
[rosmake-1] Finished <<< saetta_msgs [PASS] [ 0.25 seconds ]                    
[rosmake-1] Starting >>> saetta_base [ make ]                                   
[rosmake-0] Starting >>> saetta_vision [ make ]                                 
[rosmake-0] Finished <<< saetta_vision  No Makefile in package saetta_vision
[...]

Originally posted by Claudio on ROS Answers with karma: 859 on 2013-02-19
Post score: 0

A:

When you created your package with roscreate-pkg (as shown in this tutorial: http://ros.org/wiki/ROS/Tutorials/CreatingPackage), it should have created the required Makefile for you. Since you don't have one, you technically have have a malformed ROS package, which is why rosmake won't build it.
Either regenerate your package using roscreate-pkg or just create a Makefile in your package with the following contents:
include $(shell rospack find mk)/cmake.mk

Also for things like OpenCV you should look into using standard find_package syntax as opposed to going through pkg-config.
Here's an example snippet from the CMakeLists.txt of a package using that approach:
find_package(OpenCV REQUIRED)
include_directories(${OPENCV_INCLUDE_DIR})

rosbuild_add_executable(dilation_sample src/dilation_sample.cpp)
target_link_libraries(dilation_sample ${OPENCV_LIBS})

You may find a similar find_package module is provided by CMake or GTK for using GTK libriaries in a CMake project.

Originally posted by Eric Perko with karma: 8406 on 2013-02-20
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by Claudio on 2013-02-20:
I used roscreate-pkg only at the beginning, thinking that was just for new users, I thought cmake and manifest would be sufficient. Never realized it also created a makefile.
For the OpenCV fact is the fuerte version isn't compatible with the C++0x parameter.
Why do you say find_package is better?
Comment by Eric Perko on 2013-02-20:
I would recommend find_package over pkg-config mainly since that is the standard way to find dependencies in CMake. In my experience, I've also seen external dependencies that had not quite correct pkg-config files, but their find_package module was fine.
Comment by Eric Perko on 2013-02-20:
As for roscreate-pkg, it is the standard way of getting the scaffolding right when creating a new ROS package (at least a rosmake package... catkin is different). You can of course create all of the files by hand, but roscreate-pkg will make sure you end up with all of the expected files.
Comment by Claudio on 2013-02-20:
thanks Eric, fact is when I started writing many programs I did not know from the start which libraries I was going to use in the end, so roscreate-pkg was fine but I had to learn ho to modify everything by hand. and this little thing of the makefile completely escaped me.  well thanks for that!


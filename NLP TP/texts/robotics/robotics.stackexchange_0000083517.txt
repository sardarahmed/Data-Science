Q:

ROS dependency Boost 1.58, additional dependency Boost 1.64?

Hey everyone,
I've got a problem here that I seem unable to solve... or even fully get my head around.
ROS itself installs libboost 1.58 as one of its dependencies. In addition I have a 3rd party dependency for a node of libboost 1.64. Boost 1.58 is installed via apt in /usr/lib/x86_64-linux-gnu as usual and comes with ros-kinetic-desktop-full. So deinstalling it isn't an option.
Boost 1.64 on the other hand is manually built by cmake/make/make install and installed in /usr/local/lib. This doesn't appear to be an issue in this particular case, actually, but catkin warns about not being able to generate a safe linker path. The node actually works. The warning is annoying though, and I'd like to somehow cleanly solve this issue instead of just suppressing the warning. But if there's no other way, I'd go with simply deactivating that particular warning.
How should I deal with this?
Thanks

Originally posted by Hendrik Wiese on ROS Answers with karma: 1145 on 2017-10-25
Post score: 4

A:

How should I deal with this?

Ideally: avoid trying to use two different Boost versions on the same machine. Or at least: make sure that they are only visible (ie: findable) by the applications that need them.
Mixing Boost versions like this can lead to subtle and hard to diagnose SEGFAULTs and other problems. Even in the case where one Boost library is header only, and linking is not even involved (just search around, the internet is full of examples).

Boost 1.64 on the other hand is manually built by cmake/make/make install and installed in /usr/local/lib. This doesn't appear to be an issue in this particular case, actually, but catkin warns about not being able to generate a safe linker path. The node actually works. The warning is annoying though, and I'd like to somehow cleanly solve this issue instead of just suppressing the warning. But if there's no other way, I'd go with simply deactivating that particular warning.

One suggestion: if you're compling the node that needs the newer Boost version yourself (and I assume that is the case, as ROS Kinetic binaries are built against 1.58), a somewhat clean work-around could be to move the 1.64 artefacts to a location that is not on the default include, linker and search paths. Use the regular CMake knobs to tell the CMakeLists.txt that need it (ie: the node that needs 1.64) where to find it and to require it (something like find_package(Boost REQUIRED 1.64 EXACT ..)). It could be that running binaries built this way need some tweaking of library search paths afterwards, but that is all non-ROS specific (all of this is, actually).
If done correctly, this should avoid inadvertent mixing of libraries and headers of the two Boost versions.
Note that you'll probably have to clean out the 1.64 install you have in /usr/local already, and rebuild it with a suitable PREFIX.

Originally posted by gvdhoorn with karma: 86574 on 2017-10-25
This answer was ACCEPTED on the original site
Post score: 6

Original comments
Comment by gvdhoorn on 2017-10-25:
It's not absolutely necessary to get the non-default Boost off the default search paths, but it's probably the easiest way to avoid running into any issues later. /usr/local is (I believe) searched first, so every find_package(Boost ..) is going to find it, and again: mixing is not a good idea.
Comment by Hendrik Wiese on 2017-10-25:
I'll see if I can make the node link against (maybe even statically) some "locally" installed boost 1.64 while removing the latter from /usr/local and keeping only 1.58 in the system search paths. Prbbly gonna be a hell of a ride. I also hope to get rid of some weird node shutdown behavior by this.
Comment by gvdhoorn on 2017-10-25:
It shouldn't be too difficult: dealing with multiple versions of libraries is something that CMake can do since a long time.
Comment by gvdhoorn on 2017-10-25:
Keep in mind though that 'the rest' of ROS Kinetic (ie: all libraries that you use) will still bring in Boost 1.58 artefacts. That is not going to change, and can still lead to issues.
The only way to really avoid that is to build ROS (all of it) from sources against 1.64.
Comment by gvdhoorn on 2017-10-25:
And finally: this problem - linking against different versions of dependencies in a single compilation unit - is not ROS specific. It's a universal problem when dealing with languages that support (dynamic) linking (ie: even Python has it).
It's called the dependency hell.
Comment by DangTran on 2020-05-22:
For anyone having problems with multiple version dependency when working in ROS, this link may useful. The example demonstrates very much @gvdhoom 's explanation


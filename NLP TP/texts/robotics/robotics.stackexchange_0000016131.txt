Q:

Alternative to ROS?

This might be a tricky question, but having dug in deep with ROS I am noticing the complexity that one has to deal with. 
Simple Arduino programming is much simpler but of course canâ€™t do many useful things. No threading, IPC, and many many more. To be clear, I am not planning on using an Arduino, I am just using it as the extreme end point of a spectrum.
So my question is, is there another package or library or framework that does some of the things that ROS does but perhaps not at the level of sophistication?
Additional
Thanks to the responses so far, and the feedback. I've added below and updated above.
As an example application, let's say an experimental (i.e I am not trying to build a commercial product - yet) mobile robot, with a depth camera, Lidar, and wheels, that can navigate indoors and be controlled over WiFi. It would likely include slam navigation and/or fiducials. Obviously I am OK with buying the hardware or the hardware components and doing a lot of programming. I would prefer something other than C++ but that's not a strict requirement.

A:

I think you are getting confused between the basic ROS possibilities and some more advanced libraries which are integrated but do not need to be used by users without 'advanced' requirements. If you find it too difficult most likely those are functionalities which are not necessary for your project.
That being said, ROS is a middleware that makes the glue between several modular pieces of software by providing interfaces and taking care of communication.
There exist other middlewares for robotics like YARP, POCOLIBS, OROCOS,  ROCK (but there are many more). Some are targeted more for real-time, some more with specificity target at their original application.
If you want to program in a middleware independent way, you can look into genom3, which is an additional abstraction layer allowing to choose middleware at compilation time. 

A:

Arduino is not really relevant since its output is a bare-metal microcontroller code. You can gain experience with more complex microcontroller systems by using a realtime OS on your arduino board.
I have used ROS in several large projects and have an informed understanding of it. While I disagree with many of the choices that the core authors of ROS made, I still recommend using ROS when it is an appropriate choice made with full awareness of the other approaches that can be taken.
ROS is a poor choice in many robotics situations. Real-time systems and distributed systems with unreliable communications for example.
ROS has a list of alternative frameworks, thought they leave out ROCK which arguably has a better design but uses Ruby instead of Python as its scripting language of choice. 
Some of the things that ROS provides are things that are already provided by your operating system and the OS version is probably better developed. 
Deploy your software using your OS's package manager instead of rospack.
Start your processes using (b)ash and your OS's service manager instead of roslaunch.
Use LDAP instead of rosparameters.
Use DNS instead of roscore for service discovery.
You can also cherry pick the parts of ROS that work for you.
Most of the software that is distributed with ROS is developed such that it can be used without ROS.

A:

ROS is still a good framework, even if you just use a little of it. However, if I just needed the message passing, I'd probably just use MQTT. But ROS has a lot of useful components that I'd otherwise have to create or integrate myself. These include message passing, SLAM, path control, and many other components.
That being said, there are quite a few alternatives out there. Most of the ones I've heard of were listed in this Wikipedia article on Open Source Robotics.
The alternative that I'm most familiar with is Gobot, available here. This framework is much smaller than ROS, but it's working on producing cross-platform code.
There are sister projects, Artoo (Ruby) and Cylon (Javascript).


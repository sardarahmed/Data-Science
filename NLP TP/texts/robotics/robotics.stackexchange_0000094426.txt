Q:

how to correctly use code from another package? Error: Does not name a type

The project has two packages, and as one packages tries to to use code from the other package, this error occurs:
In file included from /home/mo/Desktop/workspace/src/jimmy_lidar_motor_control/src/lidar_motor_control.cpp:40:0:/home/mo/Desktop/workspace/src/jimmy_lidar_motor_control/include/jimmy_lidar_motor_control/lidar_motor_control.h:17:5: error: ‘jimmycpp’ does not name a type
 jimmycpp::LidarRotation lidarMotorForRotationObj;
 ^

in workspace/srcdirectory there are 2 packages (for now). one acts as a library (called jimmycpp), and the other (called jimmy_lidar_motor_control) is trying to use a file in the jimmycpp library. I am using standard ros package organization:
└─-----─ src
          ├── jimmycpp
          │   ├── CMakeLists.txt
          │   ├── include
          │   │   └── jimmycpp
          │   │       ├── ampsteppers.h
          │   │       ├── arduinomega.h
          │   │       ├── lidar_encoder.h
          │   │       ├── lidar_rotation.h
          │   │       └── trc_logging.h
          │   ├── package.xml
          │   ├── README.md
          │   └── src
          │       ├── ampsteppers.cpp
          │       ├── arduinomega.cpp
          │       ├── lidar_encoder.cpp
          │       ├── lidar_rotation.cpp
          │       ├── main.cpp
          │       └── trc_logging.cpp
          └── jimmy_lidar_motor_control
              ├── CMakeLists.txt
              ├── include
              │   └── jimmy_lidar_motor_control
              │       └── lidar_motor_control.h
              ├── launch
              │   └── lidar_motor_control.launch
              ├── msg
              │   └── motion_command_to_execute.msg
              ├── package.xml
              └── src
                  └── lidar_motor_control.cpp

The library header file that needs to be included by the the package using the library is: jimmycpp/include/jimmycpp/lidar_rotation.h. Here is a very brief internal view:
//no implementation only a bunch of declarations
class LidarRotation
{
    private:
          //bunch of code
    public:
         LidarRotation();
         //public methods for other packages to call
};

The actual implementation of the LidarRotation class takes place in src/lidar_roation.cpp in jimmycpp. The CMakeLists.txt for jimmycpp library package looks like this:
# What version of CMake is needed?
cmake_minimum_required(VERSION 2.8.3)
# The name of this package (must match name in package.xml).
project(jimmycpp)
#use the C++11 standard
add_compile_options(-std=c++11)

find_package(catkin REQUIRED COMPONENTS
  roscpp
)

# Declare our catkin package.
catkin_package(
  INCLUDE_DIRS 
    include
  CATKIN_DEPENDS
    roscpp
  LIBRARIES
    jimmycpp
)

# Specify locations of header files.
include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)

install(DIRECTORY include/${PROJECT_NAME}/
  DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}
  FILES_MATCHING PATTERN "*.h"
  PATTERN ".svn" EXCLUDE)

add_library(jimmycpp
    include/${PROJECT_NAME}/arduinomega.h
    include/${PROJECT_NAME}/ampsteppers.h
    include/${PROJECT_NAME}/trc_logging.h
    include/${PROJECT_NAME}/lidar_rotation.h
    include/${PROJECT_NAME}/lidar_encoder.h
   src/arduinomega.cpp
   src/ampsteppers.cpp
   src/trc_logging.cpp
   src/lidar_rotation.cpp
   src/lidar_encoder.cpp
)

#serial was added for serial comm to motor rotating lidar.
#labjackusb is the exodriver for the U3. 
target_link_libraries(jimmycpp serial labjackusb ${catkin_LIBRARIES})

In the package that wants to use the jimmycpp library (the lidar_rotation.h & lidar_rotation.cpp) there is only one header file called lidar_motor_control.h. In this header file I declare my library, and a few variables. no classes, very simple:
/// my low level library
#include <jimmycpp/lidar_rotation.h>

//This is my handle for my library.
//jimmycpp::LidarRotation lidarMotorForRotationObj;
//lots more stuff

if I uncomment the line jimmycpp::LidarRotation lidarMotorForRotationObj; i get the error at the begining of this long (sorry) question. But if I comment the line out catkin_make completes with no errors (but I can't use my library). Here is the CMakeLists.txt for the second package:
# What version of CMake is needed?
cmake_minimum_required(VERSION 2.8.3)

# The name of this package (must match package.xml).
# from here on "${PROJECT_NAME}" == "jimmy_base"
project(jimmy_lidar_motor_control)

## Compile as C++11, supported in ROS Kinetic and newer
add_compile_options(-std=c++11)

# Find catkin macros and libraries if COMPONENTS list like find_package(catkin 
# REQUIRED COMPONENTS xyz) is used, also find other catkin packages. 
# I added: roscpp, rospy, std_msgs, message_generation, and jimmycpp. All this
# is out of the manual_operation package (used to initially test jimmycpp)
find_package(catkin REQUIRED COMPONENTS
  roscpp
  rospy
  std_msgs
  jimmycpp
  message_generation
)

#declare any custom files that I have created
add_message_files(
  FILES
  motion_command_to_execute.msg
)

#the custom message I am declaring relies on data types found here
generate_messages(DEPENDENCIES std_msgs )

catkin_package( 
  INCLUDE_DIRS include
#  LIBRARIES my_robot_base
  CATKIN_DEPENDS roscpp message_runtime
#  DEPENDS system_lib
)

# Specify locations of header files.
include_directories(include ${catkin_INCLUDE_DIRS})

#NOTE: executable name and source file name should be the same!!!!
add_executable(${PROJECT_NAME}_node 
  src/lidar_motor_control.cpp
)

# Specify libraries against which to link. This line should be copied for each
# distinct executable in the package (where executable names should be the same
# as source names).
target_link_libraries(${PROJECT_NAME}_node serial ${catkin_LIBRARIES})

# this line is to be used anytime I am using custom messages. It prevents build 
# errors when I run `catkin_make`. The first argument is the same name as the 
# name of the source file. The second argument is the name of the package plus 
# add “_generate_messages_cpp”. This solution to my problem is described on 
# http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber(c%2B%2B) in section
add_dependencies(${PROJECT_NAME}_node
  ${${PROJECT_NAME}_EXPORTED_TARGETS}
  ${catkin_EXPORTED_TARGETS}
  jimmy_lidar_motor_control_generate_messages_cpp
)

I can't figure out what is going wrong. Why cant I use the library? Could you please let me know where I am making the mistake? Thanks a bunch for your time!

Originally posted by BuilderMike on ROS Answers with karma: 247 on 2020-01-18
Post score: 0

A:

Is your class LidarRotation defined inside a namespace jimmycpp ?
If not you would need to access it as LidarRotation lidarMotorForRotationObj; directly
Useful resource: cppreference namespaces

Originally posted by marguedas with karma: 3606 on 2020-01-19
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by BuilderMike on 2020-01-19:
@marguedas You are totally right, and everything builds now. Could you please post you comment as an answer so I can accept it. Merci. J'apprécie vraiment cela :-)
Comment by marguedas on 2020-01-19:
Glad it solved your issue :)


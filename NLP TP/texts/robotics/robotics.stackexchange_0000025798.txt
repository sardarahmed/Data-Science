Q:

Gazebo ROS Fuerte Integration

This stub is just to sort of report and query whether we are on the right track with using Gazebo in ROS.
Yesterday we wanted to couple ROS Fuerte with Gazebo on Ubuntu 12.04.
We first installed gazebo 1.4 from source and followed this tutorial for ROS integration: http://gazebosim.org/wiki/Tutorials/1.4/ros_enabled_model_plugin.  Worked well but now the problem with the tutorial is that the plugin is not a ROS package anymore. After talking to @jhsu he's told me the following:
jhsu: this was an exercise in cmake. We've recently moved drcsim's ros plugins into a cmake subproject using ExternalProject_Add, which seems to work despite the fact that we haven't yet figured out how to make it track dependent file modification and trigger recompile, otherwise seems to be working ok. Using this approach, we will switch back to invoking rosbuild as a ros package directly. On the ros front, the plan is to update simulator_gazebo in Hydro so it does not pull/compile it's own binary, but use a system debian install instead.
We in fact did go back, use pkg-config magic from the tutorial within the ros package for our plugin and were able to build it successfully. The problem however now was that we could not run gazebo from the Gazebo script anymore. This basically also means that
a) we could not run Gazebo as a ROS node anymore and
b) could not conveniently use ROS package file structure anymore. Too many drawback which led us back to the gazebo_simulator ROS stack.
In there we enabled building of Gazebo from source and checked out the deprecated_parser_sdf_1.2_support branch. This one also compiled and run fine (we could run it rosrun for instance) but all of a sudden could not load our robot sdf model anymore. It then turned out that was because GAZEBO_MODEL_PATH was not set by the gazebo_ros_paths_plugin.cpp.
This is our state as of today, tomorrow we will provide the patch for the latter.
@jhsu also said that from ROS Hydro all these issues will go away since Gazebo will become a system dependency. But  since we need ROS and Gazebo working today, I would still like to raise couple of questions to help us move forward.

URDF vs SDF: How do you model your robots that are running in simulation as well as in real hardware? Do you maintain both sdf and urdf files?

When using Gazebo in ROS - are we supposed to set any of the GAZEBO_* environment variables explicitly in bash? Or is everything begin taken care of by the gazebo/scripts/gazebo scripts? GAZEBO_MODEL_PATH is obviously not.

Is Gazebo ROS node actually publishing robot's joint_states as needed by the robot_state_publisher?

Is Gazebo currently (branch deprecated_parser_sdf_1.2_support) running on different computers (e.g. server on one and client on another one)? If yes, is there an example?

Thx, D.

Originally posted by dejanpan on Gazebo Answers with karma: 60 on 2013-02-05
Post score: 2

Original comments
Comment by dejanpan on 2013-02-06:
Nate thanks a lot for your answer, I am sure it will help plenty of people. Sorry for missing on the rosrun and Gazebo publishing joint_states things, I in no case did not want to be misleading. I just wanted to gather whether my current understanding of things was correct. You guys are doing great and I am sure all the changes and muddy waters are for the better. When Gazebo will be factored out of ROS, can you comment on how that is planned to be done?
Comment by dejanpan on 2013-02-06:
I can see how you do something like this with openCV or PCL which are pure libraries and then in ROS you only call their functions, but with Gazebo you will always need to run gzserver and gzclients as separate processes, no?

A:

Thanks for the detailed note. There are definitely many changes underway, which can lead to a lot of confusion. Let me try to clarify things.
Running Gazebo
Consider Gazebo and ROS two separate entities. When ROS came into existence, the philosophy was to wrap external programs and libraries into ROS in order to produce a stable and reliable system of components. There are drawbacks to this approach, which I won't go into for brevity sake. You can still run Gazebo via a roslaunch script, but rosrun won't work because Gazebo is not a ROS package.
This fix will be complete with ROS Hydro. As of Groovy, you can still build the simulator_gazebo package and rosrun gazebo from the commandline.
Writing a Plugin for Gazebo
A Gazebo plugin is a shared library that links against a few specific Gazebo libraries and is loaded at runtime. A plugin can also be linked again other libraries, such as roscpp. In fact, you can make a Gazebo plugin live within a ROS package.
Loading a Plugin
Gazebo needs to find your plugin. In order to do this, Gazebo looks in GAZEBO_PLUGIN_PATH for the name of the plugin you specify in SDF. You should append path to GAZEBO_PLUGIN_PATH to point to directories that contain your plugins.
SDF and URDF
We are in the process of combining the two. Right now the waters are muddy because of the coexistence of the two formats. Gazebo requires SDF, which means that URDF files are converted to SDF behind the scenes for you.
You can define a robot using URDF, and Gazebo will handle it. However, you can only define an environment (lighting, physics, etc) in SDF.
Gazebo ROS Node
Your statement "Is Gazebo ROS node actually publishing robot's joint_states as needed by the robot_state_publisher" is misleading. Gazebo does not publish anything to ROS. Only a Gazebo plugin can talk ROS. What looks like Gazebo publishing joint_states is really a Gazebo plugin that is also running ROS.
Client and Server Separation
The Gazebo server (gzserver) runs the physics and sensor update loops. The Gazebo client (gzclient) runs the graphical front end. Each of these executables, gzserver and gzclient, can be run on separate machines. You just need to set GAZEBO_MASTER_URI and optionally GAZEBO_IP appropriately. These two environment variables behavior in much the same way as ROS_MASTER_URI and ROS_IP.

Originally posted by nkoenig with karma: 7676 on 2013-02-06
This answer was ACCEPTED on the original site
Post score: 4


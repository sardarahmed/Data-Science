Q:

Subscribe and publish velocity

Hi,
I have a code where I want to see the linear velocity of a powered wheelchair and then publish linear velocity to it.
An example of the code is:
ros::Publisher vel_pub_=n.advertise<geometry_msgs::Twist>("cmd_vel", 1);
if(vel.linear.x > 1.8){
    vel.linear.x = 1.8;
    vel_pub_.publish(vel);}

--UPDATE--
To subscribe to the cmd_vel topic I do:
ros::Subscriber vel_sub = n.subscribe("cmd_vel", 0, velCallback);

My question is... What do I insert in the velCallback function? What does it contain? What should the header of the function be?
Thank you!

Originally posted by anamcarvalho on ROS Answers with karma: 123 on 2014-08-08
Post score: 1

A:

If you want to synchronize the data and use one callback for both of the topics, have a look at the message_filter tutorial.
Edit:
The callback should look something like this (no guarantee that this works though, beware of typos):
void velCallback(geometry_msgs::Twist::ConstPtr& vel) {
 //Since vel is a const pointer you cannot edit the values inside but have to use the copy new_vel.
 geometry_msgs::Twist new_vel = *vel; 
 if(vel->linear.x > 1.8) {
    new_vel.linear.x = 1.8; 
    vel_pub_.publish(new_vel);
  }
}

Please have a look at this tutorial to see how subscribers and publishers work.
I would also suggest to have a queue size of at least 1: ros::Subscriber vel_sub = n.subscribe("cmd_vel", 1, velCallback);
Edit2:
For the case you mentioned in the comments something like this could work (not tested, beware of typos):
#include "ros/ros.h"
#include "geometry_msgs/Twist.h"

ros::Publisher pub;

void velCallback(geometry_msgs::Twist::ConstPtr& vel)
{
   geometry_msgs::Twist new_vel = *vel;
   if (vel->linear.x > 1.8) {
     new_vel.linear.x = 1.8;
   }
   pub.publish(new_vel);
}

int main(int argc, char **argv)
{

ros::init(argc, argv, "my_node");
ros::NodeHandle n;

pub = n.advertise<geometry_msgs::Twist>("cmd_vel", 10);
ros::Subscriber sub = n.subscribe("my_cmd_vel", 10, velCallback);

ros::spin();

return 0;
}

You only have to make sure that the node publishing the original cmd_vel values publishes to my_cmd_vel now which you can achieve via remapping the topic in the launch file. The node I posted above will take that value and pass it on to cmd_vel or change the linear speed if necessary and then pass it on to cmd_vel.
Since the callback is running in a different thread than your main function you cannot rely on always having a value for your linear_actual in the main function. So do whatever you need to do with the actual values in the callback. In this easy example this is good enough.

Originally posted by Chrissi with karma: 1642 on 2014-08-10
This answer was ACCEPTED on the original site
Post score: 4

Original comments
Comment by anamcarvalho on 2014-08-13:
Hi @Chrissi, do you this this will work?
void velCallback (const geometry_msgs::Twist::ConstPtr& vel_msg) {

ros::NodeHandle n;
ros::Publisher vel_pub_=n.advertise<geometry_msgs::Twist>("cmd_vel", 1);
geometry_msgs::Twist vel;

linear_actual=vel_msg->linear.x;
angular_actual=vel_msg->angular.z;
}

Comment by anamcarvalho on 2014-08-13:
What I do in the code I inserted in the comment above is to update linear and angular velocity to the current velocities!
Then, in main function I do:
if(linear_actual > 1.8){
    vel.linear.x = 1.8;
    vel_pub_.publish(vel);}

Is this ok?
Comment by Chrissi on 2014-08-13:
I wouldn't create the publisher in the callback because then the publisher will be created when ever a new message arrives, this is unnecessary. Even though a kitten dies every time you use global variable, I would make it a global variable.
The thing with the cmd_vel is, that still both messages will reach the robot, so the one with linear.x > 1.8 and your new one and the robot will not know what to do and start stuttering. You have to remap the output of whatever publishes the cmd_vel in the first place to a new topic and listen to that. Then you pass on every message you get to cmd_vel and change it where necessary.
Comment by anamcarvalho on 2014-08-13:
Sorry, my bad! I forgot to delete the publisher in the code!
void velCallback (const geometry_msgs::Twist::ConstPtr& vel_msg) {

linear_actual=vel_msg->linear.x;
angular_actual=vel_msg->angular.z;
}

The code is just like this.. I just updates the current velocity!
Comment by anamcarvalho on 2014-08-13:
The rest of the code, the comparison to see it its greater that 1.8 I need to have in the main, because in the real code I have, it isn't so simple! So I really need to do this comparison inside main!
Is it ok this time?
Comment by Chrissi on 2014-08-13:
You have to make sure that callback is not writing to the variable while you are trying to read it. See this thread on how to use boost scoped lock
Comment by anamcarvalho on 2014-08-13:
This updates at a rate of 40Hz... I will be a matter of milliseconds, I am assuming that shouldn't be a problem!


Q:

Having trouble sending a message to ROS

I am pretty new in ROS. I am just trying to publish a message to a node in a linux server with this code:
#include "stdafx.h"
#include "ros.h"
#include <string>
#include <stdio.h>
#include <Windows.h>

using std::string;

int _tmain(int argc, _TCHAR * argv[])
{
    ros::NodeHandle nh;
    char *ros_master = "*.*.*.*";

    printf("Connecting to server at %s\n", ros_master);
    nh.initNode(ros_master);

    printf("Advertising cmd_vel message\n");
    string sent = "Hello robot";
    ros::Publisher cmd_vel_pub("try", sent);
    nh.advertise(cmd_vel_pub);

    printf("All done!\n");
    return 0;
}

The compiler gives me these errors:
 Error  C2664 'ros::Publisher::Publisher(ros::Publisher &&)': cannot convert argument 2 from 'std::string' to 'ros::Msg *'  LeapMotion     c:\users\vive-vr-pc\documents\visual studio    2015\projects\leapmotion\leapmotion\leapmotion.cpp    22  
Error (active)  no instance of constructor "ros::Publisher::Publisher" matches the argument list    LeapMotion  c:\Users\Vive-VR-PC\Documents\Visual Studio 2015\Projects\LeapMotion\LeapMotion\LeapMotion.cpp  22  

I am on Visual Studio 2015 and there aren't a lot of tutorial from windows to linux, so I am confused on what to do. Many thanks for the help! :D

Edit: Thanks for the clarity.
So I have modified my code in this way:
#include "stdafx.h"
#include "ros.h"
#include <string>
#include <stdio.h>
#include <Windows.h>
#include <std_msgs\String.h>

int _tmain(int argc, _TCHAR * argv[])
{
    ros::NodeHandle nh;
    char *ros_master = "*.*.*.*";

    printf("Connecting to server at %s\n", ros_master);
    nh.initNode(ros_master);

    printf("Advertising cmd_vel message\n");
    std_msgs::String sent;
    ros::Publisher cmd_vel_pub("try", &sent);
    nh.advertise(cmd_vel_pub);
    while (1) {
        sent.data = "Hello robot";
        cmd_vel_pub.publish(&sent);
        nh.spinOnce();
        Sleep(10);
    }
    printf("All done!\n");
    return 0;
}

But it has not builded yet. Now I have errors related to Windows socket or stuff like that.
1>------ Build started: Project: LeapMotion, Configuration: Debug Win32 ------
1>  LeapMotion.cpp
1>LeapMotion.obj : error LNK2019: unresolved external symbol "public: __thiscall WindowsSocket::WindowsSocket(void)" (??0WindowsSocket@@QAE@XZ) referenced in function "public: __thiscall ros::NodeHandle_<class WindowsSocket,25,25,512,512>::NodeHandle_<class WindowsSocket,25,25,512,512>(void)" (??0?$NodeHandle_@VWindowsSocket@@$0BJ@$0BJ@$0CAA@$0CAA@@ros@@QAE@XZ)
1>LeapMotion.obj : error LNK2019: unresolved external symbol "public: void __thiscall WindowsSocket::init(char *)" (?init@WindowsSocket@@QAEXPAD@Z) referenced in function "public: void __thiscall ros::NodeHandle_<class WindowsSocket,25,25,512,512>::initNode(char *)" (?initNode@?$NodeHandle_@VWindowsSocket@@$0BJ@$0BJ@$0CAA@$0CAA@@ros@@QAEXPAD@Z)
1>LeapMotion.obj : error LNK2019: unresolved external symbol "public: int __thiscall WindowsSocket::read(void)" (?read@WindowsSocket@@QAEHXZ) referenced in function "public: virtual int __thiscall ros::NodeHandle_<class WindowsSocket,25,25,512,512>::spinOnce(void)" (?spinOnce@?$NodeHandle_@VWindowsSocket@@$0BJ@$0BJ@$0CAA@$0CAA@@ros@@UAEHXZ)
1>LeapMotion.obj : error LNK2019: unresolved external symbol "public: void __thiscall WindowsSocket::write(unsigned char const *,int)" (?write@WindowsSocket@@QAEXPBEH@Z) referenced in function "public: virtual int __thiscall ros::NodeHandle_<class WindowsSocket,25,25,512,512>::publish(int,class ros::Msg const *)" (?publish@?$NodeHandle_@VWindowsSocket@@$0BJ@$0BJ@$0CAA@$0CAA@@ros@@UAEHHPBVMsg@2@@Z)
1>LeapMotion.obj : error LNK2019: unresolved external symbol "public: unsigned long __thiscall WindowsSocket::time(void)" (?time@WindowsSocket@@QAEKXZ) referenced in function "public: void __thiscall ros::NodeHandle_<class WindowsSocket,25,25,512,512>::requestSyncTime(void)" (?requestSyncTime@?$NodeHandle_@VWindowsSocket@@$0BJ@$0BJ@$0CAA@$0CAA@@ros@@QAEXXZ)
1>LeapMotion.obj : error LNK2019: unresolved external symbol "void __cdecl ros::normalizeSecNSec(unsigned int &,unsigned int &)" (?normalizeSecNSec@ros@@YAXAAI0@Z) referenced in function "public: void __thiscall ros::NodeHandle_<class WindowsSocket,25,25,512,512>::setNow(class ros::Time &)" (?setNow@?$NodeHandle_@VWindowsSocket@@$0BJ@$0BJ@$0CAA@$0CAA@@ros@@QAEXAAVTime@2@@Z)
1>C:\Users\Vive-VR-PC\Documents\Visual Studio 2015\Projects\LeapMotion\Debug\LeapMotion.exe : fatal error LNK1120: 6 unresolved externals
========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========

Can't understand why. I have included all the libraries I need to.

Originally posted by Leonardo_610 on ROS Answers with karma: 3 on 2017-02-24
Post score: 0

Original comments
Comment by gvdhoorn on 2017-02-24:
I admire your courage, but if you're really just starting out, I would not start with using the "deprecated" (not really, but it's just not maintained very well / at all anymore) Windows VC++ port. Do you have a hard requirement to use it, or would other approaches be acceptable?
Comment by Leonardo_610 on 2017-02-24:
I need to send the coordinates of hands taken with LeapMotion and head taken with HTC Vive to the linux machine. Actually I don't need to use Visual Studio, it is just to start to understand ROS. I would use Unity and C# instead of C++.
Comment by gvdhoorn on 2017-02-24:
Not an answer as we don't solve your problem (so keeping it as a comment): see if uml-robotics/ROS.NET supports enough of ROS to get you where you want. Alternatively, look into rosbridge_suite and use that.
Comment by Leonardo_610 on 2017-02-24:
Ok I will try... thanks for the help. But I would like to know why the code above doesn't work...
Comment by gvdhoorn on 2017-02-24:
I was mistaken actually: I thought you were using win_ros, but it's likely you're actually using rosserial_windows. So ignore my earlier comments.
Comment by gvdhoorn on 2017-02-24:
For future questions: please always include your OS + version, ROS version, the package you are using and links to any tutorials or API docs. That will avoid a lot of potential confusion and possibly even annoyance.
Comment by Leonardo_610 on 2017-02-24:
I am sorry, didn't know exactly how works ROS, that's why.
Comment by gvdhoorn on 2017-02-24:
No problem. We're here to help.

A:

string sent = "Hello robot";
ros::Publisher cmd_vel_pub("try", sent);

That is not a valid way to instantiate a rosserial ros::Publisher instance. wiki/rosserial/Overview/Publishers and Subscribers - Publishing to a topic includes an example:
std_msgs::String str_msg;
ros::Publisher pub("foo", &str_msg);

The second argument to the ctor is a std_msgs::String instance (ie: a rosserial message class), not a regular (std::)string. That is why you get the compiler error.

From the way you've structured your code, I also get the impression that you are thinking of a Publisher as a "high-level" TCP/IP socket: your string sent contains your payload, and you're trying to get cmd_vel_pub to send it to somewhere for you. That is not how this is supposed to work.
Typical flow of control in a regular ROS node (so not in rosserial) is as follows: init the framework, create a NodeHandle, advertise a Publisher (by specifying it's message type and topic name), init a message class instance and then start your processing loop (which is probably a while-loop with one or more Publisher::publish(..) calls and a ros::spinOnce() and ros::Rate::sleep()). For rosserial this is similar, but not identical.
So in your case, you'd init everything (framework, nodehandle, publisher), then enter some while loop and start sending std_msgs::String instances (which you can set to "Hello robot").
If you're really just starting out, it would probably be a good idea to pick up a book or two (wiki/Books: "A Gentle Introduction to ROS" is free) and follow the basic tutorials. The structure of and control flow in a rosserial program will probably make a lot more sense then.

Edit:

So I have modified my code in this way: [..] But it has not builded yet. Now I have errors related to Windows socket or stuff like that. [..] I have included all the libraries I need to.

Well, what you post is a linker error, so it would seem that something is missing.
Have you followed wiki/rosserial_windows/Tutorials/Hello World from Windows? WindowsSocket is a class distributed with rosserial_windows, so something is not configured correctly.

Originally posted by gvdhoorn with karma: 86574 on 2017-02-24
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Leonardo_610 on 2017-02-25:
Yes I fixed that. Thanks! Now it works :D


Q:

ROS UR5e robot arm teleop

Hey guys! I'm currently working on a small project which mainly consists of controlling a UR5e robot arm's movement using my keyboard. The drivers I'm using are the official drivers from this link: https://github.com/UniversalRobots/Universal_Robots_ROS_Driver.
So I have 2 questions:

Can I develop a program which controls the simulation of the robot arm in Gazebo and still use that code to control the arm in real life?
What drivers or topics would I need to access in order to get and write data to and from the robot's joints?

Thank you.

Originally posted by horvath.daniel on ROS Answers with karma: 15 on 2021-06-04
Post score: 0

A:

Depending on what you mean by "teleop" things would have to be implemented differently.
Assuming that you want to do joint velocity control of the robot you can use  the JointGroupVelocityController. With this you basically stream a target velocity for all joints into a ROS topic which will then be executed by the robot. With the gazebo implementation from ur_gazebo this won't work, as it currently only offers a position-based interface. For that method to work, you would have to modify it using a velocity joint interface (See this post as an example implementing a velocity inteface).
However, you could also use URSim instead of gazebo if you just want to have a simulated robot for checking your development and you are not actually doing a physics simulation of your application. An added benefit is, that you can test your application directly using the ur_robot_driver as if you were connecting to a real robot.

In case you would like to do some sort of Cartesian teleoperation you have two choices:

Use some kind of inverse kinematics to generate joint-based motion commands out of your Cartesian commands that can be sent to the robot using the joint-based velocity streaming as explained above.
Use the brandnew Cartesian motion controllers currently being integrated into the driver. With that, you can use the twist_controller to command any Cartesian twists directly to the robot. This solution won't be working with a gazebo simulation, as it uses new hardware interfaces not being implemented in gazebo currently. However, using URSim as a simulation backend would obviously work like the real robot, again.

Originally posted by fexner with karma: 221 on 2021-06-07
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by horvath.daniel on 2021-06-08:
Thank you for your answer! By "teleop" I mean the keyboard control of all the joint movements in the robot, for example, when I press the "W" key the robot arm would move in an upward direction, the "S" key moves the robot arm downward and so on. I'm not too familiar in working with ROS and robotic arms, but I assume that by using the JointGroupVelocityController which you mentioned above I could control only the velocity of the joints, but not their target positions. Is this right?
Comment by fexner on 2021-06-08:
correct, in which case you should look at the second part of my answer.
Comment by gvdhoorn on 2021-06-09:
The description given by @horvath.daniel sounds more like traditional jogging of an industrial robot via the TP keys than "teleop".
Comment by horvath.daniel on 2021-07-12:
Yes, I realized just now that the description I gave was for jogging such a robot. What I actually need is to control the robot's movement in a cartesian space. I have checked out the twist_controller that fexner posted but I don't understand how I can use it. Is the controller meant to be run using rosrun or roslaunch? And is it meant to be run in parallel with the ur_robot_driver?
Comment by fexner on 2021-07-14:
the twist controller expects geometry_msgs/Twist messages as an input, so it's a command of velocities in Cartesian space.
The driver uses ros_control to switch between different controllers. An overview of existing controllers and a quick reference how to switch between them can be found here.
However, doing jogging (where you want to do discrete motions such as "move 2cm down"), might also be achieved using something like jog_control
Comment by horvath.daniel on 2021-07-15:
Thank you for your respones @fexner! I'm starting to understand a little more, although I still don't understand how I can import the repository for twist_controller and run this controller. I've installed the package in my catkin workspace and tried to run it using "rosrun cartesian_ros_control twist_controller" but it tells me that it isn't a package and it can't find an executable for twist_controller.
Comment by fexner on 2021-07-22:
Controllers are not nodes, they are plugins. These plugins are handled by the controller_manager. If my linked guide on switching controllers wasn't enough, you could consider reading controller_manager's documentation
Comment by horvath.daniel on 2021-07-22:
Alright! I understand now! Thanks for all the help!
Comment by Josh Schimdt on 2021-07-26:
Hello! Sorry for intruding on the topic but I was wondering, if I wanted to send some data using rostopic pub to the /joint_group_vel_controller/command topic which seems to use Float64MultiArray message types, what would I need to publish exactly? When I try to send an array of data such as: [0.1 0.1 0.1 0.1 0.1 0.1] I get an message that there are not enough arguments and also
 * Given: ['0.1 0.1 0.1 0.1 0.1 0.1']
 * Expected: ['layout', 'data']

Args are: [layout.dim layout.data_offset data]

Comment by fexner on 2021-07-27:
The short answer: Use a comma-separated list.
For the long answer, please open a new topic, instead if hitch-hiking this one.


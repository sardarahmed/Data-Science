Q:

set_max_velocity_scaling_factor in a cartesian path

Hi,
For a Nextage open on Ubuntu 14 and Ros Indigo , I want to control de velocity in a Cartesian path using waypoints and compute_cartesian_path.
I used set_max_velocity_scaling_factor, but it is not working. As well, it is not giving any error, I change the factor but the robot is running always with the same speed.
I tried set_max_velocity_scaling_factor in a joint path and it is working. It seems that is not working for Cartesian pathes.
Here is my phyton code:
#!/usr/bin/env python
# @file     nextage_moveit_waypoint.py   #
# @brief    Nextage Move it demo program #
# @author   Amir                 #
# @date     2017/01/26                   #
from hironx_ros_bridge.ros_client import ROS_Client
# This should come earlier than later import.
# See http://code.google.com/p/rtm-ros-robotics/source/detail?r=6773
from nextage_ros_bridge import nextage_client

from hrpsys import rtm
import argparse

import sys
import moveit_commander
import copy
import rospy
import geometry_msgs.msg
import unittest
import moveit_msgs.msg

def main():
    rospy.init_node("moveit_command_sender")

    robot = moveit_commander.RobotCommander()
    
    print "=" * 10, " Robot Groups:"
    print robot.get_group_names()

    print "=" * 10, " Printing robot state"
    print robot.get_current_state()
    print "=" * 10 

    rarm = moveit_commander.MoveGroupCommander("right_arm")
    larm = moveit_commander.MoveGroupCommander("left_arm")
    both= moveit_commander.MoveGroupCommander("botharms")
    rhand= moveit_commander.MoveGroupCommander("right_hand")
    lhand= moveit_commander.MoveGroupCommander("left_hand")
    lartor= moveit_commander.MoveGroupCommander("left_arm_torso")
    larm.set_max_velocity_scaling_factor(.01)   

    print "=" * 15, " Right arm ", "=" * 15
    print "=" * 10, " Reference frame: %s" % rarm.get_planning_frame()
    print "=" * 10, " Reference frame: %s" % rarm.get_end_effector_link()
    
    print "=" * 15, " Left ight arm ", "=" * 15
    print "=" * 10, " Reference frame: %s" % larm.get_planning_frame()
    print "=" * 10, " Reference frame: %s" % larm.get_end_effector_link()

    #Right Arm Initial Pose
    rarm_initial_pose = rarm.get_current_pose().pose
    print "=" * 10, " Printing Right Hand initial pose: "
    print rarm_initial_pose

    #Light Arm Initial Pose
    larm_initial_pose = larm.get_current_pose().pose    
    print "=" * 10, " Printing Left Hand initial pose: "
    print larm_initial_pose

    print robot1.get_hand_version()
    robot1.handlight_r(True)
    robot1.handlight_l(True)
    ## Cartesian Paths
    ## ^^^^^^^^^^^^^^^
    ## You can plan a cartesian path directly by specifying a list of waypoints 
    ## for the end-effector to go through.
    waypoints = []

    # start with the current pose
    waypoints.append(larm.get_current_pose().pose)

    # first orient gripper and move forward (+x)
    wpose = geometry_msgs.msg.Pose()
    #wpose.orientation.w = 1.0
    wpose.position.x = waypoints[0].position.x + 0.15
    wpose.position.y = waypoints[0].position.y
    wpose.position.z = waypoints[0].position.z
    wpose.orientation.x = 0.0
    wpose.orientation.y = -0.707
    wpose.orientation.z = 0.0
    wpose.orientation.w = 0.707

    waypoints.append(copy.deepcopy(wpose))

    # second move up
    wpose.position.z += 0.2
    waypoints.append(copy.deepcopy(wpose))

    # third move to the side
    wpose.position.y -= 0.2
    waypoints.append(copy.deepcopy(wpose))

    wpose.position.x = waypoints[0].position.x
    wpose.position.y = waypoints[0].position.y
    wpose.position.z = waypoints[0].position.z
    wpose.orientation.x = 0.0
    wpose.orientation.y = -0.707
    wpose.orientation.z = 0.0
    wpose.orientation.w = 0.707
    waypoints.append(copy.deepcopy(wpose))
    print waypoints

    ## We want the cartesian path to be interpolated at a resolution of 1 cm
    ## which is why we will specify 0.01 as the eef_step in cartesian
    ## translation.  We will specify the jump threshold as 0.0, effectively
    ## disabling it.
    larm.set_max_velocity_scaling_factor(0.01)  
    (plan1, fraction) = larm.compute_cartesian_path(
                           waypoints,   # waypoints to follow
                           0.01,        # eef_step
                           0.0)         # jump_threshold
                           
    print "============ Waiting while RVIZ displays plan3..."
    print rospy.Time.now() 
    rospy.sleep(1)
    print larm.get_known_constraints()
    larm.set_max_velocity_scaling_factor(0.01)  
    larm.execute(plan1)
    
    robot1.handlight_r(False)
    robot1.handlight_l(False)
    
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='hiro command line interpreters')
    parser.add_argument('--host', help='corba name server hostname')
    parser.add_argument('--port', help='corba name server port number')
    parser.add_argument('--modelfile', help='robot model file nmae')
    parser.add_argument('--robot', help='robot modlule name (RobotHardware0 for real robot, Robot()')
    parser.add_argument('--dio_ver', help="Version of digital I/O. Only users "
                        "whose robot was shipped before Aug 2014 need to "
                        "define this, and the value should be '0.4.2'.")
    args, unknown = parser.parse_known_args()
    print args
    print unknown

    if args.host:
        rtm.nshost = args.host
    if args.port:
        rtm.nsport = args.port
    if not args.robot:
        args.robot = "RobotHardware0" if args.host else "HiroNX(Robot)0"
    if not args.modelfile:
        args.modelfile = "/opt/jsk/etc/NEXTAGE/model/main.wrl" if args.host else "" 

    print args.host
    print rtm.nshost

    # support old style format
    if len(unknown) >= 2:
        args.robot = unknown[0]
        args.modelfile = unknown[1]
    robot1 = nxc = nextage_client.NextageClient()
    robot1.init(robotname=args.robot, url=args.modelfile) #This launch hrpsys

    robot1.set_hand_version('0.4.2')

    #ROS Client.
    #ros = ROS_Client()

    try:
        main()
    except rospy.ROSInterruptException:
        pass

I used set_max_velocity_scaling_factor here before compute_cartesian_path and execute, but I checked it once before each command and it doesn change anything.
Thanks

Originally posted by shzargar on ROS Answers with karma: 21 on 2017-03-28
Post score: 2

Original comments
Comment by 130s on 2017-03-30:
Could you update your question with a self-contained code so that we can run it on our computers? I want to see if I can reproduce the issue but imports and variables are not known with the current snippet so that I can't.

A:

The plain and simple answer to this question is:
This doesn't work because nobody required and/or implemented it until now.
The GetCartesianPath.srv ROS service offered by the move_group does not support a max_velocity_scaling_factor in its request section and the MoveGroupCommander uses that service to compute the cartesian trajectory.
So either you have to implement support for this in there, or you have to live with the full-speed trajectory you receive and re-scale the time parameterization afterwards.

Originally posted by v4hn with karma: 2950 on 2017-03-31
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by fvd on 2018-09-19:
Would be really helpful to have code snippets for that here. Related: https://answers.ros.org/question/288989/moveit-velocity-scaling-for-cartesian-path/
Comment by cpdef on 2020-04-21:
@fvd
This is how i did it using the tutorial code:
#include <tf2_geometry_msgs/tf2_geometry_msgs.h>
#include <moveit/trajectory_processing/iterative_time_parameterization.h>
#include <moveit/robot_trajectory/robot_trajectory.h>
...
  // create cartesian path as in the tutorial
  moveit_msgs::RobotTrajectory trajectory;
  moveit_msgs::RobotTrajectory trajectory_slow;
    ...
  // add timing Note: you have to convert it to a RobotTrajectory Object (not message) and back
  trajectory_processing::IterativeParabolicTimeParameterization iptp(100, 0.05);
  robot_trajectory::RobotTrajectory r_trajec(move_group.getRobotModel(), PLANNING_GROUP);
  r_trajec.setRobotTrajectoryMsg(*move_group.getCurrentState(), trajectory);
  iptp.computeTimeStamps(r_trajec, 1, 1);
  r_trajec.getRobotTrajectoryMsg(trajectory);
  iptp.computeTimeStamps(r_trajec, 0.03, 0.03);
  r_trajec.getRobotTrajectoryMsg(trajectory_slow);

Comment by benedikt on 2022-05-05:
Thanks, this works for me. I just had to change the message namespace to get it running with Moveit2 (Galactic binary).
moveit_msgs::msg::RobotTrajectory trajectory;
moveit_msgs::msg::RobotTrajectory trajectory_slow;


Q:

Dealing with sleeps in rostest

I am trying to use rostest (coupled with gtest) to do some black box testing of our ROS nodes. So, naturally, if I am to test some node, the launch file for rostest will look like this:
<launch>
  <node (start the node under test here) ... ></node>
  <test (start the node, that will call the other node's public interfaces) ...></test>
</launch>

Naturally, the node under test might have some sleeps in it. After all, most of the time you only have to do things at some predefined rate. Of course, waiting for those sleeps to pass will introduce delays in the test. Those delays might contribute significantly to the total running time of the test suite. Unless something is done.
Is there any universal approach to this problem? One thing I can think of is using /use_sim_time parameter in the launch  file and writing my own "time server" (should be trivial), that publishes "accelerated time" to the /clock topic. This might help with the delays a bit, but it will, obviously, not eliminate them completely.
Any other ideas? This seems like a fairly common problem one might encounter while performing black box testing.

Originally posted by shylent on ROS Answers with karma: 21 on 2018-01-23
Post score: 1

Original comments
Comment by gvdhoorn on 2018-01-24:\

After all, most of the time you only have to do things at some predefined rate

I'm not sure that is such a universally true statement in an event-based, asynchronous publish-subscribe robotics framework ..

A:

One thing you can do for tests that you know will run longer is to use the time-limit tag. See the rostest wiki for a description and example. Your example would look something like this if you wanted a 20 minute timeout:
<launch>
  <node (start the node under test here) ... ></node>
  <test (start the node, that will call the other node's public interfaces) ...> time-limit="1200.0"</test>
</launch>

Note that the default value for time-limit is 60 seconds.
If you want to speed up the processing for your node you will have to go a different route, potentially something like you suggested with the time server (although I'm not convinced it would be trivial). However, in my experience it is not common to have nodes that sleep for any significant amount of time. I would be surprised if compensating for sleeping nodes in unit tests is a fairly common problem. It might be worthwhile to consider a refactor of your node that sleeps for long periods.

Originally posted by Thomas D with karma: 4347 on 2018-01-24
This answer was ACCEPTED on the original site
Post score: 1


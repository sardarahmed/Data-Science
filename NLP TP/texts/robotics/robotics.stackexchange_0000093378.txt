Q:

nodelets problem

Hi. I'm trying to create a custom pgk with nodelets.
I read already manual http://wiki.ros.org/nodelet/Tutorials/Porting%20nodes%20to%20nodelets
And for more understanding I use the pkg: https://github.com/tysik/obstacle_detector
And I got error
[ERROR] [1569303210.735895568]:Loader::load Failed to load nodelet [/test_nodelet1] of type [safety_zones/TestNodelet1] even after refreshing the cache: MultiLibraryClassLoader: Could not create object of class type safety_zones::TestNodelet1Nodelet as no factory exists for it. Make sure that the library exists and was explicitly loaded through MultiLibraryClassLoader::loadLibrary()
[ERROR] [1569303210.735951283]:Loader::load The error before refreshing the cache was: MultiLibraryClassLoader: Could not create object of class type safety_zones::TestNodelet1Nodelet as no factory exists for it. Make sure that the library exists and was explicitly loaded through MultiLibraryClassLoader::loadLibrary()

Any help, please. Thank you!
CMakeList.txt
cmake_minimum_required(VERSION 2.8.3)
project(safety_zones)

## Compile as C++11, supported in ROS Kinetic and newer
# add_compile_options(-std=c++11)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

## Find catkin macros and libraries
## if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz)
## is used, also find other catkin packages
find_package(catkin REQUIRED COMPONENTS
  roscpp
  roslaunch
  sensor_msgs
  std_msgs
  std_srvs
  pluginlib
  nodelet
)

###################################
## catkin specific configuration ##
###################################
## The catkin_package macro generates cmake config files for your package
## Declare things to be passed to dependent projects
## INCLUDE_DIRS: uncomment this if your package contains header files
## LIBRARIES: libraries you create in this project that dependent projects also need
## CATKIN_DEPENDS: catkin_packages dependent projects also need
## DEPENDS: system dependencies of this project that dependent projects also need
catkin_package(
  INCLUDE_DIRS include
  LIBRARIES test_nodelet1 test_nodelet2 ${PROJECT_NAME}_nodelets
  CATKIN_DEPENDS
    roscpp
    roslaunch
    sensor_msgs
    std_msgs
    std_srvs
    pluginlib
    nodelet
#  DEPENDS system_lib
)

###########
## Build ##
###########

## Specify additional locations of header files
## Your package locations should be listed before other locations
include_directories(
 include
  ${catkin_INCLUDE_DIRS}
)

## Declare a C++ library

add_library(test_nodelet1 src/test_nodelet1.cpp)
target_link_libraries(test_nodelet1 ${catkin_LIBRARIES})
add_dependencies(test_nodelet1 ${catkin_EXPORTED_TARGETS})

add_library(test_nodelet2 src/test_nodelet2.cpp)
target_link_libraries(test_nodelet2 ${catkin_LIBRARIES})
add_dependencies(test_nodelet2 ${catkin_EXPORTED_TARGETS})

#
# Build nodes
#

add_executable(test_nodelet1_node src/nodes/test_nodelet1_node.cpp)
target_link_libraries(test_nodelet1_node test_nodelet1)

add_executable(test_nodelet2_node src/nodes/test_nodelet2_node.cpp)
target_link_libraries(test_nodelet2_node test_nodelet2)

#
# Build nodelets
#
add_library(${PROJECT_NAME}_nodelets
  src/nodelets/test_nodelet1_nodelet.cpp
  src/nodelets/test_nodelet2_nodelet.cpp)
target_link_libraries(${PROJECT_NAME}_nodelets test_nodelet1 test_nodelet2)

#
# Install libraries
#
install(TARGETS test_nodelet1 test_nodelet2 ${PROJECT_NAME}_nodelets 
  ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
  LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
  RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION})

#
# Install nodes
#
install(TARGETS test_nodelet1_node test_nodelet2_node
  RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})

#
# Install header files
#
install(DIRECTORY include/${PROJECT_NAME}/
  DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION})

#
# Install nodelet #and rviz plugins description
#
install(FILES nodelet_plugins.xml
  DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION})

package.xml
<?xml version="1.0"?>
<package format="2">
  <name>safety_zones</name>
  <version>0.0.0</version>
  <description>The safety_zones package</description>

  <!-- One maintainer tag required, multiple allowed, one person per tag -->
  <!-- Example:  -->
  <!-- <maintainer email="jane.doe@example.com">Jane Doe</maintainer> -->
  <maintainer email=""></maintainer>

  <license>TODO</license>
   <buildtool_depend>catkin</buildtool_depend>

  <build_depend>roscpp</build_depend>
  <build_depend>roslaunch</build_depend>
  <build_depend>sensor_msgs</build_depend>
  <build_depend>std_msgs</build_depend>
  <build_depend>std_srvs</build_depend>
  <build_export_depend>roscpp</build_export_depend>
  <build_export_depend>roslaunch</build_export_depend>
  <build_export_depend>sensor_msgs</build_export_depend>
  <build_export_depend>std_msgs</build_export_depend>
  <build_export_depend>std_srvs</build_export_depend>
  <exec_depend>roscpp</exec_depend>
  <exec_depend>roslaunch</exec_depend>
  <exec_depend>sensor_msgs</exec_depend>
  <exec_depend>std_msgs</exec_depend>
  <exec_depend>std_srvs</exec_depend>
  <exec_depend>pluginlib</exec_depend>
  <build_depend>pluginlib</build_depend>
  <build_depend>nodelet</build_depend>
  <exec_depend>nodelet</exec_depend>

  <!-- The export tag contains other, unspecified, tags -->
  <export>
    <nodelet plugin="${prefix}/nodelet_plugins.xml" />
  </export>
</package>

nodelet_plugins.xml
<library path="lib/libsafety_zones">

  <class name="safety_zones/TestNodelet1" 
         type="safety_zones::TestNodelet1Nodelet" 
         base_class_type="nodelet::Nodelet">
    <description>
      TestNodelet1
    </description>
  </class>

  <class name="safety_zones/TestNodelet2" 
         type="safety_zones::TestNodelet2Nodelet" 
         base_class_type="nodelet::Nodelet">
    <description>
      TestNodelet2
    </description>
  </class>
</library>

test_nodelet1.h
#pragma once
#include <ros/ros.h>

#include <sensor_msgs/LaserScan.h>

namespace safety_zones
{
class TestNodelet1
{
public:
  TestNodelet1(ros::NodeHandle& nh, ros::NodeHandle& nh_local);
  ~TestNodelet1();

private:
  ros::Subscriber scan_sub_;
  ros::Publisher scan_pub_;
  void scanCallback(const sensor_msgs::LaserScan::ConstPtr &msg);
};

} // namespace safety_zones

test_nodelet1.cpp
#include <safety_zones/test_nodelet1.h>

using namespace safety_zones;

TestNodelet1::TestNodelet1(ros::NodeHandle& nh, ros::NodeHandle& nh_local)
{
  ROS_INFO_STREAM("init TestNodelet1");
  scan_sub_ = nh.subscribe<sensor_msgs::LaserScan>("/scan_back", 1, &TestNodelet1::scanCallback, this);
  scan_pub_ = nh.advertise<sensor_msgs::LaserScan>("/scan_test", 1);
}
TestNodelet1::~TestNodelet1()
{
}

void TestNodelet1::scanCallback(const sensor_msgs::LaserScan::ConstPtr &msg)
{
  ROS_INFO_STREAM("first_callback");
  scan_pub_.publish(msg);
}

test_nodelet1_nodelet.cpp
#include <memory>
#include <nodelet/nodelet.h>

#include "safety_zones/test_nodelet1.h"

namespace safety_zones
{

class TestNodelet1Nodelet : public nodelet::Nodelet
{
public:
  virtual void onInit()
  {
    ROS_INFO_STREAM("111");
    ros::NodeHandle nh = getNodeHandle();
    ros::NodeHandle nh_local = getPrivateNodeHandle();

    try
    {
      NODELET_INFO("[TestNodelet1]: Initializing nodelet");
      test_nodelet1_ = std::shared_ptr<TestNodelet1>(new TestNodelet1(nh, nh_local));
    }
    catch (const char *s)
    {
      NODELET_FATAL_STREAM("[TestNodelet1]: " << s);
    }
    catch (...)
    {
      NODELET_FATAL_STREAM("[TestNodelet1]: Unexpected error");
    }
  }

  // virtual ~TestNodelet1Nodelet()
  // {
  //   NODELET_INFO("[TestNodelet1]: Shutdown");
  // }

private:
  std::shared_ptr<TestNodelet1> test_nodelet1_;
};

} // namespace safety_zones

#include <pluginlib/class_list_macros.h>
PLUGINLIB_EXPORT_CLASS(safety_zones::TestNodelet1Nodelet, nodelet::Nodelet)

my launch file
<!-- Demonstation of obstacle detector -->
<launch>
  <node name="nodelet_manager" pkg="nodelet" type="nodelet" args="manager" output="screen">
    <param name="num_worker_threads" value="20"/>
  </node>

  <node name="test_nodelet1" pkg="nodelet" type="nodelet" args="load safety_zones/TestNodelet1 nodelet_manager" output="screen">
  </node>
<!-- 
  <node name="test_nodelet2" pkg="nodelet" type="nodelet" args="load safety_zones/TestNodelet2 nodelet_manager">
  </node> -->

</launch>
<!-- -->

Originally posted by listenreality on ROS Answers with karma: 3 on 2019-09-24
Post score: 0

Original comments
Comment by gvdhoorn on 2019-09-24:
I would first check whether things work without forcing C++17 in your own package.
Plugin loading works by being able to introspection and by assuming certain functions/methods exist in your .so. But that requires ABI between the host and the library.
ROS Melodic is not compiled with C++17 enabled, so it may be that by forcing it in your nodelet, you're breaking ABI causing the plugin loader unable to load (or: find) your nodelet.
Everything could be fine ABI-wise, but it's easy to check and if it is the cause, prevents us from checking all sorts of other things.
Comment by listenreality on 2019-09-24:
@gvdhoorn so, I changed it to C++11, and still got the error

A:

Are you sure about this ? In your CMakeList you declare the library with add_library(${PROJECT_NAME}_nodelets so you should change libsafety_zones for libsafety_zones_nodelets or remove the _nodelets within the CMakeList.

Originally posted by Delb with karma: 3907 on 2019-09-24
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by gvdhoorn on 2019-09-24:
Ah, @Delb's comment is probably the answer here.
I would still be careful with forcing C++17 in a package that basically requires ABI compatibility with the host that is going to load it, but not listing the correct library name is going to be an even bigger problem.
Comment by listenreality on 2019-09-24:
@Delb  Thanks, that helped!


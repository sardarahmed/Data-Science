Q:

ROS_INFO not printing anything after some point

In my code below, constructor of a class calls functions within the same class. All ROS_INFO in func1 print successfully but func2 doesn't print anything. Any idea?
Update 8/13/2012) Each action server is robot manipulation, which means there's fair amount of time before func2 gets called after func1.
#include <ros/ros.h>
#include <actionlib/client/simple_action_client.h>
#include <actionlib/client/terminal_state.h>
#include <pointcloud_filter/PointCloudFilterBoxAction.h>
#include <pointcloud_filter/PointCloudFilterBoxGoal.h>
#include <pointcloud_segmenter/RGBPointCloudSegmenterAction.h>
#include <pointcloud_segmenter/RGBPointCloudSegmenterGoal.h>

class OurClass
{
public:
    static const double DURATION = 30.0;
    OurClass()
    {
        this->func1();
        this->func2();
    }
    void func1()
    {
        ROS_INFO("msg 1-0");
        actionlib::SimpleActionClient<ourns::OurAction> ac("ourAction", true);
        bool finished_before_timeout = ac.waitForResult(ros::Duration(DURATION));
        if (finished_before_timeout)
        {
            actionlib::SimpleClientGoalState state = ac.getState();
            ROS_INFO("msg 1-1");
        }
        else
            ROS_INFO("msg 1-2");
    }

    void func2()
    {
        ROS_INFO("msg 2-0 ");
        actionlib::SimpleActionClient<pointcloud_filter::PointCloudFilterBoxAction> ac_filter("PointCloudFilterBox", true);
        ac_filter.sendGoal(goal_filter);
        bool finished_before_timeout2 = ac_filter.waitForResult(ros::Duration(DURATION));
        if (finished_before_timeout2)
        {
            actionlib::SimpleClientGoalState state = ac_filter.getState();
            ROS_INFO("2-1");
        }
        else
            ROS_INFO("2-2");
    }
};

int main(int argc, char **argv)
{
    ros::init(argc, argv, "AcClient");
    OurClass();
}

Environment) fuerte, Ubuntu 10.04

Originally posted by 130s on ROS Answers with karma: 10937 on 2012-08-12
Post score: 1

A:

If the code you posted really is 'all there is', then it seems to at least be missing a ros::spin() or similar statement. If the ros event loop is run somewhere else, the ros::init(..) seems out of place.
What is most likely going on is that the ros logging subsystem has 'enough' time to flush out the ROS_INFO(..) calls in func1(), but not for those in func2(). I've noticed this myself a few times, especially when trying to print some output at node(let) shutdown (to print statistics for instance).
Suggestions I've received included 'sleeping some time' before calling ros::shutdown(..) (if doing so explicitly) or before returning from your main.

Originally posted by ipso with karma: 1416 on 2012-08-13
This answer was ACCEPTED on the original site
Post score: 4

Original comments
Comment by 130s on 2013-03-28:
Looks reasonable explanation although I can't test it since I don't have an access to the environment I was seeing the phenomenon...


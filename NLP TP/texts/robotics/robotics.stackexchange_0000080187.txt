Q:

How do I handle quaternions?

I have read many tutorials and publications on the subject; however, I am still unclear on how to use them for causing rotation. I am working on an AUV, and I see that quaternions seem to be fundamental to motion. Are there any recommended learning materials that could help me to get a complete understanding of using them with robot motion? I am very new to ROS, so I greatly appreciate any response.

Originally posted by mclambchops on ROS Answers with karma: 7 on 2017-04-13
Post score: 0

A:

There are at least three popular ways to specify a rotation in 3-D.

3x3 rotation matrix (or 4x4 matrix in homogeneous co√∂rdinates)
Euler angles (such as angles of roll, pitch, and yaw, often X, Y, and Z axis rotations, though there are many variations on Euler angles)
Quaternions (specifies an axis of rotation and an angle of rotation about that axis)

The main thing to know about a quaternion is that it encodes two things in a 4-tuple: 1) an axis of rotation (a 3-D vector), and 2) an angle of rotation, measured as the counter-clockwise rotation in radians about that vector (right-hand rule). This can represent any 3-D rotation using four elements, only slightly more memory than used by Euler angles, and considerably less than the matrix representation.
The 4-tuple quaternion mixes the axis of rotation and angle in a strange way. Let's say the axis of rotation is the vector <x, y, z> and the angle of rotation is theta, measured as the right-hand rotation in radians about <x, y, z>. Then the quaternion that represents that rotation is:
<cos(theta/2), x*sin(theta/2), y*sin(theta/2), z*sin(theta/2)>

That's really all there is to it, it's just a fairly compact representation of an arbitrary rotation. Quaternions have several advantages over Euler angles and matrix representations.

More compact than matrix representations.
Can perform rotations with fewer multiplications, and mathematically more stable.
Can interpolate rotations component-by-component to generate intermediate states smoothly.
No "gimbal lock" problem. (Google this.)

(Note: There are actually multiple forms of quaternion representations, but only one in ROS.)

Originally posted by Mark Rose with karma: 1563 on 2017-04-14
This answer was ACCEPTED on the original site
Post score: 8

Original comments
Comment by NEngelhard on 2017-04-14:
One small point: There are libraries in ROS that cover all the computation of quaternions (transforming them to or from rotation matrices for example) so you do not need to implement a quaterion-quaternion multiplication by hand. I can't transform a point with a quat by hand and still work with it.
Comment by Mark Rose on 2017-04-14:
Yes, certainly. I didn't mean to imply that one should implement the manipulations. I was just trying to demystify quaternions a little. (The algebra definition using i, j, k can be daunting, whereas if you think about axis of rotation and angle they aren't mysterious at all.)
Comment by mclambchops on 2017-04-14:
Thanks for your responses. This definitely demystifies things for me.
Comment by eugene.katsevman on 2017-04-14:
please, accept this answer then
Comment by Mark Rose on 2017-04-17:
Yes, please accept the answer. It's easier for others to find good answers if they are accepted.


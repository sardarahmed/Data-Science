Q:

Is it possible to query the result of the action server?

Hello,
I'd like to use polling instead of callbacks.
Is it possible to query the result of the action server as it was the case in ROS1 with action_client->get_state() ?
I can't find an equivalent in ROS2 Humble.
Clement

Originally posted by Acwok on ROS Answers with karma: 85 on 2023-03-23
Post score: 0

A:

In ROS 2 Humble, when you send out a goal with "async_send_goal", assign the returned future goal handle to a variable. When you need to query for the result, you can just call "async_get_result" or "async_result" (deprecated). For example:
auto future_goal_handle = client_ptr_->async_send_goal(goal_msg, send_goal_options);
rclcpp::spin_until_future_complete(node, future_goal_handle);
auto result = client_ptr_-> async_get_result(future_goal_handle.get());
if (result.get().code == rclcpp_action::ResultCode::SUCCEEDED)
{
    return true;
}

Note that the "result" you get is a WrappedResult, so if you want the result message, you need to do something like:
result.get().result

You can also query for goal status through the client goal handle with "get_status" if you are comparing with action_client->get_state() instead.

Originally posted by GuimingChen with karma: 56 on 2023-03-23
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by Acwok on 2023-03-23:
Thank you @GuimingChen!
Comment by Acwok on 2023-03-23:
@GuimingChen The execution get stucked at auto result = client_ptr_-> async_get_result(future_goal_handle.get()); :(
The action is well executed though
Comment by GuimingChen on 2023-03-23:
hmm... interesting, I thought this should return immediately since it is a std::shared_future.
Did it give you any error message?
Can you print something in the server side to check which status the goal is currently in when it got stucked? You can try access the goal status in handle accepted callback.
Comment by Acwok on 2023-03-23:
No, there is no error, it just block at the async_get_result() call.
On the server side, the _execute() callback is correctly executed, I can see the message "Goal succeeded" in the terminal.
void SpacecraftController::change_si_state_execute(const std::shared_ptr<GoalHandleChangeSIState> goal_handle)
{
    RCLCPP_INFO(this->get_logger(), "Executing goal");
    const auto goal = goal_handle->get_goal();

    auto result = std::make_shared<ChangeSIState::Result>();
    if (emitSiCmd(*goal))
    {
        result->nb_si_handled = goal->si_list.size();
        goal_handle->succeed(result);
        RCLCPP_INFO(this->get_logger(), "Goal succeeded");
    }
}

Comment by Acwok on 2023-03-23:
The goal status in the _accepted() callback is is_active=1, is_executing=1 and is_canceling=0
Comment by Acwok on 2023-03-23:
The goal status at the end of the _execute() callback is is_active=0, is_executing=0 and is_cancelling=0
Comment by Acwok on 2023-03-23:
Actually there is an error if I kill the blocking node with CTRL+C:
    [ERROR] [1679587180.654655117] [rclcpp]: caught std::exception exception when uninstalling signal handlers in rclcpp::~SignalHandler: Invalid argument
cannot publish data, at ./src/rmw_publish.cpp:62 during '__function__'
    [ERROR] [1679587180.656454559] [sequencer.rclcpp]: Error in destruction of rcl subscription handle: Failed to delete datareader, at ./src/subscription.cpp:52, at ./src/rcl/subscription.c:183
cannot publish data, at ./src/rmw_publish.cpp:62 during '__function__'
    Fail in delete datareader, at ./src/rmw_service.cpp:104 during '__function__'
    [ros2run]: Segmentation fault

Comment by Acwok on 2023-03-23:
I tried
auto future_goal_handle = action_client->async_send_goal(goal_msg, send_goal_options);
RCLCPP_INFO(node->get_logger(), "Goal handle valid =%d", future_goal_handle.valid());
RCLCPP_INFO(node->get_logger(), "Goal status =%d", future_goal_handle.get().get()->get_status()); 

future_goal_handle.valid() returns 1
future_goal_handle.get() blocks the execution
Comment by Acwok on 2023-03-23:
Maybe it is related with this open issue: https://github.com/ros2/rclcpp/issues/2130
Comment by GuimingChen on 2023-03-23:
Oh, and I just realized that I forgot to add rclcpp::spin_until_future_complete to block the waiting until the future is ready. Based on the documentation, This doc page did mention that "A future that completes when the goal has been accepted or rejected." Maybe worth give it a shot to add the following code before calling future_goal_handle.get():
rclcpp::spin_until_future_complete(node, future_goal_handle);

Comment by GuimingChen on 2023-03-23:
you may need node->get_node_base_interface() depending on what exactly the node here mean
Comment by Acwok on 2023-03-24:
It is indeed the spin_until_future_complete() that was missing.
Thank you @GuimingChen !


Q:

OpenCV and ROS melodic using python3

Hi,
I would like to subscribe to the camera topic of my robot and use this images in openCV. Unfortunatly, I need to use Python3 in melodic because of the robot, so using cv_bridge seems not to work. I found the following sourcecode as solution at another question, adapted it to my problem, but won't get it working.
Is someone keen to help me or is there another solution for this problem?
#!/usr/bin/env python3
import rospy
from sensor_msgs.msg import Image
import cv2 as cv
import numpy as np
from geometry_msgs.msg import Twist
import sys

def callback():
    pass

def imgmsg_to_cv2(img_msg):
    img_msg = Image()
    if img_msg.encoding != "bgr8":
        rospy.logerr("This Coral detect node has been hardcoded to the 'bgr8' encoding.  Come change the code if you're actually trying to implement a new camera")
    dtype = np.dtype("uint8") # Hardcode to 8 bits...
    dtype = dtype.newbyteorder('>' if img_msg.is_bigendian else '<')
    image_opencv = np.ndarray(shape=(img_msg.height, img_msg.width, 3), # and three channels of data. Since OpenCV works with bgr natively, we don't need to reorder the channels.
                    dtype=dtype, buffer=img_msg.data)
    # If the byt order is different between the message and the system.
    if img_msg.is_bigendian == (sys.byteorder == 'little'):
        image_opencv = image_opencv.byteswap().newbyteorder()
    cv.imshow("Video", image_opencv)
    return image_opencv

cv_image = rospy.Subscriber("/robot/front_rgbd_camera/rgb/image_raw", Image, callback )

if __name__ =="__main__":
    imgmsg_to_cv2(cv_image)

Originally posted by FarmRobo on ROS Answers with karma: 1 on 2022-05-16
Post score: 0

A:

Hi,
you can use numpy instaed of cv_bridge. Get the data from callback, reshape and normalize it. That's how you can use python3 with melodic. Below is the example:
#!/usr/bin/env python3
import rospy
from sensor_msgs.msg import Image
import cv2 as cv
import numpy as np
from geometry_msgs.msg import Twist
import sys

def callback(data):
    image_a = np.frombuffer(data.data, dtype=np.uint16).reshape(data.height,data.width,-1)
    image = cv.normalize(image_a, None, 0, 255, cv2.NORM_MINMAX, cv2.CV_8U)
    cv.imshow("opencv ros image", image)

if __name__ =="__main__":
    cv_image = rospy.Subscriber("/robot/front_rgbd_camera/rgb/image_raw", Image, callback )

Play with the dtype according to your image type. Hope it works!

Originally posted by Dhara with karma: 16 on 2022-05-16
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by FarmRobo on 2022-05-16:
I tried your Idea, but will get an error in
in callback
image_a = np.frombuffer(data, dtype=np.uint32).reshape(data.height,data.width)
TypeError: a bytes-like object is required, not 'Image'
Comment by Dhara on 2022-05-16:
try this : np.frombuffer(data.data, dtype=np.int32).reshape(data.height,data.width)
Comment by FarmRobo on 2022-05-16:
now I get an ValueError: cannot reshape array of size 230400 into shape (480,640)
Comment by Dhara on 2022-05-16:
You have to input your image type in â€˜dtypeâ€™. The error you got states the same that your image topic is not of type int32.
Comment by FarmRobo on 2022-05-16:
I tried different types, but there was a -1 in reshape missing. Now its working, Thank you very much!
image_a = np.frombuffer(data.data, dtype=np.uint8).reshape(data.height,data.width,-1)

Comment by Dhara on 2022-05-17:
perfect. Then can you please accept my answer?


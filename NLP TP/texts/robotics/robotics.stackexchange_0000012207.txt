Q:

RobotC Code Malfuncion (VEX Robotics Clawbot)

I have a standard VEX Clawbot, which I've been trying to make go straight for some time. 
I've been following this guide:
http://www.education.rec.ri.cmu.edu/products/cortex_video_trainer/lesson/3-5AutomatedStraightening2.html
This is my code:
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void GOforwards()
{
    nMotorEncoder[rightMotor]=0;
    nMotorEncoder[leftMotor]=0;
    int rightEncoder = abs(nMotorEncoder[rightMotor]);
    int leftEncoder = abs(nMotorEncoder[leftMotor]);

    wait1Msec(2000);
    motor[rightMotor] = 60;
    motor[leftMotor] = 60;

    while (rightEncoder < 2000)
    {
        if (rightEncoder > leftEncoder)
        {
            motor[rightMotor] = 50;
            motor[leftMotor] = 60;
        }
        if (rightEncoder < leftEncoder)
        {           
            motor[rightMotor] = 60;
            motor[leftMotor] = 50;
        }
        if (rightEncoder == leftEncoder)
        {
            motor[rightMotor] = 60;
            motor[leftMotor] = 60;
        }
    }
    motor[rightMotor] = 0;
    motor[leftMotor] = 0;
}

task main()
{
GOforwards();
}

I am using integrated Encoders.
When I run the code my robot runs without stopping and the Encoder values diverge quickly. This is a video of the code running from the debugger windows:
https://www.youtube.com/watch?time_continue=2&v=vs1Cc3xnDtM
I am not sure why the power to the wheels never changes, or why it seems to believe that the Encoder values are equal... much less why it runs off into oblivion when the code should exit the while loop once the right encoder's absolute value exceeds 2000.
Any help would be appreciated.

A:

It looks like you don't ever update the encoder values after you initialize them. The problem seems to be that maybe you're thinking that the left and right encoder values will update automatically, but that is generally not the case. The exception might be if those variable names are actually protected variable names that have special meaning in your development environment - more on that later. 
I don't know about VEX robotics, but I'll caution you that your left and right encoders are based on nMotorEncoder and, just like how leftEncoder and rightEncoder doesn't get updated anywhere in your loop, nMotorEncoder doesn't get updated anywhere either.
So, that said, try using the following:
void GOforwards()
{
    nMotorEncoder[rightMotor]=0;
    nMotorEncoder[leftMotor]=0;
    int rightEncoder = abs(nMotorEncoder[rightMotor]); // <----- Define
    int leftEncoder = abs(nMotorEncoder[leftMotor]);   // <----- Define

    wait1Msec(2000);
    motor[rightMotor] = 60;
    motor[leftMotor] = 60;

    while (rightEncoder < 2000)
    {
        rightEncoder = abs(nMotorEncoder[rightMotor]); // <----- Update
        leftEncoder = abs(nMotorEncoder[leftMotor]);   // <----- Update

        if (rightEncoder > leftEncoder)
        {
            motor[rightMotor] = 50;
            motor[leftMotor] = 60;
        }
        if (rightEncoder < leftEncoder)
        {           
            motor[rightMotor] = 60;
            motor[leftMotor] = 50;
        }
        if (rightEncoder == leftEncoder)
        {
            motor[rightMotor] = 60;
            motor[leftMotor] = 60;
        }
    }
    motor[rightMotor] = 0;
    motor[leftMotor] = 0;
}

By adding the two lines inside the while loop, now you are checking and updating the encoder counts every time you step into a new loop. This is one of the tricky things with debugging - you have to be looking at the correct variables! In your video, you are looking at leftMotor and rightMotor, and what appears to be fields for those motors. 
You were NOT looking at the actual variables that control which case gets selected! Those variables are leftEncoder and rightEncoder. 
And again, final warning - it looks like you're counting on things like motor and nMotorEncoder to be function names or keywords that do something, because otherwise it just looks like you enter an infinite loop that never actually writes any values to the motors. 
I would have expected something more along the lines of a speed assignment followed by writing that speed to a function, but that second step never happens. For example, I would have thought you'd do something like the following:
motor[leftMotor] = 60;
motor[rightMotor] = 60;
WriteMotorSpeed(motor);

But that last function, WriteMotorSpeed() never happens. Similarly, there is no function that returns an updated encoder count. Here too it looks like you're expecting the nMotorEncoder variable name to auto-magically update, where I would have expected you to need to call a function that returns an updated value, like the following:
nMotorEncoder = GetEncoderCounts([leftMotor,rightMotor]);

or something similar. 
I could absolutely be wrong; it looks like you're using ROBOTC, and also it's VEX robotics, so there could 100% be a set of pre-defined keywords or key variable names that hold special meaning in that development environment, but again I'm just pointing out what I see versus what I would expect to see. I would highly suggest you check the documentation to see if those values automatically update or if there is, in fact, a function you should be calling to read/write encoder counts and motor speeds. 


Q:

Parameters for camera_pose_calibration

I'm trying to use the camera_pose_calibration package, which seems easy to use. Thank you! Can you help me understand some of the parameters:
PatternParameters pattern_width: Is this the # of dots in a row?
PatternParameters pattern_height: # of dots in a column?
PatternParameters pattern_distance: distance between circle centers? in meters?
neighbor_distance: The readme says this is distance between pixels. In meters, I guess? I think this should be a small number with a RealSense camera, like 0.1mm
Finally, is this OpenCV "asymmetric circle grid" the type of pattern to use?

Originally posted by AndyZe on ROS Answers with karma: 2331 on 2017-03-27
Post score: 0

Original comments
Comment by gvdhoorn on 2017-03-28:
Are you referring to the old version, or the new package?
Comment by AndyZe on 2017-03-28:
This one: camera_pose_calibration
Comment by gvdhoorn on 2017-03-28:
Yeah, so the Indigo version?
Comment by AndyZe on 2017-03-28:
Ah, yes. Indigo.

A:

The parameters that worked for me with a RealSense R200 and the circles pattern from https://nerian.com/support/resources/patterns/ (printed on US letter size) were:
srv.request.tag_frame = "calibration_circles_frame"; // This is defined in a URDF. It's known.
srv.request.camera_frame = "camera_ee_depth_frame"; // Unknown pose. Find its relation to target_frame
srv.request.target_frame = "base_link"; // This is defined in a URDF. It's fixed

  camera_pose_calibration::PatternParameters circle_pattern;
  circle_pattern.pattern_width = 4; // 4 circles wide
  circle_pattern.pattern_height = 11; // 11 circles long
  circle_pattern.pattern_distance = 0.038; // Distance between circle centers. [m]
  circle_pattern.neighbor_distance = 1; // Expected distance between pixels of image
  circle_pattern.valid_pattern_ratio_threshold = 0.5; // Min. ratio of valid pixels to NaN's
  srv.request.pattern = circle_pattern;

I still had an unexplained 45 degree rotation and a Z-offset, but those were easy enough to correct manually. So it was easier than calibrating by hand, for sure.
The RealSense is more tricky than most cameras, I think, because the point cloud is published in the frame camera_depth_optical_frame, which is a child of camera_depth_frame. So camera_depth_frame is what actually needs to be attached to camera_link in the URDF. Maybe this was the cause of the extra rotation -- which I corrected for with an extra transformation matrix.

Originally posted by AndyZe with karma: 2331 on 2017-04-25
This answer was ACCEPTED on the original site
Post score: 0


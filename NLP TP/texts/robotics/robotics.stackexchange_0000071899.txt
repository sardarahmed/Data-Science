Q:

Using a joint with motor on other than parent link thru Transmission

I have made a custom robot arm and I'm making an URDF file for that.
situation:

lower arm, mounted on base
upper arm mounted on lower arm
motor for upper arm mounted on base
motor and upper arm connected via belt.

I've searched in the tutorials on URDF and "transmissions" came up.
http://wiki.ros.org/urdf/XML/Transmission
Are there some examples or best practices on how to set up this situation in the URDF model so I can have correct behaviour in Moveit etc?
edit:
With correct behaviour I mean generated trajectories that match the situation
Thanks in advance,
Bas

Originally posted by Bas on ROS Answers with karma: 5 on 2016-02-10
Post score: 0

A:

Tbh: I don't think you necessarily need to use transmissions for this.
Transmissions can be useful, but I'm not sure how useful if you have a simple position controlled manipulator that you wish to make ROS-compatible.
The level at which most control nodes / ros_control controllers interact with hardware of this kind is at the (abstract) joint level, where the specifics about how that joint is finally controlled (and through which mechanism) isn't necessarily available / important. As long as the set of joints you model in your URDF (and thus 'expose' to the rest of ROS (ie: MoveIt, etc)) can be controlled in some way to execute the planned motion, things should just worktm.
Things to check / take care of (off the top of my head):

make sure all axis definitions in joints correspond to your hardware (ie: 1 for "positive angle increase maps to positive rotation of frame" and -1 for the inverse)
have a controller capable of consuming JointTrajectory messages that is able to map between URDF joint names and your hardware / lower level controller (either something custom or using any one of the available abstractions (ros_control fi))
make sure origins of URDF joints correspond with their locations in your real system (don't just assume things are ok because your EEF frame ends up in the right Cartesian location)
define position, velocity, acceleration and effort limits correctly: MoveIt fi uses those to not only avoid planning invalid paths, but also when populating the velocity, acceleration and effort members of JointTrajectoryPoint messages

Originally posted by gvdhoorn with karma: 86574 on 2016-02-15
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Bas on 2016-02-15:
the reason I look into this, is that the positions of the JointTrajectoryPoint need to be postprocessed otherwise. For example when the lower arm (+ all above) rotate, the angle of the upper arm wrt the lower arm doesn't change. But physically not rotating the motor while moving the lower arm does.
Comment by gvdhoorn on 2016-02-15:
Sounds similar to joint-2-3 coupling of some industrial robots (see this question fi). One approach would be to handle this in your lower-level controller, and expose only 'clean' joints to ROS.
Comment by gvdhoorn on 2016-02-15:
Also: I'm not sure transmissions can be used to express that relationship (but I'm by no means an expert). This sounds like something a mimic joint could do, but afaik those cannot actually be actuated. Hence the approach to abstract such relationships and delegate to lower-level controllers.
Comment by Bas on 2016-02-15:
Thanks, Although it feels a bit unnatural I'll use yout proposed approach and do the math in the low level controller. I'll leave the other possibilities (and lack of transmission examples) for another time.
Comment by gvdhoorn on 2016-02-15:
Well another approach could be to handle the joint linkages in a custom ros_control controller or the hardware interface plugin. Personally I'd put it at the lowest level of abstraction that can comfortably deal with it, so as to shield it from higher layers. Let's you reuse as much as possible.


Q:

Making a desktop user program to roslaunch and kill nodes

Hello everyone.
I have this problem about making a desktop user program. I hope you can help me:

I would like to create a program for users which could launch different .launch files depending on user's choice. I would like to make it the easiest as possible for them (eg: users would double-click an icon in the desktop and the program would give them the opportunity to roslaunch one .launch or another making users to write simple commands).

Also, this program would recognize when it needs to kill automatically several nodes after a roslaunch (eg: I roslaunch a .launch which shows a turtle moving from initial position to its destiny. When this turtle reaches its destiny, some nodes must be killed automatically, like node which manages to move the turtle).

Problem: I don't know how to do this automatically. I was able to do it manually, but it needs user's interaction. I don't want this to happen.
And the main question is: How would you do this program?
I tried doing that with this structure:
1. .desktop file which executes by double-click the compiled C program I created.

2. C program which make user interaction and call shell scripts (system(call_shell_script);) in order to do roslaunch depending on the command that user writes.

3. One shell script which I use to roslaunch the .launch files.

4. One shell script which manages to kill several nodes.

The best options I want to have are the next (First is the best, last is the worst):
1. Making all of that in just one C or C++ program (no shell scripts, only a .desktop and a GUI).

2. Making all of that using rqt_launch or some tool like that.

3. The structure I used.

4. Making all of that in just one shell script, no C/C++ programs.

5. Others.

Thank you in advance.

Originally posted by Adri on ROS Answers with karma: 3 on 2016-01-29
Post score: 0

Original comments
Comment by inflo on 2016-01-29:
perhaps you could extend this https://github.com/gaug-cns/ros-control-center

A:

I've done this exact same thing in the past. Here's how I did it:

Created all versions of the application using only ROS. I boiled each possible configuration down to a single launch file w/particular arguments. If you set nodes to be required in the launch file, then killing a single required node is sufficient for shutting down all nodes started by the launch file. At this point I could start my ROS application and use something like  rospy.signal_shutdown to destroy a required node based on some condition.

Then I wrote a simple Python GUI that allowed me to select options from dropdowns, checkboxes, etc.

A button in the gui then had a callback that would start a single subprocess that was a call to roslaunch with the appropriate launch file and args (as set by the options in the gui).

Then I created a .desktop file that would automatically start the GUI.

One thing to watch out for is that you need to make sure that your GUI has access to the correct ROS environment variables. For example, you could source a setup.bash file in your .desktop file.

Originally posted by jarvisschultz with karma: 9031 on 2016-01-29
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by Adri on 2016-02-03:
Thanks for the answer, but I don't understand one thing:
How do you call several .launch to the same time? I tried to use system("roslaunch package name.launch & roslaunch package2 name2.launch"), but it doesn't work.
Comment by jarvisschultz on 2016-02-03:
I would create a single launch file that includes both of the target launch files using the include tag.


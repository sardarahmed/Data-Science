Q:

Sick LMS-100 topic stops publishing measurements

Hi all,
I am using the RCPRG_laser_drivers pkg to obtain laser measurements from a sick LMS-100 laser and from a sick LMS-151 laser (each laser on a different robot, no connection between them at all).
The thing is that the laser topic stops generating messages after a while ('rostopic echo /LMS1xx/LAS_00' returns nothing when the node fails). In both cases.
Does anybody have experienced this problem?. Any suggestion how to trace this problem?
I am using Diamond Back with Ubuntu 10.04. Some weeks ago I was using CTurtle with the same laser package and I had no problem at all (tested along weeks).
Some tests I've made:

You can ping the laser once it starts to fail, even if it is not generating any message from the laser
If the node fails, you can kill the node and restart it again, and the flow of messages will start again without problem
I've observed that the node cannot recover from a disconnection of the laser. If you disconnect the ethernet cable to the laser, the node cannot reconnect to the laser and keep generating messages once you put the cable back. Only option is to restart the node
I've also checked that when the node stops generating messages, there is no disconnection at all (I used a ping -f to the laser while the node was active. Once the node failed, I checked the report of ping -f (Ctrl-C) and said 0% packet loss, so there was no disconnection at all)

Any idea, comment, suggestion, bad joke, will be welcomed (specially the last one... I need jokes now :-(
Best
Ricardo

Originally posted by Ricardo Tellez on ROS Answers with karma: 114 on 2011-08-31
Post score: 1

A:

I think I found some bugs in the RCPRG laser driver.
Debugging the code I saw that when laser topic stops being published, the driver gets stuck in a read of zero bytes because the buffer used to store data received from the sensor is already full (10000 bytes) without having received a valid sensor scan packet.
char buf[10000];
    fd_set rfds;
    struct timeval tv;
    int retval, len;
    len = 0;

    do {
        FD_ZERO(&rfds);
        FD_SET(sockDesc, &rfds);

        tv.tv_sec = 0;
        tv.tv_usec = 50000;
        retval = select(sockDesc + 1, &rfds, NULL, NULL, &tv);
        if (retval) {
            len += read(sockDesc, buf + len, 10000 - len);
        }
    } while ((buf[0] != 0x02) || (buf[len - 1] != 0x03));

The problems is more probable to happen when the scan message data includes remission values and angular resolution is set to 0.25ยบ, because a complete message is 8192 bytes. I set the buffer dimension to 20000 and it seems to work but I think that a more elegant solution would be to use a circular buffer. Furthermore I would like to change the exit condition of the while cycle because it doesn't guarantee that the loop breaks in case of receiving a complete scan data msg + some bytes of the next one.

Originally posted by luca with karma: 96 on 2011-09-08
This answer was ACCEPTED on the original site
Post score: 2


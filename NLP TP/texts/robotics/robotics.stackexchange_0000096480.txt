Q:

libros1_bridge.so Undefined reference for Time conversions

I am trying to use ros1_bridge to bridge ROS1 and ROS2 messages involving time (std_msgs/Time for ROS1, builtin_interfaces/Time for ROS2)
Error message:
libros1_bridge.so: undefined reference to `void ros1_bridge::convert_2_to_1<std_msgs::Time_<std::allocator<void> >, builtin_interfaces::msg::Time_<std::allocator<void> > >(builtin_interfaces::msg::Time_<std::allocator<void> > const&, std_msgs::Time_<std::allocator<void> >&)'

mapping_rules.yaml
-
  ros1_package_name: 'xxx'
  ros1_message_name: 'MyTime'
  ros2_package_name: 'yyy'
  ros2_message_name: 'MyTime'
  fields_1_to_2:
      time: 'time'

ros1_ws/xxx/msg/MyTime.msg:
std_msgs/Time time

ros2_ws/yyy/msg/MyTime.msg:
builtin_interfaces/Time time

build/ros1_bridge/generated/yyy__msg__MyTime__factories.cpp:
// generated from ros1_bridge/resource/interface_factories.cpp.em

#include "rmf_dispenser_msgs_factories.hpp"

#include <algorithm>

#include "rclcpp/rclcpp.hpp"

// include builtin interfaces
#include <ros1_bridge/convert_builtin_interfaces.hpp>

// include ROS 1 services

// include ROS 2 services

namespace ros1_bridge
{

std::shared_ptr<FactoryInterface>
get_factory_rmf_dispenser_msgs__msg__MyTime(const std::string & ros1_type_name, const std::string & ros2_type_name)
{
  // mapping from string to specialized template
  if (
    (ros1_type_name == "xxx/MyTime" ||
     ros1_type_name == "") &&
    ros2_type_name == "yyy/msg/MyTime")
  {
    return std::make_shared<
      Factory<
        xxx::MyTime,
        yyy::msg::MyTime
      >
    >("xxx/MyTime", ros2_type_name);
  }
  return std::shared_ptr<FactoryInterface>();
}

std::unique_ptr<ServiceFactoryInterface>
get_service_factory_rmf_dispenser_msgs__msg__MyTime(const std::string & ros_id, const std::string & package_name, const std::string & service_name)
{
  (void)ros_id;
  (void)package_name;
  (void)service_name;
  return nullptr;
}
// conversion functions for available interfaces

template<>
void
Factory<
  xxx::MyTime,
  yyy::msg::MyTime
>::convert_1_to_2(
  const xxx::MyTime & ros1_msg,
  yyy::msg::MyTime & ros2_msg)
{

  // convert non-array field
  // convert builtin field
  ros1_bridge::convert_1_to_2(ros1_msg.time, ros2_msg.time);
}

template<>
void
Factory<
  xxx::MyTime,
  yyy::msg::MyTime
>::convert_2_to_1(
  const yyy::msg::MyTime & ros2_msg,
  xxx::MyTime & ros1_msg)
{

  // convert non-array field
  // convert builtin field
  ros1_bridge::convert_2_to_1(ros2_msg.time, ros1_msg.time);
}
}  // namespace ros1_bridge

Originally posted by Rufus on ROS Answers with karma: 1083 on 2020-07-09
Post score: 0

A:

I have tried this before. But I used just time t for ROS1 message and builtin_interfaces/Time t for ROS2 message. ros1_bridge node is able to link the two message formats that way. I didnt use std_msgs/Time.

Originally posted by webvenky with karma: 117 on 2020-07-09
This answer was ACCEPTED on the original site
Post score: 1


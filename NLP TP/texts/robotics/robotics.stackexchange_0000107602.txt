Q:

Lifecycle node consuming cpu in deactivated state

My node which is a critical component of a larger system contains the following interfaces for communicating with other nodes

Two action servers
One tf listner
One service server
Four subscribers
Two publishers

[running in ros 2 foxy in docker container]
I recently implemented the lifecycle version of this node and the idea was to deactivate the node when not required and save on CPU usage. I followed the following practices while implementing the lifecycle version:

Defined all parameters in constructor of class
Initializing pubs,subs,srvers etc all in on_configure callback.
Activating things which could be activated in on_activate callback and controlling rest with bools
Deactivating things which could be deactivated in on_deactivate callback and resetting the bools for all others
resetting all pointers in cleanup

My external code which controls the lifecycle of this node uses activate and deactivate states while in operation and configure / cleanup only once per run.
The CPU usage before on_configure is less than 1% which is expected. It goes to 15% on configure but it doesn't change much on activate or deactivate.
(The compute might be going in spinnig and waiting i guess but not sure)
so activating and deactivating is not really giving me what i needed.
I tried moving a few things from cleanup and configure into deactivate and activate CBs and got some improvement like the tf_listner it saved me around 4-5% of cpu. But the rest is still being utilized under the hood in spinning I guess.
Can we do anything else to reduce the usage further ?

A:

I'm going to speculate its your TF system. TF is not a lifecycle system, so unless you're resetting the TF buffer / listener in on_deactivate, you're still processing incoming transformation information. Also, subscribers similarly have no lifecycle eq. I'd look at resetting those in on_deactivate as well.


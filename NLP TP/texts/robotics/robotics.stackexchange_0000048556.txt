Q:

Service in Android

Hi everybody!
I started to use the ROS recently.
I'm trying to call a Service in Android.
The Service is running on rospy.
Right now I have the server working well.
The client (Android) has been implemented using two different modes:

public class Client extends AbstractNodeMain: generates an exception that I do not understand why.
public class Client implements NodeMain: there is no exception, but it also does not communicate with the server.

Someone can help me?
Hope for help! Thanks..
Paulo

Originally posted by paulofinseca on ROS Answers with karma: 18 on 2013-02-21
Post score: 1

A:

Hi Paulo
The following code worked for me in implementing a ServiceClient in Android. Note that HMMv2/get_Joint_State.srv is a custom service of mine.
In the OnStart(ConnectedNode node) method (but before you implement a cancellable loop:
final ServiceClient<HMMv2.get_Joint_StateRequest, HMMv2.get_Joint_StateResponse> client;
          
          
            try 
            {
                client = node.newServiceClient("HMMv2Cont/JointState", HMMv2.get_Joint_State._TYPE);
            
            } 
            catch (ServiceNotFoundException e) 
            {
                // TODO Auto-generated catch block
                e.printStackTrace();
                throw new RosRuntimeException(e);
            }
        
            final HMMv2.get_Joint_StateRequest request=client.newMessage();
              
            request.setJointName("joints");

Then in the Cancellable loop, loop() function the code to call the service is:
client.call(request, new ServiceResponseListener<HMMv2.get_Joint_StateResponse>()    {

                                @Override
                            public void onFailure(RemoteException arg0) 
                            {
                                Log.d("Jointrequest Client", "failed to call service");
                                throw new RosRuntimeException(arg0);
                                // TODO Auto-generated method stub

                            }

                            @Override
                            public void onSuccess(HMMv2.get_Joint_StateResponse message) 
                            {
                                                           //do something with the response
                                hPos.set(0, 0, (message.getJointState().getPosition()[0]-512)*Math.PI/512);             
                            

                            }

                                });

hope this example helps you. I think the main issue I found in implementing this was the declaration of a final ServiceClient types. But I've used this format a couple of times and it works.
cheers
Peter

Originally posted by PeterMilani with karma: 1493 on 2013-02-21
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by paulofinseca on 2013-02-23:
I have something similar. But when I run, an error occurs:
02-23 17:07:52.778: E/AndroidRuntime(671): org.ros.exception.RosRuntimeException: Connection exception: paulofonseca-PC:37008
02-23 17:07:52.778: E/AndroidRuntime(671):  at org.ros.internal.transport.tcp.TcpClient.connect(TcpClient.java:109
Comment by PeterMilani on 2013-02-24:
check your logcat and see where in your program the exception is thrown. The reference you give only specifies a library file (TcpClient.java) but if you can scroll down you should see your file name with a line number. This should give some clue as to what is causing this exception.
Comment by thomasL on 2014-05-22:
I have the same issue :
org.ros.exception.RosRuntimeException: Connection exception: ubuntu:38403
at org.ros.internal.transport.tcp.TcpClient.connect(TcpClient.java:109)
Have you find a solution?


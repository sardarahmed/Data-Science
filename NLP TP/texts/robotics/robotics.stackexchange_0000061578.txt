Q:

sensor_msgs::CvBridge’ has not been declared

Im currently using Ubuntu and running on ROS groovy. I just started using ROS and opencv. Trying to capture image using my Asus Xtion Pro and using opencv codes.
Im starting on tutorial: Running the Simple Image Publisher and Subscriber with Different Transports, and i encountered a problem after make to run my_publisher and my_subscriber.
Error: sensor_msgs::CvBridge’ has not been declared
Can anyone help me out with this?

Originally posted by Azl on ROS Answers with karma: 3 on 2014-08-06
Post score: 0

A:

Because there's no such thing as a sensor_msgs::CvBridge.
Have a look at the cv_bridge tutorial
especially this part for an image callback:
void imageCb(const sensor_msgs::ImageConstPtr& msg)
{
 cv_bridge::CvImagePtr cv_ptr;
 try
 {
  cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);
 }
 catch (cv_bridge::Exception& e)
 {
  ROS_ERROR("cv_bridge exception: %s", e.what());
  return;
 }

 // Draw an example circle on the video stream
 if (cv_ptr->image.rows > 60 && cv_ptr->image.cols > 60)
  cv::circle(cv_ptr->image, cv::Point(50, 50), 10, CV_RGB(255,0,0));

 // Update GUI Window
 cv::imshow(OPENCV_WINDOW, cv_ptr->image);
 cv::waitKey(3);

 // Output modified video stream
 image_pub_.publish(cv_ptr->toImageMsg());
 }
};

You have to create a cv_bridge::CvImagePtr and afterwards you can publish it as a sensor_msgs/Image again with cv_bridge::CvImagePtr::toImageMsg().

Originally posted by Chrissi with karma: 1642 on 2014-08-07
This answer was ACCEPTED on the original site
Post score: 1


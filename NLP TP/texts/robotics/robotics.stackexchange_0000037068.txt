Q:

Fedora 16 / Electric / Gazebo / Build Issues

Having just preupgraded from Fedora 15, I set about installing ROS all over again. Fortunately, unlike the previous time, I had much fewer issues getting to the point of building gazebo. I had to build assimp, and that was it.
Build first failed due to fltk issues
    [ 15%] Building CXX object server/physics/ode/CMakeFiles/gazebo_physics_ode.dir/ODEHeightmapShape.o
Linking CXX shared library libgazebo_physics_ode.so
make[4]: Leaving directory `/home/kshaurya/ros/simulator_gazebo/gazebo/build/gazebo/build'
[ 15%] Built target gazebo_physics_ode
make[4]: Entering directory `/home/kshaurya/ros/simulator_gazebo/gazebo/build/gazebo/build'
make[4]: Leaving directory `/home/kshaurya/ros/simulator_gazebo/gazebo/build/gazebo/build'
make[4]: Entering directory `/home/kshaurya/ros/simulator_gazebo/gazebo/build/gazebo/build'
[ 16%] Building CXX object server/rendering/CMakeFiles/gazebo_rendering.dir/OgreCreator.o
/home/kshaurya/ros/simulator_gazebo/gazebo/build/gazebo/server/rendering/OgreCreator.cc: In member function ‘Ogre::RenderWindow* gazebo::OgreCreator::CreateWindow(Fl_Window*, unsigned int, unsigned int)’:
/home/kshaurya/ros/simulator_gazebo/gazebo/build/gazebo/server/rendering/OgreCreator.cc:380:19: error: incomplete type ‘Fl_X’ used in nested name specifier
make[4]: *** [server/rendering/CMakeFiles/gazebo_rendering.dir/OgreCreator.o] Error 1
make[4]: Leaving directory `/home/kshaurya/ros/simulator_gazebo/gazebo/build/gazebo/build'
make[3]: *** [server/rendering/CMakeFiles/gazebo_rendering.dir/all] Error 2
make[3]: Leaving directory `/home/kshaurya/ros/simulator_gazebo/gazebo/build/gazebo/build'
make[2]: *** [all] Error 2
make[2]: Leaving directory `/home/kshaurya/ros/simulator_gazebo/gazebo/build/gazebo/build'
make[1]: *** [installed] Error 2
make[1]: Leaving directory `/home/kshaurya/ros/simulator_gazebo/gazebo'
CMake Error at CMakeLists.txt:32 (message):
  Build of Gazebo failed

UPDATE 1 : This seems to be some issue with the updating of fltk as per this. However, looking at the x.h header from the Fl include directory, and comparing, I tried this (Sensible) patch. In ros/simulator_gazebo/gazebo/build/gazebo/server/rendering/OgreCreator.cc
-- win = OgreCreator::CreateWindow( fl_display, fl_visual->screen, 
        (int32_t)(Fl_X::i(flWindow)->xid), width, height);
++ win = OgreCreator::CreateWindow( fl_display, fl_visual->screen, 
        (int32_t)(fl_xid(flWindow)), width, height);

This resulted in the build process continuing further, with the following error
[ 46%] Building CXX object server/gui/CMakeFiles/gazebo_gui.dir/GLWindow.o
  In file included from /usr/include/FL/fl_utf8.h:73:0,
                   from /usr/include/FL/Fl.H:39,
                   from /home/kshaurya/ros/simulator_gazebo/gazebo/build/gazebo/server/gui/Gui.hh:33,
                   from /home/kshaurya/ros/simulator_gazebo/gazebo/build/gazebo/server/gui/GLWindow.cc:51:
  /usr/include/FL/Xutf8.h:161:5: error: ‘Status’ has not been declared
  make[4]: *** [server/gui/CMakeFiles/gazebo_gui.dir/GLWindow.o] Error 1
  make[4]: Leaving directory `/home/kshaurya/ros/simulator_gazebo/gazebo/build/gazebo/build'
  make[3]: *** [server/gui/CMakeFiles/gazebo_gui.dir/all] Error 2
  make[3]: Leaving directory `/home/kshaurya/ros/simulator_gazebo/gazebo/build/gazebo/build'
  make[2]: *** [all] Error 2
  make[2]: Leaving directory `/home/kshaurya/ros/simulator_gazebo/gazebo/build/gazebo/build'
  make[1]: *** [installed] Error 2
  make[1]: Leaving directory `/home/kshaurya/ros/simulator_gazebo/gazebo'
  CMake Error at CMakeLists.txt:32 (message):
    Build of Gazebo failed

Any dice?
UPDATE 2: I just went ahead and commented(!) out the relevant portion in the offending library header file. The build proceeded further. However this seems to suggest that the relevant flags need to be set. What's that about?
Gazebo built, but then a roslaunch gazebo_worlds empty_world.launch gave another error
SUMMARY
========

PARAMETERS
 * /rosversion
 * /use_sim_time
 * /rosdistro

NODES
  /
    gazebo (gazebo/gazebo)

auto-starting new master
process[master]: started with pid [3743]
ROS_MASTER_URI=http://localhost:11311

setting /run_id to cb88f5d4-3ece-11e1-96c9-88532e12696b
process[rosout-1]: started with pid [3756]
started core service [/rosout]
process[gazebo-2]: started with pid [3759]
/home/kshaurya/ros/simulator_gazebo/gazebo/bin/gazebo: error while loading shared libraries: libboost_signals-mt.so.1.46.0: cannot open shared object file: No such file or directory
[gazebo-2] process has died [pid 3759, exit code 127].
log files: /home/kshaurya/.ros/log/cb88f5d4-3ece-11e1-96c9-88532e12696b/gazebo-2*.log
^C[rosout-1] killing on exit
[master] killing on exit
shutting down processing monitor...
... shutting down processing monitor complete
done

I just checked - I have boost-devel-1.47. Why is it requiring 1.46? :S
Update 3: I cleaned all hte build directories, and when I attempted to build gazebo_worlds, build of cminpack failed as the md5 sum of the downloaded tarball didn't match the offical md5. Replacing it by the official tarball gave me this huge boost error subsequently along the build process
In file included from /usr/include/boost/ptr_container/detail/reversible_ptr_container.hpp:24:0,
                 from /usr/include/boost/ptr_container/ptr_sequence_adapter.hpp:20,
                 from /usr/include/boost/ptr_container/ptr_vector.hpp:20,
                     from /home/kshaurya/ros/image_common/image_transport/src/publisher.cpp:38:
/usr/include/boost/ptr_container/clone_allocator.hpp: In function ‘T* boost::new_clone(const T&) [with T = image_transport::PublisherPlugin]’:
/usr/include/boost/ptr_container/clone_allocator.hpp:68:33:   instantiated from ‘static U* boost::heap_clone_allocator::allocate_clone(const U&) [with U = image_transport::PublisherPlugin]’
/usr/include/boost/ptr_container/detail/reversible_ptr_container.hpp:110:63:   instantiated from ‘static boost::ptr_container_detail::reversible_ptr_container<Config, CloneAllocator>::Ty_* boost::ptr_container_detail::reversible_ptr_container<Config, CloneAllocator>::null_clone_allocator<allow_null_values>::allocate_clone(const Ty_*) [with bool allow_null_values = false, Config = boost::ptr_container_detail::sequence_config<image_transport::PublisherPlugin, std::vector<void*, std::allocator<void*> > >, CloneAllocator = boost::heap_clone_allocator, boost::ptr_container_detail::reversible_ptr_container<Config, CloneAllocator>::Ty_ = image_transport::PublisherPlugin]’
/usr/include/boost/ptr_container/detail/reversible_ptr_container.hpp:95:71:   instantiated from ‘static boost::ptr_container_detail::reversible_ptr_container<Config, CloneAllocator>::Ty_* boost::ptr_container_detail::reversible_ptr_container<Config, CloneAllocator>::null_clone_allocator<allow_null_values>::allocate_clone_from_iterator(Iter) [with Iter = boost::void_ptr_iterator<__gnu_cxx::__normal_iterator<void* const*, std::vector<void*, std::allocator<void*> > >, const image_transport::PublisherPlugin>, bool allow_null_values = false, Config = boost::ptr_container_detail::sequence_config<image_transport::PublisherPlugin, std::vector<void*, std::allocator<void*> > >, CloneAllocator = boost::heap_clone_allocator, boost::ptr_container_detail::reversible_ptr_container<Config, CloneAllocator>::Ty_ = image_transport::PublisherPlugin]’
/usr/include/boost/ptr_container/detail/scoped_deleter.hpp:70:21:   instantiated from ‘boost::ptr_container_detail::scoped_deleter<T, CloneAllocator>::scoped_deleter(InputIterator, InputIterator) [with InputIterator = boost::void_ptr_iterator<__gnu_cxx::__normal_iterator<void* const*, std::vector<void*, std::allocator<void*> > >, const image_transport::PublisherPlugin>, T = image_transport::PublisherPlugin, CloneAllocator = boost::ptr_container_detail::reversible_ptr_container<boost::ptr_container_detail::sequence_config<image_transport::PublisherPlugin, std::vector<void*, std::allocator<void*> > >, boost::heap_clone_allocator>::null_clone_allocator<false>]’
/usr/include/boost/ptr_container/detail/reversible_ptr_container.hpp:212:44:   instantiated from ‘void boost::ptr_container_detail::reversible_ptr_container<Config, CloneAllocator>::clone_back_insert(ForwardIterator, ForwardIterator) [with ForwardIterator = boost::void_ptr_iterator<__gnu_cxx::__normal_iterator<void* const*, std::vector<void*, std::allocator<void*> > >, const image_transport::PublisherPlugin>, Config = boost::ptr_container_detail::sequence_config<image_transport::PublisherPlugin, std::vector<void*, std::allocator<void*> > >, CloneAllocator = boost::heap_clone_allocator]’
/usr/include/boost/ptr_container/detail/reversible_ptr_container.hpp:303:13:   instantiated from ‘void boost::ptr_container_detail::reversible_ptr_container<Config, CloneAllocator>::constructor_impl(I, I, std::forward_iterator_tag) [with I = boost::void_ptr_iterator<__gnu_cxx::__normal_iterator<void* const*, std::vector<void*, std::allocator<void*> > >, const image_transport::PublisherPlugin>, Config = boost::ptr_container_detail::sequence_config<image_transport::PublisherPlugin, std::vector<void*, std::allocator<void*> > >, CloneAllocator = boost::heap_clone_allocator]’
/usr/include/boost/ptr_container/detail/reversible_ptr_container.hpp:348:13:   instantiated from ‘boost::ptr_container_detail::reversible_ptr_container<Config, CloneAllocator>::reversible_ptr_container(const boost::ptr_container_detail::reversible_ptr_container<Config, CloneAllocator>&) [with Config = boost::ptr_container_detail::sequence_config<image_transport::PublisherPlugin, std::vector<void*, std::allocator<void*> > >, CloneAllocator = boost::heap_clone_allocator, boost::ptr_container_detail::reversible_ptr_container<Config, CloneAllocator> = boost::ptr_container_detail::reversible_ptr_container<boost::ptr_container_detail::sequence_config<image_transport::PublisherPlugin, std::vector<void*, std::allocator<void*> > >, boost::heap_clone_allocator>]’
/usr/include/boost/ptr_container/ptr_sequence_adapter.hpp:203:26:   instantiated from ‘boost::ptr_sequence_adapter<T, VoidPtrSeq, CloneAllocator>::ptr_sequence_adapter(const boost::ptr_sequence_adapter<T, VoidPtrSeq, CloneAllocator>&) [with T = image_transport::PublisherPlugin, VoidPtrSeq = std::vector<void*, std::allocator<void*> >, CloneAllocator = boost::heap_clone_allocator, boost::ptr_sequence_adapter<T, VoidPtrSeq, CloneAllocator> = boost::ptr_sequence_adapter<image_transport::PublisherPlugin, std::vector<void*, std::allocator<void*> >, boost::heap_clone_allocator>]’
/usr/include/boost/ptr_container/ptr_vector.hpp:31:11:   instantiated from ‘boost::foreach_detail_::simple_variant<T>::simple_variant(const T&) [with T = boost::ptr_vector<image_transport::PublisherPlugin>]’
/usr/include/boost/foreach.hpp:648:95:   instantiated from ‘boost::foreach_detail_::auto_any<boost::foreach_detail_::simple_variant<T> > boost::foreach_detail_::contain(const T&, bool*) [with T = boost::ptr_vector<image_transport::PublisherPlugin>]’
/home/kshaurya/ros/image_common/image_transport/src/publisher.cpp:59:943:   instantiated from here
/usr/include/boost/ptr_container/clone_allocator.hpp:34:27: error: cannot allocate an object of abstract type ‘image_transport::PublisherPlugin’
/home/kshaurya/ros/image_common/image_transport/include/image_transport/publisher_plugin.h:13:7: note:   because the following virtual functions are pure within ‘image_transport::PublisherPlugin’:
/home/kshaurya/ros/image_common/image_transport/include/image_transport/publisher_plugin.h:22:23: note:     virtual std::string image_transport::PublisherPlugin::getTransportName() const
/home/kshaurya/ros/image_common/image_transport/include/image_transport/publisher_plugin.h:49:20: note:     virtual uint32_t image_transport::PublisherPlugin::getNumSubscribers() const
/home/kshaurya/ros/image_common/image_transport/include/image_transport/publisher_plugin.h:54:23: note:     virtual std::string image_transport::PublisherPlugin::getTopic() const
/home/kshaurya/ros/image_common/image_transport/include/image_transport/publisher_plugin.h:59:16: note:     virtual void image_transport::PublisherPlugin::publish(const Image&) const
/home/kshaurya/ros/image_common/image_transport/include/image_transport/publisher_plugin.h:72:16: note:     virtual void image_transport::PublisherPlugin::shutdown()
/home/kshaurya/ros/image_common/image_transport/include/image_transport/publisher_plugin.h:87:16: note:     virtual void image_transport::PublisherPlugin::advertiseImpl(ros::NodeHandle&, const string&, uint32_t, const SubscriberStatusCallback&, const SubscriberStatusCallback&, const VoidPtr&, bool)
make[3]: *** [CMakeFiles/image_transport.dir/src/publisher.o] Error 1

Possible clone of this? Bad news :S

Originally posted by ICodeRaven on ROS Answers with karma: 76 on 2012-01-14
Post score: 0

Original comments
Comment by joq on 2012-01-17:
I don't know enough rosdep internals to answer that. Probably, this is a bug and you should open a ticket to get it fixed: https://code.ros.org/trac/ros/newticket
Comment by ICodeRaven on 2012-01-17:
My install does definitely identify as 'fedora'. Could the fact that I have preupgraded be an issue? I don't remember what version of Boost I had on 15, but it could very well be 1.46 :S
Comment by joq on 2012-01-16:
If your install is correctly identifying fedora, then it should resolve to boost-devel (see ros/rosdep.yaml). Boost 1.46 is the Ubuntu Oneiric version, so maybe the OS identification has gone wrong somehow.
Comment by ICodeRaven on 2012-01-16:
Will sym-linking the required files to the new versions be a good thing to do? I'm trying to avoid that here.

A:

I have gazebo running happily on my Fedora 16 system. Check here for SVN version information:
http://answers.ros.org/question/12981/pcl-failing-compilation-fedora-16-segmentation
Also, I'm using boost-1.47 - so make sure you do a make clean when building gazeob, as the linking might still refer to boost libraries of your previous Fedora installation.

Originally posted by Steven Bellens with karma: 735 on 2012-03-14
This answer was ACCEPTED on the original site
Post score: 0


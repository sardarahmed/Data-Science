Q:

Robot arm falls over on spawn (Gazebo)

I'm using ROS Melodic with the denso_robot_ros package (https://github.com/DENSORobot/denso_robot_ros).
I'm currently trying to adapt my own arm to utilize the package. The package comes with a functioning example using the VS060 model, whereas I'm attempting to use the VS6577 A-B model with a custom end effector. I have created my own URDF (in xacro format) by using data obtained from the VS6577 controller for the arm and the custom end effector files.
When running the VS060 example, the arm will spawn in both Gazebo and RViz, with RViz providing the ability to control the arm by moving the position indicator located at the tip. When executing a trajectory in RViz, the model in Gazebo will make movements corresponding to the trajectory.
When running the VS6577 arm, the arm will spawn in both Gazebo in RViz, however it will flop over in both and fail to respond to commands. The arm in RViz will mimic the movement of the arm in Gazebo and doesn't exert any force to correct itself/stand up. The RViz VS6577 will still display the clickable indicator on the end of the robot arm that allows me to move it to a hypothetical position that it can then successfully plan to move it. Once I decide to execute the trajectory however, the arm doesn't make any attempt at movement while the terminal indicates that it has successfully moved.
 [ INFO] [1558814233.787314221, 39.284000000]: Combined planning and execution request received for MoveGroup action. Forwarding to planning and execution pipeline.
[ INFO] [1558814233.787400526, 39.284000000]: Planning attempt 1 of at most 1
[ INFO] [1558814233.787467946, 39.284000000]: Starting state is just outside bounds (joint 'joint_2'). Assuming within bounds.
[ INFO] [1558814233.787630107, 39.284000000]: Found a contact between 'EEF_robot_magnet' (type 'Robot link') and 'J4' (type 'Robot link'), which constitutes a collision. Contact information is not stored.
[ INFO] [1558814233.787663090, 39.284000000]: Collision checking is considered complete (collision was found and 0 contacts are stored)
[ INFO] [1558814233.787701964, 39.284000000]: Start state appears to be in collision with respect to group arm
[ INFO] [1558814233.789812451, 39.287000000]: Found a valid state near the start state at distance 1.286259 after 3 attempts
[ INFO] [1558814233.790373357, 39.287000000]: Planner configuration 'arm' will use planner 'geometric::RRTConnect'. Additional configuration parameters will be set when the planner is constructed.
[ INFO] [1558814233.790927439, 39.288000000]: RRTConnect: Starting planning with 1 states already in datastructure
[ INFO] [1558814233.790988817, 39.288000000]: RRTConnect: Starting planning with 1 states already in datastructure
[ INFO] [1558814233.791059312, 39.288000000]: RRTConnect: Starting planning with 1 states already in datastructure
[ INFO] [1558814233.791120209, 39.288000000]: RRTConnect: Starting planning with 1 states already in datastructure
[ INFO] [1558814233.801353892, 39.298000000]: RRTConnect: Created 5 states (2 start + 3 goal)
[ INFO] [1558814233.801434857, 39.298000000]: RRTConnect: Created 5 states (2 start + 3 goal)
[ INFO] [1558814233.801546992, 39.298000000]: RRTConnect: Created 5 states (2 start + 3 goal)
[ INFO] [1558814233.801651412, 39.298000000]: RRTConnect: Created 5 states (2 start + 3 goal)
[ INFO] [1558814233.801795308, 39.299000000]: ParallelPlan::solve(): Solution found by one or more threads in 0.011119 seconds
[ INFO] [1558814233.802097227, 39.299000000]: RRTConnect: Starting planning with 1 states already in datastructure
[ INFO] [1558814233.802147173, 39.299000000]: RRTConnect: Starting planning with 1 states already in datastructure
[ INFO] [1558814233.802212709, 39.299000000]: RRTConnect: Starting planning with 1 states already in datastructure
[ INFO] [1558814233.802269598, 39.299000000]: RRTConnect: Starting planning with 1 states already in datastructure
[ INFO] [1558814233.802552450, 39.299000000]: RRTConnect: Created 5 states (2 start + 3 goal)
[ INFO] [1558814233.802608898, 39.299000000]: RRTConnect: Created 5 states (2 start + 3 goal)
[ INFO] [1558814233.802740881, 39.299000000]: RRTConnect: Created 5 states (2 start + 3 goal)
[ INFO] [1558814233.803146199, 39.300000000]: RRTConnect: Created 5 states (3 start + 2 goal)
[ INFO] [1558814233.803299703, 39.300000000]: ParallelPlan::solve(): Solution found by one or more threads in 0.001278 seconds
[ INFO] [1558814233.803514565, 39.300000000]: RRTConnect: Starting planning with 1 states already in datastructure
[ INFO] [1558814233.803568959, 39.300000000]: RRTConnect: Starting planning with 1 states already in datastructure
[ INFO] [1558814233.803931234, 39.301000000]: RRTConnect: Created 5 states (2 start + 3 goal)
[ INFO] [1558814233.804018772, 39.301000000]: RRTConnect: Created 5 states (2 start + 3 goal)
[ INFO] [1558814233.804166946, 39.301000000]: ParallelPlan::solve(): Solution found by one or more threads in 0.000710 seconds
[ INFO] [1558814233.807662980, 39.304000000]: SimpleSetup: Path simplification took 0.003425 seconds and changed from 4 to 2 states
[ INFO] [1558814233.808245998, 39.305000000]: Planning adapters have added states at index positions: [ 0 1 ]
[ INFO] [1558814239.718207573, 45.209000000]: Controller vs6577/arm_controller successfully finished
[ INFO] [1558814239.721180483, 45.212000000]: Completed trajectory execution with status SUCCEEDED ...

I would also like to add that the collision detection for the arm and end effector all seem to work properly in both RViz and Gazebo.
EDIT: In addition, the base of the robot is properly attached to the world with a static link, it's just the links above it that fall over.
Here's the general robot launch file. I override the arguments in the custom launch file I made for the robot.

  <!-- Override if robot description is in Xacro format -->
  <arg name="xacro" default="false"/>
 
  <!-- the "sim" argument controls whether we connect to a Simulated or Real robot -->
  <!--  - if sim=false, a ip_address argument is required -->
  <arg name="sim" default="true" />
  <arg name="ip_address" default="192.168.0.1" />

  <!-- If you want to change send and recieve format of denso_robot_control, -->
  <!-- you can specify the send_format and recv_format parameters -->
  <arg name="send_format" default="288" />
  <arg name="recv_format" default="292" />
 
  <!-- load the robot_description parameter before launching ROS-I nodes -->
  <include file="$(find denso_robot_moveit_config)/launch/planning_context.launch" >
    <arg name="xacro" value="$(arg xacro)" />
    <arg name="load_robot_description" value="true" />
    <arg name="robot_name" value="$(arg robot_name)" />
  </include>

  <node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher">
    <param name="use_gui" value="false"/>
    <param name="publish_frequency" type="double" value="125.0" />
    <rosparam param="source_list" subst_value = "true">[/$(arg robot_name)/joint_states]</rosparam>
  </node>

  <!-- run the "real robot" interface nodes -->
  <!--   - this typically includes: robot_state, motion_interface, and joint_trajectory_action nodes -->
  <!--   - replace these calls with appropriate robot-specific calls or launch files -->
  <group if="$(arg sim)">
    <include file="$(find denso_robot_gazebo)/launch/denso_robot_gazebo.launch">
      <arg name="robot_name" value="$(arg robot_name)" />
    </include>
  </group>  

  <group unless="$(arg sim)">
    <include file="$(find denso_robot_control)/launch/denso_robot_control.launch">
      <arg name="robot_name" value="$(arg robot_name)" />
      <arg name="ip_address" value="$(arg ip_address)" />
      <arg name="send_format" value="$(arg send_format)" />
      <arg name="recv_format" value="$(arg recv_format)" />
    </include>
  </group>  

  <include file="$(find denso_robot_moveit_config)/launch/move_group.launch">
    <arg name="publish_monitored_planning_scene" value="true" />
    <arg name="robot_name" value="$(arg robot_name)" />
  </include>

  <include file="$(find denso_robot_moveit_config)/launch/moveit_rviz.launch">
    <arg name="config" value="true"/>
  </include>
  
  <include file="$(find denso_robot_moveit_config)/launch/default_warehouse_db.launch" />

</launch>

The only other change I have in my original launch file is this line I added:
<rosparam file="$(find denso_robot_moveit_config)/config/vs6577_config/gazebo_vs6577_control_params.yaml" command="load"/>

which loads in this file here:
vs6577/gazebo_ros_control/pid_gains:
  joint_1: {p: 1.0, i: 0.0, d: 0.0, i_clamp: 100.0}
  joint_2: {p: 1.0, i: 0.0, d: 0.0, i_clamp: 100.0}
  joint_3: {p: 1.0, i: 0.0, d: 1.0, i_clamp: 100.0}
  joint_4: {p: 1.0, i: 0.0, d: 1.0, i_clamp: 100.0}
  joint_5: {p: 1.0, i: 0.0, d: 1.0, i_clamp: 0.0}
  flange_joint: {p: 1, i: 0.0, d: 0.0, i_clamp: 0.0}

(I've tried all sorts of values for these and it didn't seem to change anything).
planning_context.launch:
<launch>
  <!-- By default we do not overwrite the URDF. Change the following to true to change the default behavior -->
  <arg name="load_robot_description" default="false"/>

  <!-- Determines whether to read in robot description as normal URDF or as an Xacro file-->
  <arg name="xacro" default="false"/>

  <!-- The name of the parameter under which the URDF is loaded -->
  <arg name="robot_description" default="robot_description"/>

  <!-- The name of robot which is loaded from URDF -->
  <arg name="robot_name" default="vs060"/>

  <!-- Load universal robot description format (URDF) -->

  <!-- Load in xacro format, this path is also specific to the directory structure in the vs6577 description where the urdf files are located in a subfolder -->
  <group if="$(arg xacro)">
    <param if="$(arg load_robot_description)" name="$(arg robot_description)" command="xacro '$(find denso_robot_descriptions)/$(arg robot_name)_description/urdf/$(arg robot_name).urdf.xacro'"/>
  </group>

  <!-- Load in normal URDF format, as used in the vs060 example. Would recommend xacro for more complicated robot descriptions later on down the line -->
  <group unless="$(arg xacro)">
    <param if="$(arg load_robot_description)" name="$(arg robot_description)" textfile="$(find denso_robot_descriptions)/$(arg robot_name)_description/$(arg robot_name).urdf"/>
  </group>

  <!-- The semantic description that corresponds to the URDF -->
  <param name="$(arg robot_description)_semantic" textfile="$(find denso_robot_moveit_config)/config/$(arg robot_name)_config/$(arg robot_name).srdf" />
  
  <!-- Load updated joint limits (override information from URDF) -->
  <group ns="$(arg robot_description)_planning">
    <rosparam command="load" file="$(find denso_robot_moveit_config)/config/$(arg robot_name)_config/joint_limits.yaml"/>
  </group>

  <!-- Load default settings for kinematics; these settings are overridden by settings in a node's namespace -->
  <group ns="$(arg robot_description)_kinematics">
    <rosparam command="load" file="$(find denso_robot_moveit_config)/config/kinematics.yaml"/>
  </group>
  
</launch>

move_group.launch:
<launch>

  <arg name="robot_name" default="vs060" />

  <include file="$(find denso_robot_moveit_config)/launch/planning_context.launch">
    <arg name="robot_name" value="$(arg robot_name)" />
  </include>

  <!-- GDB Debug Option -->
  <arg name="debug" default="false" />
  <arg unless="$(arg debug)" name="launch_prefix" value="" />
  <arg     if="$(arg debug)" name="launch_prefix" value="gdb --ex run --args" />

  <!-- Verbose Mode Option -->
  <arg name="info" default="$(arg debug)" />  
  <arg unless="$(arg info)" name="command_args" value="" />
  <arg     if="$(arg info)" name="command_args" value="--debug" />

  <!-- move_group settings -->
  <arg name="allow_trajectory_execution" default="true"/> 
  <arg name="max_safe_path_cost" default="1"/>
  <arg name="jiggle_fraction" default="0.05" />
  <arg name="publish_monitored_planning_scene" default="true"/>

  <!-- Planning Functionality -->
  <include ns="move_group" file="$(find denso_robot_moveit_config)/launch/planning_pipeline.launch.xml">
    <arg name="pipeline" value="ompl" />
  </include>

  <!-- Trajectory Execution Functionality -->
  <include ns="move_group" file="$(find denso_robot_moveit_config)/launch/trajectory_execution.launch.xml" if="$(arg allow_trajectory_execution)">
    <arg name="moveit_manage_controllers" value="true" />
    <arg name="moveit_controller_manager" value="denso_robot" />
    <arg name="robot_name" value="$(arg robot_name)" />
  </include>

  <!-- Sensors Functionality -->
  <include ns="move_group" file="$(find denso_robot_moveit_config)/launch/sensor_manager.launch.xml" if="$(arg allow_trajectory_execution)">
    <arg name="moveit_sensor_manager" value="denso_robot" /> 
  </include>

  <!-- Start the actual move_group node/action server -->
  <node name="move_group" launch-prefix="$(arg launch_prefix)" pkg="moveit_ros_move_group" type="move_group" respawn="false" output="screen"
   args="joint_states:=/$(arg robot_name)/joint_states $(arg command_args)">
    <!-- Set the display variable, in case OpenGL code is used internally -->
    <env name="DISPLAY" value="$(optenv DISPLAY :0)" />

    <param name="allow_trajectory_execution" value="$(arg allow_trajectory_execution)"/>
    <param name="max_safe_path_cost" value="$(arg max_safe_path_cost)"/>
    <param name="jiggle_fraction" value="$(arg jiggle_fraction)" />

    <!-- MoveGroup capabilities to load -->
    <param name="capabilities" value="move_group/MoveGroupCartesianPathService
                      move_group/MoveGroupExecuteTrajectoryAction
                      move_group/MoveGroupKinematicsService
                      move_group/MoveGroupMoveAction
                      move_group/MoveGroupPickPlaceAction
                      move_group/MoveGroupPlanService
                      move_group/MoveGroupQueryPlannersService
                      move_group/MoveGroupStateValidationService
                      move_group/MoveGroupGetPlanningSceneService
                      " />

    <!-- Publish the planning scene of the physical robot so that rviz plugin can know actual robot -->
    <param name="planning_scene_monitor/publish_planning_scene" value="$(arg publish_monitored_planning_scene)" />
    <param name="planning_scene_monitor/publish_geometry_updates" value="$(arg publish_monitored_planning_scene)" />
    <param name="planning_scene_monitor/publish_state_updates" value="$(arg publish_monitored_planning_scene)" />
    <param name="planning_scene_monitor/publish_transforms_updates" value="$(arg publish_monitored_planning_scene)" />
  </node>
  
</launch>

Controllers.yaml:
controller_manager_ns: controller_manager
controller_list:
 - name: vs6577/arm_controller
   action_ns: follow_joint_trajectory
   type: FollowJointTrajectory
   default: true
   joints: 
      - flange_joint
      - joint_1
      - joint_2
      - joint_3
      - joint_4
      - joint_5

Here's vs6577_controllers.yaml. If I remember correctly, whenever I used just this file as opposed to also loading in the gazebo_vs6577_control_params above, I would get error messages stating that there were no PID values specified.
vs6577:
  #Publish all joint states -----------------------------------
  joint_state_controller:
    type: joint_state_controller/JointStateController
    publish_rate: 50  
  
   #Position Controllers ---------------------------------------
  joint1_position_controller:
    type: effort_controllers/JointPositionController
    joint: joint_1
    pid: {p: 10000.0, i: 500.0, d: 0.0, i_clamp: 100.0}
  joint2_position_controller:
    type: effort_controllers/JointPositionController
    joint: joint_2
    pid: {p: 100.0, i: 50.0, d: 0.0, i_clamp: 100.0}
  joint3_position_controller:
    type: effort_controllers/JointPositionController
    joint: joint_3
    pid: {p: 1500.0, i: 500.0, d: 0.0, i_clamp: 100.0}
  joint4_position_controller:
    type: effort_controllers/JointPositionController
    joint: joint_4
    pid: {p: 100.0, i: 500.0, d: 0.0, i_clamp: 100.0}
  joint5_position_controller:
    type: effort_controllers/JointPositionController
    joint: joint_5
    pid: {p: 100.0, i: 10.0, d: 0.0, i_clamp: 0.0}
  joint6_position_controller:
    type: effort_controllers/JointPositionController
    joint: flange_joint
    pid: {p: 100, i: 0.0, d: 0.0, i_clamp: 0.0}

Here's denso_robot_gazebo.launch:
<launch>
  <!-- Override robot_name argument -->
  <arg name="robot_name" default="vs060" />

  <!-- Robot description argument -->
  <arg name="robot_description" value="$(arg robot_name)_description" />

  <include file="$(find gazebo_ros)/launch/empty_world.launch">
    <arg name="world_name" value="$(find denso_robot_gazebo)/worlds/denso_robot.world"/>
  </include>
  
  <!-- Load the URDF, SRDF and other .yaml configuration files on the param server -->
  <param name="robot_description" command="xacro  '$(find denso_robot_descriptions)/$(arg robot_name)_description/urdf/$(arg robot_name).urdf.xacro'"/>

  <arg name="gui" default="true"/>
  <param name="use_gui" value="$(arg gui)"/>

  <node name="spawn_urdf" pkg="gazebo_ros" type="spawn_model" args="-param robot_description -urdf -model $(arg robot_name)" />

  <rosparam file="$(find denso_robot_descriptions)/$(arg robot_description)/denso_robot_control.yaml" command="load" />
  <node name="controller_spawner" pkg="controller_manager" type="spawner" respawn="false" output="screen"
   ns="/$(arg robot_name)" args="joint_state_controller arm_controller" />

  <node name="robot_state_publisher" pkg="robot_state_publisher" 
        type="robot_state_publisher" respawn="false" output="screen">
    <remap from="/joint_states" to="/$(arg robot_name)/joint_states" />
  </node>

</launch>

Originally posted by tswie on ROS Answers with karma: 56 on 2019-05-25
Post score: 0

Original comments
Comment by PeteBlackerThe3rd on 2019-05-25:
It sounds like the joint controllers are not set up correctly, so each joint is freely moving. Can you show us the launch files and controller yaml flies you're using.
Comment by tswie on 2019-05-27:
Sure thing! Adding them to the OP now.
Comment by PeteBlackerThe3rd on 2019-05-28:
At a quick glance it looks like your PID controllers need to be tuned. I would expect some of those values to be significantly higher than they are. If you have a look at this page for a slightly different controller it gives you some hints to tune these parameters using dynamic reconfigure. You can also echo the joint effort topics and see what sort of forces the controllers are outputting.
Comment by tswie on 2019-05-30:
Thank you! Looking into the joint efforts led to me the solution, as found here: https://answers.ros.org/question/110856/controllers-are-unable-to-fight-gravity-in-gazebo-simulation/

A:

Was able to solve it by changing the effort limits in my URDF. Previously they were set to 1 (found in the joint tags in my URDF). After setting them higher, the robot can now stand on its own and manipulating PID gains leads to visible changes in error control while running the sim. I'll be fixing these values as I go along to something more reasonable.
Found a solution by going here: https://answers.ros.org/question/110856/controllers-are-unable-to-fight-gravity-in-gazebo-simulation/

Originally posted by tswie with karma: 56 on 2019-05-30
This answer was ACCEPTED on the original site
Post score: 1


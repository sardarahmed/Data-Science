Q:

When waiting for a node inside another node, should I use a service?

I have a main c++ node that needs to wait for user input to arrive at a secondary node. The user input can take quite some time, and cannot be moved to my main node. Currently I have solved the problem by simply waiting to launch my main node until I have finished setting things up in my secondary node, but I want a solution that will do all that stuff for me. It is more elegant, and eventually I will run several nodes this way, and it will be a hassle to manage it manually all the time.
I can do this with a service, but if I understand correctly, services are not recommended for functions that might block for a long time. Should I use actions instead? Or is there some standard way of implementing this, that I am not aware of?
For the record, the user needs to move an arm to it's starting position and origin (and later some more complex setup), before publishing a transform. Only once the setup is complete, can the main node start executing.

Originally posted by paturdc on ROS Answers with karma: 157 on 2014-05-14
Post score: 0

A:

OK I'm going to try answer that question but I'm not sure I'll give you the best answer so be nice =P.
I think it all depend on what you want to do exactly and I think running a Service might not be that stupid.
Service is used for a request-reply type of communication. You might want to use it there for when your arm is positioned then it send a message to the main node saying "I'm done you can start setting up yourself" and wait for a reply from the main telling him everything is ready. It could be a solution.
Using actionlib, you'll be able to have information about the user setting up the arm process at all the time. Meaning if you have any use in controlling the user set up this is the way to go. However, action lib is usually used to control how on "order" you gave is going, I didn't hear about it being used only as a way to "control" an action but I can't see any reason for it to not be possible. Again, I'm no expert on that so you'll be better searching a bit about it in case I'm wrong.
But if you want more than one node to be able to know when the user did put the arm in position, then just publish a topic /is_ready that tell everyone if the user finished his set up (sending a bool value or the arm position maybe ?). I think it's the easiest way to go and the most adaptable one to new designs (if you change your program design I mean).
So I think it's all depend on what you want and which type of usage you'll have.
Finally I don't know if it's possible to start a roslaunch within a C++ program and I'll be glad to know as it could be a quite elegant solution maybe.
EDIT :
Personally I would try to implement the "service" solution. Please, if something in my assumption is wrong, someone correct me :
Looking at this page, I don't see any reason that you can't have multiple nodes calling a service. Thus I would create the robot like this :

One main node that subscribe to the service (let's say /isready) that tell him when the robot is ready and set up  by the user.
Then you have a "set-up" node that check if the robot is ready and publish false when not and true when it is ready on the service /isready. This node does all the setup.

Like this you don't need to publish sparse data since everything is done in the setup-node and you just say ready or not when the service is called. If you add a new node in your program it can then connect to the service and ask the same information as well on demand.
Hope it helped.

Originally posted by Maya with karma: 1172 on 2014-05-14
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by paturdc on 2014-05-14:
Thanks for the answer. I'll try the topic solution as it is the simplest and most portable. I guess I have this idea in my head that I shouldn't publish topics with sparse data, but just publishing at a low rate is probably not that bad. I'm still not sure what is considered best practice.
Comment by paturdc on 2014-05-14:
Probably a better solution is to use the ROS parameter server. It is ideal for that kind of data that is small and doesn't really change.
Comment by dornhege on 2014-05-14:
Topics are fine for sparse data. Look at e.g. the /map topic usage.
Comment by paturdc on 2014-05-14:
So do you recommend just publishing a number of topics, like: /arm_in_position and /boundary_set to tell the main node that it's ok to start running?
Comment by Maya on 2014-05-14:
I think I'll personally would go for the service solution. I'm going to edit my answer to explain.
Comment by dornhege on 2014-05-14:
I think this really depends on the actual setup and behavior. Multiple services/topics to wait for something seems kinda odd. Which of your nodes does "know" that the setup is done - as in the interpretation of that?
Comment by paturdc on 2014-05-14:
Only one node is absolutely critical to start before the main. If it isn't running, the robot might crash into the wall. I have several ways of ensuring that it' running (service topics, waitfortransform etc), but I'd like to know if there is a "correct" way of implementing user comm between nodes


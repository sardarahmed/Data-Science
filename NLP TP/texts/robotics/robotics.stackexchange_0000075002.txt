Q:

Obtaining Point by using (column, row) coordinate

How to use pcl::PointCloud<pcl::PointXYZ> PCL data type to get the Euclidean points x, y, z by using its member function:
const PointT& pcl::PointCloud< PointT >::at(int column, int row)

and to save in output object:
pcl::PointCloud<pcl::PointXYZ> output;

tried so much but still didn't get how to get the real world coordinates of point cloud in PCL, if I could access the depth of point than by using the camera parameters I would have done but couldn't get that also.
I tried this:
 output.PointXYZ.p = input->const PointXYZ& pcl::PointCloud::at(34,43)

to check whether it will access pixel at (34,43) position, it's no use.

Originally posted by dinesh on ROS Answers with karma: 932 on 2016-07-05
Post score: 0

A:

This works for me:
void cloudCb(const sensor_msgs::PointCloud2ConstPtr & cloud) {
  pcl::PointCloud<pcl::PointXYZ> depth;
  pcl::fromROSMsg( *cloud, depth);
  int x = 0, y = 0; // set x and y
  pcl::PointXYZ p1 = depth.at(x, y);
}

That comes from a sample that uses the full ROS pointCloud2 data structure, but you should be able to do the same by subscribing to the pcl::PointCloud<pcl::PointXYZ> type.
Note that the PointCloud is already transformed into sensor-relative world coordinates; I don't need to perform any additional transformation or use the camera intrinsics to get XYZ data.
Perhaps if you described the problem better by posting the code that's giving you trouble, how you're running it, describing the desired results, and the actual results, we might be be able to provide more useful advice.

Originally posted by ahendrix with karma: 47576 on 2016-07-05
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by dinesh on 2016-07-05:
thank u for giving me proper solution for this problem, i was so worried for this problem but now i go it. thank u and u people are doing a beautiful work from their. really. next time ill try to describe the problem in more detail.


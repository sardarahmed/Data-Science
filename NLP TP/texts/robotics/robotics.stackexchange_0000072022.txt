Q:

Thread safe spinning with Mutex and boost::threads

I have several threads accessing the same function. To guarantee safe spinning, which means none of the threads calls        ros::spinOnce() at the same time I used a regular mutex. So if the threads wants to spin he has to lock it before, so in case he gets interrupted another thread cannot spin meanwhile, until the locking thread gets cpu-time again and releases the lock. Is this approach good/bad Idea?
    boost::mutex safespinmutex;
    #include <boost/algorithm/string.hpp>
    #include <boost/thread/thread.hpp>
    #include <boost/thread/mutex.hpp>
    boost::mutex mtx_spin;           //shared by publisher threads

    //thread safe regular mutex spin
    mtx_spin.lock();
    ros::spinOnce();
    mtx_spin.unlock();
    loop_rate.sleep();
}

It is similar to c11 mutex, just here I use c98 syntax with boost::threads and boost::mutex :)
Edit more Info I spawn a maximum of 13 threads each dedicated to publishing, which is a lot, but I dont see any problem: The call to lock() blocks the thread if another thread is inside the spinOnce() but yet not finished. Once done this thread unlocks the mutex and unblocks the waiting thread. voila or am I conceptually wrong?
This is how I start the publishing threads
      boost::thread tpool[14]; //thread pool
      int pool = 0;

  for (unsigned i=0; i<13; i++){
        if(rate_eff[i]!=0) {
            tpool[pool++] = boost::thread(publisher,(i+1), use_def);
        }
    }
    cout<<"        publishing on "<<(pool-1)<<" topics:"<<endl;

BenchmarkTo confirm what said above I spawned 9 topics each managed by their own publisher thread. One Incoming thread sorts stuff into the internal vectors rate(100Hz) and the 9 publisher threads read it with 1000Hz rate and push it onto their topic. Does it run safe: Yes.  I am glad about suggestions and improvements but please fortify your statement.  

In case you want to have a look at the complete code here.

Originally posted by user23fj239 on ROS Answers with karma: 748 on 2016-02-14
Post score: 0

A:

Spinning from multiple threads seems like a complex solution to a simple problem. Why not just have a separate thread dedicated to spinning?

Originally posted by ahendrix with karma: 47576 on 2016-02-15
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by user23fj239 on 2016-02-15:
I do have seperate threads dedicated to spinning, BUT if two threads call spinOnce() at the same time needs to be avoided at all time. That's why each thread who wants to spin first accquires a mutx shared by all threads, so he knows he's the only one and allowed to do so. Am I conceptually wrong?
Comment by user23fj239 on 2016-02-15:
If you mean with a separate thread just one thread, is what I try to avoid as it might be too much to process before spinning
Comment by ahendrix on 2016-02-15:
Each publish thread does not need to call spinOnce(). I would create a thread which does nothing but call ros::spin() and which does not do any other processing. ROS publishers are thread-safe, so there are no issues with calling publish() in one thread and spinning in another thread.
Comment by user23fj239 on 2016-02-15:
I wish I knew this before that publish and spin could be seperated.
Comment by ahendrix on 2016-02-16:
The C++ Publisher Tutorial is pretty clear about ros::spinOnce() being unrelated to publish, and only required for callbacks.


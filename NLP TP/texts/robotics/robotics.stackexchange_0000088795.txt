Q:

ROS generic subscriber as a class method

Here I am trying this example's subscriber example code from facontidavide and it works fine as it is. However when I put the topicCallback() in a Class, it's instances appear to share its global variables - whether they are public or private.
class Foo{
private:
    std::string _topic;
public:
    Foo(std::map <std::string, std::string>& info)
    {
        _topic = info["topic"];
    };
    void topicCallback(const topic_tools::ShapeShifter::ConstPtr& msg,
                   const std::string &topic_name,
                   RosIntrospection::Parser& parser)
    {
        ---EXAMPLE CODE---
        cout << _topic << endl;
    }
}

main(){
    ---SOME CODE---
    for (auto &info : topics)
    {
        Foo f(info);
        boost::function<void(const topic_tools::ShapeShifter::ConstPtr&) > callback;
        callback = [&parser, &info, &f](const topic_tools::ShapeShifter::ConstPtr& msg)->void
        {
            f.topicCallback(msg, info.at("topic"), parser) ;
        };
        subscribers.push_back( nh.subscribe(info["topic"], 10, callback) );
    }
    ---SOME MORE CODE---
}

When I create several instances of the class and subscribe to the callback just as in the example code, _topic appears to be the same for all instances. Actually it is the topic of the last instance I create.
This probably might be due to my little understanding of C++11. It'd be a great help if someone could point out what I am doing wrong here.

Edit: Yes it is a C++ related question. But I don't think I'll get an answer by asking this on stackoverflow. I tried using boost::bind instead using a lambda. But it gives some unrecognizable errors like error: use of deleted function xxx May be due to the callback expecting a topic_tools::ShapeShifter for all message types?

Originally posted by teshansj on ROS Answers with karma: 168 on 2018-08-30
Post score: 0

Original comments
Comment by gvdhoorn on 2018-08-30:
I have a feeling this has more to with your use of the lambda there and how you are capturing the context than with anything ROS related.

A:

You create Foo f(info) as a local, and then it goes out of scope and is destructed. However, you're also capturing a reference to f within your lambda, and when f goes out of scope you now have a dangling reference.
You should hold onto all of your Foo objects; maybe make them own their subscriber and then keep them in an array somewhere, instead of just holding onto the subscriber objects.
class Foo {
  public:
    Foo(ros::NodeHandle& nh, std::string topic, RosIntrospection::Parser& parser) 
     : topic_(topic)
     , parser_(parser)
     , subscriber_(nh.subscribe(topic, 10, &Foo::topicCallback, this))
    {
    }

    void topicCallback(const topic_tools::ShapeShifter::ConstPtr& msg)
    {
        ---EXAMPLE CODE---
        cout << _topic << endl;
    }
  private:
    std::string topic_;
    RosIntrospection::Parser& parser_;
    ros::Subscriber subscriber_;
};

main(){
    ---SOME CODE---
    std::vector<Foo> foos;
    for (auto &info : topics)
    {
        foos.emplace_back( nh, info["topic"], parser );
    }
    ---SOME MORE CODE---
}

Originally posted by ahendrix with karma: 47576 on 2018-08-31
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by teshansj on 2018-08-31:
Thanks. This makes more sense. I tried this but still I get use of deleted function errors. This is the only thing I found from the compiler output that makes sense. note: ‘RosIntrospection::details::Tree...’ is implicitly deleted because the default definition would be ill-formed
Comment by teshansj on 2018-08-31:
Errors I get from this is very much similar to the errors I get from using boost::bind. Nothing makes sense. use of deleted functions everywhere
Comment by gvdhoorn on 2018-08-31:
You write yourself that you have "little understanding of C++11" and this really seems like a C++ issue. If nothing makes sense then it would perhaps be good to first get a bit of a better grip on the C++ concepts that you're trying to use?


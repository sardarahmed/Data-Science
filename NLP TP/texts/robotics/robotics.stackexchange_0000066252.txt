Q:

Order of nodes in roslaunch for accessing camera images

I am trying to run two nodes, one being the usb_cam node to start the camera and the second node to use the images for image processing.
As there is no particular order in which the nodes are launched, the image processing node doesn't start displaying the highgui window as I'd written, which I think is probably because the usb_cam node hasn't started ?
It works fine when I run the node independently using rosrun, starting usb_cam node first and then the image processing thread.
How can I solve this problem?
EDIT:
Code -
IMAGE PROCESSING CODE

     #include <ros/ros.h>
     #include <image_transport/image_transport.h>
     #include <cv_bridge/cv_bridge.h>
     #include <sensor_msgs/image_encodings.h>
     #include <opencv2/imgproc/imgproc.hpp>
     #include <opencv2/highgui/highgui.hpp>
     static const std::string OPENCV_WINDOW = "Image window";

     class ImageConverter
     {
         ros::NodeHandle nh_;
         image_transport::ImageTransport it_;
         image_transport::Subscriber image_sub_;
         image_transport::Publisher image_pub_;

     public:
         ImageConverter()
            : it_(nh_)
        {
         // Subscrive to input video feed and publish output video feed
          image_sub_ = it_.subscribe("/usb_cam/image_raw", 1,
          &ImageConverter::imageCb, this);
           image_pub_ = it_.advertise("/image_converter/output_video", 1);

          cv::namedWindow(OPENCV_WINDOW);
        }

        ~ImageConverter()
        {
            cv::destroyWindow(OPENCV_WINDOW);
         }

          void imageCb(const sensor_msgs::ImageConstPtr& msg)
         {

         cv::Mat img, img_resize;
 
           try
           {
              img = cv_bridge::toCvCopy(msg, "mono8")->image;
            }
            catch (cv_bridge::Exception& e)
            {
              ROS_ERROR("cv_bridge exception: %s", e.what());
              return;
            }

            if (img.rows > 60 && img.cols > 60)
                   cv::circle(img, cv::Point(50, 50), 10, CV_RGB(255,0,0));

              cv::resize(img, img_resize, cv::Size2i(img.cols/2, img.rows/2));
              
            
              cv::imshow(OPENCV_WINDOW, img_resize);
              cv::waitKey(3);

            }
        };

        int main(int argc, char** argv)                
        {
          ros::init(argc, argv, "image_converter");
          ImageConverter ic;
          ros::spin();
          return 0;
        }

Launch File:
      <launch>

      <node pkg="usb_cam" type="usb_cam_node" name="usbcam" required="true" clear_params="true" >
           <param name="video_device" value="/dev/video0" />
       </node>

      <node pkg="opencv_ros" type="image" name="image" required="true" clear_params="true" output="screen"/>

      </launch>

It gives me an error
       Webcam: expected picture but didn't get it...

       No JPEG data  found in image

       Error while decoding frame.

but this happens just once(first time I run it after booting). After I kill the process and run it again, it doesn't show this error, but the highui window doesn't open either.

Originally posted by rookie on ROS Answers with karma: 15 on 2015-03-08
Post score: 0

Original comments
Comment by Dirk Thomas on 2015-03-08:
These is no specific order in roslaunch - all nodes are started in parallel. Without seeing your code it is difficult to give any advice. Are both nodes running (rosnode list)? Does it output any error messages?
Comment by rookie on 2015-03-08:
I have added my piece of code to the question. I hope that will help identify the problem. rosnode list shows three nodes acc to launch file: usbcam, image and rosout

A:

Hi,
You can add a .bash to the roslaunch  in order to delay the launch. There is a previous answer with an example on how to do this. http://answers.ros.org/question/51474/can-i-run-a-bash-script-using-roslaunch/
The other option is to call the roslaunch from a .bash file, and simply add pauses in the .bash
Here is an example:

echo "Run simulation full system"
echo "Launching: maps.launch"
gnome-terminal -x sh -c "roslaunch foo maps.launch; exit"
echo "Waiting 30s left"
sleep 30
echo "Launching: planning.launch"
gnome-terminal -x sh -c "roslaunch foo planning.launch; exit"
echo "Waiting 1m left"
sleep 60
"Launching: movement.launch"
gnome-terminal -x sh -c "roslaunch foo movement.launch; exit"
`

Regards

Originally posted by Mario Garzon with karma: 802 on 2016-04-13
This answer was ACCEPTED on the original site
Post score: 0


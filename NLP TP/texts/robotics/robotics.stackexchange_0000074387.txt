Q:

Error: Threads Multiple Definition of

I have two GUI exactly the same except a few alterations. I copy-paste the code and changed only the node.
Code:
  #include "tum_ardrone_gui.h"
#include "RosThread.h"
//#include "PingThread.h"
#include "time.h"
//#include "../HelperFunctions.h"

#include "ros/ros.h"
#include "ros/package.h"

#include <sys/types.h>
#include <dirent.h>
#include <errno.h>
#include <vector>
#include <string>
#include <iostream>
#include <fstream>
#include <string.h>

int getdirtxt (std::string dir, std::vector<std::string> &files)
{
    DIR *dp;
    struct dirent *dirp;
    if((dp  = opendir(dir.c_str())) == NULL) {
        std::cout << "Error(" << errno << ") opening " << dir << std::endl;
        return errno;
    }

    while ((dirp = readdir(dp)) != NULL) {
        std::string f = dirp->d_name;
        if(f.size() > 4 && f.substr(f.size()-4) == ".txt")
            files.push_back(std::string(dirp->d_name));
    }
    closedir(dp);
    return 0;
}

tum_ardrone_gui::tum_ardrone_gui(QWidget *parent)
    : QWidget(parent)
{
    ui.setupUi(this);
    rosThread = NULL;
    sensGaz = sensYaw = sensRP = 1;
    currentControlSource = CONTROL_NONE;
    useHovering = true;

    for(int i=0;i<8;i++)
    {
        isPressed[i] = false;
        lastRepeat[i] = 0;
    }

    QObject::connect( this, SIGNAL(setCountsSignal(unsigned int,unsigned int,unsigned int,unsigned int) ),
                       this, SLOT( setCountsSlot(unsigned int,unsigned int,unsigned int,unsigned int) ) );

    QObject::connect( this, SIGNAL( setPingsSignal(int, int) ),
                       this, SLOT( setPingsSlot(int, int) ) );

    QObject::connect( this, SIGNAL( setControlSourceSignal(int) ),
                       this, SLOT( setControlSourceSlot(int) ) );

    QObject::connect( this, SIGNAL( addLogLineSignal(QString) ),
                       this, SLOT( addLogLineSlot(QString) ) );

    QObject::connect( this, SIGNAL( setAutopilotInfoSignal(QString) ),
                       this, SLOT( setAutopilotInfoSlot(QString) ) );

    QObject::connect( this, SIGNAL( setStateestimationInfoSignal(QString) ),
                       this, SLOT( setStateestimationInfoSlot(QString) ) );

    QObject::connect( this, SIGNAL( setMotorSpeedsSignal(QString) ),
                       this, SLOT( setMotorSpeedsSlot(QString) ) );

    QObject::connect( this, SIGNAL( closeWindowSignal() ),
                       this, SLOT( closeWindowSlot() ) );

    std::vector<std::string> files = std::vector<std::string>();
    getdirtxt(  ros::package::getPath("tum_ardrone") + std::string("/flightPlans/"),files);

    ui.comboBoxLoadFile->addItem(QString(""), QVariant());
    for(unsigned int i=0;i<files.size();i++)
        ui.comboBoxLoadFile->addItem(QString(files[i].c_str()), QVariant());

}

tum_ardrone_gui::~tum_ardrone_gui()
{
}

// clicked functions
void tum_ardrone_gui::LandClicked()
{
    rosThread->sendLand();
}

void tum_ardrone_gui::TakeoffClicked()
{
    rosThread->sendTakeoff();
}
void tum_ardrone_gui::ToggleCamClicked()
{
    rosThread->sendToggleCam();
}
void tum_ardrone_gui::FlattrimClicked()
{
    rosThread->sendFlattrim();
}
void tum_ardrone_gui::EmergencyClicked()
{
    rosThread->sendToggleState();
}

void tum_ardrone_gui::ClearClicked()
{
    rosThread->publishCommand("c clearCommands");
}
void tum_ardrone_gui::SendClicked()
{
    QStringList l = ui.plainTextEditSendCommand->toPlainText().split('\n');
    for(int i=0;i<l.length();i++)
    {
        std::string s = l[i].trimmed().toStdString();

        if(s.size() > 0)
            rosThread->publishCommand(std::string("c ")+s);
    }
    setControlSource(CONTROL_AUTO);
}
void tum_ardrone_gui::ClearSendClicked()
{
    ClearClicked();
    SendClicked();
}
void tum_ardrone_gui::ResetClicked()
{
    setControlSource(CONTROL_NONE);
    ClearClicked();
    rosThread->publishCommand("f reset");
}

void tum_ardrone_gui::LoadFileChanged(QString val)
{
    if(val == "")
        ui.plainTextEditSendCommand->setPlainText("");
    else
    {
        std::string path = ros::package::getPath("tum_ardrone") + std::string("/flightPlans/") + val.toStdString();
        addLogLine("Load File "+ path);

        std::ifstream t;
        t.open(path.c_str());
        std::string buffer = "";
        std::string line;
        while(!t.eof())
        {
            std::getline(t, line);
            buffer = buffer + line + "\n";
        }
        t.close();

        ui.plainTextEditSendCommand->setPlainText(buffer.c_str());
    }
}
void tum_ardrone_gui::ToggledUseHovering(int val)
{
    useHovering = (val != 0);
}

void tum_ardrone_gui::ToggledPingDrone(int val)
{
    pingThread->measure = (val != 0);
}

// change control source functions
void tum_ardrone_gui::ControlSourceChanged()
{
    ControlSource s = CONTROL_NONE;

    if(ui.radioButtonControKB->isChecked())
        s = CONTROL_KB;
    if(ui.radioButtonControlNone->isChecked())
        s = CONTROL_NONE;
    if(ui.radioButtonControlJoy->isChecked())
        s = CONTROL_JOY;
    if(ui.radioButtonControlAuto->isChecked())
        s = CONTROL_AUTO;

    if(s != CONTROL_AUTO)
        rosThread->publishCommand("c stop");
    else
        rosThread->publishCommand("c start");

    currentControlSource = s;
}

void tum_ardrone_gui::setControlSourceSlot(int cont)
{

    currentControlSource = (ControlSource)cont;
    if(cont == CONTROL_KB)
        ui.radioButtonControKB->setChecked(true);
    if(cont == CONTROL_NONE)
        ui.radioButtonControlNone->setChecked(true);
    if(cont == CONTROL_JOY)
        ui.radioButtonControlJoy->setChecked(true);
    if(cont == CONTROL_AUTO)
        ui.radioButtonControlAuto->setChecked(true);

    ControlSourceChanged();
}

void tum_ardrone_gui::setCountsSlot(unsigned int nav,unsigned int control,unsigned int pose,unsigned int joy)
{
    char buf[100];
    snprintf(buf,100, "Drone Control: %d Hz", control);
    ui.labelControl->setText(buf);

    snprintf(buf,100, "Joy Input: %d Hz", joy);
    ui.labelJoy->setText(buf);

    snprintf(buf,100, "Drone Navdata: %d Hz", nav);
    ui.labelNavdata->setText(buf);

    snprintf(buf,100, "Pose Estimates: %d Hz", pose);
    ui.labelPoseEst->setText(buf);
}

void tum_ardrone_gui::setPingsSlot(int p500, int p20000)
{
    char buf[100];
    snprintf(buf,100, "Pings (RTT): %d (500B), %d (20kB)", p500, p20000);
    ui.labelDronePings->setText(buf);
}

void tum_ardrone_gui::addLogLineSlot(QString s)
{
    ui.plainTextEditMessages->appendPlainText(s);
}
void tum_ardrone_gui::setAutopilotInfoSlot(QString s)
{
    ui.plainTextEditAutopilotStatus->setPlainText(s);
}
void tum_ardrone_gui::setStateestimationInfoSlot(QString s)
{
    ui.plainTextEditStateestimationStatus->setPlainText(s);
}
void tum_ardrone_gui::setMotorSpeedsSlot(QString s)
{
    ui.labelDroneMotors->setText(s);
}
void tum_ardrone_gui::closeWindowSlot()
{
    closeWindow();
}

// these may be called from external thread,
// so they just "forward" the request.
void tum_ardrone_gui::setCounts(unsigned int nav,unsigned int control,unsigned int pose,unsigned int joy)
{
    emit setCountsSignal(nav, control, pose, joy);
}
void tum_ardrone_gui::setControlSource(ControlSource cont)
{
    emit setControlSourceSignal((int)cont);
}
void tum_ardrone_gui::addLogLine(std::string s)
{
    emit addLogLineSignal(QString(s.c_str()));
}
void tum_ardrone_gui::setAutopilotInfo(std::string s)
{
    emit setAutopilotInfoSignal(QString(s.c_str()));
}
void tum_ardrone_gui::setMotorSpeeds(std::string s)
{
    emit setMotorSpeedsSignal(QString(s.c_str()));
}
void tum_ardrone_gui::setStateestimationInfo(std::string s)
{
    emit setStateestimationInfoSignal(QString(s.c_str()));
}
void tum_ardrone_gui::setPings(int p500, int p20000)
{
    emit setPingsSignal(p500, p20000);
}
void tum_ardrone_gui::closeWindow()
{
    emit closeWindowSignal();
}

// KB control stuff
int tum_ardrone_gui::mapKey(int k)
{
    switch(k)
    {
        case 74: //j
            return 0;
        case 75: //k
            return 1;
        case 76: //l
            return 2;
        case 73: //i
            return 3;
        case 85: //u
            return 4;
        case 79: //o
            return 5;
        case 81: //q
            return 6;
        case 65: //a
            return 7;
    }
    return -1;
}

void tum_ardrone_gui::keyReleaseEvent( QKeyEvent * key)
{
    if(currentControlSource == CONTROL_KB)
    {
        int idx = mapKey(key->key());
        if(idx >= 0)
        {
            bool changed = false;
            if(!key->isAutoRepeat())    // ignore autorepeat-releases (!)
            {
                changed = isPressed[idx];
                isPressed[idx] = false;
            }

            if(changed)
                rosThread->sendControlToDrone(calcKBControl());
        }
    }
}

void tum_ardrone_gui::keyPressEvent( QKeyEvent * key)
{

    if(currentControlSource == CONTROL_KB)
    {
        int idx = mapKey(key->key());
        if(idx >= 0)
        {
            bool changed = !isPressed[idx];

            isPressed[idx] = true;
            lastRepeat[idx] = getMS();

            if(changed)
                rosThread->sendControlToDrone(calcKBControl());
        }

        else if(key->key() == 83)   // s
            rosThread->sendTakeoff();

        else if(key->key() == 68)   // d
            rosThread->sendLand();
    }

    if(key->key() == 16777216)  // ESC
    {
        setFocus();
        setControlSource(CONTROL_KB);
    }

    if(key->key() == 16777264)  // F1
    {
        rosThread->sendToggleState();
    }
}

ControlCommand tum_ardrone_gui::calcKBControl()
{
    // clear keys that have not been refreshed for 1s, it is set to "not pressed"
    for(int i=0;i<8;i++)
        isPressed[i] = isPressed[i] && ((lastRepeat[i] + 1000) > getMS());

    ControlCommand c;

    if(isPressed[0]) c.roll = -sensRP; // j
    if(isPressed[1]) c.pitch = sensRP; // k
    if(isPressed[2]) c.roll = sensRP; // l
    if(isPressed[3]) c.pitch = -sensRP; // i
    if(isPressed[4]) c.yaw = -sensYaw; // u
    if(isPressed[5]) c.yaw = sensYaw; // o
    if(isPressed[6]) c.gaz = sensRP; // q
    if(isPressed[7]) c.gaz = -sensRP; // a

    return c;
}

But it gives me this error:
CMakeFiles/drone_gui2.dir/src/UINode2/moc_tum_ardrone_gui.cxx.o: In function `tum_ardrone_gui::metaObject() const':
moc_tum_ardrone_gui.cxx:(.text+0x0): multiple definition of `tum_ardrone_gui::metaObject() const'
CMakeFiles/drone_gui2.dir/src/UINode/moc_tum_ardrone_gui.cxx.o:moc_tum_ardrone_gui.cxx:(.text+0x0): first defined here
CMakeFiles/drone_gui2.dir/src/UINode2/moc_tum_ardrone_gui.cxx.o:(.rodata+0x100): multiple definition of `tum_ardrone_gui::staticMetaObject'
CMakeFiles/drone_gui2.dir/src/UINode/moc_tum_ardrone_gui.cxx.o:(.rodata+0x100): first defined here
CMakeFiles/drone_gui2.dir/src/UINode2/moc_tum_ardrone_gui.cxx.o: In function `tum_ardrone_gui::qt_metacast(char const*)':
moc_tum_ardrone_gui.cxx:(.text+0x20): multiple definition of `tum_ardrone_gui::qt_metacast(char const*)'
CMakeFiles/drone_gui2.dir/src/UINode/moc_tum_ardrone_gui.cxx.o:moc_tum_ardrone_gui.cxx:(.text+0x20): first defined here
CMakeFiles/drone_gui2.dir/src/UINode2/moc_tum_ardrone_gui.cxx.o: In function `tum_ardrone_gui::qt_static_metacall(QObject*, QMetaObject::Call, int, void**)':
moc_tum_ardrone_gui.cxx:(.text+0x70): multiple definition of `tum_ardrone_gui::qt_static_metacall(QObject*, QMetaObject::Call, int, void**)'
CMakeFiles/drone_gui2.dir/src/UINode/moc_tum_ardrone_gui.cxx.o:moc_tum_ardrone_gui.cxx:(.text+0x70): first defined here
CMakeFiles/drone_gui2.dir/src/UINode2/moc_tum_ardrone_gui.cxx.o: In function `tum_ardrone_gui::qt_metacall(QMetaObject::Call, int, void**)':
moc_tum_ardrone_gui.cxx:(.text+0x6f0): multiple definition of `tum_ardrone_gui::qt_metacall(QMetaObject::Call, int, void**)'
CMakeFiles/drone_gui2.dir/src/UINode/moc_tum_ardrone_gui.cxx.o:moc_tum_ardrone_gui.cxx:(.text+0x6f0): first defined here
CMakeFiles/drone_gui2.dir/src/UINode2/moc_tum_ardrone_gui.cxx.o: In function `tum_ardrone_gui::setCountsSignal(unsigned int, unsigned int, unsigned int, unsigned int)':
moc_tum_ardrone_gui.cxx:(.text+0x760): multiple definition of `tum_ardrone_gui::setCountsSignal(unsigned int, unsigned int, unsigned int, unsigned int)'
CMakeFiles/drone_gui2.dir/src/UINode/moc_tum_ardrone_gui.cxx.o:moc_tum_ardrone_gui.cxx:(.text+0x760): first defined here
CMakeFiles/drone_gui2.dir/src/UINode2/moc_tum_ardrone_gui.cxx.o: In function `tum_ardrone_gui::setPingsSignal(int, int)':
moc_tum_ardrone_gui.cxx:(.text+0x7c0): multiple definition of `tum_ardrone_gui::setPingsSignal(int, int)'
CMakeFiles/drone_gui2.dir/src/UINode/moc_tum_ardrone_gui.cxx.o:moc_tum_ardrone_gui.cxx:(.text+0x7c0): first defined here
CMakeFiles/drone_gui2.dir/src/UINode2/moc_tum_ardrone_gui.cxx.o: In function `tum_ardrone_gui::setControlSourceSignal(int)':
moc_tum_ardrone_gui.cxx:(.text+0x810): multiple definition of `tum_ardrone_gui::setControlSourceSignal(int)'
CMakeFiles/drone_gui2.dir/src/UINode/moc_tum_ardrone_gui.cxx.o:moc_tum_ardrone_gui.cxx:(.text+0x810): first defined here
CMakeFiles/drone_gui2.dir/src/UINode2/moc_tum_ardrone_gui.cxx.o: In function `tum_ardrone_gui::addLogLineSignal(QString)':
moc_tum_ardrone_gui.cxx:(.text+0x850): multiple definition of `tum_ardrone_gui::addLogLineSignal(QString)'
CMakeFiles/drone_gui2.dir/src/UINode/moc_tum_ardrone_gui.cxx.o:moc_tum_ardrone_gui.cxx:(.text+0x850): first defined here
CMakeFiles/drone_gui2.dir/src/UINode2/moc_tum_ardrone_gui.cxx.o: In function `tum_ardrone_gui::setAutopilotInfoSignal(QString)':
moc_tum_ardrone_gui.cxx:(.text+0x880): multiple definition of `tum_ardrone_gui::setAutopilotInfoSignal(QString)'
CMakeFiles/drone_gui2.dir/src/UINode/moc_tum_ardrone_gui.cxx.o:moc_tum_ardrone_gui.cxx:(.text+0x880): first defined here
CMakeFiles/drone_gui2.dir/src/UINode2/moc_tum_ardrone_gui.cxx.o: In function `tum_ardrone_gui::setStateestimationInfoSignal(QString)':
moc_tum_ardrone_gui.cxx:(.text+0x8b0): multiple definition of `tum_ardrone_gui::setStateestimationInfoSignal(QString)'
CMakeFiles/drone_gui2.dir/src/UINode/moc_tum_ardrone_gui.cxx.o:moc_tum_ardrone_gui.cxx:(.text+0x8b0): first defined here
CMakeFiles/drone_gui2.dir/src/UINode2/moc_tum_ardrone_gui.cxx.o: In function `tum_ardrone_gui::setMotorSpeedsSignal(QString)':
moc_tum_ardrone_gui.cxx:(.text+0x8e0): multiple definition of `tum_ardrone_gui::setMotorSpeedsSignal(QString)'
CMakeFiles/drone_gui2.dir/src/UINode/moc_tum_ardrone_gui.cxx.o:moc_tum_ardrone_gui.cxx:(.text+0x8e0): first defined here
CMakeFiles/drone_gui2.dir/src/UINode2/moc_tum_ardrone_gui.cxx.o: In function `tum_ardrone_gui::closeWindowSignal()':
moc_tum_ardrone_gui.cxx:(.text+0x910): multiple definition of `tum_ardrone_gui::closeWindowSignal()'
CMakeFiles/drone_gui2.dir/src/UINode/moc_tum_ardrone_gui.cxx.o:moc_tum_ardrone_gui.cxx:(.text+0x910): first defined here
CMakeFiles/drone_gui2.dir/src/UINode2/moc_tum_ardrone_gui.cxx.o:(.rodata+0x120): multiple definition of `tum_ardrone_gui::staticMetaObjectExtraData'
CMakeFiles/drone_gui2.dir/src/UINode/moc_tum_ardrone_gui.cxx.o:(.rodata+0x120): first defined here
CMakeFiles/drone_gui2.dir/src/UINode2/main_GUI.cpp.o: In function `main':
main_GUI.cpp:(.text.startup+0xc1): undefined reference to `tum_ardrone_gui::tum_ardrone_gui(QWidget*)'

tum_ardrone.h
> #ifndef __TUMARDRONEGUI_H
#define __TUMARDRONEGUI_H
 
 
 
 
#include <QtGui/QWidget>
#include "ui_tum_ardrone_gui.h"
#include "geometry_msgs/Twist.h"

class RosThread;
class PingThread;
struct ControlCommand;

enum ControlSource {CONTROL_KB = 0, CONTROL_JOY = 1, CONTROL_AUTO = 2, CONTROL_NONE = 3};

class tum_ardrone_gui : public QWidget
{
    Q_OBJECT

public slots:
    void LandClicked();
    void TakeoffClicked();
    void ToggleCamClicked();
    void EmergencyClicked();
    //void ImagemMaster();

    void ClearClicked();
    void SendClicked();
    void ClearSendClicked();
    void ResetClicked();
    void FlattrimClicked();

    void LoadFileChanged(QString val);
    void ToggledUseHovering(int val);
    void ToggledPingDrone(int val);

    void ControlSourceChanged();

private slots:
    void setCountsSlot(unsigned int nav,unsigned int control,unsigned int pose,unsigned int joy);
    void setPingsSlot(int p500, int p20000);
    void setControlSourceSlot(int cont);

    void addLogLineSlot(QString);
    void setAutopilotInfoSlot(QString);
    void setStateestimationInfoSlot(QString);
    void setMotorSpeedsSlot(QString);

    void closeWindowSlot();

signals:
    void setCountsSignal(unsigned int nav,unsigned int control,unsigned int pose,unsigned int joy);
    void setPingsSignal(int p500, int p20000);
    void setControlSourceSignal(int cont);

    void addLogLineSignal(QString);
    void setAutopilotInfoSignal(QString);
    void setStateestimationInfoSignal(QString);
    void setMotorSpeedsSignal(QString);

    void closeWindowSignal();

public:
    tum_ardrone_gui(QWidget *parent = 0);
    ~tum_ardrone_gui();
    RosThread* rosThread;
    PingThread* pingThread;

    void setCounts(unsigned int nav,unsigned int control,unsigned int pose,unsigned int joy);
    void setPings(int p500, int p20000);
    void setControlSource(ControlSource cont);
    void addLogLine(std::string s);
    void setAutopilotInfo(std::string s);
    void setStateestimationInfo(std::string s);
    void setMotorSpeeds(std::string s);
    void closeWindow();

    // calculates KB command, based on currently pressed keys.
    ControlCommand calcKBControl();
    ControlSource currentControlSource;
    double sensGaz, sensYaw, sensRP;
    bool useHovering;

protected:

    // keyboard control.... this is the only way i managed to do this...
    void keyPressEvent( QKeyEvent * key);
    void keyReleaseEvent( QKeyEvent * key);
    int mapKey(int k);
    bool isPressed[8];  //{j k l i u o q a}
    unsigned int lastRepeat[8];

private:
    Ui::tum_ardrone_guiClass ui;
};

#endif /* __TUMARDRONEGUI_H */

So it looks like there's a conflict using a thread with the same name? Why? Anyway to fix it? I saw people saying to use inline method but I tried it and it doesnt work probably because I dont know where to use it.
Any help? Thanks.

Originally posted by Geaper on ROS Answers with karma: 11 on 2016-06-07
Post score: 0

A:

It looks like you are introducing some code in .h files that are included in different .cpp files.
In .h files you only have to put definitions and forward declarations. The code goes inside the cpp files. Otherwise the assemble code of the code will be duplicated in different object files (generated from cpp files)
May be the problem in "HelperFunctions.h" or "PingThread.h"??
where are located functions like this?
tum_ardrone_gui::setCountsSignal(unsigned int, unsigned int, unsigned int, unsigned int)

Originally posted by Pablo Iñigo Blasco with karma: 2982 on 2016-06-07
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Geaper on 2016-06-07:
Thx for helping. In tum_ardrone_gui.h I will post it.
Comment by Geaper on 2016-06-07:
Already posted it.
Comment by Pablo Iñigo Blasco on 2016-06-07:
you must not add code into any .h, only definitions.
Is the cpp code you showed part of the tum_ardrone_gui.h?
Comment by Geaper on 2016-06-07:
Everything works perfectly if I compile only one UINode. I just copy-pasted and renamed another folder to UINode2. But I cant compile UINode and UINode2 because it gives me the error above.
tum_ardrone_gui.h is the header file. It only declares functions
Comment by Pablo Iñigo Blasco on 2016-06-08:
It is hard to say what you have to say if we do not see the whole code and the cmake files and the contents of all the files you use. Anyhow what I can tell you is that your problem is a very typical linking problem in C++ project and it can essentially be solved through the guidelines I told you.
Comment by Geaper on 2016-06-08:
Maybe I can give you the code and u fix it? I can pay via paypal. Thank you.
Comment by Pablo Iñigo Blasco on 2016-06-08:
I can fix it, if it is easy to do I will do it just for help. You can find my contact in my linkedin webpage in my profile.
Comment by Geaper on 2016-06-08:
Thank you. Anyhow I would like to pay you if u fix it. :D
Comment by Geaper on 2016-06-08:
I uploaded the catkin folder. The project is on catkin/src/tum_ardrone/src and it's the UINode. I already deleted but I had a copy-paste folder renamed to UINode2. If u see I have drone_estimation2 and autopilot2 and they work fine. The only problem is on UINode. Check the CMakeLists.
Comment by Geaper on 2016-06-08:
On the bottom there's the copy-pasted drone_estimation2,UINode2 and autopilot2. If you need any help talk to me and I answer fast.
http://www.megafileupload.com/juZD/catkin_ws.tar.gz
Thx for helping me :) Greetings from Portugal. Is that a KUKA robot behind you?
Comment by Pablo Iñigo Blasco on 2016-06-08:
Downloading it, although we should maintain this conversation by email, please put in contact through linkedin.
Greetings from Spain, I was for several month in the University of Coimbra in the ISR department. great city and country :-).
Yes, indeed it is a kuka robot.
Comment by Pablo Iñigo Blasco on 2016-06-08:
do you have skype? my skype is "pibgeus"
Comment by Geaper on 2016-06-08:
I dont but I will download and add you.
Comment by Pablo Iñigo Blasco on 2016-06-10:
is this finally solved?


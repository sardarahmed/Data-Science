Q:

Subscriber can't keep up

I have a rosbag of ~270 Image messages over the course of 9 seconds, and a subscriber that catches them, does a little processing, and publishes a different message.
I had the feeling the subscriber was definitely not keeping up with incoming messages, so I wrote in a little logging to tally what work was actually being done. Each time I run, the count of "jobs finished processing" never gets above 25. I paused and stepped through the rosbag play, and going (comparatively) slowly this way I was able to get 50+ messages before I stopped the test.
I thought it might be an issue with the queues too small, but I set the queue sizes on my Subscriber and the --queue flag on the rosbag play both to 300, so I think that should entirely eliminate the problem if that is it. (It just occurred to me that maybe the maximum is lower than I think, maybe the default 100 is max? Still I would expect at least 100 successful runs, if that many were queued up somewhere.)
What else should I be looking for? Thanks for your advice.

Originally posted by rschwieb on ROS Answers with karma: 11 on 2016-11-10
Post score: 1

A:

Some questions and suggestions:

Are you subscribing directly, or do you use something like message_filters?
Have you tried slowing down the playback, e.g., rosbag play -r0.1?
What does rostopic hz /your-img-topic print?
What does rostopic echo /your-img-topic/header/seq print?
Can you provide a minimal example?
In C++ at least, you could use the rosbag API, if all you want is lossless bagfile processing

Originally posted by Felix Endres with karma: 6468 on 2016-11-11
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by jarvisschultz on 2016-11-11:
Just FYI, rosbag also has a Python API
Comment by rschwieb on 2016-11-11:
@felix What does rostopic hz /your-img-topic print?  While the databag is playing back, I get a sequence of messages like this:  "average rate: 30.047\n        min: 0.003s max: 0.063s std dev: 0.01161s window: 248"
Comment by rschwieb on 2016-11-11:
@felix what does rostopic echo ... print? I get a sequence of 270 integers.
Comment by rschwieb on 2016-11-11:
@felix using the -r0.1, i was able to see the messages for 226 of the messages. I think that must mean with a little more slowing down then the subscriber would see and process everything! I think I'm supposed to be able to handle full playback speed, though.
Comment by rschwieb on 2016-11-11:
This is an evaluation of sorts, so I shouldn't disclose any of the code, and I think it's probably a requirement that this can handle full playback speed. (The evaluator said if I ran into a problem like this it would be OK to ask a generic question here on answers.ros.)
Comment by rschwieb on 2016-11-11:
I'll do whatever I can to clarify the description, though.
Comment by NEngelhard on 2016-11-12:
Have you measured the runtime of your processing of the images?
Comment by rschwieb on 2016-11-12:
@NEngelhard By using time() measurements at the ends of the callback the does the processing, it looks like the routine takes around 0.4 seconds. So it's not surprising that the subscriber gets behind, I just can't figure out why the extra queue space can't keep everything from slipping away.
Comment by NEngelhard on 2016-11-12:
How often do you call a SpinOnce()? I don't know the listener implementation, but I guess that in between calls of spin, the received data is buffered by the network stack and the listener only moves the data to the ROS-Queue during the spin.
Comment by rschwieb on 2016-11-14:
@nengelhard The subscriber is inside listener(), and it triggers the callback that does the processing. Rospy.spin() happens at the end of listener().  So data loss can still happen with this setup?
Comment by NEngelhard on 2016-11-15:
Your TCP endpoint has to buffer the incoming data somehow. And if this buffer is full before you read the raw data and convert it to ROS-Messages (that are then stored in the Subscriber-Queue), the data could be thrown away. But that is just a guess.


Q:

laserscan to cloud display "live"

Hello everybody!
I got a littlebit stucked in my progress. I manged to build a node, which converts my laserscan data "/hokuyo_laser_link" to a pointcloud2 topic "cloud". When i record data and play it back - the node works perfect and i can see my /cloud in RVIZ.
But when I start the node during a "live" test, nothing happens:
thats my progress:

connect via ssh to my kobuki bringup
ros on the kobuki

second terminal: export
ROS_MASTER_URI=http://kobukiIP
export ROS_IP=http:://kobukiIP
rosrun rviz rviz (everthing works
fine)

second terminal: export
ROS_MASTER_URI=http://kobukiIP
export ROS_IP=http:://kobukiIP
./pointcloud2

In RVIZ: Poincloud2 -> status /cloud
topic ok but i cant see anything

here is my node:
#include <ros/ros.h>
#include <sensor_msgs/PointCloud2.h>
#include <pcl/point_types.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl_ros/point_cloud.h>
#include <boost/foreach.hpp>
#include <pcl/io/pcd_io.h>
#include <tf/transform_listener.h>
#include <laser_geometry/laser_geometry.h>

 ros::Publisher pub;

class My_Filter {
     public:
        My_Filter();
        void scanCallback(const sensor_msgs::LaserScan::ConstPtr& scan);
     private:
        ros::NodeHandle node_;
        laser_geometry::LaserProjection projector_;
        tf::TransformListener tfListener_;

        ros::Publisher point_cloud_publisher_;
        ros::Subscriber scan_sub_;
         };

My_Filter::My_Filter(){
        scan_sub_ = node_.subscribe<sensor_msgs::LaserScan> ("/scan", 100, &My_Filter::scanCallback, this);
        point_cloud_publisher_ = node_.advertise<sensor_msgs::PointCloud2> ("/cloud", 100, false);
       tfListener_.setExtrapolationLimit(ros::Duration(0));
}

void My_Filter::scanCallback(const sensor_msgs::LaserScan::ConstPtr& scan){
    sensor_msgs::PointCloud2 cloud;
std::cout << " ich bin drin" << std::endl;
    projector_.transformLaserScanToPointCloud("/hokuyo_laser_link", *scan, cloud, tfListener_);
    point_cloud_publisher_.publish(cloud);
}

int main(int argc, char** argv)
{
    ros::init(argc, argv, "my_filter");

    My_Filter filter;

    ros::spin();

    return 0;
}

Has anyone an idea?
Thank you all in advance!
Cheers!

Originally posted by Ben on ROS Answers with karma: 16 on 2017-02-06
Post score: 0

A:

Ok, got it:
you dont have to do
export ROS_IP=KobukiIP

before starting the node.

Originally posted by Ben with karma: 16 on 2017-02-06
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by gvdhoorn on 2017-02-06:
That would never work, as ROS_IP is supposed to only contain an ip address, not a URI.
Comment by ahendrix on 2017-02-06:
Despite having different names, ROS_IP and ROS_HOSTNAME are treated identically.
Comment by gvdhoorn on 2017-02-07:
But http://.. is still not a valid hostname ;)
Comment by Ben on 2017-02-07:
Yeah, you are total right. I just use this to describe it here in the thread (i dont want to post my real adress)
Comment by gvdhoorn on 2017-02-07:
So in your real configuration, you did not use ROS_IP=http://..?
Comment by Ben on 2017-02-07:
No,
in my setup,i was not able to start RVIZ until i export the ROS_IP=ipofmyremotecomputer
I followed this tutorial:
www.umiacs.umd.edu/~cteo/umd-erratic-ros-data/README-rvis-remote
Comment by gvdhoorn on 2017-02-07:
I specifically asked whether you added the http:// prefix to the IP, but I think we got that cleared up.
In any case: ROS_IP and ROS_HOSTNAME should not include the http:// prefix.
Comment by ahendrix on 2017-02-07:
@gvdhoorn: ah, yes. The http:// prefix is inappropriate here.


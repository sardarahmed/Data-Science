Q:

how does Moveit communicate to Gazebo?

Hi all,
I was able to simulate the UR5 and control it in simulation from RViz, fololwing these steps:
$ roslaunch ur_gazebo ur5.launch

$ roslaunch ur5_moveit_config ur5_moveit_planning_execution.launch sim:=true

$ roslaunch ur5_moveit_config moveit_rviz.launch config:=true

Now I would like to know how to control the real UR5, but first I need to know how RViz is talking to Gazebo in order to make the robot moves. Does anyone know what kind of input is needed by gazebo? Or better, what kind of information is being sent to Gazebo when I press "plan and execute" in RViz? I suspect they are the joints states, but I don't know where to read this information.
Thank you for your help in advance.

Edit: Thanks a lot for your answer, now everything is a bit more clear. But I have another question at this point.
I tried to communicate with the real hardware and I was able to move the robot running "test_move.py" from the "ur_modern_driver package".
After that I tried to move the robot with MoveIt! following this tutorial:
http://wiki.ros.org/universal_robot/Tutorials/Getting%20Started%20with%20a%20Universal%20Robot%20and%20ROS-Industrial
Problems arise when launching this command:
roslaunch ur5_moveit_config ur5_moveit_planning_execution.launch limited:=true

In the terminal the following lines appear:
[ WARN] [1529329845.474785699]: Waiting for /joint_trajectory_action to come up
[ WARN] [1529329851.474995251]: Waiting for /joint_trajectory_action to come up
[ERROR] [1529329857.475168563]: Action client not connected: /joint_trajectory_action

So that when i launch MoveIt (by typing roslaunch ur5_moveit_config moveit_rviz.launch config:=true) to try planning and execution, the planning is ok but the execution never works.
And the same is with using the limited version (limited:=true).
Do you have any idea why this happens?

Originally posted by enrico on ROS Answers with karma: 117 on 2018-06-07
Post score: 1

Original comments
Comment by gvdhoorn on 2018-06-18:
Please do not post answers, unless you are answering your own question. For short interactions, use comments. For updating us with new information, or anything else, edit your original question. Use the edit button/link for that.
I've already merged your answer into your question.
Comment by gvdhoorn on 2018-06-18:
Also: your update sounds like a different issue, almost unrelated to your initial question (which was about how Gazebo interacts with a ROS application).
Your update is about real hw and a driver that is not used with Gazebo, so please ask this in a new question (if you can't find earlier Q&As).

A:

I'm going to answer this in a bit of a weird way, but hopefully that gets the point across really quickly.

Does anyone know what kind of input is needed by gazebo?

None.

Or better, what kind of information is being sent to Gazebo when I press "plan and execute" in RViz?

Nothing.

I suspect they are the joints states, [..]

No, they're not.

The best way to think about ROS<->Gazebo integration is to consider Gazebo (or more specifically: a simulation of a specific robot / system) as a stand-in for your real robot / hw.
Where real hw needs drivers to get info out of your sensors into your ROS node graph, and actuation commands out of your node graph and 'into' your actuators, a Gazebo simulation (considered as surrogate hw) will need similar components.
We don't call those drivers though, but plugins. They serve a similar function: they 'extract' data from Gazebo, transform that to msgs and publish those as sensor data. Similarly, these plugins accept actuation commands and pass them on to virtual actuators.
So pendantically I believe my answers above are correct: Gazebo itself does not need any input data, and there is nothing sent to Gazebo itself either. The plugins are the entities that deal with those dataflows.
As to your concrete use-case: people typically use gazebo_ros_control when simulating serial manipulators with Gazebo. This is a plugin that essentially allows you to run controllers from ros_controllers inside Gazebo as if it was real hardware.
Communication with these controllers (running on the virtual hw) is then identical to how you'd communicate with drivers: via topics. For a serial manipulator that would probably be the joint_trajectory_controller that accepts FollowJointTrajectory action goals (input) and the joint_state_controller publishing JointState messages (output).
MoveIt then consumes the JointState messages and submits the action goals.

Originally posted by gvdhoorn with karma: 86574 on 2018-06-07
This answer was ACCEPTED on the original site
Post score: 6

Original comments
Comment by gvdhoorn on 2018-06-09:
Final comment (and perhaps even the real answer): MoveIt doesn't actually communicate with Gazebo. In fact, it doesn't even know anything about Gazebo, or even what it's communicating with - period.
This is all hidden by the action interfaces and topics that it uses.
Comment by Aabed Solayman on 2020-08-11:
This is a great answer! Thank you!


Q:

Passing pcl::shared_ptr to subscriber (ROS2 Foxy)

I am trying to write a pointcloud filtering node in ROS2 foxy using pcl but I am running into some problems I think are resulting from the publishing.
The resulting error is
~/ros2_ws$ colcon build --symlink-install --packages-select pointcloud_filters
Starting >>> pointcloud_filters
--- stderr: pointcloud_filters                                
** WARNING ** io features related to pcap will be disabled
** WARNING ** io features related to png will be disabled
** WARNING ** io features related to libusb-1.0 will be disabled
/usr/bin/ld: CMakeFiles/pointcloud_filters_node.dir/src/pointcloud_filters_node.cpp.o: in function `rclcpp::Publisher<pcl::PointCloud<pcl::PointXYZI>, std::allocator<void> >::Publisher(rclcpp::node_interfaces::NodeBaseInterface*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, rclcpp::QoS const&, rclcpp::PublisherOptionsWithAllocator<std::allocator<void> > const&)':
pointcloud_filters_node.cpp:(.text._ZN6rclcpp9PublisherIN3pcl10PointCloudINS1_9PointXYZIEEESaIvEEC2EPNS_15node_interfaces17NodeBaseInterfaceERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_3QoSERKNS_29PublisherOptionsWithAllocatorIS5_EE[_ZN6rclcpp9PublisherIN3pcl10PointCloudINS1_9PointXYZIEEESaIvEEC5EPNS_15node_interfaces17NodeBaseInterfaceERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_3QoSERKNS_29PublisherOptionsWithAllocatorIS5_EE]+0x6e): undefined reference to `rosidl_message_type_support_t const* rosidl_typesupport_cpp::get_message_type_support_handle<pcl::PointCloud<pcl::PointXYZI> >()'
collect2: error: ld returned 1 exit status
make[2]: *** [CMakeFiles/pointcloud_filters_node.dir/build.make:317: pointcloud_filters_node] Error 1
make[1]: *** [CMakeFiles/Makefile2:78: CMakeFiles/pointcloud_filters_node.dir/all] Error 2
make: *** [Makefile:141: all] Error 2
---
Failed   <<< pointcloud_filters [12.3s, exited with code 2]
                                 
Summary: 0 packages finished [12.4s]
  1 package failed: pointcloud_filters
  1 package had stderr output: pointcloud_filters

so its complaining about some undefined reference. I'm not entirely sure what the problem is but it seems like it could be similar to https://answers.ros.org/question/311748/how-to-pass-boostshared_ptr-in-create_subscription-ros2/. I looked at the interfaces for sensor_msgs/msg/PointCloud2 and sensor_msgs/msg./PointField and it looks identical to pcl::PointCloud so maybe I should manually transfer the attributes?
CPP file:
#include "rclcpp/rclcpp.hpp"
#include "sensor_msgs/msg/point_cloud2.hpp"

#include "pcl_conversions/pcl_conversions.h"

#include "pcl/filters/radius_outlier_removal.h"
#include "pcl/impl/point_types.hpp"
#include "pcl/point_cloud.h"

class PCFilter : public rclcpp::Node {
public:
  PCFilter() : Node("pointcloud_filters") {
    pub_ = this->create_publisher<pcl::PointCloud<pcl::PointXYZI>>(
        "filters_output", 1);
    sub_ = this->create_subscription<sensor_msgs::msg::PointCloud2>(
        "filters_input", 1,
        std::bind(&PCFilter::cloud_callback, this, std::placeholders::_1));

    this->declare_parameter("pointcloud_filters/neighbors", 1);
    this->declare_parameter("pointcloud_filters/radius", 0.2);
    this->declare_parameter("pointcloud_filters/distance", 5.0);
    this->declare_parameter("pointcloud_filters/intensity_threshold", 8);

    neighbors_ = this->get_parameter("pointcloud_filters/neighbors").as_int();
    radius_ = this->get_parameter("pointcloud_filters/radius").as_double();
    distance_ = this->get_parameter("pointcloud_filters/distance").as_double();
    intensity_threshold_ =
        this->get_parameter("pointcloud_filters/intensity_threshold").as_int();

    RCLCPP_INFO(this->get_logger(),
                "Filter "
                "pararms:\n\tneighbors:%d\t\nradius:%f\n\tdistance:%"
                "f\n\tintensity_threshold:%d",
                neighbors_, radius_, distance_, intensity_threshold_);
  }

private:
  void cloud_callback(const sensor_msgs::msg::PointCloud2::SharedPtr msg) {
    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud(
        new pcl::PointCloud<pcl::PointXYZI>);
    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud_filtered(
        new pcl::PointCloud<pcl::PointXYZI>);
    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud_dust_filtered(
        new pcl::PointCloud<pcl::PointXYZI>);

    pcl::fromROSMsg(*msg, *cloud);

    if (cloud->size() > 0) {
      // Filter dust based on low intensity within a certain distance from the
      // lidar
      double dist = 0.0;
      for (std::size_t n = 0; n < cloud->size(); n++) {
        dist = std::sqrt(std::pow(cloud->points[n].x, 2) +
                         std::pow(cloud->points[n].y, 2) +
                         std::pow(cloud->points[n].z, 2));
        if (dist < distance_) {
          if (cloud->points[n].intensity > intensity_threshold_) {
            cloud_dust_filtered->push_back(cloud->points[n]);
          }
        } else {
          cloud_dust_filtered->push_back(cloud->points[n]);
        }
      }

      cloud_dust_filtered->header.frame_id = cloud->header.frame_id;
      cloud_dust_filtered->header.stamp = cloud->header.stamp;

      // Create radius outlier removal filter
      pcl::RadiusOutlierRemoval<pcl::PointXYZI> outrem;
      outrem.setInputCloud(cloud_dust_filtered);
      outrem.setRadiusSearch(radius_);
      outrem.setMinNeighborsInRadius(neighbors_);
      // Apply filter
      outrem.filter(*cloud_filtered);
      pub_->publish(*cloud_filtered);
    } else {
      pub_->publish(*cloud);
      RCLCPP_INFO(this->get_logger(), "Empty pointcloud recieved");
    }
  }

  int neighbors_;
  double radius_;
  double distance_;
  int intensity_threshold_;

  rclcpp::Publisher<pcl::PointCloud<pcl::PointXYZI>>::SharedPtr pub_;
  rclcpp::Subscription<sensor_msgs::msg::PointCloud2>::SharedPtr sub_;
};

int main(int argc, char *argv[]) {
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<PCFilter>());
  rclcpp::shutdown();
  return 0;
}

CMakeList:
cmake_minimum_required(VERSION 3.5)
project(pointcloud_filters)

# Default to C99
if(NOT CMAKE_C_STANDARD)
  set(CMAKE_C_STANDARD 99)
endif()

# Default to C++14
if(NOT CMAKE_CXX_STANDARD)
  set(CMAKE_CXX_STANDARD 14)
endif()

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(sensor_msgs REQUIRED)
find_package(pcl_conversions REQUIRED)
find_package(PCL REQUIRED)

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  # the following line skips the linter which checks for copyrights
  # uncomment the line when a copyright and license is not present in all source files
  #set(ament_cmake_copyright_FOUND TRUE)
  # the following line skips cpplint (only works in a git repo)
  # uncomment the line when this package is not in a git repo
  #set(ament_cmake_cpplint_FOUND TRUE)
  ament_lint_auto_find_test_dependencies()
endif()

include_directories(
  include
  ${PCL_INCLUDE_DIRS}
)
link_directories(${PCL_LIBRARY_DIRS})
add_definitions(${PCL_DEFINITIONS})

add_executable(${PROJECT_NAME}_node src/pointcloud_filters_node.cpp)
target_link_libraries(${PROJECT_NAME}_node ${PCL_LIBRARIES})
ament_target_dependencies(${PROJECT_NAME}_node rclcpp sensor_msgs pcl_conversions PCL)

install(TARGETS
  ${PROJECT_NAME}_node
  DESTINATION lib/${PROJECT_NAME}
)

install(DIRECTORY
    launch
    DESTINATION share/${PROJECT_NAME}/
)

ament_package()
enter code here

Originally posted by morten on ROS Answers with karma: 198 on 2021-09-21
Post score: 0

A:

A potential solution I have found: taking more advantage of the pcl_conversions library.
Instead of trying to publish pcl::PointCloud<pcl::PointXYZI>> utilize the pcl::toROSMsg conversion by
void cloud_callback(const sensor_msgs::msg::PointCloud2::SharedPtr msg) {
    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud(
        new pcl::PointCloud<pcl::PointXYZI>);
    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud_filtered(
        new pcl::PointCloud<pcl::PointXYZI>);
    pcl::fromROSMsg(*msg, *cloud);
    
    pass_.setInputCloud(cloud);
    pass_.filter(*cloud_filtered);

    // new things
    sensor_msgs::msg::PointCloud2 output;
    pcl::toROSMsg(*cloud_filtered, output);
    
    pub_->publish(output);
}

and thereby changing the subscriber to
PCFilter() : Node("pointcloud_filters") {
    pub_ = this->create_publisher<sensor_msgs::msg::PointCloud2>>("filters_output", 1); 
...}

Note: My understanding is constantly converting with pcl::fromROSMsg and pcl::toROSMsg add unnecessary computations, looking into how to avoid this. Not so familiar with pointclouds in ROS

Originally posted by morten with karma: 198 on 2021-09-22
This answer was ACCEPTED on the original site
Post score: 1


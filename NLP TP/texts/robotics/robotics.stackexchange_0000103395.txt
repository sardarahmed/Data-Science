Q:

Compile ROS2 package with pre-compiled shared library

Hi there,
In my ros2 package, I want to compile the node with a shared library, which is an SDK shared library provided by the manufacturer of the hardware. I am able to compile my code with link_directories that points to the location of the shared library (which locates inside the ros2 package).
Back in ROS1, that's it. I could execute my node and it will load the shared library correctly during runtime.
However, in ROS2, I have to install all the files to DESTINATION lib/${PROJECT_NAME} like this:
install(FILES 
${ORBBEC_SDK_LIB_DIR}/libOrbbecSDK.so.1.5
${ORBBEC_SDK_LIB_DIR}/libOrbbecSDK.so.1.5.7
${ORBBEC_SDK_LIB_DIR}/libOrbbecSDK.so
${ORBBEC_SDK_LIB_DIR}/libudev.so
${ORBBEC_SDK_LIB_DIR}/libudev.so.1
${ORBBEC_SDK_LIB_DIR}/libudev.so.1.6.3
DESTINATION lib/${PROJECT_NAME}
)

Apparently, this just copied and pasted these files to DESTINATION lib/${PROJECT_NAME}.
Another option that could work is that I can make an environment hook to add the folder of the shared library to LD_LIBRARY_PATH.
Both solutions are kind of gross.
What is the proper way of doing this?
In ROS 1 how does it find the shared library in the src folder? Since the setup.bash does not modify the LD_LIBRARY_PATH, I have no idea how does it find the shared library object. (I am sure the .so file is not in the system library.)

Originally posted by hank880907 on ROS Answers with karma: 50 on 2023-07-06
Post score: 0

Original comments
Comment by magladko on 2023-07-06:
I am using pre-compiled libraries by invoking:
INCLUDE_DIRECTORIES( ${LIBRARY_INCLUDE_DIRECTORIES} )
LINK_DIRECTORIES(  ${LIBRARY_DIRECTORIES} )
TARGET_LINK_DIRECTORIES(${TARGET} ${LIBRARY_DIRECTORIES})

I did not notice any copy-pasting and the package works alright.

A:

Apparently, this just copied and pasted these files to DESTINATION lib/${PROJECT_NAME}.

This is the "proper" way to do this. That's exactly what an install rule is supposed to do. In general after you have built the runtime environment should only be interacting with installed files. After installation it should run without the source tree available on disk anymore.
In ROS 1 we did quite a bit of non-standard work to make things work from the source workspace but they are convenient for many use cases, but turn into problems when you try to flesh out all corner cases. So ROS 2 does it the standard way with requiring installation of resources.

Originally posted by tfoote with karma: 58457 on 2023-07-06
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by hank880907 on 2023-07-06:
I see! Thanks for the explanation!


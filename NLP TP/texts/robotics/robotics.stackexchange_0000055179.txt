Q:

Help with calling a ros method

Hi everyone, I have been trying to convert the following code on this tutorial  link:text into .cpp and .h files. This is not an algorithm question as the code works when it is all in one .cpp file. Here is what I have so far in my .cpp file:
    //Code from http://siddhantahuja.wordpress.com/2011/07/20/working-with-ros-and-opencv-draft/
#include "../header/Webcam.h"
#include <iostream>

void Webcam::invertImage(cv_bridge::CvImagePtr cv_ptr){
 //Invert Image
    //Go through all the rows
    for(int i=0; i<cv_ptr->image.rows; i++)
    {
        //Go through all the columns
        for(int j=0; j<cv_ptr->image.cols; j++)
        {
            //Go through all the channels (b, g, r)
            for(int k=0; k<cv_ptr->image.channels(); k++)
            {
                //Invert the image by subtracting image data from 255               
                cv_ptr->image.data[i*cv_ptr->image.rows*4+j*3 + k] = 255-cv_ptr->image.data[i*cv_ptr->image.rows*4+j*3 + k];
            }
        }
    }
}

 void Webcam::imageCallback(const sensor_msgs::ImageConstPtr& camera_image)
{

//Store all constants for image encodings in the enc namespace to be used later.
namespace enc = sensor_msgs::image_encodings;
 
//Declare a string with the name of the window that we will create using OpenCV where processed images will be displayed.
static const char WINDOW[] = "Image Processed";
 
//Use method of ImageTransport to create image publisher
image_transport::Publisher pub;

    //Convert from the ROS image message to a CvImage suitable for working with OpenCV for processing
    cv_bridge::CvImagePtr cv_ptr;
    try
    {
        //Always copy, returning a mutable CvImage
        //OpenCV expects color images to use BGR channel order.
        cv_ptr = cv_bridge::toCvCopy(camera_image, enc::BGR8);
    }
    catch (cv_bridge::Exception& e)
    {
        //if there is an error during conversion, display it
        ROS_ERROR("camera::main.cpp::cv_bridge exception: %s", e.what());
        return;
    }
 
   //modify the image
   Webcam wc;
   wc.invertImage(cv_ptr);
     
 
    //Display the image using OpenCV
    cv::imshow(WINDOW, cv_ptr->image);
    //Add some delay in miliseconds. The function only works if there is at least one HighGUI window created and the window is active. If there are several HighGUI windows, any of them can be active.
    cv::waitKey(3);
    /**
    * The publish() function is how you send messages. The parameter
    * is the message object. The type of this object must agree with the type
    * given as a template parameter to the advertise<>() call, as was done
    * in the constructor in main().
    */
    //Convert the CvImage to a ROS image message and publish it on the "camera/image_processed" topic.
        pub.publish(cv_ptr->toImageMsg());
}
 

Here is the .h file:
//Includes all the headers necessary to use the most common public pieces of the ROS system.
#include <ros/ros.h>
//Use image_transport for publishing and subscribing to images in ROS
#include <image_transport/image_transport.h>
//Use cv_bridge to convert between ROS and OpenCV Image formats
#include <cv_bridge/cv_bridge.h>
//Include some useful constants for image encoding. Refer to: http://www.ros.org/doc/api/sensor_msgs/html/namespacesensor__msgs_1_1image__encodings.html for more info.
#include <sensor_msgs/image_encodings.h>
//Include headers for OpenCV Image processing
#include <opencv2/imgproc/imgproc.hpp>
//Include headers for OpenCV GUI handling
#include <opencv2/highgui/highgui.hpp>

class Webcam{
    public:
   void imageCallback(const sensor_msgs::ImageConstPtr& original_image);
   void invertImage(cv_bridge::CvImagePtr cv_ptr);
   
 
   
    private:
    
     
    
};

Here is my main:
#include "header/Webcam.h"
 
//Store all constants for image encodings in the enc namespace to be used later.
namespace enc = sensor_msgs::image_encodings;
 
//Declare a string with the name of the window that we will create using OpenCV where processed images will be displayed.
static const char WINDOW[] = "Image Processed";
 
//Use method of ImageTransport to create image publisher
image_transport::Publisher pub;
 
//This function is called everytime a new image is published

int main(int argc, char **argv)
{
   
        ros::init(argc, argv, "image_processor");

        ros::NodeHandle nh;
    //Create an ImageTransport instance, initializing it with our NodeHandle.
        image_transport::ImageTransport it(nh);
    //OpenCV HighGUI call to create a display window on start-up.
    cv::namedWindow(WINDOW, CV_WINDOW_AUTOSIZE);
   
    Webcam wc;
        image_transport::Subscriber sub = it.subscribe("camera/image_raw", 1, &Webcam::imageCallback,&wc); //"camera/image_raw"
    //OpenCV HighGUI call to destroy a display window on shut-down.
    cv::destroyWindow(WINDOW);
   
        pub = it.advertise("camera/image_processed", 1); //ERROR
   
        ros::spin();
    //ROS_INFO is the replacement for printf/cout.
    ROS_INFO("Camera::main.cpp::No error.");
 
}

 

I get an error when I try to create an object of class Webcam and call the imageCallback method. I find it strange that in the original documentation, it does not use the method  imageCallback with the parenthesis such as  imageCallback(original_image).
Thanks in advance!

Originally posted by JP on ROS Answers with karma: 95 on 2013-11-01
Post score: 0

A:

In your header you declare three methods. But in their definitions only one of them has a WebCam:: prefix. Which makes your imageCallback method no real instance member, so what give as the callback cannot work.
If after fixing it still does not work, check your syntax with the wiki: roscpp/Overview -> Publishing

Originally posted by felix k with karma: 1650 on 2013-11-01
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by JP on 2013-11-01:
Thanks for the help! I also looked at the roscpp/Overview and I have updated my code above to reflect my changes. I do have a problem when I advertise my processed image over ROS. I get the error: Call to publish() on an invalid image_transport::Publisher which is called in my main near the bottom.


Q:

Robot drives arm into table on its way to target pose

Greetings,
Apologies for newbie question.  Is there a command that moves "straight" to a target set of joint angles, where "straight" means the end effector moves in a roughly straight line?
Background:
I use my Kinova MICO 4DOF arm for art projects.  I drive it with shell commands.  It currently plays a decent game of chess, using a DGT sensory board.  I'm an end user who programs in bash, consumed by art projects that leave little time for mastering robotics.
I've recorded joint angles for all robot arm poses of interest.  I can get current joint positions with:
rostopic echo -c /m1n4s200_driver/out/joint_angles
I subtract these from the target-position angles, and drive the arm like this:
rosrun kinova_demo joints_action_client.py -v -r m1n4s200 degree -- $M1 $M2 $M3 $M4
This works fine much of the time.  However, all joints seem to move at the same speed independently, toward their individual goals.  So the end effector follows a ponderous curvy path.  Depending on where the joints are, the robot will often try to drive straight through the table surface (presumably hoping to emerge somewhere else en route to the target angles).
Is there a command that will move the end effector straight, or avoid the table surface?  I'm using joint angles, not Cartesian positions.
I'm using kinova-ros, as described here:
https://github.com/Kinovarobotics/kinova-ros/blob/master/README.md
Everything I know comes from this document -- it's a pretty spare tutorial for me.
Thanks,
Kevin
PS. My software versions:
% rosversion -d
kinetic

% lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 16.04.4 LTS
Release:        16.04
Codename:       xenial

Originally posted by kevin.crawford.knight on ROS Answers with karma: 3 on 2018-08-19
Post score: 0

A:

You need to plan a path for the end effector to follow and then control the joint motors at varying speeds over time to move the end effector along this path. Planning can involve making sure the robot doesn't collide with itself, making sure any part of the robot doesn't try to drive through the table, varying the speeds of joints to give smooth motion of the end effector, and many other factors. Sounds difficult, right? It is! That's why we all use the MoveIt! stack to control our manipulators.
Fortunately, it looks like the Kinova Robotics ROS software supports MoveIt! as of version 1.20.
MoveIt is a very complex piece of software, but the simple things like what you want to do are relatively straightforward. You do need to learn a little about how it works, though. There are a lot of tutorials available. I recommend you start by going through that Kinova Robotics page to make sure it's all working, and then move on to the tutorials provided by MoveIt. The quickstart tutorial could be a good place to begin. If you want a simple API to do simple tasks, then the Python interface is the one for you. That tutorial will take you through the basics of telling the end effector to go somewhere. In particular, pay attention to the bit about adding objects to the planning scene. This is how you tell MoveIt that you have a table and chess pieces so that it doesn't try to drive through the table or throw chess pieces around the room like an angry toddler.
The tutorials on the C++ API give a lot more detail on the things that are possible with MoveIt. The majority of them are possible with the Python API as well so don't feel like you have to learn C++ just to use MoveIt.
If ultimately you want to program it all using bash, then I recommend you make a simple Python script that sends an end effector goal to the robot using MoveIt and executes that motion before returning. Then you can do the rest through bash.

Originally posted by Geoff with karma: 4203 on 2018-08-19
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by PeteBlackerThe3rd on 2018-08-20:
I'd just like to add that the OP's goal of moving the end effector I'm a straight line to a goal is actually a very challenging task and in some cases impossible where that route passes through a singularity. Hence the requirement to use a path planning algorithm to achieve this goal.
Comment by kevin.crawford.knight on 2018-08-21:
Thank you very much for the clear explanation.  I got 90% of the way there with rosrun shell commands, but for the last 10%, looks like I should learn MoveIt and Python and 3D models.  At least I know the path!  Thanks for your patience @gvdhorn, much obliged.
Comment by Geoff on 2018-08-21:
You won't need to learn too much about 3D models to use MoveIt. The robot comes with its own 3D model, and for representing things in the environment you can get away with using boxes.


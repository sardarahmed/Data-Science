Q:

calculate NavSatFix covariance

This is with reference to: http://www.ros.org/doc/api/sensor_msgs/html/msg/NavSatFix.html
I am wondering how can I see the code behind position_covariance data structure filled in this message and how the four different parameters -
uint8 COVARIANCE_TYPE_UNKNOWN = 0
uint8 COVARIANCE_TYPE_APPROXIMATED = 1
uint8 COVARIANCE_TYPE_DIAGONAL_KNOWN = 2
uint8 COVARIANCE_TYPE_KNOWN = 3

change the position_covariance values respectively.
Would appreciate some pointer link to where I can see the actual code. I am not able to find it.

Originally posted by Vaibhav Bajpai on ROS Answers with karma: 58 on 2011-06-18
Post score: 3

A:

Hi Vaibhav,
This message is part of sensor_msgs, these are designed to be output by "drivers" that communication with varying hardware and output a ROS unified message.  An example of this would be LaserScan.  It doesn't matter whether you're using a Hokuyo, a SICK, or even a Neato XV-11 laser, the responsibility of the driver is to talk to the sensor and publish the appropriate sensor_msg.
We're still going pretty slowly on actually providing code that uses any GPS signals, but I'll explain use cases for each of these definitions.  It should be noted that these do NOT affect the actual covariance numbers, but are guidelines for how they should be used and trusted by a sensor fusion algorithm.
uint8 COVARIANCE_TYPE_UNKNOWN = 0
This is to be used when your GPS does not provide any quality estimation or you do not know to model the reported precision in SI units (m^2).  Filtering algorithms will assume large possible errors with this case and some safety applications may outright reject this.
uint8 COVARIANCE_TYPE_APPROXIMATED = 1
There are multiple use cases for this one, and for low cost GPS sensors, this will be the most used.  The first would be for use cases like Android Location Services.  This only returns a single float (in meters, so don't forget to square!) when you call getAccuracy().  One safe way to use the data would be to approximate the covariance as a diagonal matrix with the accuracy squared for each axis you wish to report.
Another use case would be for when your receiver outputs Dilution of Precision.  If you only get one value, as above, you would take the dilution of precision value (somewhere between 1 [ideal] and >20 [really bad]) and multiply this by the ideal measurement error (usually a few meters, let's say 1.5m for now).  So an HDOP (horizontal) dilution of precision of 2.3 would yield a 1.5m * 2.3 = 3.45m standard deviation and thus a variance of 11.90m^2 for latitude and longitude.  Doing the same with height and HDOP should yield similar results.
uint8 COVARIANCE_TYPE_DIAGONAL_KNOWN = 2
This one is useful for high end GPS receivers that actually output variances or standard deviations for every measurement.  Example: Our Novatel Propak HP-V3 outputs latitude deviation, longitude deviation, and height deviation.  We simply have to square these values and plug them into the diagonal of the covariance matrix, leaving the other elements zero.
uint8 COVARIANCE_TYPE_KNOWN = 3
Represents what should be reported if the GPS receiver actually outputs the 3x3 covariance matrix as a set of 9 numbers.  I expect these receivers to be fairly expensive and complicated.  This set will be fully trusted by filtering algorithms as accurate, so don't report this if your receiver does not support full covariance matrices.

Originally posted by Chad Rockey with karma: 4541 on 2011-06-19
This answer was ACCEPTED on the original site
Post score: 5


Q:

SLAM with cartesian point clouds

I'm doing an autonomous navigation project as my Capstone project with a Raspberry Pi 3 in c/c++ and I'm trying to figure out how to deal with the robot's locating. A robot has been given to me, it already receives user input to be controlled manually with an Arduino(receives characters from a RPI: 'f' = forward, 'r' = rotate etc). I will list the details for a bit of organization:
**Hardware:**
- Rpi3
- Arduino
- RPLiDAR A2(2D LiDAR)
- Servo(changes lidars pitch up and down to make 3D point clouds)
 **With the code I've written so far in C++ from scratch I'm able to:**
- Convert spherical coordinates to xyz Point Cloud
- Discard points higher than robot and floor(not going to collide with those)
- Make a 2D map with the points (ignoring z-axis)
- Merge a new "map" to the main map using the robot's new position and yaw(I've only tested this manually, no IMU)
 **Requirements:**
 - Can't use a raw 2D data(RPLiDAR without change in pitch) to ensure it detects objects higher and lower than the LiDAR. 
**Additional tools I'm using:**
- D* Lite algoritm in C++ (not mine, so not too emotionally attached, the 2D map has been tested with it)
- GNUplot (just to confirm I'm processing the raw coordinates correctly)
After some research I've found out even with filters an IMU is not very reliable(at least by itself). I read yesterday about the SLAM algorithm and found out about the existence of ROS (wow...if I only knew beforehand...). I've been reading on how to use ROS and I've found a lot of different SLAM packages and also a package called robot_localization which takes odometry, pose and IMU messages. 
I want to use the code I've written so far(make and merge 3D clouds and 2D maps) but I would like to use ROS to make things easier with the robot's locating and following the path returned by the D* algorithm(or maybe use a ROS pathfinding package?). Can I convert the 3D cloud(filtering floor and high points) to 2D map and use the SLAM algorithm? I'm still a little lost on what package is more practical(and light for the rpi3) for the data I have at hand, I'm totally new to ROS and would really appreciate to be pointed to an efficient approach to solve the locating and following the D* path.

Originally posted by liquidjorge on ROS Answers with karma: 1 on 2017-02-27
Post score: 0

A:

I have limited experience with the ROS 2D SLAM packages, but hector slam can deal with changing pitch in the laser scans.

hector_mapping is a SLAM approach that can be used without odometry as well as on platforms that exhibit roll/pitch motion (of the sensor, the platform or both)

http://wiki.ros.org/hector_mapping

Originally posted by Felix Endres with karma: 6468 on 2017-02-28
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by liquidjorge on 2017-02-28:
I have total control of the pitch and I know the pitch's angle at every time, should I pass the algorithm only the LiDAR's polar coordinate data (radius, angle) or should I also include the pitch's angle and pass the whole spherical coordinates? Is there a way of passing xyz data?
Comment by Felix Endres on 2017-03-06:
I don't know, but Iwould guess that you publish that knowledge as a tf transformation from the "base_frame" to your sensor frame. See http://wiki.ros.org/hector_mapping#Required_tf_Transforms


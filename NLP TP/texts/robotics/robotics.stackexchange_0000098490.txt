Q:

unexpected output from laser assembler

Hi everyone,
I have a topic that publishes sensor_msgs/Pointcloud2 and my intention was to merge every 2 pointclouds of these messages. In order to do that I used point_cloud_assembler with this launch file. Expecting to have as a result a topic that contains half of the messages of the original topic.
<launch>
   <node type="point_cloud2_assembler" pkg="laser_assembler" name="test_client">
 <remap from="cloud" to="/velodyne_points"/>
 <param name="max_clouds" type="int" value="2" />
 <param name="fixed_frame" type="string" value="velodyne" />  
  </node>
</launch>

But that did not work as expected and I got back a lot less from it. Does anybody know why this happened?

Originally posted by Ifx13 on ROS Answers with karma: 54 on 2021-03-05
Post score: 0

A:

Are you getting the output by calling the assemble_scans2 service in custom code?  If so, the assembler only aggregates the clouds in the buffer--at most 2 in your case--at the time you call the service.  Therefore, you'll only get clouds as often as you call the service.  If you happen to be calling the service at exactly half the frequency of the input clouds, you'll get half the original number of messages; however, if the service calls are slower, you'll get fewer.  There's also the possibility that there aren't any scans in the buffer during a call, but the default cache length (tf_cache_time_secs) is 10 seconds, so that seems unlikely.

Originally posted by tryan with karma: 1421 on 2021-03-05
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by Ifx13 on 2021-03-05:
Hi tryan,
thank you for taking the time to help me. The following script is what calling the service and publishes the new topic with the merged point cloud messages. I do not quite understand what I should change in order to make it work, can you help me figure it out ?
#!/usr/bin/env python

import rospy
from laser_assembler.srv import *
from sensor_msgs.msg import PointCloud2

rospy.init_node("test_client2") 
rospy.wait_for_service("assemble_scans2")
assemble_scans = rospy.ServiceProxy('assemble_scans2',AssembleScans2)
pub = rospy.Publisher("/pointcloud2", PointCloud2, queue_size = 1)
r = rospy.Rate(1)

while not rospy.is_shutdown():
    try:
        resp = assemble_scans(rospy.Time(0,0), rospy.get_rostime())
        print "Got cloud with %u points" %len(resp.cloud.data)
        pub.publish(resp.cloud)
    except rospy.ServiceException, e:
        print "Service call failed: %s" %e
    r.sleep()

Comment by tryan on 2021-03-05:
In your while loop, you call the assemble_scans2 service, publish the result, then sleep for 1 second.  That means the service only gets called (and an output cloud published) at 1 Hz.  Each time through the loop, you'll get the aggregate cloud from whatever's in the assembler's buffer.  If you want it to happen more often, just increase the loop rate.  To get (roughly) one cloud for every two, set the loop rate to half the lidar's publish rate.  If the lidar publishes at 20 Hz, set the loop rate to 10 Hz.
It's worth noting that this isn't exactly the same as combining pairs of point clouds in sequential order, though; since this method relies on a rolling buffer and asynchronous timing, you may lose some input clouds for example.  If you want to enforce a strict (deterministic) 2:1 conversion, you may have to subscribe to the clouds directly and assemble them yourself, but depending on your application, it might not be that critical.
Comment by Ifx13 on 2021-03-06:
Thank you tryan, yesterday I was so tired I couldn't even understand what you were saying, but you were right. Thanks again!


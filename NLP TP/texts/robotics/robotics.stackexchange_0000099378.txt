Q:

Is it possible for the global planner in move_base to copy an already made plan?

I understand from the nav_core::BaseGlobalPLanner class that MakePlan()  needs a goal, and a starting point and will fill the plan accordingly to whatever algorithm is being used.
In my case, I have an already made plan that is being sent from the other framework I am working with (Isaac SDK) that I would like to pass on to move_base so it can be, in the end, processed by the local planner. Is there a way to give the global planner an already made plan or have MakePlan() copy the plan available by Isaac?
I am mainly interested in using only the local planner.
A step by step to the answer can be found here.

Originally posted by jmyazbeck on ROS Answers with karma: 22 on 2021-06-27
Post score: 0

A:

You are actually right. The MakePlan() inside the  nav_core::BaseGlobalPLanner is a virtual function which means that it expects the global planner plug in to override this function with its own MakePlan() function.
This is apparent if you look at the MakePlan() function in GlobalPlanner which is the default planner for ROS1:  https://github.com/ros-planning/navigation/blob/2b807bd312fac1b476851800c84cb962559cbc53/global_planner/src/planner_core.cpp#L218
If you examine the plan you will notice that it returns std::vector<geometry_msgs::PoseStamped>& plan which is effectively a container of geometry_msgs::PoseStamped messages. PoseStamped messages contain headers, position and orientation information, http://docs.ros.org/en/noetic/api/geometry_msgs/html/msg/PoseStamped.html. The usual move_base/global_plan that is published is of type nav_msgs::Plan, http://docs.ros.org/en/melodic/api/nav_msgs/html/msg/Path.html, which are effectively these PoseStamped data arrows with a header. In layman terms, they are a bunch of arrows on the map which then constitute a global plan.
Therefore, to answer your question, as long as you are able to obtain a set of poses from the Isaac SDK you can package each pose into geometry_msgs::PoseStamped and and then further package all the poses of type geometry_msgs::PoseStamped into nav_msgs::Path. All other aspects of Move_base or even external packages will be able to work with the nav_msgs::Path data that you have published as the global plan. Cheers!

Originally posted by ParkerRobert with karma: 113 on 2021-06-27
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by jmyazbeck on 2021-06-27:
What I am able to do through Isaac is generate the plan as nav_msgs::Path. Is there a way to just send that to the local_planner directly (or through the global planner which should just copy it and send it)? If not I can try converting the plan to a std::vector<geometry_msgs::PoseStamped>... but then I don't really see how MakePlan() would just copy it
Comment by ParkerRobert on 2021-06-27:
One suggestion would be to subscribe to the node that outputs the std::vector<geometry_msgs::PoseStamped> from the Isaac SDK, and set plan = the data of type std::vector<geometry_msgs::PoseStamped>. As you would see in move_base, the call to planner_->makePlan(), this happens 3 times.
https://github.com/ros-planning/navigation/blob/kinetic-devel/move_base/src/move_base.cpp#L373
In those instances, you can set the third argument, which is "global_plan" in 2 of the instances and just "plan" in one of the instances to be equal to the the data of type std::vector<geometry_msgs::PoseStamped> directly from the Isaac SDK.
I am personally not sure of how Isaac SDK interfaces with ROS but the most elegant way would be to make a service call to the Isaac SDK to obtain the data of type std::vector<geometry_msgs::PoseStamped> instead of using planner_->make_plan() in those 3 instances. In this way you override the usual way of making plans and use Isaac SDK's way instead
Comment by jmyazbeck on 2021-06-27:
Mainly what happens is, Isaac appears as a node in ros that publishes and subscribes to topics... So I would have /plan coming from Isaac. When you say that you'd subscribe to the topic published by Isaac, which you recommend to be of type std::vector<geometry_msgs::PoseStamped> ... you're suggesting of doing that by editting the move_base code where the call planner_->makePlan() is happening? If I choose this way what would happen to the global_planner? Would it be bypassed? Or would I need to implement a global_planner of my own.
Regarding the more elegant suggestion, please if you could explain what you mean by "making a service call". Sorry, I am quite new to ROS in general, I really appreciate your guidance.
Comment by jmyazbeck on 2021-06-28:
The how to is well explained here!
Comment by ParkerRobert on 2021-06-28:
Yep it is well explained! The solution in this case shows you how to edit the global planner source code, so that when planner_->makePlan() is called the service call to your Isaac node is made

Edit the header of the source code of the global_planner package (this is the default global planner used in ROS 1), to add the name of your service. For example in line 186, add ros::ServiceClient isaac_plan_client; At the top of this same file write:  #â€‹include <custom_package/custom_serv.h>
Edit the cpp file to declare the service client, for example line 150 isaac_plan_client = n.serviceClient<Custom_serv>("make_plan_isaac

Comment by ParkerRobert on 2021-06-28:
3. call the service: by putting these 3 lines. custom_package::custom_serv variable; variable.data = true; isaac_plan_client.call(variable, returned_plan); Use returned_plan as the global plan. Here returned_plan should be of type std::vector<geometry_msgs::PoseStamped>
4. In your Isaac node, create the service server with the same name "make_plan_isaac" and return the  std::vector<geometry_msgs::PoseStamped> plan
Comment by jmyazbeck on 2021-06-29:
I am almost done implementing it. I am getting this error  if you have any idea what's happening


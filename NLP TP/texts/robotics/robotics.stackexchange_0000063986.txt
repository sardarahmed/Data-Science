Q:

Support for tool changing

This is probably more of a question for ROS-Industrial type applications, but with ROS what would be the best way to support the ability to load and unload a tool on the end of a robotic arm? Specifically to do with the dynamic plannning and collision geometry constraints.
To use a tool changer I believe the following is required;

Use a single IK fast generated kinematics solver for the robot arm + tool change mount. (as this won't change)
Load tools with transforms to the tool tip and collision geometry from either a URDF, yaml or database
Calculate IK solutions with modified end effector tool tip
Enable and disable the collision geometries associated with each gripped tool
Provide ability to adjust tool transforms at run-time after calibration routines

As far as I can tell robot_model doesn't really support such behavior. Has anyone managed to enable or disable specific end effectors and their associated collision geometry at runtime?
We have managed to prove that we can apply tool offset transform to the low level IK code and tie this into the planners.
One option is to treat the gripped tools like grasped objects, but this seems a bit hacky.
Has anyone had a similar use case?
I have found the following with similar scenarios;

UW biorobotics Raven 2 surgical robot;

https://github.com/uw-biorobotics/raven2/issues/9
Suggest using dynamic reconfigure / service to modify tools

USARSimROS using KUKA KR60 robot as example for their simulation bridge

http://sourceforge.net/p/usarsimros/wiki/URDF%20Generation/
Suggest that the robot urdf and generated ikfast IK should only be up to the tool changer mount.
"A robot with a toolchanger effector does not need a new URDF for each end effector that can be attached. The URDF should contain only a reference to the toolchanger, and will handle attaching/detaching end effectors from it as it runs."

Other tool changer question

http://answers.ros.org/question/49818/urdf-with-tool-changer/
Suggests loading tool urdfs separately and using node to publish transforms of tools to robot
Is this compatible with collision checking?

Originally posted by Jeremy Corbett on ROS Answers with karma: 397 on 2014-11-12
Post score: 13

Original comments
Comment by sedwards on 2014-11-13:
Jeremy, ros answers won't allow me to up vote this more than once :(  I'm not aware of a clean solution to this problem, but one is needed (especially for ROS-I applications).  Thanks for asking!
Comment by Jeremy Corbett on 2014-11-13:
Thanks for the upvote Shaun. We are going to try a few things, I'll let you know how it goes.
Comment by Damien on 2016-01-08:
Hi
Jeremy, did you find a solution for your issue?
It is indeed a hard requirement for any Industrial application...
Thanks
Comment by BrettHemes_ on 2016-06-27:
+1 This is something we have recently begun trying to figure out as well...
Comment by gvdhoorn on 2016-06-27:
Something that should be possible with the current state of ROS / MoveIt would probably involve a 'bare' robot URDF (ie: sans EEF), and attaching the EEF as a collision object using the appropriate MoveIt APIs. For visualisation this wouldn't be too nice, but it should make planning work, with EEF.
Comment by BrettHemes_ on 2016-06-27:
Awesome; thanks for the comment gvdhoorn!  This is the approach we are currently exploring so it is nice to get some confirmation that we are on the right path.
Comment by gvdhoorn on 2016-06-27:
Note that I haven't verified that too extensively yet.
Also note that you'd probably have to transform any EEF pose back to the tool0 (or whatever link you have configured as the last link of your chain) before asking MoveIt to plan for it. But that depends on some factors.
Comment by fvd on 2018-07-31:
It would be interesting to hear an update from people who have attempted this. We have a similar use case (and I am sure many others will, too).
Comment by gvdhoorn on 2018-08-01:
Afaik things haven't changed too much (at least not in MoveIt). One utility that could make this slightly easier / more feasible would be moveit_visual_tools. It supports publishing EEFs separately from the main URDF. Still not complete ..
Comment by gvdhoorn on 2018-08-01:
.. support for the concept of tool changing, but perhaps something that helps.
In the end, all consumers of URDF (or whatever geometry/robot modeling infrastructure is used) will need to be capable of dealing with mutable models. Without that, any approach will probably remain a 'hack'.

A:

Not a complete answer, but you might want to try and see how Rethink Robotics did this for Baxter. IIRC, the different EEFs that can be connected (gripper, suction cups) to Baxter's arms dynamically update the urdf, without the user needing to reconfigure and / or restart anything.
We have one here in a lab, so I can try to take a look if you want (I'm rather curious myself).
What I can imagine right now is a node that just overwrites the robot_description parameter when needed (and causes the needed transforms to be published). This would obviously require some special logic in other nodes in your system working with the robot_description parameter, as normally I retrieve it once and assume it never changes.

Originally posted by gvdhoorn with karma: 86574 on 2014-11-13
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Jeremy Corbett on 2014-11-13:
Thanks for the tip. I was wondering if this was a possibility, though I can see a few issues that would probably arise around robot_state. I will have a dig through Baxters, and the Rethink Robotics repo's.
Comment by StanislawZ on 2020-12-30:
Hi Jeremy, did you manage to get it to work.  I have the same issue here in 2020 (implementing a tool changer for an industrial application) and surprisingly little has happened since 2014! ROS2 is supposedly going to solve this issue, but it is till not supported well enough and this thread is one of the few lifelines i have.
I tried downloading Rethink Robotics mutable_robot_state_publisher but catkin won't build it. (I work on ROS melodic while tha package was probably developed for an older distro.) Just wanted to know if it worked for you, before i dig deeper into trying to debug it.
The error code from catkin:
 robot_state_publisher.cpp:73:106: error: conversion from ‘std::map<std::__cxx11::basic_string<char>’ to non-scalar type` ‘std::map<std::__cxx11::basic_string<char>


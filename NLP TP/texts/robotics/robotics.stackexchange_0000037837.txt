Q:

cv_bridge and IplImage -> Mat when going from OpenCV 2.1 to OpenCV 2.3?

Hello,
I am trying to use some of the newer Python sample code included with OpenCV 2.3 while also using cv_bridge in ROS Electric.  It appears that most of the sample code (such as the lk_track.py demo) assumes images are in Mat format rather than IplImage format.  However, cv_bridge converts ROS Image format to IplImage format so that I am constantly running into format incompatibilities.  Is there some way I can have cv_bridge convert ROS Image messages to Mat format instead of IplImage?  Alternatively, can I convert the IplImage returned by cv_bridge to Mat?  I am programming in Python so I am hoping for a solution in that language.
Thanks!
patrick

Originally posted by Pi Robot on ROS Answers with karma: 4046 on 2012-02-13
Post score: 2

A:

cv.GetMat(myIplImage)

Since OpenCV seems to be moving away from IplImages, it would make sense for cv_bridge to do the same. Perhaps that should be ticketed.

Originally posted by Dan Lazewatsky with karma: 9115 on 2012-02-13
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by Pi Robot on 2012-02-13:
Many thanks @diaz!  Do you happen to know what type of Mat is returned by GetMat?  For example, if I use 'frame = cv.GetMat(self.bridge.imgmsg_to_cv(ros_image, "bgr8"))', what Mat type is frame?  e.g. 8UC3, 32FC3? etc.  I ask because I'm still having size and/or type compatibility problems when trying to copy or perform other operations with the 'frame' matrix and other image matrices in my code.
Comment by Dan Lazewatsky on 2012-02-13:
I'm not sure what the correspondence is between IplImage encodings and the regular Mat encodings, but it should be semantically equivalent. bgr8 would likely give you 8UC3 or something similar. When creating new Mats of the same type, you can be encoding-agnostic by using mat.type and mat.channels.
Comment by Pi Robot on 2012-02-13:
Thanks again @diaz.  Yes, it looks like its type 8UC3 or 16 in integer format.
Comment by Dan Lazewatsky on 2012-02-13:
Could you post code that requires converting to a numpy array? Most OpenCV functions work on array-like objects, and Mats certainly are. I just tried cv.CvtColor using a Mat as the source and destination, and it works fine.
Comment by Pi Robot on 2012-02-13:
OK, I jumped the gun.  It looks like it is only the functions in cv2 that require a numpy array.  In the lk_track.py demo the convert function used is cv2.cvtColor and this requires a numpy array whereas the old cv.CvtColor does not.  Similarly, the new cv2.goodFeaturesToTrack requires numpy arrays.


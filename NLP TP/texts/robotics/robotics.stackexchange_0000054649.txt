Q:

Move base issue motor direction

Update:   When move base sends a cmd_vel that is translated to say -1,-1 on the wheels the gazebo model moves backwards, but in rviz it moves forward. If I negate the values then the model moves forward but backwards in rviz. What would cause this?
Here are my setting also.
rrbot:
  # Publish all joint states -----------------------------------
  joint_state_controller:
    type: joint_state_controller/JointStateController
    publish_rate: 50

  # Position Controllers ---------------------------------------
  joint1_position_controller:
    type: effort_controllers/JointVelocityController
    joint: joint1
    pid: {p: 30, i: 1, d: 1, i_clamp: 100}
  joint2_position_controller:
    type: effort_controllers/JointVelocityController
    joint: joint2
    pid: {p: 30, i: 1, d: 1, i_clamp: 100}

TrajectoryPlannerROS:
  # for details see: http://www.ros.org/wiki/base_local_planner
  max_vel_x: .005
  max_trans_vel: .05
  min_vel_x: .05
  min_trans_vel: .05
  max_rotational_vel: .025   # 0.1 rad/sec = 5.7 degree/sec
  min_in_place_rotational_vel: .025

  acc_lim_th: .005
  acc_lim_x:  .005
  acc_lim_y:  0

More data on inversion:
[ INFO] [1381338035.462489594, 4.700000000]: pv1=[-0.913283] pv2=[-0.913356]
[ INFO] [1381338035.462557027, 4.700000000]: er1=[-0.086717] er2=[-0.086644] 
[ INFO] [1381338035.462593604, 4.700000000]: sp1=[-1.000000] sp2=[-1.000000] 

[ INFO] [1381338036.459313255, 4.800000000]: pv1=[-0.908281] pv2=[-0.912306]
[ INFO] [1381338036.459382353, 4.800000000]: er1=[1.408281] er2=[1.412306] 
[ INFO] [1381338036.459414965, 4.800000000]: sp1=[0.500000] sp2=[0.500000] 

Update: I have been seeing this now for a while. Move base will send a positive velocity on a wheel and in the very next sequence send a negative one or vice verse. Is there any configuration that will stop navigation from doing this. Not all motors can change direction like this. Would this be a new feature? Does anyone else see this behavior in move base?
I am running move base navigation and got the following which is causing a problem for the motor controls. I am not sure why this is happening could be initial odometry but in either case. I am using the gazebo ros velocity controller.
The navigation starts sending cmd velocities of -5 -5 then it switches to 1 1. Which cause the system to react violently. I would like a smooth transition so that the wheels do get thrown into reverse. notice the error continues to build even though the set point stays steady after the initial values.
The numbers I get are as follows from the joint state controller msg.
pv=process_value
er=error
sp=set_point
pv1=[-0.057762] pv2=[-0.045411]
er1=[0.057762] er2=[0.045411] 
sp1=[0.000000] sp2=[0.000000] 
 
pv1=[-0.339482] pv2=[-0.292756]
er1=[-0.160518] er2=[-0.207244] 
sp1=[-0.500000] sp2=[-0.500000] 

pv1=[-0.406273] pv2=[-0.389512]
er1=[-0.093727] er2=[-0.110488] 
sp1=[-0.500000] sp2=[-0.500000] 
 
pv1=[-0.111645] pv2=[-0.368285]
er1=[1.111645] er2=[1.368285] 
sp1=[1.000000] sp2=[1.000000] 
 
pv1=[-0.115296] pv2=[-0.294882]
er1=[1.115296] er2=[1.294882] 
sp1=[1.000000] sp2=[1.000000] 
 
pv1=[-0.209185] pv2=[-0.315181]
er1=[1.209185] er2=[1.315181] 
sp1=[1.000000] sp2=[1.000000] 
 
pv1=[-0.301285] pv2=[-0.498914]
er1=[1.301285] er2=[1.498914] 
sp1=[1.000000] sp2=[1.000000] 
 
pv1=[-0.645544] pv2=[-1.598098]
er1=[1.645544] er2=[2.598098] 
sp1=[1.000000] sp2=[1.000000] 
 
 
pv1=[-1.456144] pv2=[-3.104899]
er1=[2.456144] er2=[4.104899] 
sp1=[1.000000] sp2=[1.000000] 

 
pv1=[-2.931451] pv2=[-11.441737]
er1=[3.931451] er2=[12.441737] 
sp1=[1.000000] sp2=[1.000000] 

 
pv1=[-13.388657] pv2=[-34.636285]
er1=[14.388657] er2=[35.636285] 
sp1=[1.000000] sp2=[1.000000] 
 
 
pv1=[-43.225496] pv2=[-111.991643]
er1=[44.225496] er2=[112.991643] 
sp1=[1.000000] sp2=[1.000000] 

Here is the code that takes the cmd_vel and converts it.
void handelerTwist(const geometry_msgs::Twist msg)
{
   std_msgs::Float64 cmdVel1;
   std_msgs::Float64 cmdVel2;  

   ROS_INFO("liner.x[%f]  angular.z[%f]",msg.linear.x , msg.angular.z);
     
   float vel1 =  (msg.linear.x - msg.angular.z *.26/2)*(2/.2);
   float vel2 =  (msg.linear.x + msg.angular.z *.26/2)*(2/.2);

   cmdVel1.data = vel1;  
   cmdVel2.data = vel2;
   pubLeftVel.publish(cmdVel1);
   pubRightVel.publish(cmdVel2);
} 

Originally posted by rnunziata on ROS Answers with karma: 713 on 2013-10-07
Post score: 0

Original comments
Comment by fergs on 2013-10-09:
max_vel_x < min_vel_x.... i have no idea what that might do to the planner.
Comment by rnunziata on 2013-10-09:
wow...didn't see that. Would be nice to have semantic checks. Thanks!

A:

You should probably look into setting the acc_lim_x and acc_lim_th acceleration limits for the local planner. You should lower these enough to be within the limits of your robot.

Originally posted by fergs with karma: 13902 on 2013-10-08
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by rnunziata on 2013-10-13:
This seem to stopped them from moving in opposite directions however I made other changes as well.


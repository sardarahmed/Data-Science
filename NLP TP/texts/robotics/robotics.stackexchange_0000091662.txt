Q:

'double' is not a supported type in ROS messages?

Hello all,
I meet two issues for the data type delcaration:
Q1: I define the message in the svr file as below--but when I check the srv by rossrv show I got error message like:
unknown srv type... Cannot locate message [double] in package with paths... blablabla..
So I can not define double type data in srv file? instead uint32 works OK.. But ROS should support double , correct?
 uint8 Number    #0/1/2/3
 string Name     
 bool  In_Out      #(true) Out(False)
 double TimeStamp       #double??
 double Duration        #double??
 ---
 string Feedback        
 bool PaySucc           

Q2: In the relevant Server.cpp file, I define a struct data class as below, but this time the IDE (I am using QT creator w/ROS plugin) report that unknow type of "string", and double is support instead..
This really confused me.. is this the QTcreator  issue?
BTW, is there a standard data type roscpp support can refer to?
typedef struct Req
{
    uint8_t Number;    //0/1/2/3
    string Name;    
    bool IN_OUT;     //(true) Out(False)
    double TimeStamp;      //double??
    double Duration;       //double??
    /******/
    string Feedback;        
    bool Succ;               //Success(true) Fail (false)

} Req;

Originally posted by macleonsh on ROS Answers with karma: 26 on 2019-05-13
Post score: 0

A:

For Q1, see #q205541 and the link to this page therein. In short: in msg/srv definition you need to use float64 as this is a "ROS built-in type". Those are used to autogenerate the code for different languages. In C++ use double.
Q2: this is expected behavior, as you are now using C++. This is, double is a C++ primitive type, whereas string is not. Use std::string instead. No fault with QTCreator there.

Edit:
std::string is the C++ string type, whereas std_msgs::String is the C++ representation of a ROS standard message that only contains a string (ROS built-in type) / std::string (C++ type) as a field. Check the std_msgs/String message definition here.
I.e., manipulating the respective data field of the std_msgs::String with c_str() will work.
E.g. (using std::strings empty() method for sake of brevity)
std_msgs::String string_msg;
std::string cpp_string;
cpp_string.empty(); // compiles
string_msg.empty();  // does not compile
string_msg.data.empty(); // compiles

Originally posted by mgruhler with karma: 12390 on 2019-05-14
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by macleonsh on 2019-05-14:
@mgruhler Thanks so much. This is exactly what I want to find--simple and strightforward..
Yes follow your suggestion I solve the issue quickly..
One additional questions:
What is the difference between std::string  and std_msgs:String? my initial understand is the 1st one is c++ type and 2nd one is ROS override type? but looks not that simple.
Some small experience that I can manipulate std::string by using c_str() but can not do that to std_msgs:String..
Comment by mgruhler on 2019-05-14:
@macleonsh edited answer above.
If you feel this is answering your question, please mark the answer as correct by clicking the check-mark next to it.


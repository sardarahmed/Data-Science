Q:

URDF velocity limit, how it works?

Hello! I've taken the 06-flexible.urdf model from the urdf_tutorial package, and I've added the lines to set a velocity limit on the head_swivel joint into the urdf file.
http://wiki.ros.org/urdf/XML/joint
Then I've displayed it on rviz thinking that when I would make a fast change on the joint value, it would take a little more time to get into this position, but  what I have found is that the velocity limit is not making any effect in the robot representation. The changes take effect inmediately. So, how is the velocity limit supposed to work?
Thank you very much!
Ruben

Originally posted by rubenvm on ROS Answers with karma: 17 on 2015-08-11
Post score: 0

Original comments
Comment by lucasw on 2015-08-11:
Are you using the joint_state_publisher gui slider?  I haven't used it in a while but those bypass the velocity limits.  You need a controller in operation to respect velocity limits, and then you would be publishing commanded positions into the controller and then watch it work more slowly.
Comment by rubenvm on 2015-08-11:
First of all, thank you for your answer. Yes, you are right, I'm using the joint_state_publisher gui sliders, I did not know it bypasses the limit. So, how I could implement this controller in operation? Is there any package to make it, or to make it easier?
Thanks!
Comment by lucasw on 2015-08-11:
I've only used the controllers with gazebo following http://gazebosim.org/tutorials?tut=ros_overview and https://github.com/ros-simulation/gazebo_ros_demos - the controllers can be used outside of gazebo to connect to real hardware, but without real hardware you would need a sim.
Comment by lucasw on 2015-08-11:
Take a look at http://wiki.ros.org/ros_control?distro=indigo also.
Comment by rubenvm on 2015-08-11:
Aha! Ok, I understand what you mean. We are assembling a robot, so the idea was keeping the simulation near to the robot and watch both. So, it's better if they move in a similar way. Thank you very much, I will try it.

A:

Adding joint limits to a URDF is only the specification part. For these limits to be taken into account, you need an implementation that enforces them.
As you have already noticed, not all URDF-parsing implementations take the complete specification into account. The joint_state_publisher, for instance, takes joint names, types and position limits into account for publishing  sensor_msgs/JointState messages, but does not not consider joint velocity limits. Also, there are certain specifications, like the maximum joint effort, that cannot be enforced with a kinematic-only implementation. So, the important thing is to understand the scope and limitations of an implementation, and a package's documentation should help here. I went ahead and added to the joint_state_publisher ROS wiki entry a comment to this effect.
As @lucasw mentions, you could consider using the ros_control framework for setting up your robot and move it with controllers that are aware of the complete URDF joint limits spec. You might find the joint_limits_interface package of particular interest. A more general discussion can be found on 24:14 of this video. Note that the overhead of setting up ros_control for your robot will be higher than setting up the joint_state_publisher, there's no free lunch.

Originally posted by Adolfo Rodriguez T with karma: 3907 on 2015-08-12
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by rubenvm on 2015-08-12:
Ok, thank you very much!
Un placer encontrar españoles por aquí.
Regards from Málaga.


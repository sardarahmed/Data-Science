Q:

how to use more than one marker types

I want to visualize 3 seperate markers to be visualized in rviz until same line group donot appear again. I found that by doing line_list.points.clear() and line_list.colors.clear() i can make given line visualize until another line donot appears so that at one time only one marker of that name exist. But i want to display more than one marker and line like that so that whenever the same name of marker arrives the previous marker is vanished. I tried below program but donot works:
void
cloud_cb (const sensor_msgs::PointCloud2ConstPtr& input)
{
pcl::PointCloud<pcl::PointXYZRGB> output;
pcl::fromROSMsg(*input,output);

visualization_msgs::Marker marker, line_list, text_view_facing;
marker.header.frame_id = line_list.header.frame_id = text_view_facing.header.frame_id = "/camera_link";
marker.header.stamp = line_list.header.stamp = text_view_facing.header.stamp =ros::Time();
marker.ns = line_list.ns = text_view_facing.ns ="lines";
marker.action = line_list.action = text_view_facing.action = visualization_msgs::Marker::ADD;
marker.pose.orientation.w = line_list.pose.orientation.w = text_view_facing.pose.orientation.w = 1;
marker.id = 0;
line_list.id = 1;
text_view_facing.id = 2;
marker.type = visualization_msgs::Marker::POINTS;
line_list.type = visualization_msgs::Marker::LINE_LIST;
text_view_facing.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
text_view_facing.color.b = 1; text_view_facing.color.a = 1.0; text_view_facing.color.g = 1.0; text_view_facing.color.r = 1.0;
line_list.color.r = 0; line_list.color.g = 0; line_list.color. b = 1; line_list.color.a = 1;
text_view_facing.scale.z = 0.015;  line_list.scale.x = 0.001;
marker.header.stamp = ros::Time::now();
marker.lifetime = ros::Duration(0.01);
marker.scale.x = 0.002;
marker.scale.y = 0.002;
marker.scale.z = 0.002;
marker.color.a = 1.0;
marker.color.r = 0.0;
marker.color.g = 1.0;
marker.color.b = 0.0;
string obj1 = "first_segmented_image";
vector<line_list> line;
line.resize(2);

    bigarray size_arr, arr0;
    for(int p0=0;p0<bound.size() && ros::ok();p0++) {
        p[0] = output.at(bound[p0].x,bound[p0].y);
        if(!isnan(p[0].x) && !isnan(p[0].y) && !isnan(p[0].z)) {
            P.x = p[0].x; P.y = p[0].y; P.z = p[0].z;
            pc.r = 1; pc.g = 1; pc.b = 1; pc.a = 1;
            marker.points.clear(); marker.colors.clear();
            marker.points.push_back(P);
            marker.colors.push_back(pc);
            marker_pub.publish(marker);
        }
        for(int p1=0;p1<bound.size() && ros::ok();p1++) {
            p[1] = output.at(bound[p1].x,bound[p1].y);
            /*if(!isnan(p[0].x) && !isnan(p[0].y) && !isnan(p[0].z)) {
                P.x = p[0].x; P.y = p[0].y; P.z = p[0].z;
                pc.r = 1; pc.g = 1; pc.b = 1; pc.a = 1;  marker.points.clear(); marker.colors.clear();
                marker.points.push_back(P);
                marker.colors.push_back(pc);
                marker_pub.publish(marker);
            }*/
            if(!isnan(p[1].x) && !isnan(p[1].y) && !isnan(p[1].z)) {
                line[0].points.clear(); line[0].colors.clear();
                line[0].scale.x = 0.00075; line[0].colors.push_back(pc);
                P.x = p[0].x; P.y = p[0].y; P.z = p[0].z;  line[0].points.push_back(P);
                P.x = p[1].x; P.y = p[1].y; P.z = p[1].z;  line[0].points.push_back(P);
                marker_pub.publish(line[0]);
            }
            int d0r = sqrt(pow(p[1].x-p[0].x,2)+pow(p[1].y-p[0].y,2)+pow(p[1].z-p[0].z,2) )*1000;
            if(d0r==10) {
                for(int p2=0;p2<bound.size() && ros::ok();p2++) {
                    p[2] = output.at(bound[p2].x,bound[p2].y);
                    int d1r = sqrt(pow(p[2].x-p[1].x,2)+pow(p[2].y-p[1].y,2)+pow(p[2].z-p[1].z,2) )*1000;
                    int d4r = sqrt(pow(p[2].x-p[0].x,2)+pow(p[2].y-p[0].y,2)+pow(p[2].z-p[0].z,2) )*1000;
                    if(d4r>10 && d1r>10) { cout<<p0<<"\t"<<p1<<"\t"<<p2<<endl;
                        int key = ++size_arr(1,1,d0r,d1r,d4r);
                        arr0(1,key,d0r,d1r,d4r) = p0;
                        arr0(2,key,d0r,d1r,d4r) = p1;
                        arr0(3,key,d0r,d1r,d4r) = p2;
                    }
                }
            }
        }
    }

    ofstream ofs(dimnam, ios::binary);
    ofs << arr0;
    ofs.close();

    ofstream ofs1(dimnam1, ios::binary);
    ofs1 << size_arr;
    ofs1.close();
}
int
main(int argc, char** argv)
{
    ros::init(argc, argv,"godgift");
    ros::NodeHandle nh;
    ros::Subscriber sub = nh.subscribe("/camera/depth/points", 1, cloud_cb);
    marker_pub = nh.advertise<visualization_msgs::Marker> ("visualization_marker",1);
    ros::spin();
}

Here i tried to create a vector of markers so each index of marker represents one set of marker, but it shows error.

Originally posted by dinesh on ROS Answers with karma: 932 on 2017-02-01
Post score: -1

A:

Found the answer myself.
demonstration: youtube.com/watch?v=j0OzYY3aTdc
Here what i did basically is i created a vector of line_list and markers of type visualization_msgs::Marker, in this way now i can use more than one line_list and marker by using its index, so if i want to delete given specific marker no other markers will be deleted. Here i also had to specify different marker id for different line list and marker so that rviz can identify tham seperately. so basic is very simple:

make vector of marker instead of single marker.
specify different marker id for each of them, and delete any one of them whenever u want.

code:
vector<visualization_msgs::Marker> line_list, marker;
visualization_msgs::Marker text_view_facing;
line_list.resize(3);
marker.resize(3);
for (int i = 0; i < line_list.size(); i++) {
  marker[i].header.frame_id = line_list[i].header.frame_id =
      text_view_facing.header.frame_id = "/camera_link";
  marker[i].header.stamp = line_list[i].header.stamp =
      text_view_facing.header.stamp = ros::Time();
  marker[i].ns = line_list[i].ns = text_view_facing.ns = "lines";
  marker[i].action = line_list[i].action = text_view_facing.action =
      visualization_msgs::Marker::ADD;
  marker[i].pose.orientation.w = line_list[i].pose.orientation.w =
      text_view_facing.pose.orientation.w = 1;
  marker[i].id = i + 3;
  line_list[i].id = i;
  marker[i].type = visualization_msgs::Marker::POINTS;
  line_list[i].type = visualization_msgs::Marker::LINE_LIST;
  line_list[i].color.r = 0;
  line_list[i].color.g = 1;
  line_list[i].color.b = 1;
  line_list[i].color.a = 1;
  marker[i].lifetime = ros::Duration(0.01);
  marker[i].scale.x = 0.003;
  marker[i].scale.y = 0.003;
  marker[i].scale.z = 0.003;
}
text_view_facing.id = 6;
text_view_facing.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
text_view_facing.color.b = 1;
text_view_facing.color.a = 1.0;
text_view_facing.color.g = 1.0;
text_view_facing.color.r = 1.0;
text_view_facing.scale.z = 0.015;
string obj1 = "first_segmented_image";
bigarray size_arr, arr0;
for (int p0 = 0; p0 < bound.size() && ros::ok(); p0++) {
  p[0] = output.at(bound[p0].x, bound[p0].y);
  if (!isnan(p[0].x) && !isnan(p[0].y) && !isnan(p[0].z)) {  // point p0
    P.x = p[0].x;
    P.y = p[0].y;
    P.z = p[0].z;
    pc.r = 1;
    pc.g = 0;
    pc.b = 0;
    pc.a = 1;
    marker[0].points.clear();
    marker[0].colors.clear();
    marker[0].points.push_back(P);
    marker[0].colors.push_back(pc);
    marker_pub.publish(marker[0]);
  }
  for (int p1 = 0; p1 < bound.size() && ros::ok(); p1++) {
    p[1] = output.at(bound[p1].x, bound[p1].y);
    if (!isnan(p[1].x) && !isnan(p[1].y) && !isnan(p[1].z)) {  // point p1
      P.x = p[1].x;
      P.y = p[1].y;
      P.z = p[1].z;
      pc.r = 0;
      pc.g = 1;
      pc.b = 0;
      pc.a = 1;
      marker[1].points.clear();
      marker[1].colors.clear();
      marker[1].points.push_back(P);
      marker[1].colors.push_back(pc);
      marker_pub.publish(marker[1]);
    }
    if (!isnan(p[1].x) && !isnan(p[1].y) && !isnan(p[1].z)) {  // line p0p1
      line_list[0].points.clear();
      line_list[0].colors.clear();
      line_list[0].scale.x = 0.00075;
      P.x = p[0].x;
      P.y = p[0].y;
      P.z = p[0].z;
      line_list[0].points.push_back(P);
      P.x = p[1].x;
      P.y = p[1].y;
      P.z = p[1].z;
      line_list[0].points.push_back(P);
      marker_pub.publish(line_list[0]);
    }
    int d0r = sqrt(pow(p[1].x - p[0].x, 2) + pow(p[1].y - p[0].y, 2) +
                   pow(p[1].z - p[0].z, 2)) *
              1000;
    if (d0r == 10) {
      for (int p2 = 0; p2 < bound.size() && ros::ok(); p2++) {
        p[2] = output.at(bound[p2].x, bound[p2].y);
        if (!isnan(p[2].x) && !isnan(p[2].y) && !isnan(p[2].z)) {  // point p2
          P.x = p[2].x;
          P.y = p[2].y;
          P.z = p[2].z;
          pc.r = 0;
          pc.g = 0;
          pc.b = 1;
          pc.a = 1;
          marker[2].points.clear();
          marker[2].colors.clear();
          marker[2].points.push_back(P);
          marker[2].colors.push_back(pc);
          marker_pub.publish(marker[2]);
        }
        if (!isnan(p[2].x) && !isnan(p[2].y) && !isnan(p[2].z)) {  // line p1p2
          line_list[1].points.clear();
          line_list[1].colors.clear();
          line_list[1].scale.x = 0.00075;
          P.x = p[2].x;
          P.y = p[2].y;
          P.z = p[2].z;
          line_list[1].points.push_back(P);
          P.x = p[1].x;
          P.y = p[1].y;
          P.z = p[1].z;
          line_list[1].points.push_back(P);
          marker_pub.publish(line_list[1]);
          line_list[2].points.clear();
          line_list[2].colors.clear();  // line p0p2
          line_list[2].scale.x = 0.00075;
          P.x = p[2].x;
          P.y = p[2].y;
          P.z = p[2].z;
          line_list[2].points.push_back(P);
          P.x = p[0].x;
          P.y = p[0].y;
          P.z = p[0].z;
          line_list[2].points.push_back(P);
          marker_pub.publish(line_list[2]);
        }
        int d1r = sqrt(pow(p[2].x - p[1].x, 2) + pow(p[2].y - p[1].y, 2) +
                       pow(p[2].z - p[1].z, 2)) *
                  1000;
        int d4r = sqrt(pow(p[2].x - p[0].x, 2) + pow(p[2].y - p[0].y, 2) +
                       pow(p[2].z - p[0].z, 2)) *
                  1000;
        if (d4r > 10 && d1r > 10) {
          cout << p0 << "\t" << p1 << "\t" << p2 << endl;
          int key = ++size_arr(1, 1, d0r, d1r, d4r);
          arr0(1, key, d0r, d1r, d4r) = p0;
          arr0(2, key, d0r, d1r, d4r) = p1;
          arr0(3, key, d0r, d1r, d4r) = p2;
        }
      }
    }
  }
}

Originally posted by dinesh with karma: 932 on 2017-02-01
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by gvdhoorn on 2017-02-01:
Please spend some time formatting your question properly:

move this answer to your original question. Use the edit button/link for that
use the Preformatted Text button to format code & console copy/pastes

Right now this is unreadable.
Comment by dinesh on 2017-02-01:
sorry, when i tried to format it it was not being formatted to code.
Comment by dinesh on 2017-02-01:
If their is better method than answer please.
Comment by gvdhoorn on 2017-02-01:
I've reformatted everything using clang format and updated your answer.
It would be nice if you could accept your own answer.
Please also add a short summary of what you did / changed at the top of the anwer, so future readers won't have to read all your code and figure it out for themselves.


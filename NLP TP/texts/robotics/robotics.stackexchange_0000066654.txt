Q:

data from and towards MotionMind motorcontroller

Hi all,
Right now we are working on a robot that was controlled by LabView on Windows before. We are trying to get it working on Ubuntu 14.04 with ROS indigo. We've been working through the tutorials, and already got our logitech controller working with turtlesim. Afterwards, we tried to connect to our motorcontrollers to read and write new positions from and towards the wheel. But we are not able to get data from and write data to the motorcontrollers. Our setup: It is a four wheeled robot, with one Maxon RE25 motor for steering and one Maxon RE40 for driving for each wheel. Each motor is controlled by a MotionMind rev 2 from Solutions Cubed. The data from and towards the motorcontrollers goes through four COM-ports and comes per USB into the pc.
We've managed to find a driver ( https://searchcode.com/codesearch/view/17958649/ ) for these motorcontrollers, but we don't have a clue how to install this on Ubuntu. Besides, we tried to read the USB port, but this gave us no more information than "00 00 2C".
We guess it should be fairly simple to control this setup, but we think the lack of our knowledge in ROS is the problem.
Hence, here the question: How can we control this setup using ROS?

Edit:
We tried to translate the Player driver, what did not work out very well, since we can't find how the opaque driver works.
Therefore we tried to write our own program to manage a connection with the motorcontrollers. The communication protocol is setup as binary. We tried lots of options of serial.serial as in http://pyserial.sourceforge.net/pyserial_api.html , however we did not manage to communicate with the ports. The program written is as follows:
import time
import serial

ser = serial.Serial("/dev/ttyUSB1", baudrate=19200, timeout=1)

a = bytearray("00011010000000010000000100000000000000000000000000011100")

while True: #infinite loop
    bytes_written = ser.write(a)
    read_byte = ser.read() 
    print "read_byte:\t", read_byte
    print "type:\t", type(read_byte)
    print "len\t", len(read_byte)

Are we overlooking something?

Originally posted by Sander on ROS Answers with karma: 3 on 2015-03-27
Post score: 0

Original comments
Comment by gvdhoorn on 2015-03-31:
@Sander: I've moved your update to your main question. Here on ROS Answers, we try to reserve Answers for actual answers. Discussion is in comments, but updates to the 'current state' of the original poster go into edits of the original question.
Comment by gvdhoorn on 2015-03-31:
You'll have to be more specific than "we did not manage to communicate with the ports". Which errors did you get?
Also: I don't think the bytearray class works the way you use it. You typically use (hexa)decimal notation with it. It can work with octal notation, but I don't think you want that.

A:

The driver you link is for Player (player driver documentation), that is a different -- but with comparable goals I'd say -- framework, so you cannot directly use that code. Neither for ROS, nor "for Ubuntu / Linux". At the very least you'll have to write / find a ROS driver node that can interface with your MotionMind controller. A quick google didn't turn up anything, neither did a search on ROS Index.
Creating a ROS compatible driver for this kind of controller shouldn't be too difficult though, and the fact that you've found something for Player helps, as you can use that to see how to use the serial protocol. The protocol section (chapter 5) in the MotionMind v3 documentation doesn't seem too complicated either.
One thing to keep in mind I think, is the difference between a driver for the MotionMind itself, and for your platform (your four-wheeled robot) as a whole. The former would probably just take in some message that commands the MotionMind to drive the attached motor at a certain velocity / torque. The latter typically takes in a geometry_msgs/Twist and converts that into appropriate commands for the individual actuators to make the platform as a whole perform the desired motion (so turn with a certain velocity fi). The same goes for position controlled motors, there you typically use an additional pkg to perform the IK for you, then forward those commands to the individual joint controllers.
Some packages that could provide reuse opportunities are serial and the diff_drive_controller from ros_control.

PS: if you really want to make use of the Player driver, you can probably use the Erratic robot support packages as a guide. They do the same thing, but for a different platform. It would probably require some knowledge about Player as well though, so might not be worth the additional learning curve.

Originally posted by gvdhoorn with karma: 86574 on 2015-03-27
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Sander on 2015-03-27:
Thanks for your quick response. We will try to figure it out. Just for our own information, you do not think we are using a wrong way of gathering information by USB? Since the only thing we get from it is "00 00 2C".
Comment by gvdhoorn on 2015-03-27:
Well, it's not wrong, but not very useful either. You can probably look at the Player driver to see how you can use the ASCII protocol to communicate with the MotionMind in a useful way. You'll have to translate 'ros commands' and send them using that protocol to the controller.
Comment by gvdhoorn on 2015-03-28:
See the serial_example pkg for an example of how to use the serial pkg btw.


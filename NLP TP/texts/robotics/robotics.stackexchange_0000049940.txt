Q:

Cloud Normal Calculation

I want to see the cloud normal for a given point cloud in vector format means in position vector. Here is my sample code. From my code, I can found only the cloud normal points size.
#include <iostream>
#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>

#include <pcl/surface/convex_hull.h>
#include <pcl/surface/mls.h>

#include <pcl/filters/filter.h>
#include <pcl/filters/voxel_grid.h>

#include <pcl/features/normal_3d.h>
#include <pcl/features/boundary.h>

#include <pcl/registration/distances.h>

#include <pcl/kdtree/kdtree_flann.h>

#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <Eigen/Geometry>

using namespace Eigen;

int main (int argc, char** argv)
{
  pcl::PointCloud<pcl::PointXYZ> cloud;

  // Fill in the cloud data
  cloud.width    = 5;
  cloud.height   = 1;
  cloud.is_dense = false;
  cloud.points.resize (cloud.width * cloud.height);

  for (size_t i = 0; i < cloud.points.size (); ++i)
  {
    cloud.points[i].x = 1024 * rand () / (RAND_MAX + 1.0f);
    cloud.points[i].y = 1024 * rand () / (RAND_MAX + 1.0f);
    cloud.points[i].z = 1024 * rand () / (RAND_MAX + 1.0f);
  }

  pcl::io::savePCDFileASCII ("test_pcd.pcd", cloud);
  std::cerr << "Saved " << cloud.points.size () << " data points to test_pcd.pcd." << std::endl;

  for (size_t i = 0; i < cloud.points.size (); ++i)
    std::cerr << "    " << cloud.points[i].x << " " << cloud.points[i].y << " " << cloud.points[i].z << std::endl;

// Create the normal estimation class, and pass the input dataset to it
          
          pcl::NormalEstimation<pcl::PointXYZ, pcl::Normal> ne;
          ne.setInputCloud (cloud.makeShared());

          // Create an empty kdtree representation, and pass it to the normal estimation object.
          // Its content will be filled inside the object, based on the given input dataset (as no other search surface is given).
          pcl::search::KdTree<pcl::PointXYZ>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZ> ());
          ne.setSearchMethod (tree);

          // Output datasets
          pcl::PointCloud<pcl::Normal>::Ptr cloud_normals (new pcl::PointCloud<pcl::Normal>);

          // Use all neighbors in a sphere of radius 3cm
          ne.setRadiusSearch (0.03);

          // Compute the features
          ne.compute (*cloud_normals);
        
          std::cerr << "Normal cloud size " << cloud_normals->points.size()<< std::endl;

}

Originally posted by Nihad on ROS Answers with karma: 22 on 2013-03-31
Post score: 0

Original comments
Comment by jarvisschultz on 2013-04-01:
I'm not completely sure that I understand your question, but you can access the components of a normal for a given point using cloud_normals->points.at(i).normal. Here i would be the point number. I use Eigen::Map<Eigen::Vector3f> tmp(cloud_normals->points.at(i).normal); to get into Eigen
Comment by jarvisschultz on 2013-04-01:
I'm not sure why &gt and &lt are showing up instead of the actual greater-than and less-than signs...  Hopefully it is still readable
Comment by Nxzx on 2016-01-15:
Hello, Jarvis, I have a problem do you know how to estimate a normal for a single point using the function:
computePointNormal (const pcl::PointCloud &cloud, const std::vector &indices, Eigen::Vector4f &plane_parameters, float &curvature);
How can I fill the indices?
Comment by Nxzx on 2016-01-15:
After the normal calculation how can I compare two normals of different points and check if their pointing directions?

A:

To access the components of a normal for a given point, I use following code.
.................

for (size_t i = 0; i < cloud_normals->points.size(); ++i)
 std::cerr << "    " << cloud_normals->points[i].normal_x << " " << cloud_normals->points[i].normal_y << " " << cloud_normals->points[i].normal_z << std::endl;

.................

Originally posted by Nihad with karma: 22 on 2013-04-01
This answer was ACCEPTED on the original site
Post score: 0


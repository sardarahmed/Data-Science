Q:

Problem in determining a link language while using external libraries

Hi I am a PhD student and quite new to ROS trying to make a ROS package to use my Robot. The company who built the robot has also provided us some C++ libraries and codes, i.e. libRover.h and libRover.cc. Inside these codes there are some functions from different classes that help us to read status of the robot and also send commands to it. For example:
int Rover::getSpeed ( Time & _timestamp,
float & _left,
float & _right 
) 

Get the speed of the tracks [in rad/s].

Parameters
[out] _timestamp the current timestamp [in s].
[out] _left the average speed of the front and rear left tracks [in rad/s].
[out] _right the average speed of the front and rear right tracks [in rad/s].
Returns
0 if success, an error code otherwise.

Now what I am trying to do is to create a package that executes some of this functions, for example to read the voltage of the battery, and publish the data as ROS messages. I put the *.h and the *.cc files in my_package/include. I also set up my CMakeLists.txt as follows:
cmake_minimum_required(VERSION 2.8.3)
project(donkey_rover)

## Find catkin macros and libraries
## if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz)
## is used, also find other catkin packages
find_package(catkin REQUIRED COMPONENTS
  roscpp
  rospy
  std_msgs
)

catkin_package(
  INCLUDE_DIRS include LIBRARIES donkey_rover 
  CATKIN_DEPENDS roscpp rospy std_msgs
  DEPENDS system_lib
)

include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -Wall -I../include")
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -L../include")

add_library(Rover STATIC BogieScanner.cc CANopenHelper.cc CANopenMaster.cc Drive.cc Track.cc libRover.cc)
## Declare a C++ executable
add_executable(rovstate src/rovstate.cpp)

## Add cmake target dependencies of the executable
## same as for the library above
# add_dependencies(donkey_rover_node ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
add_dependencies(rovstate donkey_rover_generate_messages_cpp)
add_dependencies(rovstate ${catkin_EXPORTED_TARGETS})

## Specify libraries to link a library or executable target against
target_link_libraries(rovstate libRover.a pthread
   ${catkin_LIBRARIES}
 )

add_subdirectory(include)

install(DIRECTORY include/${PROJECT_NAME}/
   DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}
   FILES_MATCHING PATTERN "*.h"
   PATTERN ".svn" EXCLUDE
 )

Here is my catkin_make log:
CMake Error: Cannot determine link language for target "Rover".
CMake Error: CMake can not determine linker language for target: Rover
-- Generating done
-- Build files have been written to: /home/sherpa/catkin_ws/build
make: *** [cmake_check_build_system] Error 1
Invoking "make cmake_check_build_system" failed

The problem arises from the part of CMakeList.txt where I say
add_library(Rover STATIC BogieScanner.cc CANopenHelper.cc CANopenMaster.cc Drive.cc Track.cc libRover.cc)

I figured it out by removing the elements of this argument and observing the error on the next one. In other words, when I remove "Rover" from the add_library arguments I get a similar error from the next one, like:
CMake Error: Cannot determine link language for target "STATIC".
CMake Error: CMake can not determine linker language for target: STATIC
-- Generating done
-- Build files have been written to: /home/sherpa/catkin_ws/build
make: *** [cmake_check_build_system] Error 1
Invoking "make cmake_check_build_system" failed

Can anybody tell me what I am missing?
Thank you very much

Originally posted by mohsen1989m on ROS Answers with karma: 397 on 2015-09-22
Post score: 1

A:

Finally I managed to solve the problem. After all it was not that complicated. So basically the first step is to include the folder which contains your  source files (**.h and **.cc [or maybe .cpp]) to the directories. In my case it's LibRover
include_directories(
  include
  LibRover
  ${catkin_INCLUDE_DIRS}
  ${Boost_INCLUDE_DIRS}
  ${GSTREAMER_INCLUDE_DIRS}
)

Then making a library out of source files, in my case I call it Rover:
add_library(Rover LibRover/BogieScanner.cc LibRover/CANopenHelper.cc LibRover/CANopenMaster.cc LibRover/Drive.cc LibRover/Track.cc LibRover/libRover.cc)

of course adding the executable:
add_executable(rovstate src/rovstate.cpp)

and adding your executable as a dependency:
add_dependencies(rovstate  your_package_generate_messages_cpp ${catkin_EXPORTED_TARGETS})

linking the executable to the library that you just created above:
target_link_libraries(rovstate Rover
  ${catkin_LIBRARIES}
  ${Boost_INCLUDE_DIRS}
  ${GSTREAMER_INCLUDE_DIRS}
 )

and finally installing the header files:
install(TARGETS Rover
        ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
        LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
        RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION})

install(DIRECTORY include/${PROJECT_NAME}/
   DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}
   FILES_MATCHING PATTERN "*.h"
   PATTERN ".svn" EXCLUDE
 )

more information can be found in this link: http://docs.ros.org/jade/api/catkin/html/howto/format2/building_libraries.html

Originally posted by mohsen1989m with karma: 397 on 2015-10-08
This answer was ACCEPTED on the original site
Post score: 0


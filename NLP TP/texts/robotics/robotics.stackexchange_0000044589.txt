Q:

depth image to CV_16UC1

Hi, I am currently trying to capture images and localizing a colored landmark in the kinect frame. I first tried detecting the color in a downsampled pointcloud but that was just too slow, and so now I am doing color segmentation with OpenCV hoping that i can also mask a depth image with which I can build a smaller point cloud.
Here is my current problem.
    void depthCb(const sensor_msgs::ImageConstPtr& msg)
  {
    cv_bridge::CvImageConstPtr cv_ptr;
    try
    {
      cv_ptr = cv_bridge::toCvShare(msg, enc::TYPE_16UC1);
    }
    catch (cv_bridge::Exception& e)
    {
      ROS_ERROR("cv_bridge exception: %s", e.what());
      return;
    }
   
     //dst is the mask resultant from color segmentation, class member
   Mat result= dst & src;
    cv::imshow("depth_filtered", result);

    cv::imshow("depth_image", cv_ptr->image);
    cv::waitKey(3);
    
    image_pub_.publish(cv_ptr->toImageMsg());
  }

This is a callback for the depth raw data. When I run this I get an exception
[ERROR] [1349283297.431785349]: cv_bridge exception: Unsupported conversion from [16UC1] to [mono16]

I chose to convert to mono16 because I tought it was basically the same thing since the kinect image is 16UC1. I was trying to avoid writting the code to convert this, so it would be nice if there was any existing solution.
I am sort of new to openCV as well as ROS itself so if you have any ideas of how to overcome this particular obstacle or if you know of a better method to achieve my goal, please share. Thanks in advance.
EDIT
This worked, but it kind of slowed down the code
void depthCb(const sensor_msgs::ImageConstPtr& msg)
  {
    cv_bridge::CvImageConstPtr cv_ptr;
    try
    {
      cv_ptr = cv_bridge::toCvShare(msg, enc::TYPE_16UC1);
    }
    catch (cv_bridge::Exception& e)
    {
      ROS_ERROR("cv_bridge exception: %s", e.what());
      return;
    }
    
     ROS_INFO("Applying mask to depth image");
   Mat m=Mat(cv_ptr->image.size(), cv_ptr->image.type());
  
   cvtColor(dst,m,CV_RGB2GRAY); 
   Mat result=Mat(cv_ptr->image.size(), cv_ptr->image.type());
   cv_ptr->image.copyTo(result, m); 
    
    cv::imshow("depth_filtered", result);
    cv::imshow("depth_image", cv_ptr->image);
    cv::waitKey(1);
    
  }

Originally posted by Barbosa on ROS Answers with karma: 35 on 2012-10-03
Post score: 0

A:

The encoding option to cv_bridge::toCvShare is optional; if you don't pass it, the conversion function should choose the opencv format that is most convenient (which should preserve the incoming data and be a faster conversion).
It looks like you're making couple copies of your image, and it isn't obvious why. Memory allocation and image copies are SLOW; avoid them if you can.

Originally posted by ahendrix with karma: 47576 on 2012-10-08
This answer was ACCEPTED on the original site
Post score: 1


Q:

GUI RQT Plugin library built under Catkin

Hello everyone!
I try to create a qt based gui for my package.
According to the comment, I adapted the example.
I created a library Projectgui which is just dependent on gui.h and gui.c and is found in in devel/lib/Projectgui.so.
This library I installed
install(PROGRAMS Projecgui DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})
I can compile the Project, I get the library, I can start rqt without an error, but
the plugin is not shown in the rqt. So I guess the library is installed at the wrong place?!
Do you have any idea what's my mistake?
Thank you very much.
In the following you find a simplified version of the project.
My package has the following order:
Catkin/src/Project/
 - src/System/
      -system.cpp     --> Contains int main()
      -system.h 
 - src/Gui/
      -gui.cpp 
      -gui.h 
      -gui.ui
 - CMakeLists.txt
 - package.xml
 - plugin.xml
 - setup.py

with setup.py
## ! DO NOT MANUALLY INVOKE THIS setup.py, USE CATKIN INSTEAD

from distutils.core import setup
from catkin_pkg.python_setup import generate_distutils_setup

# fetch values from package.xml
setup_args = generate_distutils_setup(
    packages=['Project'],
    package_dir={'':'src'},
    requires=['std_msgs', 'roscpp']
)

setup(**setup_args)

CMakeLists:
cmake_minimum_required(VERSION 2.8)
add_definitions(-std=c++11)

project(Project)

find_package(Boost)
find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation rosbag rqt_gui_cpp rqt_gui)

find_package(Qt4 COMPONENTS QtCore QtGui REQUIRED)
include(${QT_USE_FILE})
add_definitions(${QT_DEFINITIONS})
catkin_python_setup() #needed for qt setup.py to install plugin

add_message_files(  FILES  VrepInfo.msg)        
generate_messages(  DEPENDENCIES  std_msgs) 

catkin_package(
    INCLUDE_DIRS include
    CATKIN_DEPENDS roscpp rospy std_msgs rosbag message_runtime  rqt_gui_cpp rqt_gui
    CATKIN_DEPENDS message_runtime
    DEPENDS Boost
)

include_directories(include 
        ${CMAKE_CURRENT_BINARY_DIR}
        ${catkin_INCLUDE_DIRS}          
        ${Boost_INCLUDE_DIRS}
        /include
        /Project/include
        src/System/
)
add_executable(Project_node src/System/system.cpp  )        
QT4_WRAP_CPP(MOC_SRC_H
  src/Gui/gui.h
)
QT4_WRAP_UI(MOC_GUI_H 
  src/Gui/gui.ui
)
add_library(Projectgui
    src/Gui/gui.cpp
    src/Gui/gui.h       
    ${MOC_SRC_H} 
    ${MOC_GUI_H}
)   
target_link_libraries(Project_node 
        ${catkin_LIBRARIES} 
        ${Boost_LIBRARIES} 
        yaml-cpp 
        ${QT_QTCORE_LIBRARY} 
        ${QT_QTGUI_LIBRARY}
        Projectgui)

install(TARGETS Project_node RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})
install(PROGRAMS Projectgui DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})

plugin.xml
<library path="lib/libProjectgui">
  <class name="MyPlugin" type="Gui::MyPlugin" base_class_type="rqt_gui_cpp::Plugin">
    <description> An example C++ GUI plugin. </description>
    <qtgui>
      <label>Project GUI</label>
      <icon type="theme">image-x-generic</icon>
      <statustip>User Interface.</statustip>
    </qtgui>
  </class>
</library>

gui.ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MyPluginWidget</class>
 <widget class="QWidget" name="MyPluginWidget">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>400</width>
    <height>300</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Form</string>
  </property>
 </widget>
 <resources/>
 <connections/>
</ui>

gui.src
#include "gui.h"
#include <pluginlib/class_list_macros.h>
#include <QWidget>
#include <QStringList>

namespace Gui {

MyPlugin::MyPlugin(): rqt_gui_cpp::Plugin(), widget_(0) {
    // give QObjects reasonable names
    setObjectName("MyPlugin");
}
void MyPlugin::initPlugin(qt_gui_cpp::PluginContext& context) {
    // access standalone command line arguments
    QStringList argv = context.argv();
    // create QWidget
    widget_ = new QWidget();
    // extend the widget with all attributes and children from UI file
    ui_.setupUi(widget_);
    // add widget to the user interface
    context.addWidget(widget_);
}
void MyPlugin::shutdownPlugin(){
}
void MyPlugin::saveSettings(qt_gui_cpp::Settings& plugin_settings, qt_gui_cpp::Settings& instance_settings) const{
}
void MyPlugin::restoreSettings(const qt_gui_cpp::Settings& plugin_settings, const qt_gui_cpp::Settings& instance_settings){
}
} // namespace
PLUGINLIB_DECLARE_CLASS(Gui, MyPlugin, Gui::MyPlugin, rqt_gui_cpp::Plugin)

gui.h
#ifndef GUI_H_
#define GUI_H_

#include <rqt_gui_cpp/plugin.h>
#include <ui_gui.h>
#include <QWidget>

namespace Gui {

class MyPlugin: public rqt_gui_cpp::Plugin {
    Q_OBJECT
public:
    MyPlugin();
    virtual void initPlugin(qt_gui_cpp::PluginContext& context);
    virtual void shutdownPlugin();
    virtual void saveSettings(qt_gui_cpp::Settings& plugin_settings, qt_gui_cpp::Settings& instance_settings) const;
    virtual void restoreSettings(const qt_gui_cpp::Settings& plugin_settings, const qt_gui_cpp::Settings& instance_settings);
private:
    Ui::MyPluginWidget ui_;
    QWidget* widget_;
};
} 
#endif 

Originally posted by JanOr on ROS Answers with karma: 170 on 2016-02-02
Post score: 1

A:

The plugin should be in a lib that can be loaded by another process, it should not implement the process itself. I. e. there should not be a main() in your process and you should create a library rather than an executable.
This means remove your main and change
add_executable(Project_node 
        src/System/system.cpp 
        src/Gui/gui.cpp     
        ${MOC_SRC_H} 
        ${MOC_GUI_H}
)       

for
add_library(rqt_project 
        src/System/system.cpp 
        src/Gui/gui.cpp     
        ${MOC_SRC_H} 
        ${MOC_GUI_H}
)

in your CMakeLists.txt. Note that rqt_project will correspond to an output library file named librqt_project.so. This in turn is loaded because in your plugin.xml you state: <library path="lib/librqt_project">, i. e. the postfix of the library path in plugin.xml must correspond with the target name of  add_library in the CMakeLists.txt.
You can launch your plugin then via rgt_gui (it should appear there amongst the plugins) or standalone using a script like the one mentioned here:
http://answers.ros.org/question/124706/how-to-run-a-newly-created-rqt-plugin/#191986
Edit:
Maybe you have to add a group tag to make your plugin appear in rqt_gui, e. g.:
<library path="lib/libfoobar">
  <class name="foo/Bar" type="foo::Bar" base_class_type="rqt_gui_cpp::Plugin">
    <description>
      A GUI plugin to view a sensor_msgs/Image topic in an foobar manner.
    </description>
    <qtgui>
      <group>
        <label>Visualization</label>
        <icon type="theme">folder</icon>
        <statustip>Plugins related to visualization.</statustip>
      </group>
      <label> blub image view</label>
      <icon type="theme">image-x-generic</icon>
      <statustip>A GUI plugin to view foobar topic in some manner.</statustip>
    </qtgui>
  </class>
</library>

Originally posted by Wolf with karma: 7555 on 2016-02-02
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by JanOr on 2016-02-02:
Hey thanks a lot.
It becomes clearer and clearer.
Unfortunately I get the issue that the plugin is not found by rqt anymore.
I updated the question above according to your comment.
Comment by Wolf on 2016-02-02:
go to ~/.config/ros.org and remove rqt_gui.ini . Then relaunch rqt_gui.ini in order for having it to crawl again for available plugins. Your plugin show then appear..
Comment by JanOr on 2016-02-03:
Thanks, but I still get the same problem. It still doesn't show up.
I think the problem is still the installation of the pacakge in setup.py
I have been searching in /opt/ros/indigo/lib/ and find rqt_* folders, but I can't find any library or folder of my plugin there?!


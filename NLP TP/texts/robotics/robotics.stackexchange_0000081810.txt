Q:

Can ROS Service be used in Real-time Application or Hardware Control?

I have 3 related questions about ROS service:

Is it a good idea to put a ROS service client in my robot hardware code?
Will it increase the time-delay of the hardware node and make my robot unable to work correctly?
Does PR2 robot use ROS service in its hardware node?
When should I use ROS service compared with ROS messages?)

Originally posted by Winston on ROS Answers with karma: 180 on 2017-07-16
Post score: 1

A:

ROS does not provide any guarantees about request latency, scheduling delay, processing time or response latency when using services (or topics for that matter). For two nodes running on the same computer these delays are typically between a few milliseconds and a few hundred milliseconds.
Unlike topics, services are synchronous and the client must wait for the transport delay in both the request and the response.
Service clients can be persistent or non-persistent. Persistent clients only have to establish the TCP session once; non-persistent clients create a new TCP session for every request. Setting up the TCP session can add latency, but it increases the client's robustness to changes in the server's address (such as when the server node is stopped and restarted).
With those facts about services in mind, I can help you find answers to some of your questions:

Is it a good idea to put a ROS service client in my robot hardware code?

This depends on your requirements and how you plan to use the service client. If you are using services in the feedback loop they may work if your system has a lot of inertial or a slow time-constant, but they're clearly not appropriate for systems that need to run at 1kHz or more. If you're just using services for occasional updates and with a good threading model they're probably fine in any system.

Will it increase the time-delay of the hardware node and make my robot unable to work correctly?

This is completely dependent on how you write you code.

Does PR2 robot use ROS service in its hardware node?
The PR2 uses services, topics, non-blocking queues, and a few other real-time software techniques in the node that runs the real-time control loops. The PR2 needs to run the control loop at 1kHz, so it also runs the real-time thread with increased priority on a linux kernel with the rt-preempt patches. The combination of these tools is far more important than their presence.
When should I use ROS service compared with ROS messages?
This has been asked and answered many times before: http://answers.ros.org/question/11834/when-should-i-use-topics-vs-services-vs-actionlib-actions-vs-dynamic_reconfigure/

Originally posted by ahendrix with karma: 47576 on 2017-07-16
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by Winston on 2017-07-16:
Thank you so much for your reply. I know you are one of the designers of PR2 robot, and I am lucky to have coded on PR2 before. Sorry I have a technical mistake here; I use a ROS service server (not client) in my ROS hadware node. And in another node, I call this service at 66Hz.
Comment by Winston on 2017-07-16:
My hardware uses EtherCAT and I have tested that when the time latency is more than 18 ms, the EtherCAT will report an error and all the motors are free of torque. So I just wonder the problem is in my frequent (66Hz) call of service to the hardware node.  What do you think?
Comment by ahendrix on 2017-07-17:
When dealing with real-time systems, do not guess. Measure. If you think your service isn't getting called frequently enough, measure it. You may also want to measure the latency between when the client makes service calls and when they're processed by the server.
Comment by Winston on 2017-07-17:
Thank you for your suggestion. I will measure the latency. What I mean is the call of service is actually too frequent, making the service server in hardware node busy with responding to every call. This may lead to interruption of the normal process of the hardware node and cause free of torque.
Comment by ahendrix on 2017-07-17:
The PR2 solved this by running the realtime communication task in a separate thread from the ROS callbacks, and using non-blocking queues to move data from ROS callbacks into the realtime thread.
Comment by Winston on 2017-07-17:
Thank you for this comment. Could you provide me with the related code so that I know how to write this for  our own robot?
Comment by ahendrix on 2017-07-17:
The PR2 had modular controllers and supported loading new controllers as plugins, so it was complex. Controllers implemented the https://github.com/PR2/pr2_mechanism/tree/hydro-devel/pr2_controller_interface , like https://github.com/PR2/pr2_controllers/tree/hydro-devel/robot_mechanism_controllers
Comment by ahendrix on 2017-07-17:
Controllers relied heavily on the classes from the realtime_tools package.
Comment by ahendrix on 2017-07-17:
In the years since PR2 was developed, other uses have extended the original framework and made it more modular, and the result is the ros_control system.
Comment by Winston on 2017-07-19:
Thank you very much. Sorry but the information is overwhelming. I try to use ros_control before but I think the documentation is not sufficient, and I want to use a simple method to reduce the time latency of my hardware node. Just a quick question, does custom call back queues useful in this case?
Comment by Winston on 2017-07-19:
For example, the gazebo_plugin uses extensively the custom call back queues. Does it serve the purpose of processing the ROS message call back in a separate thread?
Comment by Winston on 2017-07-21:
@ahendrix Have you seen my comments?
Comment by ahendrix on 2017-07-23:
Custom callback queues allow you to control which thread executes callbacks, but just putting callbacks in a separate thread doesn't solve your issue. You need data structures and inter-thread communication primitives that are designed for real-time systems.
Comment by ahendrix on 2017-07-23:
What you are describing is a fairly tricky problem, and it requires careful thought and design. You will not find a quick fix for what you're trying to do.
Comment by ahendrix on 2017-07-23:
As with most fields of study, the design of realtime systems is not needlessly complex. I strongly advise you to study the existing systems and literature and learn from it.


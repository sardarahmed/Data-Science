Q:

Unable to run simultaneous rosserial publisher and subscriber

I'm working through the rosserial_embeddedlinux tutorials:  https://wiki.ros.org/rosserial_embeddedlinux
Both the publisher and subscriber tutorials work as described in isolation.
For the publisher:  I can run rosrun rosserial_python serial_node.py tcp, run the HelloROS publisher example, run rostopic echo chatter, and see the expected output on the host.
For the subscriber:  I can run rosrun rosserial_python serial_node.py tcp, run the ExampleSubscriber subscriber example, run rostopic pub chatter std_msgs/String -1 -- "Hello Embedded Linux", and see the expected output printed by the subscriber node.
When I try to run them together though (as described by the subscriber tutorial).  I am not successful.
Whichever executable I start first (publisher or subscriber) connects to the rosserial_python server and behaves as expected.  When I try to start the other executable, it doesn't connect to the server.  If I kill the first application while the second is still running, the second one automatically connects to the rosserial_python server and then behaves as expected.
I assume there is some resource conflict here, but I don't understand the setup well enough to diagnose and correct it.  The two executables connect from different ports (though they both connect to the server on port 11411).
I am also running everything on the same host machine (i.e., roscore, rosserial_python server, publisher, and subscriber).  It's running Ubuntu 18.04.  This may be my problem, but as each executable worked individually, it seemed easier to continue with the tutorials on my host machine before moving the embedded executables to a separate device which may be harder to debug.

Originally posted by broomstick on ROS Answers with karma: 111 on 2020-02-18
Post score: 0

A:

The easiest way I have found to overcome this is to run two serial_node.py nodes listening on two different ports.  You have to rename one of them, to avoid namespace collisions.
At the command line:
[in terminal 1] rosrun rosserial_python serial_node.py tcp 11411 __name:=server_one
[in terminal 2] rosrun rosserial_python serial_node.py tcp 11412 __name:=server_two

You can verify the renaming worked correctly with:
rosnode list
You can also do this in a launch file:
<node pkg="rosserial_python" type="serial_node.py" name="server_one" output="screen" args="tcp 11411">
    <param name="port" value="tcp" />
</node>

<node pkg="rosserial_python" type="serial_node.py" name="server_two" output="screen" args="tcp 11412">
    <param name="port" value="tcp" />
</node>

In either case, you need to make sure your rosserial applications are conneting to the correct port.
node_handle::initNode() will accept either an IP address or an IP address and a port number.  In this case, then we would initialise one rosserial application with HOST_IP:11411 and the other with HOST_IP:11412.  For example:
nh_.initNode("192.168.0.1:11411");

Originally posted by broomstick with karma: 111 on 2020-04-02
This answer was ACCEPTED on the original site
Post score: 0


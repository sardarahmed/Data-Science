Q:

Ros not responding to keypress to WaitKey

Hi guys..
I am using openCV to run some video processing, in which i switch 2 algorithm, and the switch is performed by the user, from a key press.. The only problem is though i am not able it make react on key press.
It seems like it keep looping around the same code, even though i press a key..
How do i make it change??
Here is the code..
Main.cpp
#include "class.cpp"

int main( int argc, char** argv )
{
   ros::init(argc, argv, "image_converter");
   ImageConverter ic;
   ros::spin();
   return 0;
}

class.h
#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include "sensor_msgs/JointState.h"
#include "facedetect.h"
#include <cmath>

using namespace cv;
using namespace std;

static const std::string OPENCV_WINDOW = "Image window";

class ImageConverter
{
  ros::NodeHandle nh_;
  image_transport::ImageTransport it_;
  image_transport::Subscriber image_sub_;
  image_transport::Publisher image_pub_;
  std::vector<double> pos;
  std::vector<double> vel;
  double position_prev_p;
  double position_prev_t;
  pair<double,double> displacement;
  ros::Subscriber sub;
  ros::Publisher facedetect_pub;
  Rect face;
  bool state;
  

public:
      void chatterCallback(const sensor_msgs::JointState::ConstPtr& msg);
      ImageConverter();
      ~ImageConverter();
      void imageDetect(const sensor_msgs::ImageConstPtr& msg);

};

class.cpp
#include "class.h"

ImageConverter::ImageConverter()
    : it_(nh_),pos(2),  vel(2) 
  {
    // Subscrive to input video feed and publish output video feed
    
        image_sub_ = it_.subscribe("/custom/left/image_rect_color", 1, 
        &ImageConverter::imageDetect, this);
        image_pub_ = it_.advertise("/image_converter/output_video", 1);
        state = false;
  }

 

    ImageConverter::~ImageConverter()
      {
        //cv::destroyAllWindows();
      }
      
      void ImageConverter::imageDetect(const sensor_msgs::ImageConstPtr& msg)
      {
         facedetect_pub = nh_.advertise<sensor_msgs::JointState>("/custom/cmd", 1);
         sub = nh_.subscribe("/joint_states",1,&ImageConverter::chatterCallback,this); 
         cv_bridge::CvImagePtr cv_ptr;
         sensor_msgs::JointState ms;
        try
        {
          cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);
        }
        catch (cv_bridge::Exception& e)
        {
          ROS_ERROR("cv_bridge exception: %s", e.what());
          return;
        }
    
        if (!state) {
            cout <<"Can i see you ?" << endl;
    
            if(waitKey(10) != 'y')
            {
                face = detectAndDisplay(cv_ptr->image);
            }else{
                state = true;
            }
        }else{
            cout <<"Face detected" << endl; 
            displacement = track(face,cv_ptr->image);
            if(abs(pos[0]-position_prev_p) < 0.50 )
            {
                pos[0] = ceil(sin(displacement.first*0.000727220522)*1000)/1000 + position_prev_p;
            }
            if(abs(pos[1]-position_prev_t) < 0.50)
            {
                cout << "tilt change" << endl;
                pos[1] = -ceil(sin(displacement.second*0.000727220522)*1000)/1000 + position_prev_t;
            }
            
                ms.position = pos;
                vel[0] =0;
                vel[1] = 0;
                ms.velocity = vel;
                ROS_INFO_STREAM("pan: "<<pos[0]);
                ROS_INFO_STREAM("pan_prev: " << position_prev_p);
                ROS_INFO_STREAM("Subtracted: " <<abs(pos[0]-position_prev_p));
                ROS_INFO_STREAM("tilt: "<<pos[1]);
                ROS_INFO_STREAM("tilt_prev: " << position_prev_t);
                ROS_INFO_STREAM("Subtracted: " <<abs(pos[1]-position_prev_t));
                facedetect_pub.publish(ms);
                ROS_WARN_STREAM("OUT of if");
        
        }
    
    }
    
    void ImageConverter::chatterCallback(const sensor_msgs::JointState::ConstPtr& msg)
       {    
         position_prev_p = (msg->position[0]);
         position_prev_t = (msg->position[1]);
       }

facedetect.h - detectAndDisplay
Rect detectAndDisplay( Mat frame )
{
        vector<Rect> faces(1);
        Point center_of_frame(frame.size().width/2,frame.size().height/2);
        pair<Point, Point> corners;
        pair<double,double> displacement;
        double displacement_pixel_x;
        double displacement_pixel_y;
        bool foundFace = false;
        pair<Rect, bool> response;
                if (frame.type()!= 8) {
                        cvtColor(frame, frame, CV_8U);
                }
   
        //-- 1. Load the cascades
                if( !face_cascade.load( face_cascade_XML ) ){
                        cout << "Cascade Error" << endl;
                };
   
                circle(frame, center_of_frame, 1, CV_RGB(0,255,255),8,8,0);
   
        //-- Detect faces
                face_cascade.detectMultiScale( frame, faces, 1.1, 2, 0, Size(100, 100) );
                       
                        for( int i = 0; i<faces.size() ; i++)
                        {
                                Point center_position_of_face((faces[i].br().x+faces[i].tl().x)/2,(faces[i].tl().y+faces[i].br().y)/2);
                                Point corner_1(faces[i].br().x,faces[i].tl().y);
                                Point corner_2 = faces[i].tl();
                                Point corner_3 = faces[i].br();
                                Point corner_4(faces[i].tl().x,faces[i].br().y);
                                rectangle(frame, faces[i], CV_RGB(0,255,0),4,8,0);
                                circle(frame, center_position_of_face, 8, CV_RGB(128,128,128),8,8,0);
                                circle(frame, corner_1, 1, CV_RGB(128,128,128),8,8,0);
                                circle(frame, corner_2, 1, CV_RGB(128,128,128),8,8,0);
                                circle(frame, corner_3, 1, CV_RGB(128,128,128),8,8,0);
                                circle(frame, corner_4, 1, CV_RGB(128,128,128),8,8,0);
                                line(frame, center_position_of_face, center_of_frame, CV_RGB(0,200,0),1,8);
                                //displacement_pixel_x = (center_position_of_face.x-center_of_frame.x);
                                //displacement_pixel_y = (center_position_of_face.y-center_of_frame.y);
 
                        }
       
                flip(frame, frame, 1);
                imshow("Facedetection", frame);
               
                if(waitKey(1000) != 'y')
                return faces.back();
 
}

It keeps outputting "can i see you?" i it looks like it keeps looping the same statement, again and again.. how do i fix it..

Originally posted by 215 on ROS Answers with karma: 156 on 2015-03-25
Post score: 0

A:

I choose to remove the waitKey(1) != 'y' solution and use this one instead
http://answers.ros.org/question/63491/keyboard-key-pressed/

Originally posted by 215 with karma: 156 on 2015-04-01
This answer was ACCEPTED on the original site
Post score: 0


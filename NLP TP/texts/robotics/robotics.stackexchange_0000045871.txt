Q:

Problems with Int32MultiArrays

Hi,
I'm wondering if anyone knows what these errors mean:
My code is really long to post, so I was wondering if there was something general that these are getting at that I can look out for in my code.
I'm trying to pass std_msgs::Int32MultiArray::ConstPtr&
arrays from a subscribed topic into a function to pull out the data.
Any help on this would be greatly appreciated!!
Edit: I am running ROS electric on Ubuntu 11.10.
Full Error Message:
/opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:570:14: note: template<class M, class T> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (T::*)(const boost::shared_ptr<const MReq>&)const, const boost::shared_ptr<U>&, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:618:14: note: template<class M> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (*)(M), const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:663:14: note: template<class M> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (*)(const boost::shared_ptr<const M>&), const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:706:14: note: template<class M> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, const boost::function<void(const boost::shared_ptr<const M>&)>&, const VoidConstPtr&, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:752:14: note: template<class M, class C> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, const boost::function<void(C)>&, const VoidConstPtr&, const ros::TransportHints&)
  /home/gregory/ros_workspace/socbot/src/mainProcessing.cpp:111:133: error: no matching function for call to ‘ros::NodeHandle::subscribe(const char [17], int, void (mainProcessing::*)(const ConstPtr&), mainProcessing* const)’
  /home/gregory/ros_workspace/socbot/src/mainProcessing.cpp:111:133: note: candidates are:
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:379:14: note: template<class M, class T> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (T::*)(M), T*, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:390:14: note: template<class M, class T> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (T::*)(M)const, T*, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:438:14: note: template<class M, class T> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (T::*)(const boost::shared_ptr<const MReq>&), T*, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:448:14: note: template<class M, class T> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (T::*)(const boost::shared_ptr<const MReq>&)const, T*, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:498:14: note: template<class M, class T> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (T::*)(M), const boost::shared_ptr<U>&, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:509:14: note: template<class M, class T> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (T::*)(M)const, const boost::shared_ptr<U>&, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:559:14: note: template<class M, class T> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (T::*)(const boost::shared_ptr<const MReq>&), const boost::shared_ptr<U>&, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:570:14: note: template<class M, class T> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (T::*)(const boost::shared_ptr<const MReq>&)const, const boost::shared_ptr<U>&, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:618:14: note: template<class M> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (*)(M), const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:663:14: note: template<class M> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (*)(const boost::shared_ptr<const M>&), const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:706:14: note: template<class M> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, const boost::function<void(const boost::shared_ptr<const M>&)>&, const VoidConstPtr&, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:752:14: note: template<class M, class C> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, const boost::function<void(C)>&, const VoidConstPtr&, const ros::TransportHints&)
  /home/gregory/ros_workspace/socbot/src/mainProcessing.cpp:112:136: error: no matching function for call to ‘ros::NodeHandle::subscribe(const char [18], int, void (mainProcessing::*)(const ConstPtr&), mainProcessing* const)’
  /home/gregory/ros_workspace/socbot/src/mainProcessing.cpp:112:136: note: candidates are:
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:379:14: note: template<class M, class T> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (T::*)(M), T*, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:390:14: note: template<class M, class T> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (T::*)(M)const, T*, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:438:14: note: template<class M, class T> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (T::*)(const boost::shared_ptr<const MReq>&), T*, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:448:14: note: template<class M, class T> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (T::*)(const boost::shared_ptr<const MReq>&)const, T*, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:498:14: note: template<class M, class T> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (T::*)(M), const boost::shared_ptr<U>&, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:509:14: note: template<class M, class T> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (T::*)(M)const, const boost::shared_ptr<U>&, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:559:14: note: template<class M, class T> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (T::*)(const boost::shared_ptr<const MReq>&), const boost::shared_ptr<U>&, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:570:14: note: template<class M, class T> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (T::*)(const boost::shared_ptr<const MReq>&)const, const boost::shared_ptr<U>&, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:618:14: note: template<class M> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (*)(M), const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:663:14: note: template<class M> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, void (*)(const boost::shared_ptr<const M>&), const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:706:14: note: template<class M> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, const boost::function<void(const boost::shared_ptr<const M>&)>&, const VoidConstPtr&, const ros::TransportHints&)
  /opt/ros/electric/stacks/ros_comm/clients/cpp/roscpp/include/ros/node_handle.h:752:14: note: template<class M, class C> ros::Subscriber ros::NodeHandle::subscribe(const string&, uint32_t, const boost::function<void(C)>&, const VoidConstPtr&, const ros::TransportHints&)
  make[3]: *** [CMakeFiles/mainProcessing.dir/src/mainProcessing.o] Error 1
  make[3]: Leaving directory `/home/gregory/ros_workspace/socbot/build'
  make[2]: *** [CMakeFiles/mainProcessing.dir/all] Error 2
  make[2]: Leaving directory `/home/gregory/ros_workspace/socbot/build'
  make[1]: *** [all] Error 2
  make[1]: Leaving directory `/home/gregory/ros_workspace/socbot/build'

Code:
class mainProcessing{

    public: 
        
    mainProcessing();

    private:

    int RED;                    //Value of 333
    int BLUE;                   //Value of 444

    std_msgs::Int32MultiArray arrayRED;
    std_msgs::Int32MultiArray arrayBLUE;
    std_msgs::Int32MultiArray arrayBALL;

    int leaderRED;                  //Value of 0, 1 or 2
    int leaderBLUE;                 //Value of 0, 1 or 2
    int fwd;                    //Value of 123
    int def;                    //Value of 456

    int minPixelX;
    int maxPixelX;
    int defenceRefRED;
    int defenceRefBLUE;
    int goalxRED;
    int goalyRED;
    int goalxBLUE;
    int goalyBLUE;

    ros::NodeHandle mainHUB;
    
    ros::Publisher redBLANKPUB;
    ros::Publisher redWHITEPUB;
    ros::Publisher redBLACKPUB;
    ros::Publisher blueBLANKPUB;
    ros::Publisher blueWHITEPUB;
    ros::Publisher blueBLACKPUB;
    
    ros::Subscriber redTrackSUB;        
    ros::Subscriber blueTrackSUB;   
    ros::Subscriber ballTrackSUB;   

    ros::Subscriber leaderRedSUB;
    ros::Subscriber leaderBlueSUB;

    double calcDistance(int,int,int,int);
    double calcRelDefAngle(int,int,int,int,int,int);
    double calcRelFwdAngle(int,int,int,int);

    void setCurrPosRED(const std_msgs::Int32MultiArray::ConstPtr&);
    void setCurrPosBLUE(const std_msgs::Int32MultiArray::ConstPtr&);
    void setCurrPosBALL(const std_msgs::Int32MultiArray::ConstPtr&);
    void updateLeaderRED(const std_msgs::Int32MultiArray::ConstPtr&);
    void updateLeaderBLUE(const std_msgs::Int32MultiArray::ConstPtr&);
    void initializeSides();
    void run();

    void leaderPush0(std_msgs::Int32MultiArray&);
    void fwdPush(std_msgs::Int32MultiArray&, int, int, int, int);
    void defPush(std_msgs::Int32MultiArray&, int, int, int, int);
};

int RED = 333;
int BLUE = 444;
int minPixelX = 0;
int maxPixelX = 640;
int defenceRefRED = -1;
int defenceRefBLUE = -1;
int fwd = 123;                  
int def = 456;                  

mainProcessing::mainProcessing(){

    //Individual Robot Publishers (Publishes RoLES and Directions)
    redBLANKPUB = mainHUB.advertise<std_msgs::Int32MultiArray>("redBLANK", 30);
    redWHITEPUB = mainHUB.advertise<std_msgs::Int32MultiArray>("redWHITE", 30);
    redBLACKPUB = mainHUB.advertise<std_msgs::Int32MultiArray>("redBLACK", 30);
    blueBLANKPUB = mainHUB.advertise<std_msgs::Int32MultiArray>("blueBLANK", 30);
    blueWHITEPUB = mainHUB.advertise<std_msgs::Int32MultiArray>("blueWHITE", 30);
    blueBLACKPUB = mainHUB.advertise<std_msgs::Int32MultiArray>("blueBLACK", 30);

    //Subscriptions         
    redTrackSUB = mainHUB.subscribe<std_msgs::Int32MultiArray::ConstPtr>("redTrack", 30, &mainProcessing::setCurrPosRED,this);
    blueTrackSUB = mainHUB.subscribe<std_msgs::Int32MultiArray::ConstPtr>("blueTrack", 30, &mainProcessing::setCurrPosBLUE,this);
    ballTrackSUB = mainHUB.subscribe<std_msgs::Int32MultiArray::ConstPtr>("ballTrack", 30, &mainProcessing::setCurrPosBALL,this);
    leaderRedSUB = mainHUB.subscribe<std_msgs::Int32MultiArray::ConstPtr>("toArduinoLeadRED", 30, &mainProcessing::updateLeaderRED,this);
    leaderBlueSUB = mainHUB.subscribe<std_msgs::Int32MultiArray::ConstPtr>("toArduinoLeadBLUE", 30, &mainProcessing::updateLeaderBLUE,this);

    this->run();
}

void mainProcessing::setCurrPosRED(const std_msgs::Int32MultiArray::ConstPtr& x){

    //This function stores and updates the current positions of each robot in arrayRED

    //This didn't work on Arduino code, need to figure out how to use this one.
    arrayRED.data = x->data;

}

void mainProcessing::setCurrPosBLUE(const std_msgs::Int32MultiArray::ConstPtr& x){

    //This function stores and updates the current positions of each robot in arrayBLUE

    //This didn't work on Arduino code, need to figure out how to use this one.
    arrayBLUE.data = x->data;

}

void mainProcessing::setCurrPosBALL(const std_msgs::Int32MultiArray::ConstPtr& x){

    //This function stores and updates the current positions of each robot in arrayBALL

    //This didn't work on Arduino code, need to figure out how to use this one.
    arrayBALL.data = x->data;

}

void mainProcessing::updateLeaderRED(const std_msgs::Int32MultiArray::ConstPtr& x){

    // Leader = 0 = BLANK RED/BLUE is leader (default)
    // Leader = 1 = WHITE is leader
    // Leader = 2 = BLACK is leader

    if(x->data[0] == 1)
        leaderRED = 0;
    else if(x->data[1] == 1)
        leaderRED = 1;
    else if(x->data[2] == 1)
        leaderRED = 2;
    else{
        ROS_ERROR("mainProcessing::updateLeaderRED: Invalid leaderRED assignment");
        return;
    }   
    return;

}

void mainProcessing::updateLeaderBLUE(const std_msgs::Int32MultiArray::ConstPtr& x){

    // Leader = 0 = BLANK RED/BLUE is leader (default)
    // Leader = 1 = WHITE is leader
    // Leader = 2 = BLACK is leader

    if(x->data[0] == 1)
        leaderBLUE = 0;
    else if(x->data[1] == 1)
        leaderBLUE = 1;
    else if(x->data[2] == 1)
        leaderBLUE = 2;
    else{
        ROS_ERROR("mainProcessing::updateLeaderBLUE: Invalid leaderBLUE assignment");
        return;
    }   
    return;

}

void mainProcessing::initializeSides(){

    //This function determines what sides the colour teams are initially on. This will give a reference to the defensive zones of the respective teams throughout the rest of the game.

    //Assume traditional camera placement of left-to-right, along the X pixel axis of the camera.
    //Pixel 0 indicates the left side of the arena
    //Pixel 640 represents the right side of the arena

    //arrayRED/arrayBLUE = [333/222, blankX, blankY, 111, whiteX, whiteY,222, blackX, blackY];

    int midline = (minPixelX + maxPixelX)/2;    //check this division...

    if((arrayRED.data[1] < midline && arrayRED.data[4] < midline && arrayRED.data[7] < midline) && (arrayBLUE.data[1] > midline && arrayBLUE.data[4] > midline && arrayBLUE.data[7] > midline)){
        defenceRefRED = minPixelX;
        defenceRefBLUE = maxPixelX;
        goalxRED = defenceRefRED + 10;
        goalyRED = (arrayRED.data[7]+arrayBLUE.data[7])/2;
        goalxBLUE = defenceRefBLUE - 10;
        goalyBLUE = (arrayRED.data[7]+arrayBLUE.data[7])/2;
    }
    else if((arrayRED.data[1] > midline && arrayRED.data[4] > midline && arrayRED.data[7] > midline) && (arrayBLUE.data[1] < midline && arrayBLUE.data[4] < midline && arrayBLUE.data[7] < midline)){
        defenceRefRED = maxPixelX;
        defenceRefBLUE = minPixelX;
        goalxRED = defenceRefRED - 10;
        goalyRED = (arrayRED.data[7]+arrayBLUE.data[7])/2;
        goalxBLUE = defenceRefBLUE + 10;
        goalyBLUE = (arrayRED.data[7]+arrayBLUE.data[7])/2;
    }
    else{
        ROS_ERROR("mainProcessing::initializeSides(): Invalid initialization of Defensive References");
    }
    return; 
}

double mainProcessing::calcDistance(int x0, int y0, int x1, int y1){

    double a = sqrt((pow(y1,2)-pow(y0,2)) + (pow(x1,2)-pow(x0,2)));
    return a;

}   

double mainProcessing::calcRelDefAngle(int ballX, int ballY, int goalX, int goalY, int defX, int defY){

        //This one will get the relative angle, from the robots persepctive (start of robot is angle 0), of which the robot needs to point.
        //It accepts an input of ballX,ballY, goalX, goalY, and defX, defY
        //This function is specific to the defensive position of the team.
        //For now, it will hard code to 20% of the distance between the ball and the pre-determined goal point.

        double k1 = 1;
        double k2 = 4;

        double tempX = ((k1*ballX)+(k2*goalX))/(k1+k2);
        double tempY = ((k1*ballY)+(k2*goalY))/(k1+k2);

        double A = calcDistance(tempX,tempY,defX,defY);
        double B = calcDistance(tempX,tempY, tempX,defY); //This assumes the arena is 90 degrees with camera. May want to account for tilt later.   
        double C = calcDistance(tempX,defY,defX,defY);
        double theta = acos((pow(A,2) + pow(C,2) - pow(B,2))/(2*A*C));

        if(tempY > defY)        //Account for 0 Degree relative +/- convention for robot angle
            theta = -theta;

        if(theta >= 180)
            theta = theta - 360;
        else if(theta <=-180)
            theta = theta + 360;

        return round(theta);
}

double mainProcessing::calcRelFwdAngle(int oppX, int oppY, int fwdX, int fwdY){

        //This one will get the relative angle, from the robots persepctive (start of robot is angle 0), of which the robot needs to point.
        //It accepts an input of oppX, oppY, fwdX and fwdY
        //This function is specific to the forward position of the team.
        //The idea is to locate and follow the positions of the opposing team's leader

        double A = calcDistance(oppX,oppY,fwdX,fwdY);
        double B = calcDistance(oppX,oppY, oppX,fwdY); //This assumes the arena is 90 degrees with camera. May want to account for tilt later.  
        double C = calcDistance(oppX,fwdY,fwdX,fwdY);
        double theta = acos((pow(A,2) + pow(C,2) - pow(B,2))/(2*A*C));

        if(oppY > fwdY)         //Account for 0 Degree relative +/- convention for robot angle
            theta = -theta;

        if(theta >= 180)
            theta = theta - 360;
        else if(theta <=-180)
            theta = theta + 360;
        
        return round(theta);
}

void mainProcessing::run(){

    if(defenceRefRED == -1 && defenceRefBLUE == -1){
        ROS_ERROR("mainProcessing::run(): Invalid initialization of Defensive References. Did not run().");
        return;
    }

    //This function watches the Arena and transmits AI controls:
    //AI = [CONTROL(POSITION), FORWARD(ON), TURN(ON), ANGLE]
    //It is up to the code on the microcontroller to limit the updates(perhaps every 3s?). (This will update frequently) 

    //Position of Robots
    //arrayRED/arrayBLUE = [333/222, blankX, blankY, 111, whiteX, whiteY,222, blackX, blackY];

    //Robot Reference
    // Index 0 = BLANK RED/BLUE Robot(default leaderRED)
    // Index 1 = WHITE Robot (default fRED)
    // Index 2 = BLACK Robot (default dRED)

    //Set up Arrays to be Published
    std_msgs::Int32MultiArray arrayRed0;
    std_msgs::Int32MultiArray arrayRed1;
    std_msgs::Int32MultiArray arrayRed2;
    std_msgs::Int32MultiArray arrayBlue0;
    std_msgs::Int32MultiArray arrayBlue1;
    std_msgs::Int32MultiArray arrayBlue2;

    //Clear Arrays to be Published
    arrayRed0.data.clear();
    arrayRed1.data.clear();
    arrayRed2.data.clear();
    arrayBlue0.data.clear();
    arrayBlue1.data.clear();
    arrayBlue2.data.clear();

    //Initialize Local Variables
    int blankxRED = arrayRED.data[1];
    int blankyRED = arrayRED.data[2];
    int whitexRED = arrayRED.data[4];
    int whiteyRED = arrayRED.data[5];
    int blackxRED = arrayRED.data[7];
    int blackyRED = arrayRED.data[8];
    int blankxBLUE = arrayBLUE.data[1];
    int blankyBLUE = arrayBLUE.data[2];
    int whitexBLUE = arrayBLUE.data[4];
    int whiteyBLUE = arrayBLUE.data[5];
    int blackxBLUE = arrayBLUE.data[7];
    int blackyBLUE = arrayBLUE.data[8];
    int ballX = arrayBALL.data[0];
    int ballY = arrayBALL.data[1];
    int leaderxRED; 
    int leaderyRED;
    int leaderxBLUE;
    int leaderyBLUE;

    //***NOTE: Assumed Starting of Linear Position along centre line: leaderRED, fRED, then bRED***//
    while(1){

        //Update Local Variables
        blankxRED = arrayRED.data[1];
        blankyRED = arrayRED.data[2];
        whitexRED = arrayRED.data[4];
        whiteyRED = arrayRED.data[5];
        blackxRED = arrayRED.data[7];
        blackyRED = arrayRED.data[8];
        blankxBLUE = arrayBLUE.data[1];
        blankyBLUE = arrayBLUE.data[2];
        whitexBLUE = arrayBLUE.data[4];
        whiteyBLUE = arrayBLUE.data[5];
        blackxBLUE = arrayBLUE.data[7];
        blackyBLUE = arrayBLUE.data[8];
        ballX = arrayBALL.data[0];
        ballY = arrayBALL.data[1];

        //Determine Leader Coordinates
        if(leaderRED == 0){
            leaderxRED = blankxRED; 
            leaderyRED = blankyRED;
            leaderPush0(arrayRed0);

            //Blank Controlled
            if(calcDistance(goalxRED, goalyRED,whitexRED,whiteyRED) > calcDistance(goalxRED,goalyRED,blackxRED,blackyRED)){
                fwdPush(arrayRed1,leaderxRED,leaderyRED,whitexRED,whiteyRED);   //White Forward
                defPush(arrayRed2,leaderxRED,leaderyRED,blackxRED,blackyRED);   //Black Defence
            }
            else{
                fwdPush(arrayRed2,leaderxRED,leaderyRED,blackxRED,blackyRED);   //Black Forward
                defPush(arrayRed1,leaderxRED,leaderyRED,whitexRED,whiteyRED);   //White Defence
            }
        }
        else if(leaderRED == 1){
            leaderxRED = whitexRED; 
            leaderyRED = whiteyRED;
            leaderPush0(arrayRed1);

            //White Controlled
            if(calcDistance(goalxRED, goalyRED,blankxRED,blankyRED) > calcDistance(goalxRED,goalyRED,blackxRED,blackyRED)){
                fwdPush(arrayRed0,leaderxRED,leaderyRED,blankxRED,blankyRED);   //Blank Forward
                defPush(arrayRed2,leaderxRED,leaderyRED,blackxRED,blackyRED);   //Black Defence
            }
            else{
                fwdPush(arrayRed2,leaderxRED,leaderyRED,blackxRED,blackyRED);   //Black Forward
                defPush(arrayRed0,leaderxRED,leaderyRED,blankxRED,blankyRED);   //Blank Defence
            }
        }
        else if(leaderRED == 2){
            leaderxRED = blackxRED; 
            leaderyRED = blackyRED;
            leaderPush0(arrayRed2);

            //Black Controlled
            if(calcDistance(goalxRED, goalyRED,whitexRED,whiteyRED) > calcDistance(goalxRED,goalyRED,blankxRED,blankyRED)){
                fwdPush(arrayRed1,leaderxRED,leaderyRED,whitexRED,whiteyRED);   //White Forward
                defPush(arrayRed0,leaderxRED,leaderyRED,blankxRED,blankyRED);   //Blank Defence
            }
            else{
                fwdPush(arrayRed0,leaderxRED,leaderyRED,blankxRED,blankyRED);   //Blank Forward
                defPush(arrayRed1,leaderxRED,leaderyRED,whitexRED,whiteyRED);   //White Defence
            }
        }
        else{
            ROS_ERROR("mainProcessing::run(): Invalid leaderRED");
            continue;
        }

        if(leaderBLUE == 0){
            leaderxBLUE = blankxBLUE;   
            leaderyBLUE = blankyBLUE;
            leaderPush0(arrayBlue0);

            //Blank Controlled
            if(calcDistance(goalxBLUE, goalyBLUE,whitexBLUE,whiteyBLUE) > calcDistance(goalxBLUE,goalyBLUE,blackxBLUE,blackyBLUE)){
                fwdPush(arrayBlue1,leaderxBLUE,leaderyBLUE,whitexBLUE,whiteyBLUE);  //White Forward
                defPush(arrayBlue2,leaderxBLUE,leaderyBLUE,blackxBLUE,blackyBLUE);  //Black Defence
            }
            else{
                fwdPush(arrayBlue2,leaderxBLUE,leaderyBLUE,blackxBLUE,blackyBLUE);  //Black Forward
                defPush(arrayBlue1,leaderxBLUE,leaderyBLUE,whitexBLUE,whiteyBLUE);  //White Defence
            }
        }
        else if(leaderBLUE == 1){
            leaderxBLUE = whitexBLUE;   
            leaderyBLUE = whiteyBLUE;
            leaderPush0(arrayBlue1);

            //White Controlled
            if(calcDistance(goalxBLUE, goalyBLUE,blankxBLUE,blankyBLUE) > calcDistance(goalxBLUE,goalyBLUE,blackxBLUE,blackyBLUE)){
                fwdPush(arrayBlue0,leaderxBLUE,leaderyBLUE,blankxBLUE,blankyBLUE);  //Blank Forward
                defPush(arrayBlue2,leaderxBLUE,leaderyBLUE,blackxBLUE,blackyBLUE);  //Black Defence
            }
            else{
                fwdPush(arrayBlue2,leaderxBLUE,leaderyBLUE,blackxBLUE,blackyBLUE);  //Black Forward
                defPush(arrayBlue0,leaderxBLUE,leaderyBLUE,blankxBLUE,blankyBLUE);  //Blank Defence
            }
        }
        else if(leaderBLUE == 2){
            leaderxBLUE = blackxBLUE;   
            leaderyBLUE = blackyBLUE;
            leaderPush0(arrayBlue2);

            //Blank Controlled
            if(calcDistance(goalxBLUE, goalyBLUE,whitexBLUE,whiteyBLUE) > calcDistance(goalxBLUE,goalyBLUE,blankxBLUE,blankyBLUE)){
                fwdPush(arrayBlue1,leaderxBLUE,leaderyBLUE,whitexBLUE,whiteyBLUE);  //White Forward
                defPush(arrayBlue0,leaderxBLUE,leaderyBLUE,blankxBLUE,blankyBLUE);  //Blank Defence
            }
            else{
                fwdPush(arrayBlue0,leaderxBLUE,leaderyBLUE,blankxBLUE,blankyBLUE);  //Blank Forward
                defPush(arrayBlue1,leaderxBLUE,leaderyBLUE,whitexBLUE,whiteyBLUE);  //White Defence
            }
        }
        else{
            ROS_ERROR("mainProcessing::run(): Invalid leaderBLUE");
            continue;
        }

        //Publish Arrays
        redBLANKPUB.publish(arrayRed0);
        redWHITEPUB.publish(arrayRed1);
        redBLACKPUB.publish(arrayRed2);
        blueBLANKPUB.publish(arrayBlue0);
        blueWHITEPUB.publish(arrayBlue1);
        blueBLACKPUB.publish(arrayBlue2);
    }
    return;
}

void mainProcessing::leaderPush0(std_msgs::Int32MultiArray& arr){
    arr.data.push_back(0);  
    arr.data.push_back(0);
    arr.data.push_back(0);
    arr.data.push_back(0);
    return;
}

void mainProcessing::fwdPush(std_msgs::Int32MultiArray& arr, int leaderX, int leaderY, int fwdX, int fwdY){
    
    //Forward Array Inputs
    int distance = (int)(round(calcDistance(leaderX, leaderY,fwdX,fwdY)));
    int fwdAngle = (int)calcRelFwdAngle(leaderX, leaderY,fwdX,fwdY);
    arr.data.push_back(fwd);
    if(distance > 30)
        arr.data.push_back(1);
    else
        arr.data.push_back(0);
    arr.data.push_back(1);
    arr.data.push_back(fwdAngle);
    return;
}

void mainProcessing::defPush(std_msgs::Int32MultiArray& arr, int leaderX, int leaderY, int defX, int defY){
    
    //Defence Array Inputs
    int distance = (int)(round(calcDistance(leaderX, leaderY,defX,defY)));
    int defAngle = (int)calcRelFwdAngle(leaderX, leaderY,defX,defY);
    arr.data.push_back(def);
    if(distance > 0)
        arr.data.push_back(1);
    else
        arr.data.push_back(0);
    arr.data.push_back(1);
    arr.data.push_back(defAngle);
    return;
}

int main(int argc, char **argv)
{ 
    std::cout << "Running Main Processing" << std::endl;
    
    ros::init(argc, argv, "mainProcessing");
    ros::NodeHandle node;

    mainProcessing centralHub;
    ros::spin();    //Enters Loop. Cancells when node is shut down or Ctrl+C is pressed

    return 0;
}

Originally posted by sgwhack on ROS Answers with karma: 73 on 2012-11-18
Post score: 0

Original comments
Comment by Lorenz on 2012-11-18:
Please read the support page. At least post the complete error output. You left out the important parts. From what I can see, the problem could be related to a call to subscribe, but without all error messages and the corresponding code it's impossible to say more.

A:

Okay, I have no idea what I was doing, but I changed the lines:
redTrackSUB = mainHUB.subscribe<std_msgs::Int32MultiArray::ConstPtr>("redTrack", 30, &mainProcessing::setCurrPosRED,this);

to
redTrackSUB = mainHUB.subscribe<std_msgs::Int32MultiArray>("redTrack", 30, &mainProcessing::setCurrPosRED,this);

...and it seems to work better now.
If anyone has an explanation, please do so in the comments. Thanks!

Originally posted by sgwhack with karma: 73 on 2012-11-19
This answer was ACCEPTED on the original site
Post score: 0


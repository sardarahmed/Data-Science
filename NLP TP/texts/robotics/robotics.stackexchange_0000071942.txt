Q:

How should I develop an Ackermann vehicle?

Last summer (2015) I used a simple ROS configuration to remotely control a small vehicle (Tractobot00) with Ackermann steering.  I only used ROS for the joystick driver and message passing between nodes I wrote.
https://www.youtube.com/watch?v=URQXUtGENxs
I extended the control to navigating using a single RTK GPS with very limited success.
I see that there are cars with ROS interfaces now but I don't see any major development in ROS support for Ackermann vehicles.  Is there a simple path to using ROS to control an Ackermann vehicle in a standard way?  My initial goal is to be able to drive a large vehicle in a straight line using dual RTK GPS and an IMU.  It looks like I could do this easily with APM Rover but I would much rather have the ROS infrastructure available.
[2016.05.29 update]
What did I do?  Well...I got really frustrated - both with ROS and APM.  Out of desperation, I decided to write my own monolithic Python script.  It is amazingly dumb.  It does not know about kinematics, vehicle geometry, or even correlation of steering value and steer angle.  It does not even use the IMU.  It just uses the GPS data for pose, and feeds a steering PID with the difference between the current and desired heading based on cross-track distance.  It works surprisingly well for Tractobot01.
https://youtu.be/HclgNBaS-Dg
Tractobot01 has been in the shop with transmission problems because it sat unused for decades.  I brought it home yesterday and added a solenoid valve for implement control.  I hope to have that working next week so that it can drill some soybeans without my assistance.
As my needs become more complex, I often have the urge to return to a ROS-based system.  I could certainly port my existing work to ROS but I'd like to start fresh when I return to ROS and do better.  I contacted Earle Robotics about continuing to port APM to ROS but it's apparently a bigger undertaking than I expected.
I would gladly pay for someone to port more pieces of APM to ROS and/or help me use existing ROS code to do what I need.
[2016.07.17 update]
It seems that there is interest in this, so here are a few more details on Tractobot01.  Also, I'm returning to ROS for Tractobot02 so I'm very interested in porting my work.
Tractobot01 came out of the shop with a repaired transmission, went to the field, and blew a steering cylinder seal.  Although I was very late, it did eventually drill about 45 acres of soybeans.
I will describe the guidance in more detail.  For reference, here are videos of Tractobot01 in various phases.
resuming operation:  https://www.youtube.com/watch?v=LhKV-5O64IY
midfield:  https://www.youtube.com/watch?v=fNX1M38h-ck
headland:  https://www.youtube.com/watch?v=XWopH24B1cw
Tractobot01 had one capability:  follow a line.  That meant that it tried to minimize the product of its cross-track distance (XTD) and cross-track angle (XTA).  Given XTD, an intercept heading is determined and the difference between that heading and the current heading is fed to a PID.  The output of the PID determines the steering angle.
I struggled developing this simple algorithm for a ridiculously long time so I'll try to explain it the way I would have understood.
Let's say that we're trying to follow an AB line (agriculture term for the line to navigate - it's really a vector) that goes straight North (0 degrees) and we are right on top of it (XTD=0).  The desired heading while on the line like this is 0 degrees, the same as the direction of the line.
If we are also pointed straight North (0 degrees), the PID is fed a difference of 0 and, if we've been on that line for awhile (small I and D components), the PID will output something close to 0 which tells the steering system to go straight ahead.
If we are pointed straight East (90 degrees), the PID is fed a difference of 90 and will direct full left steering.
If we are pointed straight West (270 degrees), the PID is fed a difference of -90 and will direct full right steering.
As we move off the AB line, the desired heading gradually changes from being the same as the direction of the AB line to being perpendicular to it.  In the first video above Tractobot01 is resuming operation far from the AB line.  It turns so that it's headed toward and perpendicular to the AB line.  As Tractobot01 approaches the AB line, it steers so that its heading approaches the direction of the AB line.
Midfield, XTD is on the order of an inch or two, and the desired heading changes very little, resulting in small steering changes.
On the ends, the AB line is suddenly flipped and an offset (of 15 feet in this case) is added.  Tractobot01 directs full steering to turn toward the new line.  It (thankfully) can not turn tight enough to simply intercept the new line.  Instead it overshoots and eventually circles around and captures the line.  The result is a sort of "keyhole" pattern.
For Tractobot01, I used a single navigation PID.  It was my first time programming with a PID and selecting values was a challenge.  I've considered having multiple PID configurations for different stages - "close" to the AB line (with implement engaged) and "off-line" (when maneuvering with implement disengaged).  Oscillation was huge problem which I had addressed pre-season by riding in the tractor in corn stubble (which marked the desired lines) and tuning the PID with repeated runs.  (Despite the resulting motion sickness, it was thrilling but I'd rather do something smarter next time.)
So...after all that, I've given up on Ackermann vehicles for now.  Tractobot02 is differential steering (and a lot of fun).
https://www.youtube.com/watch?v=BuTcVa8rPns
Because I did not use kinematics for Tractobot01, I expect to be able to re-use a lot of the code for Tractobot02.  I'm going to port it to ROS, though.
I'm still frustrated to know that all of the intelligent control code I need is just sitting there in APM.  When I reach the limit of what I can do, I plan to start digging through APM code and port some pieces to ROS.  (Or pay someone to do that...)
addressing VEGETA's question:  For Tractobot01 I certainly considered using GPS data to provide odometry so that I could take advantage of more ROS code.  I got overwhelmed wading through transforms and such, not knowing if GPS data would even be sufficient.  I have radar ground speed available on Tractobot02 and am considering using it for odometry.  Also, for Tractobot01 I used a LabJack to drive the FETs powering the solenoid hydraulic valves and clutch linear actuator.  (I like using LabJacks for prototyping because it's easy to switch between different computers controlling it.)  For Tractobot02, however, I'm just providing PWM signals to the tractor controller and I do use an Arduino for that.  (The LabJack can't achieve the 500Hz signal required.)

Originally posted by kylerlaird on ROS Answers with karma: 104 on 2016-02-11
Post score: 0

Original comments
Comment by VEGETA on 2016-05-29:
please tell me what u did
Comment by VEGETA on 2016-05-30:
I was hoping for a ROS solution. how about you use Arduino to control motors and send odometry back to ROS?

A:

hi kylerlaird.
Not sure if you are still interested in ackermann system but the most promising ackermann steering development in ROS seems to be teb_local_planner. This can be used in the place of the original planner or DWA planner within move_base. Within the setting you can convert the twist messages to ackermann style messages and specify steering angles. The development of the ackermann implementation is still in development, and still very active, but I have used it without any issues.

Originally posted by berno with karma: 26 on 2016-10-06
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by David michelman on 2021-01-09:
Sorry to revive a 4 year-old thread, but have any other local planners supporting ackermann steering been developed?


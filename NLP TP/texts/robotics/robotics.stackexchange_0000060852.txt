Q:

Using tf for plotting frames in rviz

So I'm developing some lab exercises for an introductory robotics course. In one of the first labs, we want students to be able to plot tf frames in rviz by defining the transformations between them:
void plotf(Eigen::Matrix4f h, std::string parentName, std::string childName){
  tf::TransformBroadcaster br;

  tf::Transform frame;
  frame.setOrigin(tf::Vector3(h(0,3), h(1,3), h(2,3)));
  frame.setBasis(tf::Matrix3x3(h(0,0), h(0,1), h(0,2),
                               h(1,0), h(1,1), h(1,2),
                               h(2,0), h(2,1), h(2,2)));
  
  ros::Duration(0.3).sleep();
  br.sendTransform(tf::StampedTransform(frame, ros::Time::now(), parentName, childName));
  ros::Duration(0.3).sleep();
} 

This function works (though only after putting those odd  delays in).
We'd also like them to be able to look up the transformation between various frames. I'm having trouble getting lookupTransform()  to work, however. It says that the frames don't exist.
Any advice on the delays or the inability to look up transforms?
If the problem looking them up is that they are only published once (rather than continuously), I suppose I could write a node that continuously publishes frames and also change plotf(...) accordingly.

Originally posted by rkeatin3 on ROS Answers with karma: 156 on 2014-07-15
Post score: 0

A:

It looks like you're creating the transform publisher and then immediately trying to use it. The trouble with this is that, ROS subscribers take some time to subscribe to a topic after a new publisher comes online, and usually miss the first message on a topic - your delay is compensating for this a bit.
The other problem you're having is that you're only publishing once, and then destrying the publisher when you're done - any nodes that aren't running and subscribed to tf when you publish won't receive the transform.
You've also ignoring the time component of the transforms - tf is designed to handle time-varying transformations, and all frames should be published continuously in order to keep them up to date.
The more standard way to use tf is to set up a persistent tf publisher object, either as a class member variable or a global variable, and then publish transforms at a fixed rate - usually between 10 and 100Hz.
There are a couple of ways you could hide these complexities from your students:

Provide a wrapper object which has a publish method and contains a thread which continuously republishes the transform.
If you're not publishing moving frames, you could move to tf2 and use the static transform broadcaster. you'll still have to keep the publisher around, but you won't have to publish to it continuously.
Have your students use the tf::TransformBoadcaster directly, and provide a helper method to convert from Eigen matrices to tf::Transform objects.

Originally posted by ahendrix with karma: 47576 on 2014-07-19
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by rkeatin3 on 2014-07-23:
Thanks for your answer!
I figured that publishing them only once might be a problem, but I was under the impression that I would have to create another ROS node that runs separately to publish the transforms continuously. Can you elaborate a bit (or point me in the direction of some information) on how to create a wrapper object with a continuously publishing thread? I'm not very familiar with multithreading at all.
Comment by ahendrix on 2014-07-23:
I would probably write a C++ class that contains a Boost::Thread. Note that proper threading and synchronization is one of the hardest topics in computer science. You should probably get some guidance from your professor.


Q:

ROSI and Universal Robot for an industrial application

I have been looking at ROS and ROSI with the intention of using a Universal Robot (UR5) and ROS in a commercial application.
I have a fresh Ubuntu Xenial 16.04.05 install with ROS Kinetic.
I have been reading "ROS Programming : Building Powerful Robots master" and other publications as well as the other material and the online documentation.
My first target was to control a simulated UR5 using the MoveIt, Gazebo, RViz and my test application using the Moveit C++ API.
I have had quite a painful ride but I understand the ROS framework now but drivers and compatibility seem to be giving me issues.
My current implementation fails when I try to execute move(), a known problem.
I have 2 questions :
(1) UR5 and ROS
The universal robot package (http://wiki.ros.org/universal_robot) is shown as experimental and use in production systems not recommended.
This greatly concerns me as a non starter, we have this powerful framework available but experimental drivers?
Is this assertion reasonable or is this driver package really not suitable for production?
Am I missing something or are universal robots not considered for production systems?
Before I put in more effort, I wanted to confirm the suitability of my configuration?
(2) Outdated drivers
I believe the universal_robot ur_driver is the cause of my issues, and is no longer recommended. It seems ur_modern_driver is recommended (https://answers.ros.org/question/254575/universal_robot-package-for-ros-kinetic/.
The ur_modern_driver adds ros_control required for move() support when simulated.
Why has the ur_modern_driver not replaced the ur_driver?
Surely everyone will fall at the first hurdle and have to find the above thread?
================================================================================
UPDATE following response from @gvdhoorn
Thanks for your reply, I appreciate you taking the time.
I have several responses, in reply to your questions.
(1) Experimental status
Thanks for the detailed explanation, it is hard to understand how the ROS framework comes together without your comments.
Understood that it depends on what functionality and hardware I chose to use, will determine what test coverage it has had.
It essence I have to try it out myself but I am reassured there are production systems on the platform I am proposing and an active community willing to support.
(2) The ur_modern_driver adds ros_control required for move() support when simulated.
I have to put my hand up and say this was my interpretation, I thought the driver added the simulation functionality.
I have since read, the Gazebo simulation with the ros control plugin with the function, instead of the driver.
(3) Documentation
Noted regarding the books going out of date (which was from the http://wiki.ros.org/Books list).
The tutorials are already out of date and use the previous moveIt API, that are deprecated (or soon to be).
(4) ur_driver vs ur_modern_driver
It seems perverse to keep the ur_driver in the main repository when it is "urged" to use the ur_modern_driver (https://answers.ros.org/question/254575/universal_robot-package-for-ros-kinetic/).
I can understand the ur_driver still has a use but as with the API's, things change for the better. Just my thought.
(5) Getting a development platform running
So now I more confident that the undertaking is worthwhile (your answer contributing heavily), my main problem is still outstanding.
How do I get a Xenial/Kinetic/UR5/MoveIt/Gazebo simulated system up and running with MoveIt C++ API calls running (with a view to transition to actual hardware)?
My end goal is currently simple, UR5 movement with collision detection of keep out areas.
Can you recommend tutorials or book that explain this, rather than approaching via trial and error?

Originally posted by reynot on ROS Answers with karma: 3 on 2018-11-14
Post score: 0

A:

Edit:

How do I get a Xenial/Kinetic/UR5/MoveIt/Gazebo simulated system up and running with MoveIt C++ API calls running (with a view to transition to actual hardware)?
My end goal is currently simple, UR5 movement with collision detection of keep out areas.
Can you recommend tutorials or book that explain this, rather than approaching via trial and error?

As an aside: I like how we are apparently at a point where "(runtime) collision detection of keep out areas" with "online real-time motion planning" is currently thought of as "simple" in robotics. Think about it: it's a massive task with all sorts of complicated things going on.
As to your question: I don't know which tutorials you are referring to when you write "they are already out of date", but perhaps first going through the MoveIt tutorials can help give you some overview.
Those should give you a bit more of an idea of the parts that go into the kind of setup that you are trying to create. Not with the UR5, with a different robot, but that is not really a problem: at the MoveIt level those differences don't matter.
re: books: as I don't typically read/use ROS books, I cannot recommend you any I'm afraid.

original answer:
To start: the documentation stating compatibility of the available drivers with the various controllers should be improved. However I believe some of the things you describe / ask about in your question are not just caused by this not being clear.

My first target was to control a simulated UR5 using the MoveIt, Gazebo, RViz and my test application using the Moveit C++ API.

Just to clarify: are you trying to use a driver with a robot in Gazebo? Because that is not needed nor possible.

My current implementation fails when I try to execute move(), a known problem.

Without more information this is not something we can act on. There can be various causes for this, but again, if you're using a simulation no drivers would be needed so I'd first like to get that cleared up.

The ur_modern_driver adds ros_control required for move() support when simulated.

Can you clarify where you read/found this? Because it is certainly not true (or at least not as you phrase it here).

Why has the ur_modern_driver not replaced the ur_driver? Surely everyone will fall at the first hurdle and have to find the above thread?

Because ur_driver still has its uses.
For all intents and purposes ur_modern_driver has replaced ur_driver. See the wiki for ur_driver for instance, Compatibility section:

The ur_driver package has been successfully used with system versions ranging from v1.5.7849 to v1.8.23117. Newer versions seem to have introduced various incompatible changes, and can at present not be used with the ur_driver package.
We recommend users with newer system versions (v3.x and up) to use the ur_modern_driver package.

And the Driver Compatibility notice in the Prerequisites section of the Getting Started with a Universal Robot and ROS-Industrial tutorial.
If your question was actually "why is ur_driver still part of the universal_robot repository?" then the answer would be: because it is still used by many users with a CB1 or CB2 controller and just removing or replacing packages (in repositories) that are still being used is not something that we do.
In fact: ur_modern_driver will never be integrated with the universal_robot repository. See ros-industrial/ros_industrial_issues#49 for the rationale.
As to your other concerns:

(1) UR5 and ROS The universal robot package ( http://wiki.ros.org/universal_robot ) is shown as experimental and use in production systems not recommended. This greatly concerns me as a non starter, we have this powerful framework available but experimental drivers?

All the code in that repository -- and in fact all drivers available for UR robots -- have been written by community members (as is also clarified by the support level: community badge in the repository readme and the top-level wiki page). Some while being part of a company, but that doesn't mean that the company guarantees the quality of the code. Everything is best effort. The software status label that you refer to is there to tell you -- up front -- that this code may not have received as much testing as it should have, that some things may not work fully yet and that components may contain code that has only been tested against the robot(s) that the developer has access to.
The community (still) hasn't come up with certification programs for (robot) drivers, so this subjective 'stamp' if you will is a stop-gap measure, but it at least gives you a heads-up.
See Production Ready solutions for a related discussion on ROS Discourse.

Is this assertion reasonable or is this driver package really not suitable for production? Am I missing something or are universal robots not considered for production systems? Before I put in more effort, I wanted to confirm the suitability of my configuration?

Please note this sentence on the Software Status label wiki page:

This status by design is not based on any quantitative evaluation, [..]. Rather, the status is merely the author/developer/maintainer's informed opinion on whether the code is production ready.

The last time that status label was updated for the universal_robot packages the maintainers and/or authors determined that there was still enough to improve to warrant the experimental label. That is all that label tells you. For the packages in universal_robot it could be upgraded to developmental in my opinion, and perhaps even production for the description packages. But as the status is generally applied to the whole repository it is generally best to be conservative.

Originally posted by gvdhoorn with karma: 86574 on 2018-11-14
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by gvdhoorn on 2018-11-14:
Also: please keep in mind that books can contain incorrect information and especially instructions can become outdated pretty quickly.
I've not read the book you refer to, but I've seen multiple that are flat-out wrong (but just because they've not been updated for new releases).
Comment by reynot on 2018-11-15:
Thanks for the reply again.
As to quote, it was a compliment to the ROS framework to simplify such a task.
I have been looking at MoveIt tutorials today, I'll continue.


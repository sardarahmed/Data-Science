Q:

Sharing non-ROS code between packages in catkin

I'm currently writing 3 separate packages for 3 different gripper designs. Under the hood, however, they all use the same UDP interface for sending and receiving commands, data, etc.
What is the recommended way to share the common code between those packages? Is standard practice just to add a separate, non-package directory in the catkin workspace for building a shared library containing common code?

Originally posted by rkeatin3 on ROS Answers with karma: 156 on 2017-11-09
Post score: 2

A:

TwoThree options:

make your shared code a ROS package (ie: add package.xml and use catkin_package(..) in a CMakeLists.txt)
install shared code "system wide" and treat it as a system dependency
create a "plain CMake" package (see REP-134)

My preference is always option 2, especially if the shared code does not have any ROS dependencies.

Originally posted by gvdhoorn with karma: 86574 on 2017-11-09
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by rkeatin3 on 2017-11-09:
A non-package directory is an option as well, right? Though that would necessitate building with catkin_make_isolated as opposed to catkin_make?
I was hesitant to make another package for the common code (since it's not really standalone), but it's better than option 2 for me in this instance.
Comment by rkeatin3 on 2017-11-09:
Thanks for your help!
Comment by gvdhoorn on 2017-11-09:
You're right, there is a third option (and probably some others as well). I've added it to the list.
Comment by gvdhoorn on 2017-11-09:
Note that it's really easy to create a Debian pkg with something like checkinstall. That makes things immediately usable as system dependency.
Comment by gvdhoorn on 2017-11-09:
re: not really stand-alone: I'm not sure how that matters. Library code is almost never stand-alone (ie: doesn't do anything by itself if not used by something else).
Comment by gvdhoorn on 2017-11-09:
Btw: do the designs change the way the shared code is used? If not, it might make sense to create a stand-alone 'driver' node that gets parameterised by the three packages that provide info about the gripper designs.
Comment by rkeatin3 on 2017-11-09:
The shared code just does the socket/UDP stuff, and each gripper will likely have a different interface (though that isn't nailed down yet). The way I have it architected now, each gripper can be controlled with or without ROS, so I'll probably want to stick with that (as opposed to strictly...
Comment by rkeatin3 on 2017-11-09:
coupling the shared code to ROS).
Comment by gvdhoorn on 2017-11-10:\

The shared code just does the socket/UDP stuff

to me this sounds like an ideal candidate for a system dependency.
Note that that is nothing magical, it just means that you install the headers and libs in /usr/local fi and make sure CMake can find them there.


Q:

Using set_entity_state service on ros2 programmatically

Hello,could anyone help me to get my result? It is the first time I have to work with gazebo plugins. Since I would create a reinforcement learning-like environment I would that a model "box" could respawn in it's original pose at each learning loop. I understood that the new way to work should rely on the set_entity_state plugin and so I included it in my world file. Now the set_entity_state arises in my ros2 services list. The only think remaining is to make a call to this Gazebo service whenever I need it but I would make it programmatically in a file using c++. For what I understood I have not to create a Gazebo plugin because it exists already, so can you give me some help in coding the service call in c++? I'm using ros2 galactic and gazebo11. thank you in advance for your support.

Originally posted by iopoi97 on Gazebo Answers with karma: 1 on 2023-03-27
Post score: 0

A:

Ok, with just a bit of effort I managed this problem in this way. I will post the solution I figured out in a sort of pseudocode. I have a class in which I make different things. i just added a client:
class WHATEVER : public rclcpp::Node{
  private:
     //stuff...
      rclcpp::Client<gazebo_msgs::srv::SetEntityState>::SharedPtr _client;

  public:
     WHATEVER() : Node("whatever"){
       //stuff...
      _client = this->create_client<gazebo_msgs::srv::SetEntityState>("set_entity_state");
      }
      void client_request();
      //stuff...
};
void  WHATEVER::client_request(){
    auto request=std::make_shared<gazebo_msgs::srv::SetEntityState::Request>();
    request->state.name="small_box_1";
    request->state.pose.position.x=0.41;
    request->state.pose.position.y=0.00;
    request->state.pose.position.z=0.75;
    request->state.pose.orientation.x=0.00;
    request->state.pose.orientation.y=0.00;
    request->state.pose.orientation.z=0.00;
    request->state.pose.orientation.w=1.00;
    request->state.twist.linear.x=0.00;
    request->state.twist.linear.y=0.00;
    request->state.twist.linear.z=0.00;
    request->state.twist.angular.x=0.00;
    request->state.twist.angular.y=0.00;
    request->state.twist.angular.z=0.00;
    request->state.reference_frame="world";
    _client->async_send_request(request);
}

And the game is done! You can call this function client request() whenever you want or also call it periodically threating it as a  rclcpp::TimerBase::SharedPtr callback!

Originally posted by iopoi97 with karma: 1 on 2023-03-28
This answer was ACCEPTED on the original site
Post score: 0


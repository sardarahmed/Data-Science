Q:

Gazebo camera timestamp issue

If I use a gazebo camera like this:
<sensor:camera name="camera1_sensor">
  <imageSize>160 160</imageSize>
  <controller:gazebo_ros_camera name="controller-cam1" plugin="libgazebo_ros_camera.so">
    <updateRate>20.0</updateRate>
    <imageTopicName>/gazebo/cam1</imageTopicName>
    <cameraInfoTopicName>/gazebo/cam1/info</cameraInfoTopicName>
  </controller:gazebo_ros_camera>
</sensor:camera>

The timestamps for full second N is actually output as N-1 + 1000000000ns. This leads to weird behavior, for example when using
boost::lexical_cast<std::string>(image_message1->header.stamp)

in a C++ application, as it produces the string "{N-1}.10" instead of the expected "{N}.00".
I assume that it is probably wrong to blindly use the lexical_cast on every datatype that comes along. And actually this is not a big issue, if you finally realize that it works that way.
But I wonder if this is the correct behavior/usage of ROS::Time? Can I expect other components that output ROS::Time tho behave in the same way and should I do it the same if I ever was to create a ROS::Time object?

Originally posted by nitschej on ROS Answers with karma: 35 on 2011-10-25
Post score: 0

A:

I believe ros::Time() has an operator<<(), which should do the correct normalization.
Have you tried that?

Originally posted by joq with karma: 25443 on 2011-10-26
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by nitschej on 2011-10-30:
Ok, I'll try that. Btw. I wonder, doesn't lexical_cast actually use the ostream operator?
Comment by joq on 2011-10-27:
It probably should. Either that, or the ros::Time() implementation intended to maintain normalized data as an invariant. We should open a defect ticket.
Comment by nitschej on 2011-10-26:
I didn't know about that operator until now. But I checked it and it does not normalize the output stream.


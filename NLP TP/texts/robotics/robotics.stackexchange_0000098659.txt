Q:

Unable to sync Arduino Mega and RP4 using rosserial

Hello!
I know there has been many people posting about this issue, but I have tried all of the solutions I have seen so far and I am still unable to establish the connection. Here is the error message I am getting:
Unable to sync with device; possible link problem or link software version mismatch such as hydro rosserial_python with groovy Arduino
This is the compilation message I am getting:
Sketch uses 11894 bytes (4%) of program storage space. Maximum is 253952 bytes. Global variables use 1192 bytes (14%) of dynamic memory, leaving 7000 bytes for local variables. Maximum is 8192 bytes.
I am trying to publish encoder data from an Arduino Mega through rosserial. Here are some of the things I have tried so far: I have confirmed that this setup works with the rosserial examples. I have switched from odometry messages to Float32 since it seems that the size of these may cause the small memory of the Arduino board to overflow. I have confirmed that the baud rate in both Arduino and RPi are matching, I have tried increasing and lowering the baud rate, I have tried increasing and lowering the buffer size of NodeHandle_<ArduinoHardware>, I have tried changing the cable and board, confirmed that the ports are connected and have sudo permission, and I have tried lowering and increasing the delay in loop(). I have also tried using ros launch to start the node, hard coding baud rate and buffer size in ros.h and ArduinoHardware.h, and trying to set the parameters from the terminal rosrun rosserial_python serial_node.py _port:=/dev/ttyACM0 _baud:=115200. No success...
This is what I currently have:
encoder_data_publisher.ino
#include <ros.h>
#include <std_msgs/Float32.h>

ros::NodeHandle_<ArduinoHardware, 10, 15, 128, 256> nh;
std_msgs::Float32 right_wheel_rpm_msg;
std_msgs::Float32 left_wheel_rpm_msg;

long publisher_timer;

    volatile int motor_right_input_A_count = 0; //if the interrupt will change this value, it must be volatile;
    volatile int motor_left_input_A_count = 0;
    
    const byte motor_right_input_A = 2;
    const byte motor_right_input_B = 3;
    const byte motor_left_input_A = 21;
    const byte motor_left_input_B = 20;
    
    float motor_cpr = 16.0;
    float right_motor_rpm;
    float left_motor_rpm;
    float right_wheel_rpm;
    float left_wheel_rpm;
    int gear_ratio = 270;
    
    // ROS publisher
    ros::Publisher right_wheel_msg_pub("right_wheel_rpm", &right_wheel_rpm_msg);
    ros::Publisher left_wheel_msg_pub("left_wheel_rpm", &left_wheel_rpm_msg);
    
    void setup() { 
      // ROS setup
      nh.getHardware()->setBaud(115200);
      nh.initNode();
      nh.advertise(right_wheel_msg_pub);
      nh.advertise(left_wheel_msg_pub);
      
      // Define the rotary encoder for right motor
      pinMode(motor_right_input_A, INPUT);
      pinMode(motor_right_input_B, INPUT);
      digitalWrite(motor_right_input_A, HIGH); 
      digitalWrite(motor_right_input_B, HIGH);
      attachInterrupt(digitalPinToInterrupt(motor_right_input_A), motor_right_interruptCounter, RISING); 
    
      // Define the rotary encoder for left motor
      pinMode(motor_left_input_A, INPUT);
      pinMode(motor_left_input_B, INPUT);  
      digitalWrite(motor_left_input_A, HIGH);
      digitalWrite(motor_left_input_B, HIGH);
      attachInterrupt(digitalPinToInterrupt(motor_left_input_A), motor_left_interruptCounter, RISING);
    }
    
    void loop() {
      motor_right_measureRPM();
      motor_left_measureRPM();
    
      right_wheel_rpm = right_motor_rpm / gear_ratio;
      left_wheel_rpm = left_motor_rpm / gear_ratio;
    
      right_wheel_rpm_msg.data = right_wheel_rpm;
      left_wheel_rpm_msg.data = left_wheel_rpm;
      
      right_wheel_msg_pub.publish(&right_wheel_rpm_msg);
      left_wheel_msg_pub.publish(&left_wheel_rpm_msg);
    
      nh.spinOnce();
      delay(1000);
    }
    
    void motor_right_interruptCounter()
    {
      motor_right_input_A_count++;
    }
    
    void motor_left_interruptCounter()
    {
      motor_left_input_A_count++;
    }
    
    void motor_right_measureRPM(){
      unsigned long start_time;
      unsigned long end_time;
      motor_right_input_A_count = 0;
      start_time = millis();
      
      while(motor_right_input_A_count < 101){
        continue;
      }
      
      end_time = millis();
      right_motor_rpm = 60000.0/(end_time - start_time)*motor_right_input_A_count / motor_cpr;
    }
    
    void motor_left_measureRPM(){
      unsigned long start_time;
      unsigned long end_time;
      motor_left_input_A_count = 0;
      start_time = millis();
      
      while(motor_left_input_A_count < 101){
        continue;
      }
      
      end_time = millis();
      left_motor_rpm = 60000.0/(end_time - start_time)*motor_left_input_A_count / motor_cpr;
    }

rosserial_test.launch
<launch>
  <node pkg="rosserial_python" type="serial_node.py" name="rosserial_lipo" output="screen">
  <param name="~port" value="/dev/ttyACM0" />
  <param name="~baud" value="115200" />
  </node>
</launch>

Any suggestions would be greatly appreciated. Thanks!

Originally posted by Sknet on ROS Answers with karma: 3 on 2021-03-28
Post score: 0

A:

I have experienced that re-creating ros_lib solved the corresponding error.
I suggest that you do rosrun rosserial_arduino make_libraries.py . with ROS running on RP4 and recreate ros_lib.
Update:
Thank you for trying my suggestion.
I read the source code.
  while(motor_right_input_A_count < 101){
    continue;
  }

The above is an infinite loop and it looks like it is not publishing.
void motor_right_interruptCounter()
{
  motor_right_input_A_count++;
}

is not running in parallel with motor_right_measureRPM.
( The same is  left side. )

Originally posted by miura with karma: 1908 on 2021-03-29
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Sknet on 2021-04-03:
Unfortunately, that did not solve the problem. I tried removing and rebuilding the libraries with roscore running.
Comment by Sknet on 2021-04-07:
Yeap, that is correct. I was testing with the motor not moving so it was stuck in the while loop. Thank you!
Comment by miura on 2021-04-08:
I'm glad I could be of help.
If the problem has been solved, please click the correct button.
Comment by miura on 2021-04-09:
Thank you.


Q:

How to Improve Inaccurate ROS Timer

I use a ROS timer in my progarm and plot the difference between the expected event time and the real event time as follows: event.current_real - event.current_expected;. However, I plot the data and find that the ROS Timer is NOT accurate AT ALL. In my program, the timer period is set to 0.002 second, but the largest error (0.01152 second) could be as large as more than 5.7 times of that. The plot is shown below:

I know from ROS wiki that ROS Timer does no intend to be accurate and is suject to the system load and other factors. So what I want to know is how to make it as accurate as possible? Is there any alternative method to substitute the ROS Timer?
I am using ROS Indigo and Ubuntu 14.04. The source code is listed below:
#include "ros/ros.h"
#include <fstream>

using namespace std;
std::ofstream time_file;

void callback1(const ros::TimerEvent& event)
{
    ros::Duration error_dur = event.current_real - event.current_expected;
    time_file<<error_dur.toSec()<<endl;
}

int main(int argc, char **argv)
{
    time_file.open("time_file.txt");
    time_file<<"error_dur"<<endl;
    ros::init(argc, argv, "talker");
    ros::NodeHandle n;

    ros::Timer timer1 = n.createTimer(ros::Duration(0.002), callback1);

    ros::spin();
    if(!ros::ok())
        time_file.close();

    return 0;
}

Originally posted by Winston on ROS Answers with karma: 180 on 2017-05-02
Post score: 0

Original comments
Comment by DavidN on 2017-05-02:
Simply ROS is not real time. This post probably would give you some idea why: http://answers.ros.org/question/134551/why-is-ros-not-real-time/
There is also some new approach in ROS 2 regarding "real-time" aspect:
http://design.ros2.org/articles/realtime_background.html

A:

If you require jitter lower than millisecond level you probably need to look into using a hard real-time kernel and running your time critical loop in a thread that has been set to use hard real-time priority (or alternatively use OROCOS to hide some of the complexity). Searching for "hard real-time ROS" will provide some useful info such as this Q/A. Be warned that a hard real-time setup can be quite daunting to setup, so better be sure you actually need it ;)
Other option would be to just run your own thread and experiment with busy waiting etc., but I suspect that would be limited by OS scheduling still, similar to the ROS timer example you provided.

Originally posted by Stefan Kohlbrecher with karma: 24361 on 2017-05-02
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by gvdhoorn on 2017-05-02:
RTROS (mentioned in my answer on #q9330) could also be an option. Perhaps @Jan Carstensen can give an update on what the status of that is?
Comment by Winston on 2017-05-02:
If I use OROCOS or RTROS, do I need to configure the real-time Linux kernel first? @Stefan Kohlbrecher.
Comment by gvdhoorn on 2017-05-03:
If you want more than soft-realtime determinism, then yes.


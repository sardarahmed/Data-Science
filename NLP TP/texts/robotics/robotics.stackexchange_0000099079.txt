Q:

How to get the int value instead of BOOL?

I'm doing the sample of publisher.
Here is the section of the file:
def __init__(self):
    super().__init__('minimal_publisher')
    self.publisher_ = self.create_publisher(Int64, "scan", 10)
    timer_period = 0  # seconds
    self.timer = self.create_timer(timer_period, self.timer_callback)
    self.i = 0

def timer_callback(self):  # this is the part where we need to get it keep running
    check = ser.readline()
    if check == ' ':  # this if statement is to skip string id. It doesn't seem like it works
        print("Skipped the ' '")  # in #44 line, it kept recieving a string ' '
    else:
        sensorvalue = float(ser.readline())  # posts the value
    msg = sensorvalue
    print(msg)
    msg = self.get_logger().info("distance: ".format(float(ser.readline())))
    print(type(msg))  # this is to verify the type of the value. It should be float only
    self.publisher_.publish(check)  # this is to publish the data to topic 'scann'. It can change to 'scan' in #34 line
    self.i += 1

As you can see that I use print(type(msg)), this is for me to verify if the msg is being sent to publisher data as an integer or float. Somehow, it kept getting BOOL value.
Here is the actual output using HC-SR04 sonar sensor.

Also if I run ros2 topic echo /scan  (I'm using /scan but that name can be changed at anytime anyway)
The memory suddenly dumped, take a look at the picture

To be honest with you, I'm super confused how I get a BOOL value instead of float/int.
Software: Ubuntu 20.04
Distro: Foxy
Language: Python 3 with Ardiuno (Doing Ardiuno + ros2 using Serial)

Originally posted by kak13 on ROS Answers with karma: 113 on 2021-05-20
Post score: 0

A:

You have 2 issues in the line msg = self.get_logger().info("distance: ".format(float(ser.readline()))):

You re-assign msg with the return value of .info(...), which is a boolean: True if logging was successful or False if some filter prevented the message from being logged (see here). This is where your main issue comes from.
You call .format(...) on a string without any formatting placeholders
You read from the serial again within the log message, after which the line you read is lost. Could well be that this reads ' ' which is why you don't get it from your other read.

You maybe meant that line to be:
self.get_logger().info("distance: {}".format(float(sensorvalue)))

Originally posted by sgvandijk with karma: 649 on 2021-05-20
This answer was ACCEPTED on the original site
Post score: 1

Original comments
Comment by kak13 on 2021-05-20:
Thank you!! That worked flawlessly but now it led me some new questions.

Why does it change to float when I removed the msg= and it changed from BOOL to float? is msg some global variable? I thought it was just a local variable?

this
self.get_logger().info("distance: {}".format(float(sensorvalue)))

made everything working properly now. So, how do you publish the value for ros2 topic echo /scan?
Because right now, I'm having this output if I ran ros2 topic echo /scan
Id get error like this
terminate called after throwing an instance of 'eprosima::fastcdr::exception::NotEnoughMemoryException'
what():  Not enough memory in the buffer stream
Aborted (core dumped)
Comment by sgvandijk on 2021-05-20:
msg is local within timer_callback, if you change its value anywhere in there, it will have that value afterwards and overwrite any old value. I'd suggest to maybe first spend a bit more time to familiarise yourself further with Python; it's tough to learn a big new framework like ROS 2 and it's a good investment to help understand better when this kind of issues are a problem with ROS or just a programming mistake!
For the memory exception, my guess would be that you publish check which is a text string, whereas you defined your publisher to publish Int64 messages. You probably need something like:
msg = Int64()
msg.data = int(sensorvalue)
self.publisher_.publish(msg)

But difficult to say, your code seems to have a few issues in what variables you think are holding what values, and again practising Python a bit more will probably help. Then if you still have this issue it's probably best to open a separate question.
Good luck!


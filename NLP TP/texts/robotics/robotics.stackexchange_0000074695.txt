Q:

How to convert sensor_msgs/Image to PointCloud?

I am trying to use PCL implementation of generating pointcloud and disparity from stereo images. I am using pcl::StereoMatching Class and stereo.compute() function to get disparity image. But compute() function requires left and right camera images in PointCloudpcl::RGB format. While I am using ros and my images are in the form of sensor_msgs/Image. Is there any way to do this conversion??
PCL stereo implementation guide: here
I am able to convert sensor_msgs/Image to PCLImage format using function pcl_conversions::toPCL(), but apparently PCLImage format is not same as PointCloudpcl::RGB format. please someone help me.

Originally posted by Anshul Paigwar on ROS Answers with karma: 1 on 2016-06-20
Post score: 0

A:

You can use OpenCV to do this task. You can get your disparity map using StereoSGBM, then your depth map using reprojectImageTo3D. Once you have your depth map, you can reconstruct your 3D scene using something like this:
pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZRGB>);

//Reconstruct PointCloud with the depthmap points
for (int i = 0; i < depth.rows; ++i)
{
    for (int j = 0; j < depth.cols; ++j)
    {
        pcl::PointXYZRGB p;

        //The coordinate of the point is taken from the depth map
        //Y and Z  taken negative to immediately visualize the cloud in the right way
        p.x = depth.at<Vec3f>(i,j)[0];
        p.y = -(depth.at<Vec3f>(i,j)[1]);
        p.z = -(depth.at<Vec3f>(i,j)[2]);

        //Coloring the point with the corrispondent point in the rectified image
        p.r = static_cast<uint8_t>(color.at<Vec3b>(i,j)[2]);
        p.g = static_cast<uint8_t>(color.at<Vec3b>(i,j)[1]);
        p.b = static_cast<uint8_t>(color.at<Vec3b>(i,j)[0]);

        //Insert point in the cloud, cutting the points that are too distant
        if(( abs( p.x ) < 500 )&&( abs( p.y ) < 200 )&&( abs( p.z ) < 500 ))
            cloud->points.push_back(p);
    }
}
cloud->width = (int) cloud->points.size();
cloud->height = 1;

Originally posted by Fabiobreo with karma: 16 on 2016-06-21
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Sooryakiran on 2018-05-07:
Hi there,
Is there any faster method other than looping through all the pixels? I need to do something similar in real time. Any suggestions?
Thanks in Advance


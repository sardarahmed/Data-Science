Q:

Usage of ros_control

Hi ROS community.
I am working on project where the ultimate goal is to build autonomus car.
I found out that navigation stack is basically moving a robot by geometry_msgs/Twist.
I have also found out about ros_control but so far I have not figured out how to use it with my use case.
We have a car controlled by serial interface or bluetooth interface.
I would like to know how where (or if) should I use ros_control because I feel like I need to be missing something. What can ros_control do for me? To me it looks like I can just subsribe on Twist message and convert it to commands for the custom car and use it like that. I have read wiki and the paper but I feel like it is written for someone who already knows what to do.
Thanks in advance.

Originally posted by Nitramek on ROS Answers with karma: 11 on 2018-03-24
Post score: 1

A:

In Ros Control you need to understand basically 2 things:

ROS controllers. Those are controllers already implemented for you (You can, of course, implement your own). Those controllers are for position/velocity/effort and the joint_state_controller that is a bit different because this is going to publish the status of all your joints. Let's take the example of a position controller. In this case, it implements does not implement any PID because for a joint position request you are going to send a joint position command a PID is going to be implemented only in a case like effort_controllers/joint_position_controller. You can also have more complex controllers like diff_drive_controllers that are used for diff drive robot. In this case, you need only one controller for the wheels and not one per wheel. What you are maybe thinking is that controllers like "forward controllers" are useless but actually, this is just a way to define a common interface. Thus. if you use Gazebo to simulate your robot you are going to have the exact same interface and won't have a different code to control the real robot or the simulated one. List of the controllers

Hardware Interface. Here you are going to define the interface between your controllers and your hardware. In this code, you are going to communicate with the controllers and feed them with informations you got from hardware (joint position or wheel speed ...) and also apply the desired command. You have plenty of nice features you can add to your Hardware Interface like the enforce limits, to enforce position, velocity, acceleration, Jerk limits for example. You can directly communicate with your hardware but I would recommend you to publish/subscribe topics and to do your hardware communication in different nodes. Implementing your own hardware interface is maybe a bit complex but you can see tutorials here. You can also have look to ros_control_boilerplate, that is simplifying many things.

Originally posted by GuillaumeB with karma: 312 on 2018-07-21
This answer was ACCEPTED on the original site
Post score: 6

Original comments
Comment by Nitramek on 2018-07-23:
Thanks for answering, that does make things clearer!


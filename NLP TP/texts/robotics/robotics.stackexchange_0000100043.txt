Q:

Big difference between simulated robot and real robot (ros_control, position & velocity controllers)

Hello! I've been working with an UR5e robot arm these past few weeks and I've tried to control it using ROS. I'm using the ur_robot_driver to connect to my robot arm. Currently, I'm trying to test out a few movements using the /joint_group_vel_controller/command topic (and yes, I've switched to the said controller using rosservice). The real robot is positioned just like the one in the gazebo from the picture below (only with a few millimeters difference, but basically the same values).

As I was connecting to the robot I received this notification:
[ERROR] [1631004560.884070577]: The calibration parameters of the connected robot don't match the ones from the given kinematics config file. Please be aware that this can lead to critical inaccuracies of tcp positions. Use the ur_calibration tool to extract the correct calibration from the robot and pass that into the description. See [https://github.com/UniversalRobots/Universal_Robots_ROS_Driver#extract-calibration-information] for details.

So I ran rostopic echo /joint_states the first time I've connected to the robot to check the position and the values were approximate to the ones in the picture, meaning that it read the position correctly. But once I ran the command with the values I used in gazebo, I was expecting to only get a small amount of movement (as the values are still a bit off from the real position of the robot). Instead, the whole robot arm moved in an completely unexpected position, far from the expected values.
Next, I disconnected from the robot, and used the calibration_correction to create a calibration file (I've pasted the contents of the said file in this pastebin: https://pastebin.com/z4Jv4Gec) and then used that file as the kinematics file when I launched the driver again, but this time when I ran rostopic echo /joint_states I got values that were way different than what they should have been:
---
header: 
  seq: 34396
  stamp: 
    secs: 1631003512
    nsecs: 161211710
  frame_id: ''
name: 
  - elbow_joint
  - shoulder_lift_joint
  - shoulder_pan_joint
  - wrist_1_joint
  - wrist_2_joint
  - wrist_3_joint
position: [-6.643843516940251e-05, -1.5709220371642054, -0.000134770070211232, -1.5709978542723597, 6.315350765362382e-05, -0.00014382997621709137]
velocity: [-0.0, 0.0, 0.0, -0.0, 0.0, 0.0]
effort: [0.13641898334026337, -0.10197316110134125, -0.007954925298690796, -0.039881058037281036, -0.02918042428791523, 0.012054499238729477]
---
header: 
  seq: 34397
  stamp: 
    secs: 1631003512
    nsecs: 163216999
  frame_id: ''
name: 
  - elbow_joint
  - shoulder_lift_joint
  - shoulder_pan_joint
  - wrist_1_joint
  - wrist_2_joint
  - wrist_3_joint
position: [-5.399739893618971e-05, -1.5709430179991664, -8.184114565068512e-05, -1.5709816418089808, 4.259109846316278e-05, -0.000134770070211232]
velocity: [-0.0, 0.0, 0.0, -0.0, 0.0, 0.0]
effort: [0.10822169482707977, -0.1689099222421646, -0.031928807497024536, -0.04185150936245918, -0.04760636389255524, 0.0033494792878627777]
---

Why are the values for the position so off even if I've done the calibration and why do they keep changing so much (some values go from for example -5.6 to 6.4)?

Originally posted by horvath.daniel on ROS Answers with karma: 15 on 2021-09-07
Post score: 0

Original comments
Comment by gvdhoorn on 2021-09-07:
This may sound pedantic (edit: it is), but it would be better to only describe what you observe, instead of trying to ask questions about possible causes.
What I mean is: your question title is: "UR robot not calibrated correctly?", which implies you've concluded something is wrong with your robot (or at least, you're considering that as a possibility).
In reality, you've observed a difference between the pose and JointState of a robot in a simulator and your real robot.
There is a possibility calibration influences some aspect here, but it could be something completely different. By posting it as the title of your question, you make it sound like you're only after confirmation of the former.

Currently, I'm trying to test out a few movements using the /joint_group_vel_controller/command topic [..]

the screenshot shows the joint_group_position_controller, which would also make more sense, seeing your setpoints.
Comment by horvath.daniel on 2021-09-08:
Yes, in the gazebo simulation I did use joint_group_position_controller as it is similar to the joint_group_vel_controller from the real robot. At first I tested in gazebo to see if the setpoints would correspond to those from the real robot and also to test out sending a message to a topic via rostopic pub which I wanted to use also with the real robot. Then when I tested the command on the real robot (the robot being in the same pose as the one in gazebo) I expected only a small amount of movement since the setpoints are the same, but instead the real robot started tilting completely. That is why I suspect that there's some error in my calibration. Also I didn't really know what title to give to the thread :/.
Comment by gvdhoorn on 2021-09-08:\

I didn't really know what title to give to the thread :/.

just describe what you observed.
I just changed the title.

A:

Yes, in the gazebo simulation I did use joint_group_position_controller as it is similar to the joint_group_vel_controller from the real robot.

no, not really. They are actually quite different.
If you're using the default ros_control controller configuration as supplied by UR (so I can assume joint_group_position_controller and joint_group_velocity_controller mean what I believe they do), then:

the joint_group_position_controller forwards whatever position setpoints you provide it with directly to the UR CB, so you're commanding the robot in position mode (ie: it moves to those joint space positions)
the joint_group_vel_controller forwards whatever velocity setpoints you provide it with directly to the UR CB, so you're commanding the robot in velocity mode (ie: it rotates joints, in joint space, at the velocities you specify)

position control != velocity control.
A (imaginary) setpoint of 0.01 for a velocity controller for a revolute joint would mean: start moving in the positive direction at 0.01 radians/sec.
That same setpoint for a position controller would mean: move the joint to position 0.01 radians.
Those are two very different things.

Then when I tested the command on the real robot (the robot being in the same pose as the one in gazebo) I expected only a small amount of movement since the setpoints are the same

the values might be identical, but their semantics are completely different (ie: their meaning).
This may explain why you observed two different behaviours.

Originally posted by gvdhoorn with karma: 86574 on 2021-09-08
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by horvath.daniel on 2021-09-09:
Thanks for the clarification! I understand better now. So I guess that the equivalent to the joint_group_pos_controller from gazebo would be pose_joint_traj_controller from the ur_robot_driver?
Comment by gvdhoorn on 2021-09-09:
No.
You can run the exact same controller on both the real robot and your Gazebo simulation.
That's sort of the point.
Just add the necessary stanzas to your ros_control configuration file.
pose_joint_traj_controller is a JointTrajectoryController. That's rather different from a simple forwarding JointGroupPositionController.
Comment by horvath.daniel on 2021-09-09:
Right, I see. Where exactly do I find this ros_control configuration file?
Comment by gvdhoorn on 2021-09-09:
Where did you add the stanzas for the twist_controller?
I assume here: ur_robot_driver/config.
Comment by gvdhoorn on 2021-09-09:
And a suggestion: if you haven't already, I would recommend to get some familiarity with some control engineering terminology and functionality.
Names like pose, twist, linear, angular, translation, transformation, what the difference is between a position and a velocity controller, joint space, Cartesian, etc, etc. That might make the kinds of issues you're running into easier to deal with and diagnose.
Comment by horvath.daniel on 2021-09-09:
Yes, the twist_controller is already implemented in ur_robot_driver/config in each controller.yaml file so I didn't have to implement it myself. I guess that before anything else I'll try to become more familiar with both ROS and the engineering terminology. Cheers!


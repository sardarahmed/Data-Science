Q:

marker position and orientation

right now i am detecting a moving object in 3d point cloud and than sending the voxels of moved object in rviz. but when i view it in rviz, its color and oreantation is not coming correctly, what should i do to remove this problem?
Here is the screen shot, where i've put a bag infront of kinect sensor, but it is not displayed correctly in rviiz:

im using ubuntu 18.04, ros melodic.  Here is the full code:
#include <ros/ros.h>
// PCL specific includes
#include <sensor_msgs/PointCloud2.h>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_types.h>
#include <pcl/filters/voxel_grid.h>
#include <visualization_msgs/Marker.h>
#include <rosbag/bag.h>
#include <std_msgs/Int32.h>
#include <rosbag/view.h>
#include <boost/foreach.hpp>
#define foreach BOOST_FOREACH
#include <fstream>
    
#include <pcl/point_cloud.h>
#include <pcl/octree/octree_pointcloud_changedetector.h>
#include <pcl/io/pcd_io.h>
#include <iostream>
#include <vector>
#include <ctime>
#include <thread>
ros::Publisher marker_publisher;
int frame_index = 0;
using namespace std;
int x[200000];
void thread_function(pcl::PointCloud<pcl::PointXYZRGB>::ConstPtr cloudB,vector<int> v,int p0) {
    for(size_t p1=0;p1<v.size() && ros::ok();++p1) {
        int p0p1 = sqrt( pow(cloudB->points[v[p1]].x-cloudB->points[v[p0]].x,2)                
        +pow(cloudB->points[v[p1]].y-cloudB->points[v[p0]].y,2)
        +pow(cloudB->points[v[p1]].z-cloudB->points[v[p0]].z,2) ) * 1000;
        if(p0p1>10) {
            for(size_t p2=0;p2<v.size() && ros::ok();++p2) {
                int p0p2 = sqrt( pow(cloudB->points[v[p2]].x-cloudB->points[v[p0]].x,2)                
                +pow(cloudB->points[v[p2]].y-cloudB->points[v[p0]].y,2)
                +pow(cloudB->points[v[p2]].z-cloudB->points[v[p0]].z,2) ) * 1000;
                int p1p2 = sqrt( pow(cloudB->points[v[p2]].x-cloudB->points[v[p1]].x,2)                
                +pow(cloudB->points[v[p2]].y-cloudB->points[v[p1]].y,2)
                +pow(cloudB->points[v[p2]].z-cloudB->points[v[p1]].z,2) ) * 1000;
                if(p0p2>10 && p1p2>10) {
                }    
            }    
        }       
    }    
    x[p0] = 3;
    cout<<"ended thread="<<p0<<endl;
}
    
void cloud_cb (const sensor_msgs::PointCloud2ConstPtr& input)
{
    frame_index++;
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloudB (new pcl::PointCloud<pcl::PointXYZRGB> );
    pcl::fromROSMsg(*input,*cloudB);

    // Initializing Marker parameters which will be used in rviz
    vector<visualization_msgs::Marker> line_list, marker, text_view_facing;
    line_list.resize(4); marker.resize(4); text_view_facing.resize(4);
    for(int i=0;i<line_list.size();i++) {
        marker[i].header.frame_id = line_list[i].header.frame_id = text_view_facing[i].header.frame_id = "/X3/base_link";
        marker[i].header.stamp = line_list[i].header.stamp = text_view_facing[i].header.stamp =ros::Time();
        marker[i].ns = line_list[i].ns = text_view_facing[i].ns ="lines";
        marker[i].action = line_list[i].action = text_view_facing[i].action = visualization_msgs::Marker::ADD;
        marker[i].pose.orientation.w = line_list[i].pose.orientation.w = text_view_facing[i].pose.orientation.w = 1;
        marker[i].id = i+4;
        line_list[i].id = i;
        marker[i].type = visualization_msgs::Marker::POINTS;
        line_list[i].type = visualization_msgs::Marker::LINE_LIST;
        line_list[i].color.r = 1; line_list[i].color.g = 1; line_list[i].color. b = 1; line_list[i].color.a = 1;
        marker[i].scale.x = 0.003;
        marker[i].scale.y = 0.003;
        marker[i].scale.z = 0.003;
        text_view_facing[i].id = i+8;
        text_view_facing[i].type = visualization_msgs::Marker::TEXT_VIEW_FACING;
        text_view_facing[i].color.b = 1; text_view_facing[i].color.a = 1.0; text_view_facing[i].color.g = 1.0; text_view_facing[i].color.r = 1.0;
        text_view_facing[i].scale.z = 0.015;
    }
    marker[3].scale.x = 0.05;
    marker[3].scale.y = 0.05;
    marker[3].scale.z = 0.05;

    if(frame_index==10) // Saving the point cloud for only one time to find moved object in it
    {
      pcl::io::savePCDFileASCII ("test_pcd.pcd", *cloudB);
    }
    if(frame_index>10) // Reading above point cloud file after saving for once to compare it with newly arriving point clouds
    {
        pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZRGB>);

        if (pcl::io::loadPCDFile<pcl::PointXYZRGB> ("test_pcd.pcd", *cloud) == -1) //* load the file
        {
            PCL_ERROR ("Couldn't read file test_pcd.pcd \n");
        }
        else {
            
            srand ((unsigned int) time (NULL));

            // Octree resolution - side length of octree voxels
            double resolution = 0.1;

            // Instantiate octree-based point cloud change detection class
            pcl::octree::OctreePointCloudChangeDetector<pcl::PointXYZRGB> octree (resolution);
            
            // Add points from cloudA to octree
            octree.setInputCloud (cloud);
            octree.addPointsFromInputCloud ();

            // Switch octree buffers: This resets octree but keeps previous tree structure in memory.
            octree.switchBuffers ();
            
            // Add points from cloudB to octree
            octree.setInputCloud (cloudB);
            octree.addPointsFromInputCloud ();

            std::vector<int> newPointIdxVector;

            // Get vector of point indices from octree voxels which did not exist in previous buffer
            octree.getPointIndicesFromNewVoxels (newPointIdxVector);
            
            geometry_msgs::Point p; std_msgs::ColorRGBA c;
            for (size_t i = 0; i < newPointIdxVector.size (); ++i)
            {                        
                p.x = cloudB->points[newPointIdxVector[i]].x;
                p.y = cloudB->points[newPointIdxVector[i]].y;
                p.z = cloudB->points[newPointIdxVector[i]].z;
                c.r = cloudB->points[newPointIdxVector[i]].r/255.0; 
                c.g = cloudB->points[newPointIdxVector[i]].g/255.0; 
                c.b = cloudB->points[newPointIdxVector[i]].b/255.0; 
                c.a = 1;

                //cout<<newPointIdxVector.size()<<"\t"<<p.x<<"\t"<<p.y<<"\t"<<p.z<<endl;   

                if(!isnan(p.x) && !isnan(p.y) && !isnan(p.z)) {

                    marker[3].points.push_back(p);
                    marker[3].colors.push_back(c);
                }
            }
            marker_publisher.publish(marker[3]);
            
            pcl::PointCloud<pcl::PointXYZRGB> P;
            thread t[newPointIdxVector.size()];

            for(int p0=0;p0<newPointIdxVector.size();++p0) { // For each voxel in moved object 
                t[p0] = thread(thread_function,cloudB,newPointIdxVector,p0);  
            }   
            for(int p0=0;p0<newPointIdxVector.size();++p0) { // For each voxel in moved object 
                t[p0].join();
                cout<<"joined"<<"\t"<<p0<<"\t"<<x[p0]<<endl;
            }
        } 

    }    

        
}

int main (int argc, char** argv)
{
  ros::init (argc, argv, "training");
  ros::NodeHandle nh;

  ros::Subscriber sub = nh.subscribe<sensor_msgs::PointCloud2> ("input", 1, cloud_cb);
  marker_publisher = nh.advertise<visualization_msgs::Marker> ("visualization_marker",1);

  // Spin
  ros::spin ();
}

Originally posted by dinesh on ROS Answers with karma: 932 on 2018-12-16
Post score: 1

A:

There are a few things to fix here.
The points of the object are in the wrong place because you're copying the x, y and z in the wrong order. So your switching the x and z values. That's an easy one to fix.
The color values are also switched but there is another thing to fix here too. The color problem is caused because the point cloud and RVIZ marker describe color values in different ranges. The point cloud uses 0-255 while the RVIZ marker uses 0.0 - 1.0 for this reason you'll need to divide the color values by 255.0 . The '.0' at the end is very important it forces c++ to perform a floating point divide as opposed to an integer divide.
Hope this gets this working for you.

Originally posted by PeteBlackerThe3rd with karma: 9529 on 2018-12-16
This answer was ACCEPTED on the original site
Post score: 2

Original comments
Comment by dinesh on 2019-01-04:
ok the color is coming correctly after i divide them with 255.0 but the position is still not coming correctly .
Comment by PeteBlackerThe3rd on 2019-01-05:
Can you show us your updated code so we can see what you've changed.
Comment by dinesh on 2019-01-05:
ok, i've updated the code.
Comment by PeteBlackerThe3rd on 2019-01-05:
The frame Id of the marker you're creating is hard coded to "/X3/base_link", if the point cloud has a different  frame id, then this would explain the problem. Can you look at the original point cloud in RVIZ and find out what it's frame_id is?


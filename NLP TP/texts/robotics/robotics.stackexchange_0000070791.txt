Q:

Does a callback complete before being called again?

Hi!
Suppose I have a subscriber with a callback C. C manipulates a number of global variables and then calls a second method M, that builds a message from those global variables and publishes the message.
I am now wondering: Is is possible that C and M interfere, i.e., that M uses global variables that have been modified by a different call to C? Or, stated differently, is it possible to call C before the previous call to C has returned?
I was not able to figure out if ros::getGlobalCallbackQueue()->callAvailable blocks till completion. If interference in this situation can happen, how does one usually deal with it?
Thank you!

Originally posted by Jay4Ros on ROS Answers with karma: 35 on 2015-12-08
Post score: 1

A:

Callback execution is single-threaded, unless you setup things differently, by using a Multithreaded or Asynchronous spinner fi. See also roscpp/Overview/Callbacks and Spinning.
Btw, this has been asked (and answered) many times before. A quick search immediately turned up ROS callbacks, threads and spinning fi.

Originally posted by gvdhoorn with karma: 86574 on 2015-12-08
This answer was ACCEPTED on the original site
Post score: 3

Original comments
Comment by Jay4Ros on 2015-12-08:
Hey! I saw the question you linked before, but I must have missed "Single thread spinner: the default one, takes the messages contained in a callback queue and process the callbacks one by one while blocking the execution of the thread that called it." Thanks!
Comment by Jay4Ros on 2015-12-08:
Oh, I guess if a program is single threaded a callback can only be called one by one.... My bad!


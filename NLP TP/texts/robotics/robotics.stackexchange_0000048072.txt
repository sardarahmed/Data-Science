Q:

navfn stability

Hi.
I encountered with the problem that global_planner in navfn package makes invalid plans. It means that they go through walls on a map like on this picture.

There is ROS Electric on board.
Cannot find out why it happens, so I'd appreciate any suggestions.
UPD. I tried with original navigation stack (as well as with forked base_local_planner and move_base) and it still makes plans through the walls sometimes.
Is it possible that it's a bug in navfn package?
Is there any others global planners?
Here are my configs:

base_local_planner_params
 controller_frequency: 5.0

TrajectoryPlannerROS:
max_vel_x: 0.70
min_vel_x: 0.1
max_rotational_vel: 1.5
min_in_place_rotational_vel: 1.0
acc_lim_th: 0.75
acc_lim_x: 0.50
acc_lim_y: 0.35
holonomic_robot: false
yaw_goal_tolerance: 1.1
xy_goal_tolerance: 0.15
goal_distance_bias: 0.8
path_distance_bias: 0.6
sim_time: 1.5
heading_lookahead: 0.325
oscillation_reset_dist: 0.05
vx_samples: 6
vtheta_samples: 20
dwa: false

costmap_common_params
obstacle_range: 2.5
raytrace_range: 3.0
footprint: [[-0.35, -0.245], [0.35,-0.245], [0.35,0.245], [-0.35, 0.245]]
footprint_padding: 0.01
inflation_radius: 1.0
observation_sources: filter
filter: {data_type: LaserScan, topic: /filter, marking: true, clearing: true}

3 global_costmap_params
global_costmap:
   global_frame: /map
   robot_base_frame: /base_link
   update_frequency: 3.0
   publish_frequency: 0.0
   static_map: true
   transform_tolerance: 0.5

4 local_costmap_params
local_costmap:
   global_frame: /odom
   robot_base_frame: /base_link
   update_frequency: 5.0
   publish_frequency: 5.0
   static_map: false
   rolling_window: true
   width: 4.0
   height: 4.0
   resolution: 0.1
   transform_tolerance: 0.5

UPD2.
5 BaseLocalPlanner.cfg
# gen.add("inscribed_radius", double_t, 0, "The radius of the inscribed circle of the robot", 1, 0)
# gen.add("circumscribed_radius", double_t, 0, "The radius of the circumscribed circle of the robot", 1, 0)

gen.add("acc_lim_x", double_t, 0, "The acceleration limit of the robot in the x direction", 1.0, 0, 20.0)
gen.add("acc_lim_y", double_t, 0, "The acceleration limit of the robot in the y direction", 1.0, 0, 20.0)
gen.add("acc_lim_theta", double_t, 0, "The acceleration limit of the robot in the theta direction", 1.0, 0, 20.0)

gen.add("max_vel_x", double_t, 0, "The maximum x velocity for the robot in m/s", 0.55, 0, 20.0)
gen.add("min_vel_x", double_t, 0, "The minimum x velocity for the robot in m/s", 0.0, 0, 20.0)

gen.add("max_vel_theta", double_t, 0, "The absolute value of the maximum rotational velocity for the robot in rad/s",  1.0, 0, 20.0)
gen.add("min_vel_theta", double_t, 0, "The absolute value of the minimum rotational velocity for the robot in rad/s", -1.0, 0, 20.0)
gen.add("min_in_place_vel_theta", double_t, 0, "The absolute value of the minimum in-place rotational velocity the controller will explore", 0.4, 0, 20.0)

gen.add("sim_time", double_t, 0, "The amount of time to roll trajectories out for in seconds", 3, 0, 10)
gen.add("sim_granularity", double_t, 0, "The granularity with which to check for collisions along each trajectory in meters", 0.025, 0, 5)

gen.add("pdist_scale", double_t, 0, "The weight for the path distance part of the cost function", 0.4, 0, 5)
gen.add("gdist_scale", double_t, 0, "The weight for the goal distance part of the cost function", 0.8, 0, 5)
gen.add("occdist_scale", double_t, 0, "The weight for the obstacle distance part of the cost function", 0.05,0, 5)

gen.add("oscillation_reset_dist", double_t, 0, "The distance the robot must travel before oscillation flags are reset, in meters", 1.0, 0, 5)
gen.add("escape_reset_dist", double_t, 0, "The distance the robot must travel before oscillation flags are reset, in meters", 0.10, 0, 5)
gen.add("escape_reset_theta", double_t, 0, "The distance the robot must travel before oscillation flags are reset, in meters", pi/2, 0, 5)

gen.add("vx_samples", int_t, 0, "The number of samples to use when exploring the x velocity space", 20, 1, 300)
gen.add("vtheta_samples", int_t, 0, "The number of samples to use when exploring the theta velocity space", 20, 1, 300)

gen.add("heading_lookahead", double_t, 0, "How far the robot should look ahead of itself when differentiating between different rotational velocities", 0.325, 0, 5)

gen.add("holonomic_robot", bool_t, 0, "Set this to true if the robot being controlled can take y velocities and false otherwise", True)

gen.add("escape_vel", double_t, 0, "The velocity to use while backing up", -0.25, -2, 2)

gen.add("dwa", bool_t, 0, "Set this to true to use the Dynamic Window Approach, false to use acceleration limits", False)

gen.add("heading_scoring", bool_t, 0, "Set this to true to use the Dynamic Window Approach, false to use acceleration limits", False)
gen.add("heading_scoring_timestep", double_t, 0, "How far to look ahead in time when we score heading based trajectories", 0.1, 0, 1) 

gen.add("simple_attractor", bool_t, 0, "Set this to true to allow simple attraction to a goal point instead of intelligent cost propagation", False)

gen.add("angular_sim_granularity", double_t, 0, "The distance between simulation points for angular velocity should be small enough that the robot doesn't hit things", 0.025, 0, pi/2)

gen.add("y_vels", str_t, 0, "A comma delimited list of the y velocities the controller will explore", "-0.3,-0.1,0.1,-0.3")

gen.add("restore_defaults",  bool_t, 0, "Retore to the default configuration", False)

exit(gen.generate(PACKAGE, "base_local_planner", "BaseLocalPlanner"))

6 MoveBase.cfg
gen.add("base_global_planner", str_t, 0, "The name of the plugin for the global planner to use with move_base.", "navfn/NavfnROS")
gen.add("base_local_planner", str_t, 0, "The name of the plugin for the local planner to use with move_base.", "base_local_planner/TrajectoryPlannerROS")

#gen.add("recovery_behaviors", str_t, 0, "A list of recovery behavior plugins to use with move_base.", "[{name: conservative_reset, type: clear_costmap_recovery/ClearCostmapRecovery}, {name: rotate_recovery, type: rotate_recovery/RotateRecovery}, {name: aggressive_reset, type: clear_costmap_recovery/ClearCostmapRecovery}]")

gen.add("planner_frequency", double_t, 0, "The rate in Hz at which to run the planning loop.", 0, 0, 100)
gen.add("controller_frequency", double_t, 0, "The rate in Hz at which to run the control loop and send velocity commands to the base.", 20, 0, 100)
gen.add("planner_patience", double_t, 0, "How long the planner will wait in seconds in an attempt to find a valid plan before space-clearing operations are performed.", 5.0, 0, 100)
gen.add("controller_patience", double_t, 0, "How long the controller will wait in seconds without receiving a valid control before space-clearing operations are performed.", 5.0, 0, 100)
gen.add("conservative_reset_dist", double_t, 0, "The distance away from the robot in meters at which obstacles will be cleared from the costmap when attempting to clear space in the map.", 3, 0, 50)

gen.add("recovery_behavior_enabled", bool_t, 0, "Whether or not to enable the move_base recovery behaviors to attempt to clear out space.", True)
# Doesnt exist
gen.add("clearing_rotation_allowed", bool_t, 0, "Determines whether or not the robot will attempt an in-place rotation when attempting to clear out space.", True)
gen.add("shutdown_costmaps", bool_t, 0, "Determines whether or not to shutdown the costmaps of the node when move_base is in an inactive state", False)

gen.add("oscillation_timeout", double_t, 0, "How long in seconds to allow for oscillation before executing recovery behaviors.", 0.0, 0, 60)
gen.add("oscillation_distance", double_t, 0, "How far in meters the robot must move to be considered not to be oscillating.", 0.5, 0, 10)

gen.add("restore_defaults", bool_t, 0, "Restore to the original configuration", False)
exit(gen.generate(PACKAGE, "move_base_node", "MoveBase"))

UPD3.
Thanks!

Originally posted by Peter Listov on ROS Answers with karma: 338 on 2013-02-06
Post score: 1

Original comments
Comment by dornhege on 2013-02-07:
This should never happen and I've never seen it happen. I suspect it's probably more of a setup issue. Could you add your configuration?
Comment by dornhege on 2013-02-08:
Can't see anything obviously wrong, besides maybe the publish_frequency of 0.0. I can't look it up right now as ros.org is down. One other thing: Your rviz display seem not to correspond to each other at all. Can you explain that? Maybe something is wrong with tf/frames?
Comment by Peter Listov on 2013-02-08:
Sorry, did not get what is not corresponded? And one more clarification. As far as I understood navfn algorithm works standalone and my base_local_planner hacks will not affect global_planner. For example I've changed the weights for local trajectories.
Comment by dornhege on 2013-02-08:
The pink cells you display are the plan, etc. right? It doesn't seem to match anything (the map, the current robot pose). That seems odd.  Yes, you understood this correctly. Changing things in the local planner is irrelevant for the global planner.
Comment by Peter Listov on 2013-02-08:
Yes, the pink cells are inflated obstacles. The green one are lethal_ostacles recognized by kinect. The red are laser scans. I think that they are dismatched with the static map a little because of errors in the navigation system.
Comment by dornhege on 2013-02-08:
OK, so this might only be for the local planner. What is the green plan then? Is that maybe from the local planner? This would explain everything. Given the obstacles you display the green plan is correct. Unfortunately this local planner isn't bound to the global plan and makes its own decisions.
Comment by dornhege on 2013-02-08:
If it doesn't consider the map the observations are consistent. Can you check which plan you display? Usually there are three different topics.
Comment by Peter Listov on 2013-02-08:
The green plan is the global plan computed by navfn. One interesting thing: the first plan is always correct. This problem popped up when I tried cope with oscillations of my robot. So I hacked move_base a little to remake the global plan once a minute.
Comment by Peter Listov on 2013-02-08:
And now when I'm trying the original navigation the problem came back. I make the global plan and it's correct, then I let robot to move a bit and turn off actuators and trying to remake global path. Here appears mistake. Have you tried this experiment?
Comment by dornhege on 2013-02-08:
Replanning is a very common use case. This should definitely work. I've even used the get_plan service to produce arbitrary plans between locations independent on the start position. Unfortunately I don't know what would cause this given your information.

A:

It looks like your range sensor possibly has seen through the wall.  In that case the map will be updated to reflect that there's no obstacles seen in that location and it's valid to plan there.

Originally posted by tfoote with karma: 58457 on 2013-03-12
This answer was ACCEPTED on the original site
Post score: 0

Original comments
Comment by Peter Listov on 2013-03-18:
And in this case navfn disregards the static map?
Comment by David Lu on 2013-03-20:
Yes. Problematic as it may be, the costmap will overwrite the static map to trust its local sensors (just in case there's noise in the map)
Comment by KruseT on 2013-08-02:
Same happened to us, not sure whether tullys explanation holds: https://github.com/ros-planning/navigation/issues/102 In any case setting /move_base_node/planner_frequency to non-zero can help reduce the problem. hydro seems to be okay for us, with stage anyway.
Comment by David Lu on 2013-08-02:
In the updated hydro nav, the static map is NOT overwritten. It should probably be configurable, but I haven't made that edit yet.

